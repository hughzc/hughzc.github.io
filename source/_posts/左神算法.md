---
title: 左神算法
date: 2020-02-25 09:51:49
tags: 算法
categories: 算法
---

## OJ处理技巧

类名为public class Main

较好的做法是将要用到的类都封装好，不要放在Main类中，主类只需要持有要用到的类的对象，然后调用即可。

StringBuilder类的append方法，res.append(str1).append(str2)比res.append(str1+str2)效率高。

<!-- more -->

### 获取不知次数的输入

使用BufferedReader来获取，需要Import，主函数需要抛出异常

valueOf返回值类型为Integer，parseInt返回值类型为int

~~~java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class Main {
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s = null;
        while((s = br.readLine())!= null){
            //获取第一行输入，输入为一个数
            int len = Integer.valueOf(s);
            //获取第二行输入，输入为数组
            String[] arrStr = br.readLine().split(" ");
            int [] arr = new int[len];
            for (int i = 0; i < arr.length; i++) {
                arr[i] = Integer.valueOf(arrStr[i]);
            }
            System.out.println(要求的函数);
        }
    }
~~~

### 获取有限次数的输入

输出的结果先用StringBuilder类存起来，如果有多行，每一行最后要加上换行标识。最后要输出的时候，将stringbuilder转变为String类输出。

~~~java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main{
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        //要持有的写的类
        DogCatQueue dq = new DogCatQueue();
        String s = null;
        StringBuilder res = new StringBuilder();
        s = br.readLine();
        int count = Integer.valueOf(s);
        for (int i = 0; i < count; i++) {
            String[] strArr = br.readLine().split(" ");
            //if或者switch判断
            switch (strArr[0]){
                case "add":
                    String type=strArr[1];
                    dq.add(new Pet(type,Integer.valueOf(strArr[2])));
                    break;
                case "pollAll":
                    while(!dq.isEmpty()){
                        pet = dq.pollAll();
                        res.append(pet.getPetType()+" "+pet.getPetIndex()+"\n");
                    }
                    break;
                case "isDogEmpty" :
                    res.append(dq.isDogEmpty()?"yes\n":"no\n");
                    break;
            }
        }
        System.out.println(res.substring(0,res.length()-1));
    }
}
~~~

### 获取输入矩阵

~~~java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        //要持有的写的类
        //PringtEdge pe = new PringtEdge();
        String[] s = null;
        StringBuilder res = new StringBuilder();
        s = br.readLine().split(" ");
        //获取第一行的矩阵行与列
        int row = Integer.valueOf(s[0]);
        int col = Integer.valueOf(s[1]);
        int[][] arr = new int[row][col];
        //获取后面几行的矩阵数据
        for (int i = 0; i < row; i++) {
            s = br.readLine().split(" ");
            for (int j = 0; j < col; j++) {
                arr[i][j] = Integer.valueOf(s[j]);
            }
        }
        //通过自己编写方法获取结果
        //res = pe.printCircle(arr);
        System.out.println(res.substring(0,res.length()-1));
    }
~~~

### 获取数组

~~~java
import java.util.Scanner;
	//交换数组中的数
    public static void swap(int[] arr,int i, int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
	//打印数组
    public static void printArr(int[] arr){
        for(int i = 0; i < arr.length; i++){
            System.out.print(arr[i]+" ");
        }
    }
public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        String[] strArray = str.split(" ");
        int[] intArray = new int[strArray.length];
        for(int i = 0;i<strArray.length;i++) {
            intArray[i] = Integer.parseInt(strArray[i]);
        }
    	//要解决的
        Solution(intArray);
    	//输出数组
        for(int i = 0;i<intArray.length;i++) {
            System.out.print(intArray[i] + " ");
        }
    	//or
    	printArr(printArr);
    }
~~~



### 获取链表

~~~java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

//链表结构
class Node{
    int value;
    Node next;
    Node pre;
    Node(int value){
        this.value = value;
    }
}

	//创建单向链表
	private static Node createNode(String[] str,int n){
        Node head = new Node(Integer.parseInt(str[0]));
        Node node = head;
        for(int i=1;i<n;i++){
            Node newNode = new Node(Integer.parseInt(str[i]));
            node.next = newNode;
            node = newNode;
        }
        return head;
    }
    //创建双向链表
    private static Node createNodeDL(String[] str,int n){
        Node head = new Node(Integer.parseInt(str[0]));
        Node node = head;
        for(int i=1;i<n;i++){
            Node newNode = new Node(Integer.parseInt(str[i]));
            node.next = newNode;
            node.next.pre = node;
            node = newNode;
        }
        return head;
    }
	//打印列表
	private static void printList(Node node){
        StringBuilder builder = new StringBuilder();
        while (node != null){
            builder.append(node.value).append(" ");
            node = node.next;
        }
        System.out.println(builder.toString());
    }
	//主函数部分
	public static void main(String[] args) throws IOException{
        BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
        //创建第一个链表
        int n = Integer.parseInt(input.readLine());
        String[] strings1 = input.readLine().split(" ");
        Node list1 = createNode(strings1,n);
        //创建第二个链表
        int m = Integer.parseInt(input.readLine());
        String[] strings2 = input.readLine().split(" ");
        Node list2 = createNode(strings2,m);
        //要操作的函数
        //printCommonPart(list1,list2);
    }
~~~



## 左神算法笔记

### 排序问题

#### 小和问题

题目描述：

数组小和的定义如下：

例如，数组s = [1, 3, 5, 2, 4, 6]，在s[0]的左边小于或等于s[0]的数的和为0；在s[1]的左边小于或等于s[1]的数的和为1；在s[2]的左边小于或等于s[2]的数的和为1+3=4；在s[3]的左边小于或等于s[3]的数的和为1；

在s[4]的左边小于或等于s[4]的数的和为1+3+2=6；在s[5]的左边小于或等于s[5]的数的和为1+3+5+2+4=15。所以s的小和为0+1+4+1+6+15=27

给定一个数组s，实现函数返回s的小和

[要求]

时间复杂度为O(nlogn)，空间复杂度为O(n)

思路：找小和，就是看当前数右边哪些数比他大 ，顺序并没有关系，因此可以用mergesort的思想，先分再合，产生小和的过程为merge的过程，如果右边数比左边大，那么总的小和个数为左边当前数*右边数个数，然后将两个数组sort中产生的数和当前merge共三部门数相加即可。

坑：

最后的小和可能很大，需要long类型才能过OJ，小和为小于等于，因此merge外排时判断为<=

~~~sql
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s = null;
        while((s=br.readLine())!=null){
            int len = Integer.valueOf(s);
            String[] arrStr = br.readLine().split(" ");
            int[] arr = new int[len];
            for(int i = 0;i < len;i++){
                arr[i] = Integer.parseInt(arrStr[i]);
            }
            System.out.println(smallSum(arr));
        }
    }
    public static long smallSum(int[] arr){
        if(arr == null || arr.length < 2)
            return 0;
        return sortProcess(arr,0,arr.length-1);
    }
    public static long sortProcess(int[] arr,int l,int r){
        if(l == r)
            return 0;
        int mid = l + (r - l)/2;
        return sortProcess(arr,l,mid)+sortProcess(arr,mid+1,r)+merge(arr,l,mid,r);
    }
    public static long merge(int[] arr,int l,int mid, int r){
        int p1 = l,p2 = mid+1,i = 0;
        int[] help = new int[r-l+1];
        long res = 0;
        while(p1<=mid && p2 <= r){
            if(arr[p1] <= arr[p2]){
                res += arr[p1] * (r-p2+1);
                help[i++] = arr[p1++];
            }else{
                help[i++] = arr[p2++];
            }
        }
        while(p1<=mid){
            help[i++] = arr[p1++];
        }
        while(p2<=r){
            help[i++] = arr[p2++];
        }
        for(i = 0;i<help.length;i++){
            arr[l+i] = help[i];
        }
        return res;
    }
}
~~~

#### 数组排序后相邻数的最大差值

题目描述

给定一个整形数组arr，返回排序后相邻两数的最大差值

arr = [9, 3, 1, 10]。如果排序，结果为[1, 3, 9, 10]，9和3的差为最大差值，故返回6。

arr = [5, 5, 5, 5]。返回0。

[要求]

时间复杂度为O(n)，空间复杂度为O(n)

当要排序，然后时间复杂度给定O(n)，那么只能使用桶排序，思路为把n个数放在n+1个桶中，那么肯定有1个桶中没有数字，这样最大的差值一定出现在两个桶之间，那么桶中有哪些数字不重要，只需要关注桶中是否有数字，最大数字和最小数字即可，最大差值为当前非空桶的最小值减去上一个非空桶的最大值。将数字放入桶，依据为将min-max的数据，放入0-len的桶中，数据长度为为len，桶的个数为len+1。在计算时为了避免越界，采用long型，然后转换为int。可以优化的点在于，如果算出来数组的最大值和最小值相等，那么可以直接返回0，不用建立桶。

~~~java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s = null;
        while((s=br.readLine())!=null){
            int len = Integer.valueOf(s);
            int[] arr = new int[len];
            String[] arrStr = br.readLine().split(" ");
            for(int i = 0;i<len;i++){
                arr[i] = Integer.valueOf(arrStr[i]);
            }
            System.out.println(maxGap(arr));
        }
    }
    public static int maxGap(int[] arr){
        if(arr == null || arr.length < 2)
            return 0;
        //统计数组最大和最小值
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;
        int len = arr.length;
        for(int i = 0;i<len;i++){
            min = Math.min(min,arr[i]);
            max = Math.max(max,arr[i]);
        }
        //如果max=min，那么可以直接返回0
        if(max == min)
            return 0;
        //建立桶，范围是0-len
        //有三个属性，是否进来过数，最大值，最小值
        boolean[] hasNum = new boolean[len+1];
        int[] maxs = new int[len+1];
        int[] mins = new int[len+1];
        int bid = 0;
        //将每一个数装入桶
        for(int i = 0; i < len;i++){
            //计算当前数应该在哪个桶
            bid = bucket(arr[i],len,min,max);
            //统计桶的最大最小值，是否进去过数
            maxs[bid] = hasNum[bid]?Math.max(maxs[bid],arr[i]):arr[i];
            mins[bid] = hasNum[bid]?Math.min(mins[bid],arr[i]):arr[i];
            hasNum[bid] = true;//当前桶进去了数
        }
        //开始计算差值
        int res = 0;
        int lastMax = maxs[0];
        for(int i = 1;i < len;i++){
            if(hasNum[i]){
                res = Math.max(res,mins[i]-lastMax);
                lastMax = maxs[i];
            }
        }
        return res;
    }
    public static int bucket(long num,long len, long min, long max){
        //目的，让值为min的在0桶，让值为max的在len桶
        //范围变换，从min-max变化为0-len
        int res = (int)((num-min)*len/(max-min));
        return res;
    }
}
~~~

### 队列和栈

#### 用数组实现栈和队列

用数组实现栈比较简单，此类需要持有一个数组和当前位置标记，有初始化构造函数，获取最上面一个数peek方法，入栈push方法，出栈pop方法，要注意的是执行者三个方法时第一步为判断index范围，pop方法返回类型要是Integer而不是int，因为换成int不能返回null

~~~java
public class ArrayStack {
    //用数组实现栈，应该持有数组，当前位置
    private int[] arr;
    private int index;
    public ArrayStack(int size){
        if (size < 0)
            throw new IllegalArgumentException("The init size is less than 0");
        arr = new int[size];
    }
    //peek，获取最上面的数
    //返回类型为Integer，不然不能返回NULL
    public Integer peek(){
        if (index == 0)
            return null;
        return arr[index-1];
    }
    //入栈
    public void push(int obj){
        //如果超出范围，报错
        if (index == arr.length)
            throw new ArrayIndexOutOfBoundsException("The stack is full");
        //如果正常，放入数据
        arr[index++] = obj;
    }
    //出栈
    public Integer pop(){
        if (index == 0)
            throw new ArrayIndexOutOfBoundsException("The stack is empty");
        return arr[--index];
    }
}
~~~

用数组实现队列，需要持有一个数组，一个入队列位置end，一个出队列位置start，一个队列大小size，用size来给end和start解耦

~~~java
public class ArrayQueue {
    //用数组实现队列，需要持有数组，队列末尾，队列开始，size
    private int[] arr;
    private int start;
    private int end;
    private int size;
    public ArrayQueue(int initSize){
        if (initSize < 0)
            throw new IllegalArgumentException("The init size is less than 0");
        arr = new int[initSize];
        size = 0;
        end = 0;
        start = 0;
    }
    //peek方法
    public Integer peek(){
        if (size == 0)
            return null;
        return arr[start];
    }
    //push方法
    public void push(int obj){
        if (size == arr.length)
            throw new ArrayIndexOutOfBoundsException("The queue is full");
        size++;
        arr[end] = obj;
        //循环队列
        end = (end + 1) % arr.length;
    }
    //poll方法
    public int poll(){
        if (size == 0)
            throw new ArrayIndexOutOfBoundsException("The queue is empty");
        size--;
        int temp = arr[start];
        start = (start+1)%arr.length;
        return temp;
    }
}
~~~

#### getMin()功能的栈

实现一个特殊功能的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。

思路：持有两个栈，一个为数据栈，一个为最小栈，数据栈正常进出，而最小栈有两种方法实现。

方法一：当进来的数比最小数要小，直接入栈；当比最小数大，入栈最小数出栈时。两个栈正常出栈，返回data栈的值。

方法二：当进来的数比最小数要小，直接入栈；当比最小数大，min不入栈 。出栈时，当data出栈数等于最小数才出栈 ，其他时候min不出栈。

~~~java
import java.util.Stack;
public class MyStack2 {
    //第二种方法，入栈的时候，如果当前数比较大，则min栈不进
    //出栈的时候，如果当前数比min栈小，min栈不出
    private Stack<Integer> dataStack;
    private Stack<Integer> minStack;
    //初始化
    public MyStack2() {
        dataStack = new Stack<>();
        minStack = new Stack<>();
    }
    //getMin()方法
    public Integer getMin() {
        //如果栈为空，返回空
        if (minStack.empty())
            return null;
        return minStack.peek();
    }
    //入栈方法
    public void push(int num) {
        if (minStack.empty()) {
            minStack.push(num);
        } else if (num <= getMin()) {
            minStack.push(num);
        }
        dataStack.push(num);
    }
    //出栈方法
    public Integer pop() {
        if (dataStack.empty())
            return null;
        int num = dataStack.pop();
        //只有当前数等于getmin，min栈才出
        //只有等于，没有小于
        if (num == getMin())
            minStack.pop();
        return num;
    }    
}
~~~

#### 用队列实现栈

用队列来实现栈的功能，要有2个队列，当push的时候，正常进入队列，当peek的时候，先弹出其他的进入辅助队列，然后获取剩下来的一个的值，再将其放入辅助队列，再交换两个的引用。

~~~java
import java.util.LinkedList;
import java.util.Queue;
public class TwoQueueStack {
    //用两个队列实现栈
    private Queue<Integer> queue;
    private Queue<Integer> help;
    public TwoQueueStack(){
        queue = new LinkedList<Integer>();
        help = new LinkedList<Integer>();
    }
    //push
    public void push(int num){
        queue.add(num);
    }
    public int peek(){
        if (queue.isEmpty()){
            throw new RuntimeException("Queue is empty");
        }
        while (queue.size()!=1){
            help.add(queue.poll());
        }
        int res = queue.poll();
        help.add(res);
        swap();
        return res;
    }
    public int pop(){
        if (queue.isEmpty()){
            throw new RuntimeException("Queue is empty");
        }
        while (queue.size()>1){
            help.add(queue.poll());
        }
        int res = queue.poll();
        swap();
        return res;
    }
    //交换两个队列引用
    public void swap(){
        Queue<Integer> temp = queue;
        queue = help;
        help = queue;
    }
}
~~~

#### 用栈实现队列

准备两个栈，一个push栈只用于push数据进去，一个pop栈只用于pop数据出来。从push栈倒数据进pop栈有两个要求，一个是pop栈中不能有数据，另一个是倒就要全部倒完。

~~~java
import java.util.Stack;
public class TwoStackQueue {
    private Stack<Integer> stackPush;
    private Stack<Integer> stackPop;
    public TwoStackQueue(){
        stackPush = new Stack<>();
        stackPop = new Stack<>();
    }
    public void push(int num){
        stackPush.push(num);
        goTo();
    }
    //关键的倒数据步骤
    public void goTo(){
        while (stackPop.isEmpty()){
            //要倒完
            while (!stackPush.isEmpty()){
                stackPop.push(stackPush.pop());
            }
        }
    }
    //peek步骤
    public int peek(){
        if (stackPush.isEmpty() && stackPop.isEmpty())
            throw new RuntimeException("The stack is empty");
        goTo();
        return stackPop.peek();
    }
    public int pop(){
        if (stackPush.isEmpty() && stackPop.isEmpty())
            throw new RuntimeException("The stack is empty");
        goTo();
        return stackPop.pop();
    }
}
~~~

#### 猫狗队列

实现一种猫狗队列的结构，要求如下：

1. 用户可以调用 add 方法将 cat 或者 dog 放入队列中

2. 用户可以调用 pollAll 方法将队列中的 cat 和 dog 按照进队列的先后顺序依次弹出

3. 用户可以调用 pollDog 方法将队列中的 dog 按照进队列的先后顺序依次弹出

4. 用户可以调用 pollCat 方法将队列中的 cat 按照进队列的先后顺序依次弹出

5. 用户可以调用 isEmpty 方法检查队列中是否还有 dog 或 cat

6. 用户可以调用 isDogEmpty 方法检查队列中是否还有 dog

7. 用户可以调用 isCatEmpty 方法检查队列中是否还有 cat

思路：将Pet封装上一个index数据项，这样使用一个新类将二者封装。然后持有一个狗队列，一个猫队列，持有index，初始为0，在add操作中，如果是狗，就加入狗队列，是猫就加入猫队列。从队列中弹出较早入队列的，比较猫、狗队列中较小的index，弹出即可。

坑点：牛客网上的题目相比于原始题目，Pet自己也需要封装上一个index项，而比较的时候，比的是封装后的宠物队列类自己定义的index，而不是pet的index。

~~~java
class Pet {
    private String type;
    private int x;
    public Pet(String type,int index){
        this.type = type;
        this.x = index;
    }
    public String getPetType(){
        return this.type;
    }
    public int getPetIndex(){
        return this.x;
    }
}
class PetEnterQueue {
    //持有Pet和index
    private Pet pet;
    private long index;
    public PetEnterQueue(Pet pet, long index){
        this.pet = pet;
        this.index = index;
    }
    //API：获取当前类型，index
    public Pet getPet() {
        return pet;
    }
    public long getIndex() {
        return index;
    }
    public String getPetType(){
        return pet.getPetType();
    }
}
class DogCatQueue {
    //猫狗队列，一个持有猫，，一个持有狗
    private Queue<PetEnterQueue> dogQueue;
    private Queue<PetEnterQueue> catQueue;
    private long index;
    public DogCatQueue(){
        dogQueue = new LinkedList<>();
        catQueue = new LinkedList<>();
        index = 0;
    }
    public void add(Pet pet){
        //如果为狗，加到狗；如果为猫，加到猫
        if ("dog".equals(pet.getPetType())){
            dogQueue.add(new PetEnterQueue(pet,index++));
        }else if ("cat".equals(pet.getPetType())){
            catQueue.add(new PetEnterQueue(pet,index++));
        }else{
            throw new RuntimeException("error, no dog or cat");
        }
    }
    //弹出猫或者狗中较小的
    public Pet pollAll(){
        //如果两个均不为空
        if (!dogQueue.isEmpty() && !catQueue.isEmpty()){
            if (dogQueue.peek().getIndex() < catQueue.peek().getIndex()){
                return dogQueue.poll().getPet();
            }else {
                return catQueue.poll().getPet();
            }
        }else if (!dogQueue.isEmpty()){
            //狗不为空
            return dogQueue.poll().getPet();
        }else if (!catQueue.isEmpty()){
            //猫不为空
            return catQueue.poll().getPet();
        }else{
            throw new RuntimeException("The queue is empty");
        }
    }
    //弹出狗队列
    public Pet pollDog(){
        if (dogQueue.isEmpty())
            throw new RuntimeException("Dog queue is empty");
        return dogQueue.poll().getPet();
    }
    //弹出猫队列
    public Pet pollCat(){
        if (catQueue.isEmpty())
            throw new RuntimeException("Dog queue is empty");
        return catQueue.poll().getPet();
    }
    public boolean isEmpty(){
        return isCatEmpty()&&isDogEmpty();
    }
    public boolean isCatEmpty(){
        return catQueue.isEmpty();
    }
    public boolean isDogEmpty(){
        return dogQueue.isEmpty();
    }
}
~~~

输入输出的处理比较麻烦，使用StringBuilder来添加结果，最后用substring方法将其转换为字符串，要记得添加换行。

~~~java
public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s = null;
        DogCatQueue dq = new DogCatQueue();
        Pet pet = null;
        StringBuilder res=new StringBuilder();
        s = br.readLine();
        int count = Integer.valueOf(s);
        for (int i = 0; i < count; i++) {
            String[] strArr = br.readLine().split(" ");
            switch (strArr[0]){
                case "add":
                    String type=strArr[1];
                    dq.add(new Pet(type,Integer.valueOf(strArr[2])));
                    break;
                case "pollAll":
                    while(!dq.isEmpty()){
                        pet = dq.pollAll();
                        res.append(pet.getPetType()+" "+pet.getPetIndex()+"\n");
                    }
                    break;
                case "pollCat":
                    while(!dq.isCatEmpty()){
                        pet = dq.pollCat();
                        res.append(pet.getPetType()+" "+pet.getPetIndex()+"\n");
                    }
                    break;
                case "pollDog":
                    while(!dq.isDogEmpty()){
                        pet = dq.pollDog();
                        res.append(pet.getPetType()+" "+pet.getPetIndex()+"\n");
                    }
                    break;
                case "isDogEmpty" :
                    res.append(dq.isDogEmpty()?"yes\n":"no\n");
                    break;
                case "isCatEmpty":
                    res.append(dq.isCatEmpty()?"yes\n":"no\n");
                    break;
                case "isEmpty":
                    res.append(dq.isEmpty()?"yes\n":"no\n");
                    break;
            }
        }
        System.out.println(res.substring(0,res.length()-1));
    }
~~~

### 哈希表

#### RandomPool结构

题目：

设计一种结构，在该结构中加入如下三种功能

insert(key)：将某个key加入到该结构，做到不重复加入

delete(key)：将原本在结构中的某个key移除

getRandom()：等概率随机返回结构中的任何一个key

要求：这三种方法的时间复杂度均为O(1)

思路：一个不行就两个。持有两个哈希表，一个为key-index映射，一个为index-key映射，麻烦的地方在于删除后如何保证之后的随机性，解决方法为每次找到要删除的位置，然后获取其key，获取最后行的key和index，然后将最后行的数据存到要删除行，再删除最后行数据。

~~~java
import java.util.HashMap;
public class RandomPool<K> {
    //持有两个哈希表，一个索引
    private HashMap<K,Integer> keyIndexMap;
    private HashMap<Integer,K> indexKeyMap;
    private int index;
    public RandomPool(){
        keyIndexMap = new HashMap<>();
        indexKeyMap = new HashMap<>();
        index = 0;
    }
    //添加方法
    public void insert(K key){
        //如果已经存在了，返回
        if (keyIndexMap.containsKey(key))
            return;
        keyIndexMap.put(key,index);
        indexKeyMap.put(index++,key);
    }
    //随机返回方法
    public K getRandom(){
        //如果没有数据，返回空
        if (index == 0)
            return null;
        int res = (int)(Math.random()*index);
        return indexKeyMap.get(res);
    }
    //删除方法
    public void delete(K key){
        if (!keyIndexMap.containsKey(key))
            return;
        //1、找到要删除位置的index
        int deleteIndex = keyIndexMap.get(key);
        //2、找到最后的index和key
        int lastIndex = --index;
        K lastKey = indexKeyMap.get(lastIndex);
        //3、将待删除位置的值替换为最后行的值
        keyIndexMap.put(lastKey,deleteIndex);
        indexKeyMap.put(deleteIndex,lastKey);
        //4、删除最后行数据，将行数-1
        keyIndexMap.remove(key);
        indexKeyMap.remove(lastIndex);
    }
}
~~~

### 数组

#### 转圈打印矩阵

{% asset_img 转圈打印矩阵.png This is an example image %}

思路：打印矩阵的思路一般都是宏观调度，用有限个变量去约束要打印的范围，然后循环调用打印函数。此处用左上角和右下角的点去约束范围，调用打印函数，然后将左上角和右下角的点进行收缩。打印矩阵函数为分别判断一行，一列和多行多列的情况，如果为单行单列的，用for循环控制行和列，如果为多行多列，分四次打印。

{% asset_img 转圈矩阵约束.png This is an example image %}

说明的是，在原方法中采用的是直接sout输出，此处使用StringBuilder进行添加。

~~~java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

class PringtEdge {
    //转圈打印矩阵
    public StringBuilder printCircle(int[][] arr){
        //1、找两个边界点
        int row1 = 0, col1 = 0;
        int row2 = arr.length-1,col2 = arr[0].length-1;
        StringBuilder sb = new StringBuilder();
        //只要满足边界条件，循环调用打印函数
        while (row1 <= row2 && col1 <= col2){
            printEdge(arr,sb,row1++,col1++,row2--,col2--);
        }
        return sb;
    }
    public void printEdge(int[][] arr, StringBuilder sb, int row1, int col1, int row2, int col2){
        //1、如果只有一行
        if (row1 == row2){
            for (int i = col1; i <= col2; i++) {
                sb.append(arr[row1][i]+" ");
            }
        }else if(col1 == col2){
            //2、如果只有一列
            for (int i = row1; i <= row2; i++) {
                sb.append(arr[i][col1]+" ");
            }
        }else{
            //3、分四部分打印
            int curR = row1;//当前行
            int curL = col1;//当前列
            while (curL < col2){
                sb.append(arr[curR][curL++]+" ");
            }
            while (curR < row2){
                sb.append(arr[curR++][curL]+" ");
            }
            while (curL > col1){
                sb.append(arr[curR][curL--]+" ");
            }
            while (curR > row1){
                sb.append(arr[curR--][curL]+" ");
            }
        }
    }
}
public class Main{
        public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        //要持有的写的类
        PringtEdge pe = new PringtEdge();
        String[] s = null;
        StringBuilder res = new StringBuilder();
        s = br.readLine().split(" ");
        int row = Integer.valueOf(s[0]);
        int col = Integer.valueOf(s[1]);
        int[][] arr = new int[row][col];
        for (int i = 0; i < row; i++) {
            s = br.readLine().split(" ");
            for (int j = 0; j < col; j++) {
                arr[i][j] = Integer.valueOf(s[j]);
            }
        }
        res = pe.printCircle(arr);
        System.out.println(res.substring(0,res.length()-1));
    }
}
~~~

#### 之字型打印矩阵

{% asset_img 之打印矩阵.png This is an example image %}

思路：宏观调度，打印的是两个点之间的对角线的值，那么只要解决点的运动路径和打印对角线即可。要注意的是点在运动过程中时，如果变量A依靠变量B来约束其行为，要先改变变量A，再改变B，不然B先改变则A会缺少值。而对角线打印的时候有方向变化，可以用标记变量来控制。

这种题目依靠的是宏观调度，不要去想每个点到底怎么变。

~~~java
//之字型打印矩阵，找宏观规律
    public StringBuilder printZhi(int[][] m){
        //往右，再下
        int row1 = 0,col1 = 0;
        //往下，再右
        int row2 = 0,col2 = 0;
        int endR = m.length-1;
        int endC = m[0].length-1;
        StringBuilder res = new StringBuilder();
        //先下，再上
        boolean fromUp = false;
        while (row1 <= endR){
            printProcess(m,res,row1,col1,row2,col2,fromUp);
            //路径变化
            //关键为将引发判断的值后判断
            row1 = col1 == endC ? row1+1:row1;
            col1 = col1 == endC ? col1:col1+1;
            col2 = row2 == endR ? col2+1 : col2;
            row2 = row2 == endR ? row2:row2+1;
            fromUp = !fromUp;
        }
        return res;
    }
    public void printProcess(int[][] m,StringBuilder res, int row1,int col1, int row2, int col2,boolean fromUp){
        //如果fromUp为false，从左下向右上打印
        if (!fromUp){
            while (row1 <= row2){
                res.append(m[row2--][col2++]+" ");
            }
        }else{
            while (row1 <= row2){
                res.append(m[row1++][col1--]+" ");
            }
        }
    }
~~~

#### 在行列都排好序的矩阵中找数

{% asset_img 排序矩阵找数.png This is an example image %}

思路：从右上角或者左下角开始找，此处选右上角，要是当前数小了就往下，当前数大了就往左。

精髓的点在于开始寻找的位置，利用矩阵的特征，可以将部分不可能的情况给排除掉，这题从右上角或者左下角开始找都可以。但是左上和右下不行，因为没办法缩小规模。核心在于右上或左下，**一边比它大，一边比它小**。这样子存在**要么去一边，要么另一边**的0 1情况，即非黑即白。

实质是将没有可能的数据直接舍弃，即将问题的规模进行缩小。

~~~java
    //在已排序的矩阵中找到数
    public boolean findNum(int[][] m,int k){
        //选择右上角的数
        int row = 0,col = m[0].length-1;
        int endR = m.length-1;
        while (row<=endR && col >=0){
            //如果当前数小，往下走
            if (m[row][col] == k){
                return true;
            }else if(m[row][col]>k){
                //当前数比较大，往左走
                col--;
            }else {
                row++;
            }
        }
        return false;
    }
~~~

### 链表

#### 打印两个链表的公共部分

给定两个升序链表，打印两个升序链表的公共部分。

思路：类似于外排，谁小动谁，如果相等，打印并两个一起动

值得注意的点：将head1或者2为空的情况放在最上面，直接返回；将head1.value==head2.value的情况放在三种判断的第一个，这样可以缩短判断时间；整理链表基本结构及生成链表的套路。StringBuilder添加时候，使用两次append比一次append两个str效率高。原因是使用+的时候多了生成String的步骤，这样降低了效率。

~~~java
    //打印两个链表公共部分
    public static void printCommonPart(Node head1,Node head2){
        //将不可能的情况先列出
        if (head1 == null || head2 == null)
            return;
        StringBuilder res = new StringBuilder();
        //类似外排
        //谁小动谁，如果相等，添加并两个一起动
        while (head1 != null && head2 != null) {
            //将相等的判断放在最上面
            if (head1.value == head2.value) {
                //这样比直接append(value+" ")效率高
                res.append(head1.value).append(" ");
                head1 = head1.next;
                head2 = head2.next;
            } else if(head1.value < head2.value){
                head1 = head1.next;
            }else{
                head2 = head2.next;
            }
        }
        System.out.println(res.toString());
    }
~~~

#### 判断链表是否为回文结构

给定链表的头结点，判断是否为回文链表

方式一：将链表元素全部存进栈中，利用栈先进后出的特点，与链表逐个比较，额外空间复杂度O(N)

```java
//解法1：将链表中的数据用栈存起来，然后一个个取出来进行对比
public boolean isPalindrome1(Node head){
    if (head == null || head.next == null)
        return true;
    //准备一个栈
    Stack<Node> stack = new Stack<>();
    Node node = head;
    while(node != null){
        stack.push(node);
        node = node.next;
    }
    //取出来比较
    node = head;
    while (!stack.isEmpty()){
        if (node.value != stack.pop().value)
            return false;
        node = node.next;
    }
    return true;
}
```

方法二：只放一半的元素进栈中，缩短一半的额外空间。

为了找到链表中点，用到的方法为快慢指针，是链表题目中比较常见的方法，慢指针一下子走一步，快指针走两步，当快指针走到末尾时，慢指针正好走到中间。注意：如果是要中点位置，慢指针从头结点开始，如果是中点位置下一个，慢指针从头节点下一个开始。此处慢指针的起始点就是头节点下一个。

~~~java
//解法2：只需要判断链表的一半即可，问题是如何找到链表的中点
    //用快慢指针
    public boolean isPalindrome2(Node head){
        if (head == null || head.next == null)
            return true;
        Node slow = head.next;
        Node fast = head;
        while (fast.next != null && fast.next.next != null){
            slow = slow.next;
            fast = fast.next;
        }
        //此时slow来到中点位置，将剩下的节点存入栈中
        Stack<Node> stack = new Stack<>();
        while (slow != null){
            stack.push(slow);
        }
        slow = head;
        while (!stack.isEmpty()){
            if (slow.value != stack.pop().value)
                return false;
            slow = slow.next;
        }
        return true;
    }
~~~

方法三：进阶方式，额外空间复杂度为O(1)，不依靠栈，而是先找到链表中点，将链表右半部分进行翻转，这里有个操作是将中点节点指向null，方便后面判断。然后从链表两端进行判断，注意不能直接返回值，因为还需要将链表还原。判断结束后，将链表右半部分还原。

注意：反转链表，删除链表节点需要利用3个指针，一个指向当前节点，一个指向当前节点的前序节点，一个指向当前节点的后序节点。先保存其下一个进行位置的，再进行操作。

~~~java
//解法3，不利用栈，先找到链表的中点，反转剩下的链表
    //进行判断，然后将链表还原
    public boolean isPalindrome3(Node head){
        if (head == null || head.next == null)
            return true;
        //找到链表中点
        Node n1 = head;
        Node n2 = head;
        while(n2.next != null && n2.next.next != null){
            n1 = n1.next;
            n2 = n2.next.next;
        }
        //此时n1来到中点，反转链表，先要记录n1下一个位置
        n2 = n1.next;
        n1.next = null;
        Node n3 = null;
        //反转链表
        while (n2 != null){
            n3 = n2.next;
            n2.next = n1;
            n1 = n2;
            n2 = n3;
        }
        //此时n1为链表末尾，进行记录
        n3 = n1;
        //开始判断头和尾的值是否相等
        n2 = head;
        boolean res = true;
        while (n2 != null && n1 != null){
            if (n2.value != n1.value){
                //不能直接返回假，这样链表没有被调整回来
                res = false;
                break;
            }
            n2 = n2.next;
            n1 = n1.next;
        }
        //还原链表
        n2 = n3.next;
        n3.next = null;
        while (n2 != null){
            n1 = n2.next;
            n2.next = n3;
            n3 = n2;
            n2 = n1;
        }
        return res;
    }
~~~

#### 单向链表的基础partition

题目描述：

给定一个链表，再给定一个整数 pivot，请将链表调整为左部分都是值小于 pivot 的节点，中间部分都是值等于 pivot 的节点， 右边部分都是大于 pivot 的节点。

除此之外，对调整后的节点顺序没有更多要求。

思路：将链表用数组存起来，然后对数组partition，再将数组组合成链表，返回arr[0]，要注意的是将数组的最后个元素的next指向null，以及partition过程的约束条件是index<more，不能取等于，不然会越界。

~~~java
//单链表的partition基础问题，利用数组来实现
    public static Node listPartition(Node head,int pivot){
        if (head == null || head.next == null)
            return head;
        //1、统计链表长度
        int len = 0;
        Node node = head;
        while(node != null){
            len++;
            node = node.next;
        }
        //2、造数组，将链表中元素填充进去
        Node[] arr = new Node[len];
        node = head;
        int i = 0;
        while (node != null){
            arr[i++] = node;
            node = node.next;
        }
        //3、数组的partition问题
        //将其封装为函数
        partitionArr(arr,pivot);
        //将数组组合成链表
        for (i = 1; i < len; i++) {
            arr[i-1].next = arr[i];
        }
        //将最后个节点指针指向null
        arr[i-1].next = null;
        return arr[0];
    }
    public static void partitionArr(Node[] arr, int pivot){
        int less = -1;
        int more = arr.length;
        int i = 0;
        //约束条件为i < more或者i != more
        //如果是等于，当more为数组最后，会越界
        while (i < more){
            if (arr[i].value < pivot){
                swap(arr,i++,++less);
            }else if (arr[i].value > pivot){
                swap(arr,i,--more);
            }else {
                i++;
            }
        }
    }
~~~

#### 单链表的partition进阶

要求：在原来基础之上，partition后每个部分的节点从左至右的顺序和原链表中节点的顺序一致。要时间复杂度O（N）,额外空间复杂度O（1）。

思路：将原链表拆分为小，等，大三个区域，遍历链表，来一个就丢到对应的位置中去（将节点从原链表中断开），最后将三个链表合并，考察的是扣边界能力。

~~~java
    //链表的复杂partition
    public static Node listPartition2(Node head,int pivot){
        if (head == null || head.next == null)
            return head;
        //分三个部分，小于、等于、大于区，来个节点就丢到对应的地方去
        //最后将三个部分合并
        Node sH = null;
        Node sT = null;
        Node eH = null;
        Node eT = null;
        Node bH = null;
        Node bT = null;
        Node next = null;
        while(head != null){
            next = head.next;
            head.next = null;
            //将当前节点丢到三个部分中
            if (head.value < pivot){
                //如果为空
                if (sH == null){
                    sH = head;
                    sT = head;
                }else{
                    sT.next = head;
                    sT = head;
                }
            }else if(head.value == pivot){
                if (eH == null){
                    eH = head;
                    eT = head;
                }else{
                    eT.next = head;
                    eT = head;
                }
            }else{
                if (bH == null){
                    bH = head;
                    bT = head;
                }else{
                    bT.next = head;
                    bT = head;
                }
            }
            head = next;
        }
        //将三个链表连接
        if (sT != null){
            sT.next = eH;
            eT = eT == null ? sT:eT;
        }
        if (eT != null){
            eT.next = bH;
        }
        return sH != null ? sH : eH != null ? eH : bH;
    }
~~~

#### 复制含有随机节点的链表

方法一：用哈希表，将key为原链表节点，value为新链表节点，然后再复制下一个和rand指针关系

~~~java
public static Node copyListWithRand1(Node head){
    //创建存储用的HashMap，key与value均为Node
    HashMap<Node,Node> map = new HashMap<Node,Node>();
    Node cur = head;
    //对每个结点进行拷贝
    while(cur != null){
        map.put(cur, new Node(cur.value));
        cur = cur.next;
    }
    cur = head;
    while (cur != null){
        //将复制节点的next与random指向cur相同部分
        //get(x)为得到x节点的拷贝结点x'
        map.get(cur).next = map.get(cur.next);//1' 指向 2(1.next)的对应节点2'
        map.get(cur).random = map.get(cur.random);
        cur = cur.next;
    }
    return map.get(head);
}
~~~

方法二：不使用其他数据结构，在原来链表中每个节点后面复制一个新节点，然后复制rand指针关系，再将两个链表拆分开来

~~~java
public static Node copyListWithRand2(Node head){
    if(head == null)
        return null;
    Node cur = head;
    Node next = null;
    // copy node and link to every node
    while(cur != null){
        next = cur.next;
        cur.next = new Node(cur.value);
        cur.next.next = next;
        cur = next;
    }
    cur = head;
    Node curCopy = null;
    // set copy node rand
    while (cur != null){
        next = cur.next.next;
        curCopy = cur.next;
        curCopy.random = cur.random != null ? cur.random.next : null;
        cur = next;
    }
    Node res = head.next;//记录下复制链表的头结点
    cur = head;
    // split
    while(cur != null){
        next = cur.next.next;
        curCopy = cur.next;
        cur.next = next;
        curCopy.next = next != null ? next.next : null;
        cur = next;
    }
    return res;
}
~~~

#### 反转链表

反转单链表和双链表，基本思路是持有三个节点，当前节点的前序节点，当前节点，下一个节点。

对于单链表，如果当前节点不为空，保存其下一个节点next，当前节点指向前序节点pre，pre=当前节点，当前节点=next，这样便实现了反转；对于双向链表，只是多了一步让当前节点的前序节点=next，其他和单向链表一样。

~~~java
	//反转单向链表
    public static Node reverseListSL(Node head){
        //准备三个节点
        Node pre = null;
        Node cur = head;
        Node next = null;
        while (cur != null){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
    //反转双向链表
    public static Node reverseListDL(Node head){
        //准备三个节点
        Node pre = null;
        Node cur = head;
        Node next = null;
        while (cur != null){
            next = cur.next;
            cur.next = pre;
            cur.pre = next;
            pre = cur;
            cur = next;
        }
        return pre;
    }
~~~

