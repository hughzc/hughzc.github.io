---
title: 并发与锁总结
date: 2020-02-27 11:24:31
tags: [并发,锁]
categories: 并发
---

要学习一个知识点，可以采取的思路是了解为什么要用它，怎么用它，有什么缺点，如何去改进。

对于并发 ，也将从这四个方面进行介绍。

<!-- more -->

> 引用到的资料来源：
>
> https://blog.csdn.net/cy973071263/article/details/104546954
>
> [https://blog.csdn.net/javazejian/article/details/72828483#%E7%90%86%E8%A7%A3java%E5%AF%B9%E8%B1%A1%E5%A4%B4%E4%B8%8Emonitor](https://blog.csdn.net/javazejian/article/details/72828483#理解java对象头与monitor)
>
> https://blog.csdn.net/qq_37113604/article/details/81582784?depth_1-utm_source=distribute.pc_relevant.none-task

## 并发应用场景

利用多线程去替代单线程，主要有两个应用场景。

1. 获得更好的性能

   单线程执行速度有限，为了获得更好的性能需要使用多线程

2. 由于业务模型的需要

   确实需要多个执行实体

需要分清进程与线程的区别

### 为什么要有进程与线程

进程为了解决并发操作问题，保存了当前线程的状态，由于分配时间短，会有不同进程并行执行的感觉（实际为并发）。但一个进程只能一次执行一个任务，若子任务不存在顺序的区别，可以并发执行。让CPU切给子任务更细的时间片去执行。这样一个进程包括多个线程。

**进程让操作系统的并发成为可能，线程让进程的内部并发成为可能**。

### 进程与线程区别

- 进程可以看作是独立应用，线程不可以

- 进程有独立的地址空间，相互不影响，线程只是进程的不同执行路径，线程没有独立的地址空间
- 多进程程序比多线程程序健壮
- 进程的切换比线程的切换开销大

## 多线程怎么用

### 线程状态

1. 新建（New）：创建后尚未启动的线程的状态（还未调用start方法）

2. 运行（Runnable）：包含Running和Ready（正在执行或等待CPU为其分配时间）

3. 无限期等待（Waiting）：不会被分配CPU执行时间，需要显式被唤醒
4. 限期等待（Timed Waiting）：在一定时间后会由系统自动唤醒（sleep方法）
5. 阻塞（Blocked）：等待获取排它锁（Synchronized）
6. 结束（Terminated）：已终止线程的状态，线程已经结束执行（run或main方法结束）

{% asset_img 线程状态.png This is an example image %}

### Java使用多线程的三种方式

#### 方式一：继承Thread类

1、 定义一个类继承Thread类

2、 覆盖Thread类中的run()方法。Thread类用于描述线程，因此Thread类也有对任务的描述，这个任务就是通过Thread类中的run()方法来体现，因此 run()方法就是封装自定义线程运行任务的函数。run方法中定义的是线程要运行的任务代码。

3、 直接创建Thread的子类对象创建线程

4、 调用start()方法，作用为启动线程，调用run()方法

~~~java
class MyThread extends Thread{
    @Override
    public void run(){
        for (int i = 0; i < 50; i++) {
            System.out.println(MyThread.currentThread().getName()+" "+i);
        }
    }
}
~~~

在调用的时候

~~~java
MyThread t1 = new MyThread();
MyThread t2 = new MyThread();
t1.start();
t2.start();
~~~

原理：Thread本身实现了Runnable接口，通过start()方法启动线程，native方法start()启动新线程并执行run()方法，实现方式较为简单，但继承有局限性。

#### 方式二：实现Runnable接口

1、 定义类实现Runnable接口

2、 覆盖接口中的run()方法，将线程的任务代码封装到run()方法中

3、 通过Thread类创建对象，并将Runnable接口的子类对象作为Thread类构造函数的参数进行传递

原因：因为线程的任务都封装在Runnable子类对象run()方法中，所以要在线程对象创建时明确要运行的任务。

4、 调用线程对象的start()方法启动线程

~~~java
class RunTest implements Runnable{
    @Override
    public void run(){
        for (int i = 0; i < 50; i++) {
            System.out.println(Thread.currentThread().getName()+" "+i);
        }
    }
}
~~~

调用方式

~~~java
RunTest r = new RunTest();
Thread t1 = new Thread(r);
Thread t2 = new Thread(r);
t1.start();
t2.start();
~~~

原理：当传入一个Runnable类型的任务参数target给Thread后，Thread的run()方法就会调用target.run()

#### 方式三：实现Callable接口

1、创建Callable接口的实现类，并实现call()方法，并创建该实现类的实例

2、使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值

3、使用FutureTask对象作为Thread对象的target创建并启动线程

4、调用FutureTask对象的get()方法来获得子线程执行结束后的返回值

~~~java
class MyCallable implements Callable<String>{
    @Override
    public String call() throws InterruptedException {
        String value = "test";
        System.out.println("Ready to work");
        Thread.currentThread().sleep(5000);
        System.out.println("task done");
        return value;
    }
}
~~~

启动线程

~~~java
    public static void main(String[] args) throws Exception {
        FutureTask<String> task = new FutureTask<String>(new MyCallable());
        new Thread(task).start();
        if (!task.isDone()){
            System.out.println("task has not finished, please wait");
        }
        System.out.println("task return : " + task.get());
    }
~~~

get方法会被阻塞直到子线程结束。

#### 三种方法的比较

实现Runnable和实现Callable接口的方式大致相同，基本思路均为将任务进行分装再传递给Thread对象，但后者执行call()方法有返回值且get()方法可以获取异常，且Callable接口可以搭配线程池使用，进行统一管理。二者和Thread的比较为：

1、Thread是一个类，Runnable是一个接口；

2、继承Thread类后不能继承其他类，而实现Runnable接口后仍可继承其他类，更为灵活，避免了单继承的局限性；

3、Thread类中的资源不能共享（多个任务对象），而实现Runnable接口可以实现资源共享（只有一个任务对象）；

4、Runnable将任务记性封装，更体现了面向对象的编程思想。

因此相比于继承Thread，更推荐使用Runnable接口来实现多线程。

#### Thread中run()方法执行顺序

~~~sql
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("R run");
            }
        }
        ){
            @Override
            public void run(){
                System.out.println("T run");
            }
        }.start();
~~~

输出为T run，看Thread中run()方法的源码

~~~sql
    /* What will be run. */
    private Runnable target;
    
@Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }
~~~

​	其会对target进行判断，当target不为空的时候，执行Runnable的run方法，但由于多态，当子类方法覆写了父类方法时，会优先执行子类方法。因此执行顺序为Thread子类>Runnable方法>Thread类

## 线程安全问题

上文中介绍了为什么要用多线程及如何使用，但当多个线程操作一个资源时，会带来安全问题。如两个线程都在卖票，剩最后一张票的时候，会出现票数量<0的情况。

~~~java
class Ticket implements Runnable{
    private int num = 10;
    @Override
    public void run(){
        while (true){
            if (num > 0){
                try {
                    Thread.sleep(500);
                }catch (InterruptedException e){
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName()+" "+num--);
            }
        }
    }
}
~~~

当开启多个线程卖票的时候，会出现如下的结果

{% asset_img 卖票.png This is an example image %}

已经限制了票数要>0，为什么会出现票数=-1的情况呢？

### 线程安全产生原因

1.  多个线程在操作共享的数据。

2.  操作共享数据的线程代码有多条。（操作共享数据代码在2行以上容易出事）

当一个线程在执行操作共享数据的多条代码中，其他线程参与了运算，就会导致线程安全问题的产生。

那么该如何解决呢？

解决思路：将多条操作共享数据的线程代码封装起来；当有线程在执行这些代码的时候，其他线程是不可以参与运算的。必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算，类似于上锁，当一群人要去上厕所，谁进去了将门锁住，其他人（线程）也就进不来了。

## 解决办法

### 乐观锁与悲观锁

为了解决线程安全问题，有的锁比较悲观，认为其他线程一定会修改数据，因此在拿数据的时候会上锁，若其他线程访问会被阻塞，Java中关键字synchronized的实现为悲观锁；而乐观锁，在拿数据时，认为别人不会修改，不会上锁，但在更新时会判断其他线程有没有更新数据。乐观锁适用于多读的场景，可以提高吞吐量。CAS就是比较常见的乐观锁的实现方式。

下面将主要将介绍比较常见的synchronized，RenentrantLock与JMM的内存可见性（volatile）与CAS。

### synchronized

synchronized为互斥锁，具有的特性为

1. 互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程的协调机制，这样在同一时间只有一个线程对需要同步的代码块（复合操作）进行访问。互斥性也称为操作的**原子性**。

2. 可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（**即在获得锁时应获得最新共享变量的值**），否则另一个线程可能是在本地缓存的某个副本上继续操作，从而引起不一致。

synchronized锁的不是代码，锁的都是对象。

#### synchronized使用

可以分为对象锁和类锁，均加在同步代码块上或同步方法上。同步代码块的使用如下

对象锁：

1、 同步代码块（synchronized(this)）, synchronized(类实例对象))，锁是小括号()中的实例对象

~~~java
synchrnozed(this或类实例对象){
	//要同步的代码
}
~~~

2、 同步非静态方法（synchronized method），锁是当前对象的实例对象

~~~java
public synchronized 返回值 method(){
	//要同步的代码
}
~~~

类锁：

1、 同步代码块（synchronized(类.class)），锁时小括号()中的类的对象（Class对象）

~~~java
synchrnozed(类.class){
	//要同步的代码
}
~~~

2、 同步静态方法（synchronized static method），锁是当前对象的类对象（Class对象）

~~~java
public synchronized static 返回值 method(){
	//要同步的代码
}
~~~

#### 死锁

当出现锁的嵌套时，容易出现死锁。即线程1先获取锁A，再获取锁B；而线程2先获取锁B，再获取锁A。这时候两个线程均不能请求 到另一个锁，就会出现死锁，进程卡死。

要注意的是，这里的两个锁对象一定要用static修饰，因为要保证这两个对象随类加载保证唯一性，如果不加static，就会每次new DeadLockSyn的时候，产生各自的两个o1，o2，则不能出现死锁现象。

~~~java
class DeadLockSyn implements Runnable{
    //要加static是因为随类的创建而产生
    //如果不加static，那么产生的是各自的object对象，不是同一个锁了
    public static Object o1 = new Object();
    public static Object o2 = new Object();
    private boolean flag;
    public DeadLockSyn(boolean flag){
        this.flag = flag;
    }
    @Override
    public void run(){
        if (flag){
            synchronized (o1){
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {}
                synchronized (o2){
                }
            }
        }else {
            synchronized (o2){
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {}
                synchronized (o1){
                }
            }
        }
        System.out.println(Thread.currentThread().getName()+"完成任务");
    }
}
~~~

调用过程

~~~java
        DeadLockSyn d1 = new DeadLockSyn(true);
        DeadLockSyn d2 = new DeadLockSyn(false);
        Thread t1 = new Thread(d1);
        Thread t2 = new Thread(d2);
        t1.start();
        t2.start();
~~~

简单实现死锁程序的关键

- 两个锁对象保证唯一性：static修饰
- 两个锁的嵌套调用

#### 线程间通信

当每个线程可以独立安全的完成自己的任务了，但如果A线程的任务涉及到了B线程，如A线程是生产烤鸭的，B线程是吃烤鸭的，只有生产出来的烤鸭被吃掉了A才会继续生产，那要如何实现呢？

这时候需要用到线程间的通信，即A线程刚来做烤鸭，发现B线程还没吃，就跟B线程交流下，让他快点吃，自己先睡个觉，等烤鸭被吃了再起来吃。主要用到的方法是wait、notify()与notifyAll()。

**生产者与消费者**

基本的实现思路是：封装一个烤鸭资源对象，实现Runnable接口，有一个标识变量，代表烤鸭有没有被吃。生产烤鸭的方法需要加锁，首先判断烤鸭有没有被吃，如果没被吃，生产任务停止，唤醒吃烤鸭任务。如果烤鸭被吃了，进行生产。吃烤鸭的方法与生产类似。

需要持有一个资源，其属性有资源名称name，当前资源数量和标志变量（用来判断消费还是生产）。对同步的生产方法，当还没有消费的时候，让当前线程wait，释放锁；当已经消费了，进行生产，反转标志变量，数量自增，唤醒其他线程。对同步的消费方法，当还没有生产的时候，让当前线程wait，释放锁；当已经生产了，进行消费，反转标志变量，唤醒其他线程。生产者和消费者类持有资源类对象，实现Runnable接口，并分别在run()方法中调用其生产和消费方法。

~~~java
class Resource{
    private int count = 0;
    private boolean flag = false;
    private String name;//生产的物品名称
    //同步的生产方法
    public synchronized void set(String name){
        //当还没有消费，生产线程等待
        while (flag){
            try {
                wait();
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
        //开始生产
        this.name = name;
        count++;
        flag = true;
        System.out.println(Thread.currentThread().getName()+"生产"+name+count);
        notifyAll();
    }
    //同步的消费方法
    public synchronized void out(){
        //当还没有生产，消费线程等待
        while (!flag){
            try {
                wait();
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
        //开始生产
        System.out.println(Thread.currentThread().getName()+"消费"+this.name+count);
        flag = false;
        notifyAll();
    }
}
//生产者
class Producer implements Runnable{
    private Resource r;
    public Producer(Resource r){
        this.r = r;
    }
    @Override
    public void run(){
        while (true){
            r.set("烤鸭");
        }
    }

}
//消费者
class Consumer implements Runnable{
    private Resource r;
    public Consumer(Resource r){
        this.r = r;
    }
    @Override
    public void run(){
        while (true){
            r.out();
        }
    }
}
public static void main(String[] args) throws Exception {
        Resource r = new Resource();
        Producer p = new Producer(r);
        Consumer c = new Consumer(r);
        Thread t1 = new Thread(p);
        Thread t2 = new Thread(p);
        Thread t3 = new Thread(c);
        Thread t4 = new Thread(c);
        t1.start();
        t2.start();
        t3.start();
        t4.start();
    }
~~~

值得注意的是，在同步方法中判断标记要使用while而不能使用if，因为if只进行一次判断，不安全。唤醒线程的时候要使用notifyAll()而不能使用notify()，不然容易造成死锁。notify是唤醒线程池中的一个线程，而notifyAll是唤醒线程池中的所有线程。

可见在synchronized中，线程间通信主要依靠wait()、notify()和notifyAll()方法，这三个方法均在Object类中，那么既然wait()和sleep()都能让线程休眠，二者有什么区别呢？

**wait和sleep**差别

**基本差别**

1. sleep是**Thread**类的方法，wait是**Object**类中定义的方法

2. sleep()方法可以在任何地方使用， wait()方法只能在synchronized方法或synchronized块中使用
3. sleep在设置时间结束后自动唤醒，而wait需要使用notify或者notifyAll方法唤醒

**本质差别**

​	Thread.sleep只会让出CPU，不会导致锁行为的改变；Object.wait不仅会让出CPU，还是释放已经占有的同步资源锁

二者相比，sleep类似于线程在厕所中睡着了，wait类似于从厕所中让出来睡着了。

介绍了synchronized后，需要了解为什么每个对象都可以作为锁，即需要了解synchronized的底层原理

#### 底层实现

#### 实现基础

实现synchronized的基础是以下两点

- Java对象头
- Monitor

#### 对象头结构

​	在JVM中，对象在内存中的布局有对象头、实例数据（存放类的属性数据信息）和对齐填充（虚拟机要求对象起始地址必须是8字节的整数倍）。一般synchronized使用的**锁对象**是存储在**Java对象头**里的，头结构由**Mark Word** 和**CLass Metadata Address**组成，其中CLass Metadata Address用于**确定该对象是哪个类的实例**；而**Mark Word**用于存储对象自身的运行时数据，是实现轻量级锁和偏向锁的**关键**，默认存储着对象的hashCode，分代年龄，锁类型，锁标志位等信息。

#### Markword

{% asset_img markword.png This is an example image %}

MarkWord被设计为一个**非固定**的数据结构，以便存储更多有效数据，会根据对象本身的状态，复用存储空间，轻量级锁和偏向锁是JDK6后新增。

#### Monitor

对于重量级锁，锁标志位是10，指针指向的是monitor对象的起始地址，**每个对象都有Monitor与之关联**，monitor被线程持有后就处于锁定状态。在Java虚拟机中，monitor是由ObjectMonitor实现。monitor底层由C++实现，里面有两个队列，WaitSet（等待池）和EntryList（锁池），而owner指向持有ObjectMonitor对象的线程。

具体过程为：当有多个线程同步访问同步代码时，进入锁池集合，当线程获取到锁对象的monitor以后，进入_Owner 区域并将owner变量设置为当前线程，Monitor中的计数器count+1，如果当前线程调用了wait()方法，会释放当前的Monitor，将owner变量设置为null，count减一，该线程进入等待池来等待被唤醒。若当前变量执行完毕，也会释放Monitor锁，并将对应的变量值复位。

{% asset_img monitor.png This is an example image %}

monitor对象存在于每个Java对象的对象头中，synchronized锁通过这种方式获取锁，这也是为什么所有Java对象均可以作为锁的原因，也是wait,notify,notifyAll等方法存在于对象Object中的原因。而wait,notify,notifyAll方法需要在synchronized中使用是因为调用这几个方法前必须拿到当前对象的监视器monitor对象，而synchronized关键字可以获取 monitor，因此若不在synchronized中使用会报IllegalMonitorStateException异常。

接下来反编译synchronized应用于同步代码块和同步方法中的情况

~~~java
public class Sync{
    public void synBlock(){
        synchronized (this){
            System.out.println("synchronized in code block");
        }
    }
    public synchronized void synMethod(){
        System.out.println("synchronized in method");
    }
}
~~~

具体操作为先javac生成对应class文件，然后执行javap -v Sync，首先看应用于同步代码块中的情况

~~~java
 	   3: monitorenter
       4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
       7: ldc           #3                  // String synchronized in code block
       9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      12: aload_1
      13: monitorexit
      14: goto          22
      17: astore_2
      18: aload_1
      19: monitorexit
~~~

截取了最重要的输出，可看到同步代码块实现的方式为monitorenter和monitorexit，分别是同步 开始和结束的位置。当执行monitorenter，当前线程会尝试获取对象锁，当计数器为0时，可以成功获取monitor并将计数器置为1，表示持有锁，当已经拥有此锁的时候，可以重入（再次遇到有相同对象锁时，可以获取）；若其他线程持有了锁，便会在monitorenter处阻塞，直到其他线程释放锁并将计数器置为0。为了保证monitorenter和monitorexit可以正常配对执行，编译期产生处理器声明可以处理任何异常，目的是为了处理monitorexit指令，正常释放锁，因此多了一个monitorexist。

而对于同步方法，并没有显式的monitorenter等，而是用ACC_SYNCHRONIZED访问标志来区分此方法是否是同步方法，当方法调用时，检查方法此标识是否被设置，如果设置则持有monitor，无论方法是否正常完成，释放monitor。

~~~java
 public synchronized void synMethod();
    descriptor: ()V
    flags: ACC_PUBLIC, ACC_SYNCHRONIZED
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #5                  // String synchronized in method
         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
~~~

在早期，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间（时间成本相对较高）。而从JDK6以后，其性能有了较大提升

### synchronized优化

#### **锁的膨胀**

锁并不会一开始就进入到重量级锁，在JDK6对锁优化后，锁的状态有四种，并且会根据实际情况膨胀升级，膨胀方向为无锁->偏向锁->轻量级锁->重量级锁。

**偏向锁**

在很多情况下，锁不存在多线程竞争，总是由一个线程多次获得。其核心的思想是：当一个线程获得了锁，锁就进入偏向模式，Markword的结构调整为偏向锁模式，当该线程再次请求锁的时候，获取锁的过程只要检查Markword的**锁标记位**是偏向锁且当前线程id与Markword中**ThreadID**相等即可，这样便可以省去很多锁申请的操作。

​	适用条件：无锁竞争的场合，但不适用于比较激烈的多线程场合。偏向锁失败后会先升级为轻量级锁。

**轻量级锁**

​	轻量级锁适用于线程交替执行同步代码，其依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，只允许顺序拿锁，但如果有竞争操作，轻量级锁会先尝试自旋，尝试失败后会膨胀为重量级锁。

轻量级锁的加锁过程

1. 在代码进入到同步代码块的时候，如果同步对象锁是无锁状态（锁标志位是‘01’），虚拟机首先在当前 线程的栈帧中建立叫锁空间（Lock Record）的空间用于存储锁对象目前的Mark Word拷贝，官方称为Displaced Mark Word，此时线程堆栈和对象头状态如下

{% asset_img 轻量级1.png This is an example image %}

2. 拷贝对象头中的Mark Word复制到锁记录中
3. 拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record中owner指针指向object mark word。如果更新成功，执行步骤4，否则执行步骤5
4. 如果更新成功，当前线程就拥有了该对象的锁，并且对象mark word锁标志设置成‘00’，表示此对象处于轻量级锁状态，此时线程堆栈与对象头的状态如下

{% asset_img 轻量级2.png This is an example image %}

5. 如果更新失败了，虚拟机首先将检查对象的mark word是否指向当前线程的栈帧，是说明当前线程已经拥有了锁，可以直接进入同步块继续执行。否则说明有多个线程竞争锁，先进行一段时间的自旋，如果自旋期间成功获得锁，则执行同步代码。若自旋结束后也没有获得锁，则将膨胀为重量级锁，将锁标志位变成‘10’，此时mark word中存储的就是指向重量级锁的指针，后面等待锁的线程进入阻塞状态。

执行完毕解锁

1. 通过CAS操作尝试把线程栈帧中复制的Displaced Mark Word对象替换当前的Mark Word
2. 若替换成功，整个同步过程就完成了
3. 若替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），则要在释放锁的同时，唤醒被挂起的线程

**自旋锁**

轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。依赖的思想是也许几个CPU周期后就可以获得锁，虚拟机会让当前等待锁的线程做几个空循环（称为自旋的原因），经过固定的若干次循环后，如果得到锁，就进入临界区。反之，就会将线程真实地在操作系统层面挂起。

自旋锁的缺点是：若锁被其他线程长时间占用，会带来许多性能上的开销

因此自旋**需要有一定的限度**，如果超出限度还没有获取到锁，就要用传统的方法去挂起线程。

对自旋锁有优化，为**自适应自旋锁**，自旋的次数不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，这样JVM依据之前自旋成功率在增加或减少自旋次数，**更加精确**。

比较三种锁如下

| 锁       | 优点                                                         | 缺点                                                         | 适用场景                                             |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------------------------- |
| 偏向锁   | 加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距 | 若线程存在锁竞争，会带来额外的锁撤销的消耗                   | 只有**一个线程**访问同步块或同步方法                 |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度                     | 若线程长时间抢不到锁，自旋会消耗CPU性能                      | **线程交替执行**同步方法块或同步方法的场景           |
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU                              | 线程**阻塞**，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗 | 追求吞吐量，同步块或者同步方法**执行时间较长的场景** |

#### 锁消除

上面介绍了第一种优化方式是使用锁膨胀来代替单纯的重量级锁，而第二种方式为使用锁消除。

在JIT（Just-In-Time Compiler）编译时，对运行上下文进行扫描，去除不可能存在竞争的锁

~~~java
    public void method1(){
        Object o = new Object();
        synchronized (o){
            System.out.println("method1");
        }
    }
    public void method2(){
        Object o = new Object();
        System.out.println("method2");
    }
~~~

在上面代码中，method1中方法虽然被同步修饰，但锁变量为方法内的私有变量，不会被其他线程获取到，因此在编译阶段会被优化掉，反编译得到结果如下

~~~java
 public void method1();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
~~~

可以看到并没有ACC_SYNCHRONIZED标志。

在动态编译同步块的时候，JIT编译器借助逃逸分析（Escape Analysis）技术来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。

#### 锁粗化

锁粗化是虚拟机对另一种极端情况的优化处理，通过扩大锁的范围，避免反复加锁和释放锁。

一般设置同步时尽量限制在小的范围，只在共享数据的实际作用域中，减少等待时间。但如果有一连串操作对一个对象**反复加锁解锁**，甚至加锁操作出现在**循环体**中，即使没有线程竞争，频繁进行互斥同步锁操作，会降低性能。当JIT此时会将加锁同步的范围扩散（粗化）到整个**操作序列的外部**。

~~~java
    public void test1(){
        for (int i = 0; i < 1000000; i++) {
            synchronized (this){
            }
        }
    }
    public void test2(){
        synchronized (this){
            for (int i = 0; i < 1000000; i++) {
            }
        }
    }
~~~

上面操作中，在循环体中进行了加锁，如果没有锁粗化，那么方法一应该会比方法二慢很多，但测试了两端代码运行时间后，结果为下图

{% asset_img 锁粗化.png This is an example image %}

说明方法一种锁范围被扩大至循环体外，验证了锁粗化的效果。

上文中介绍了Java中使用synchrnonized上锁的方式，那么按照面向对象的思想，能否将锁及线程间的通信业对象化 呢？下面将介绍将介绍其增强版-重入锁。

### ReentrantLock

ReentranlLock位于java.util.concurrent.locks包，基于AQS（AbstractQueuedSynchronizer队列同步器）实现，AQS是Java并发构建锁或其他同步组件的基础，是JUC包的核心，一般使用AQS的方式为继承，而利用AQS实现同步结构，必须要实现同步结构，至少要实现acquire（实现资源的独占权）和release（释放对资源的独占）。

#### ReentranlLock特点

ReentrantLock的特点有：

- 重入锁有着显式的操作过程，必须手动指定何时加锁、释放锁，在逻辑控制的灵活性上好于synchronized。

- 在退出临界区时必须释放锁。

- 可以实现比synchronized更细粒度的控制，如控制锁的公平性

  在公平时，倾向于将锁赋予等待时间最长的线程

- 性能不一定比synchronized高，也是可重入（已持有锁的线程可以再次访问需要同一个锁的代码）的

  在低竞争场合，synchronized性能可能会优于ReentrantLock

#### ReentrantLock使用

使用可重入锁的流程分为三步：

1. 上锁
2. try中写同步执行代码
3. finally中解锁

#### 处理死锁

之前演示过了synchronized的死锁情况，使用ReentrantLock也可以达到相同的效果，那么有没有方法可以处理死锁呢？

**中断响应**

对于synchronized，线程等待锁，结果是要么获取锁执行，要么继续等待，而RenentranlLock提供了线程可以被中断的情况，在等待锁的过程中，程序可以根据需要取消对锁的请求，对处理死锁有一定的帮助。

~~~java
class IntLock implements Runnable{
    public static ReentrantLock lock1 = new ReentrantLock();
    public static ReentrantLock lock2 = new ReentrantLock();
    public int lockStatus;
    public IntLock(int lockStatus){
        this.lockStatus = lockStatus;
    }
    public void run(){
        try {
            if (lockStatus == 1){
                lock1.lockInterruptibly();
                try {
                    Thread.sleep(500);
                }catch (InterruptedException e){}
                lock2.lockInterruptibly();
            } else {
                lock2.lockInterruptibly();
                try {
                    Thread.sleep(500);
                }catch (InterruptedException e){}
                lock1.lockInterruptibly();
            }
            System.out.println(Thread.currentThread().getName()+"线程完成任务");
        }catch (InterruptedException e){
            e.printStackTrace();
        }finally {
            if (lock1.isHeldByCurrentThread())
                lock1.unlock();
            if (lock2.isHeldByCurrentThread())
                lock2.unlock();
            System.out.println(Thread.currentThread().getId()+"线程退出");
        }
    }
}
		//main函数中
        IntLock lock1 = new IntLock(1);
        IntLock lock2 = new IntLock(2);
        Thread t1 = new Thread(lock1);
        Thread t2 = new Thread(lock2);
        t1.start();
        t2.start();
        Thread.sleep(1000);
        t2.interrupt();
~~~

lock1与lock2容易形成死锁，lockInterruptibly方法可以对中断进行相应的锁申请动作，在等待锁的过程中可以响应中断。当t2被中断的时候，t2会放弃对锁lock1的申请，同时释放已经获得的lock2，这样t1线程就可以顺序获取lock2而执行下去。

{% asset_img 响应中断.png This is an example image %}

**锁申请等待限时**

除了等待外部通知将线程中断外，避免死锁还可以使用限时等待。给定等待时间，让线程自动放弃，	使用tryLock()方法进行限时的等待，tryLock()方法接收两个参数，等待时长和计时单位。在请求等待时间之内，如果请求成功，返回true，否则返回false。

~~~java
class TryLock implements Runnable{
    public static ReentrantLock lock = new ReentrantLock();
    @Override
    public void run(){
        try {
            if (lock.tryLock(5, TimeUnit.SECONDS)){
                Thread.sleep(6000);
                System.out.println(Thread.currentThread().getName()+"完成任务");
            }else {
                System.out.println(Thread.currentThread().getName()+"任务失败");
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally {
            if (lock.isHeldByCurrentThread())
                lock.unlock();
        }
    }
}
~~~

当创建两个线程去执行此任务时，会发现线程2执行失败，线程1执行成功。因为先持有锁的线程会持有锁6秒，而另一个线程等待锁只有5秒钟（5,TimeUnit.SECONDS），因此后请求锁的线程请求失败。

此方法也可以空参数运行，表示当前线程尝试获取锁，如果锁未被其他线程占用，申请锁成功，并立刻返回true；若锁被其他线程占用，当前线程不会等待，立刻返回false。这种模式不会引起线程等待，也不会引起死锁。

~~~java
class TryLockDeadLock implements Runnable{
    public static ReentrantLock lock1 = new ReentrantLock();
    public static ReentrantLock lock2 = new ReentrantLock();
    int lock;
    public TryLockDeadLock(int lock){
        this.lock = lock;
    }
    @Override
    public void run(){
        if (lock == 1){
            while(true){
                //上锁1
                if (lock1.tryLock()){
                    try {
                        try {
                            Thread.sleep(1000);
                        } catch (InterruptedException e) {}
                        //上锁2
                        if (lock2.tryLock()){
                            try {
                                System.out.println(Thread.currentThread().getName()+"job done");
                                return;
                            }finally {
                                lock2.unlock();
                            }
                        }
                    }finally {
                        lock1.unlock();
                    }
                }
            }
        }else{
            while(true){
                //上锁2
                if (lock2.tryLock()){
                    try {
                        try {
                            Thread.sleep(1000);
                        } catch (InterruptedException e) {}
                        //上锁1
                        if (lock1.tryLock()){
                            try {
                                System.out.println(Thread.currentThread().getName()+"job done");
                                return;
                            }finally {
                                lock1.unlock();
                            }
                        }
                    }finally {
                        lock2.unlock();
                    }
                }
            }
        }
    }
}
~~~

死锁代码：利用条件判断，第一个线程先用锁1，再用锁2；第二个线程先用锁2，再用锁1。使用tryLock()后，线程不会一直处于阻塞状态，会不停尝试，只要执行足够长的时间，线程会得到需要的资源（同时获得两个所），从而正常执行。但结果不总是会正常完成，有时还是会出现死锁。

#### 公平锁

在大多数情况下，锁的申请都是非公平的，即不会根据等待时间来挑选执行线程。而公平锁的特点是：不会产生饥饿现象，不会出现一线程长时间等待获取不到CPU分配时间的情况。

synchronized是非公平锁，而ReentrantLock可以设置为公平锁，将fair设置为true即可。

~~~java
public ReentrantLock(Boolean fair)
~~~

~~~java
class FairLock implements Runnable{
    public static ReentrantLock fair = new ReentrantLock(true);
    public void run(){
        while (true){
            //1、上锁
            fair.lock();
            //2、try中运行代码
            try {
                System.out.println(Thread.currentThread().getName()+"工作");
            }
            //3、finally中释放锁
            finally {
                fair.unlock();
            }
        }
    }
}
~~~

这样，当开启两个线程时，两个线程轮流输出，几乎不会发生同一个线程多次获得锁的可能，而如果使用非公平锁会出现一个线程多次获得锁进行输出。实现公平锁要维护一个有序队列，实现成本比较高，性能比较低下，默认可重入锁是非公平的，若无特殊需求不使用公平锁。

#### Condition

在synchrnozied中，有wait、notify和notifyAll搭配使用进行线程间的通信，而ReentrantLock中也有，那就是Condition，Condition与重入锁相关联，通过newCondition()方法可获取Condition对象，一个锁可以获得多个Condition，类似的，Condition中提供了await()、signal()、signalAll()方法。

下面将基于重入锁和Condition来实现多生产多消费者模式。核心是一个锁，两个监视器，在要同步的方法中，先上锁，然后在try中写同步代码，最后在finally中解锁。其中利用标志变量来判断当前线程是否休眠。生产者和消费者类实现Runnable接口，在run()方法中调用资源类的方法即可。要注意的是，生产完后，要唤醒消费线程；消费完后，要唤醒生产线程。

~~~java
class LockResource{
    //一个锁，两个监视器
    public static ReentrantLock lock = new ReentrantLock();
    Condition proCondition = lock.newCondition();
    Condition conCondition = lock.newCondition();
    public boolean flag = false;
    public int count = 0;
    public String name;
    public LockResource(String name){
        this.name = name;
    }
    //同步set方法
    public void set(){
        //1、上锁
        lock.lock();
        //2、在try中写同步代码
        try {
            while (flag){
                try {
                    proCondition.await();
                } catch (InterruptedException e) {}
            }
            //进行生产
            count++;
            flag = true;
            System.out.println(Thread.currentThread().getName()+"生产"+name+count);
            //唤醒消费线程
            conCondition.signal();
        }
        //3、在finally中解锁
        finally {
            lock.unlock();
        }

    }
    //同步消费方法
    public void out(){
        //1、上锁
        lock.lock();
        //2、在try中写同步代码
        try {
            while (!flag){
                try {
                    conCondition.await();
                } catch (InterruptedException e) { }
            }
            //进行消费
            flag = false;
            System.out.println(Thread.currentThread().getName()+"消费"+name+count);
            //唤醒生产线程
            proCondition.signal();
        }
        //3、在finally中解锁
        finally {
            lock.unlock();
        }
    }
}
class ProducerRe implements Runnable{
    private LockResource r;
    public ProducerRe(LockResource r){
        this.r = r;
    }
    @Override
    public void run(){
        while (true){
            r.set();
        }
    }
}
class ConsumerRe implements Runnable{
    private LockResource r;
    public ConsumerRe(LockResource r){
        this.r = r;
    }
    @Override
    public void run(){
        while (true){
            r.out();
        }
    }
}
~~~

#### synchronized和ReentrantLock区别

1. synchronized是关键字，ReentrantLock是类
2. ReentrantLock可以设置为公平锁，synchronized不行
3. ReentrantLock可以设置锁的等待时间，避免死锁
4. 底层机制：sync操作对象头中Mark Word，lock调用Unsafe类中方法

### JMM内存可见性

Java内存模型（Java Memory Model，简称JMM）是抽象概念，描述一组规范，围绕原子性、有序性和可见性展开。通过此规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。

**原子性**

原子性指一个操作不可中断，即使是多个线程一起执行的时候，一个操作一旦开始就不会被其他线程干扰。

**可见性**

可见性指当一个线程修改了某个共享变量的值，其他线程能够立刻知道这个修改。以下情况会导致可见性问题

- 缓存优化

  CPU改动后的值被缓存在cache或寄存器中，另一个CPU读到值没有更新

- 硬件优化

  一些内存读写不会立即触发，而会先进入一个硬件队列等待

- 指令重排及编辑器优化

**有序性**

在并发时，程序的执行可能会出现乱序，原因是程序在执行时可能会进行指令重排，重排后的指令与原指令未必一致。

线程将变量从主内存中拷贝至线程自己的本地内存进行操作，操作完成后再放回主内存。主内存和工作内存的关系是，工作内存是主内存的备份，工作内存是线程的私有区域。因此线程间的传值必须依靠主内存来完成。

{% asset_img 主内存.png This is an example image %}

#### JMM中主内存和工作内存

JMM中的主内存

- 存储Java实例对象
- 包括成员变量、类信息、常量、静态变量等
- 属于数据共享的区域，多线程并发操作会引发线程安全问题

JMM中的工作内存

- 存储当前方法的所有本地变量信息，本地变量对其他线程不可见
- 字节码行号指示器，Native方法信息
- 属于线程私有区域，不存在线程安全问题

主内存与工作内存的数据类型及操作方式

- 方法里的基本数据类型本地变量将直接存储在工作内存的栈帧结构中
- 引用类型的本地变量：引用存储在工作内存中，实例存储在主内存中
- 成员变量、static信息、类信息均存储在主内存中
- 主内存共享的方式是线程各拷贝一份数据到工作内存，操作完成后刷新回主内存

前面提到指令重排会影响可见性和有序性，但指令重排对提高CPU性能非常重要，那什么时候不能够指令重排呢？答案是无法通过happens-before原则推导出来的，才能进行指令重排。在JVM内部的实现，通常依赖于**内存屏障**，通过禁止某些重排序的方式，提供内存可见性保证，即实现了各种happens-before的规则。下面将简单介绍下happens-before原则。

#### happens-before

1. 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；（先来后到）
2. 锁定规则：一个unlock操作先行于后面对同一个锁的lock操作；（解锁后才能上锁）
3. volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；（写好才给看）
4. 传递规则：A先于B，B先于C，则A先于C；（排队）
5. 线程启动规则：线程的start()方法先于它的每一个动作；（不开始不许动）
6. 线程中断规则：线程的中断（interrupt()）先于被中断的代码检测到中断的发生；
7. 线程终结规则：线程的操作先于线程的终结（Thread.join()）；
8. 对象终结规则：对象的初始化先于finalized。

值得注意的是，第1条的次序规则只在单线程下有效，多线程中不一定保证。第3条volatitle保证了线程的可见性，写一定先于读。第6条线程A若对线程B设置中断，线程B马上可以知道。第8个要保证对象的字段要在初始化后可见。

#### volatile

为了在适当的场合保证线程间的原子性、有序性和可见性，volatile关键字是JVM提供的轻量级同步机制，对于保证操作的原子性有很大的帮助，但其**不能替代锁**，也无法保证一些复合操作的原子性。

- 保证被volatile修饰的共享变量对所有线程总是**可见**的
- 禁止指令重排序优化

如果操作volatile修饰的变量是复合的（多条操作），如value++这种（先读，后自增），即使value被volatile修饰也会引发线程安全问题。synchronized会创建内存屏障，保证所有CPU结果刷到主内存中，可以保证操作的内存可见性，因此在synchronized代码块或方法中操作的变量可以省略volatile修饰。而如果对一个变量的操作是原子性的，如操作布尔类型的变量，加上volatile就可以实现可见性，实现线程安全的目的，此时可以省略synchronized。

##### 如何保证可见性

当写一个volatile变量时，JMM把该线程对应的工作内存中的共享变量刷新到主内存中；当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效，只能从主线程中重新读取。

##### 如何禁止重排序

内存屏障（Memory Barrier）

1. 保证特性操作的执行顺序
2. 保证某些变量的内存可见性

通过插入内存屏障禁止指令在内存屏障前后的指令执行重排序优化；强制刷出各种CPU的缓存数据，因此任何CPU上的线程能够读取到这些数据的最新版本。

##### 单例双重检测

广为人知的单例模式懒汉式在多线程下是不安全的，因此有如下的双重检测

~~~java
public class Singleton{
	private static Singleton instance;
    private Singleton(){}
    public static Singleton getInstance(){
        if(instance != null){
            synchronized(Singleton.class){
                if(instance != null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
~~~

其中要点是，此类中持有的instance是私有静态的，因为不能被其他类直接获取而且不能通过对象获得。构造函数要私有。获取实例的对象要公共静态，为了直接通过类名调用。锁对象为单例类的class对象而双重检测，同步是为了线程安全，外层判断是为了提高效率。但是这样依然会存在风险。

原因 ：instance = new Singleton();可以分为三步

~~~java
memory = allocate();//1、分配对象内存空间
instance(memory); //2、初始化对象
instance = memory //3、设置instance指向刚分配的内存地址，此时instance=null
~~~

而因为步骤2和步骤3之间没有happens-before关系，因此是可以被重排序的，这样排序后的顺序为

~~~java
memory = allocate();//1、分配对象内存空间
instance = memory //3、设置instance指向刚分配的内存地址，此时instance！=null
instance(memory); //2、初始化对象
~~~

这时候，会出现instance指向了分配的空间已经不为null，但还没有初始化对象，如果此时线程被切走，再次进来的线程判断instance不为空，直接将instance返回，出现问题。

因此解决办法是不让这部分指令重排，即**让instance被volatile修饰**。因此完整的线程安全的单例双重检测如下，其中volatile与static顺序没有要求。

~~~java
public Singleton{
	private volatile static Singleton instance;
    private Singleton(){}
    public static Singleton getInstance(){
        if(instance != null){
            synchronized(Singleton.class){
                if(instance != null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
~~~

#### volatile与synchronized

1. 二者本质不同。volatile为告诉JVM当前变量在寄存器（工作内存）中的值是不确定的，需要**从主存中读取**；synchronized则是**锁定当前变量**，只有当前线程可以访问该变量，其他线程被阻塞住直到该线程完成变量操作为止。
2. **使用级别**不同。volatile仅能使用在变量级别，而synchronized可以使用在变量、方法和类级别
   - synchronized(A.class) //修饰类
   - synchronized void get() //修饰方法
   - synchronized(o) //修饰变量
3. volatile仅能实现变量的修改可见性，**不确保原子性**；而synchronized可以保证变量修改的可见性和原子性
4. volatile不会造成线程阻塞，而synchronized会
5. volatile标记的变量不会被编译期优化，synchronized标记的变量可以被编译期优化

### CAS(Compare and Swap)

​	乐观锁最常见的实现方式，默认没有数据冲突，如果有就回滚数据并重新提交。

CAS是一种高效实现数据安全性的方法

- 支持原子更新操作，适用于计数器，序列发生器（给变量自增的工具）等场景
- 属于乐观锁机制，号称lock-free（底层仍有加锁行为）
- CAS操作失败时由开发者决定是否继续尝试，还是执行其他操作

#### CAS思想

包含有三个操作数——内存位置（V），预期原值（A）和新值（B）

将内存位置（主内存）的值与预期原值比较，如果匹配则自动将该位置值更新为新值，并返回true；否则不做任何操作，并返回false。

对于volatile修饰的变量，虽然保证了内存可见性，但不能保证操作原子性，反编译如下代码

~~~java
public class CASTest {
    public volatile int value;
    public void add(){
        value++;
    }
}
~~~

反编译结果部分展示如下

~~~java
 		 2: getfield      #2                  // Field value:I
         5: iconst_1
         6: iadd
         7: putfield      #2                  // Field value:I
~~~

可以看到自增这个操作是分为先取值，再自增，再将值放回去的，因此这种非原子性的操作容易引发线程安全问题。而之前介绍的将add方法加上synchronized关键字实现悲观锁可以解决，但是效率相对较低，此时也可以使用CAS这种乐观锁来实现。Java中的AtomicInteger类便可以在不使用悲观锁的情况下保证线程安全，引用其实现如下

~~~java
public class AtomicInteger extends Number implements java.io.Serializable {  
    private volatile int value; 
 
    public final int get() {  
        return value;  
    }  
 
    public final int getAndIncrement() {  
        for (;;) {  
            int current = get();  
            int next = current + 1;  
            if (compareAndSet(current, next))  
                return current;  
        }  
    }  

    public final boolean compareAndSet(int expect, int update) {  
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);  
    }  
    //存在自旋
    public final int getAndAddInt(Object var1, long var2, int var4) {
    	int var5;
    	do {
        var5 = this.getIntVolatile(var1, var2);
    	} while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
 
    	return var5;
	}
}
~~~

其中getAndIncrement相当于自增操作，那么来看CAS操作是如何实现操作的安全性的。首先value被volatile修饰，这样保证了内存的可见性，因此当前数current为从主内存中刷出来的数据(CAS中的A)，next为其操作后变成的数据(CAS中的B)，然后调用了unsafe类的compareAndSwapInt方法，其中unsafe类为底层实现，其中为native方法，其实现逻辑类似于如下

~~~java
if (this == expect) {
	this = update
	return true;
} else {
	return false;
}
~~~

即如果期望值A与主内存处为同一地址，那么就将主内存中的地址修改为更新后的值位置；否则不做修改。因此CAS的关键在于将期望值与主内存中值进行比较，确保值没有变动才进行修改。

在J.U.C包中的atomic包中提供了常用的原子性数据以及引用、数组等相关原子类型和更新操作工具，是很多线程安全服务的首选。那么CAS这么好用，有没有什么缺点呢？

#### CAS缺点及解决方式

- CAS中存在自旋等待，若循环时间长，开销很大，浪费CPU资源
- 由于CAS比较的为this对象，因此只能保证一个共享变量的原子操作
- ABA问题

下面将详细介绍ABA问题。ABA问题描述为如果内存地址V初次读取到为A，在赋值检查时仍为A，不能保证此值没有被其他线程修改过，如果曾经被改为B再改回来，CAS操作会误认为此值没有被改变过，此漏洞就是CAS的ABA问题。

那么该如何解决呢？

1、ABA问题

对于解决ABA问题，JDK1.5后后atomic包中提供了类AtomicStampedReference类，增加了**版本号的比较**，在比较值的同时，再进行版本号的比较。若存在ABA问题的应用场景，使用传统的互斥同步会更高效点。

~~~java
public boolean compareAndSet(V   expectedReference,
                             V   newReference,
                             int expectedStamp,
                             int newStamp)
~~~

版本号的使用如下(使用lambda表达式，()->{方法代码})

~~~java
public static void main(String[] args) {
        //新建类，初始化值
        AtomicStampedReference<Integer> at = new AtomicStampedReference<>(2,0);
        //新建两个任务，执行方法
        //任务1，执行ABA操作
        new Thread(()->{
            int stamp = at.getStamp();
            System.out.println("线程1第一次拿到的版本号"+stamp);
            //暂停一段时间，让线程2拿到相同的版本号
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) { }
            //进行A->B操作
            at.compareAndSet(2,5,at.getStamp(),at.getStamp()+1);
            System.out.println("线程1第一次操作后的版本号"+at.getStamp());
            //进行B->A操作
            at.compareAndSet(5,2,at.getStamp(),at.getStamp()+1);
            System.out.println("线程1第二次操作后的版本号"+at.getStamp());
        }).start();

        new Thread(()->{
            int stamp = at.getStamp();
            System.out.println("线程2第一次拿到的版本号"+stamp);
            //暂停，让线程一完成ABA操作
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
            }
            //进行A->C操作，看能否操作成功
            boolean b = at.compareAndSet(2,10,stamp,stamp+1);
            System.out.println("当前内存中最新值为"+at.getReference());
            System.out.println("线程2处理完ABA问题后的结果为："+b);
        }).start();
    }
~~~

这样当线程1执行完ABA操作后，虽然期待值与主内存中值相等，但是版本号变化了，因此当线程2用旧的版本号进行操作的时候，无法成功执行CAS操作，执行结果为

{% asset_img CAS结果.png This is an example image %}

2、循环时间长

> 以下解释引用自[博客](https://blog.csdn.net/qq_37113604/article/details/81582784?depth_1-utm_source=distribute.pc_relevant.none-task)
>
> 若JVM可以支持处理器提供的pause指令效率会有一定提升。pause指令的作用是：1、延迟流水线执行指令，使CPU不消耗过多的执行资源；2、避免在退出循环时因内存顺序冲突而引起CPU流水线被清空，提高CPU执行效率。

3、只能保证一个共享变量的原子操作

可以将多个变量合并为一个共享变量进行操作，JDK1.5后提供了AtomicReference类，可以保证引用对象之间的原子性，因此可以将多个变量放在一个对象中进行CAS操作。

~~~java
    public final boolean compareAndSet(V expect, V update) {
        return unsafe.compareAndSwapObject(this, valueOffset, expect, update);
    }
~~~

#### CAS与synchronized

在synchronized未被改进前，synchronized在资源竞争较少时，线程被阻塞在操作系统层面被挂起开销较大，因此CAS更适用于竞争较少的场合；而竞争较多的场合，CAS资源几率大，效率低于synchronized。

而synchronized在JDK1.6后被改进，有了前面介绍过的锁的膨胀机制，在竞争资源较少时也能获得与CAS类似的性能。

#### concurrent包的实现

concurrent包有通用化的实现模式

> 1. 声明共享变量为volatile（保证内存可见性）
> 2. 使用CAS的原子条件更新实现线程间的同步
> 3. 配合以volatile的读/写和CAS所具有的读和写的内存语义来实现线程间的通信

关于锁的实现先说到这里，接下来说下多线程非常常用的线程池。

### 线程池

在之前使用多线程时，依赖的是新建多个Thread对象，然后传递任务对象，再开启线程。

但是线程的创建与销毁开销是比较大的，为了重复利用线程，提高效率，便有了线程池。为了了解线程池，从为什么要用线程池（优势），怎么用线程池（方式与种类），重要参数来说明。

#### 线程池优势

- **降低资源消耗**

  重复利用已创建的线程来降低线程创建和销毁造成的消耗

- **提高线程的可管理性**

  线程是稀缺资源，无限制的创建会消耗系统资源，降低稳定性，使用线程池可以统一的分配、调优和监控

使用线程池后，创建线程变成从线程池中获得空闲线程，关闭线程变成向线程池归还线程。

#### 常见线程池种类

JDK提供了Executor框架来更好的控制线程池，下面先介绍5种常用的线程池工作方法。

1、指定工作数量的线程池

newFixedThreadPool(int nThreads)

每当一个任务去创建一个线程，如果工作线程数量达到线程池的初始最大数，将提交的任务存储池队列中；如果工作线程退出，将会有新的工作线程被创建，补足nThread的数目。

适用于可以**预测线程数量**的任务中，或者服务器**负载较重**，对当前线程数量进行限制

~~~java
    public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
~~~

2、处理大量短时间工作任务的线程池

newCachedThreadPool()

（1）试图缓存线程并重用，当无缓存线程可用时，就创建新的线程

（2）如果线程闲置的时间超过阈值（一般60s），则会被终止并移出缓存

（3）系统长时间闲置的时候，不会占用什么资源

适用于服务器**负载较轻**，执行很多短期异步任务

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
```

3、唯一的工作线程池

newSingleThreadExecutor()

创建唯一的工作线程来执行任务，如果线程异常结束，会有另一个线程取代它。可保证顺序的去执行各个任务，且在给定的时间内不会有多个线程是活动的。

适用于需要保证**顺序执行**各个任务，并且在任意时间点，**不会有多个线程是活动的**场景。

~~~java
    public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
    }
~~~

4、定时或者周期性的工作调度

newSingleThreadScheduledExecutor()与newScheduledThreadPool(int corePoolSize)

二者区别在于单一工作线程还是多个线程，前者与newSingleThreadExecutor()一样，若线程异常结束，会有另一个线程来取代它确保顺序执行。

适用于需要后台线程**执行周期任务**的场景。

~~~java
    public static ScheduledExecutorService newSingleThreadScheduledExecutor() {
        return new DelegatedScheduledExecutorService
            (new ScheduledThreadPoolExecutor(1));
    }
    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
    }
~~~

5、拥有多个任务队列的线程池

newWorkStealingPool()

内部创建ForkJoinPool，利用work-stealing算法，并行地执行任务，不保证处理顺序，JDK8引入。

可以减少连接数，创建当前可用CPU数量的线程来并行执行，适用于大耗时的操作，可以并行来执行。

```java
public static ExecutorService newWorkStealingPool() {
    return new ForkJoinPool
        (Runtime.getRuntime().availableProcessors(),
         ForkJoinPool.defaultForkJoinWorkerThreadFactory,
         null, true);
}
```

ForkJoin框架

将大任务切割成若干个小任务并发执行，最终汇总每个小任务的结果后得到大任务结果的框架。

是Executor接口的一种具体实现，更好利用多处理带来的好处，使用分治法解决问题。使用的是work-stealing算法，具体是从其他任务队列中窃取任务来执行。将任务分别放在不同的队列中，为每个队列来创建一个线程执行任务。会出现某些队列任务已经完成而其他队列任务还没有完成的情况，这时候为了提高效率，完成任务的处于空闲状态的线程会从其他处于busy状态的线程处窃取等待执行的任务。为了减少窃取和被窃取任务的竞争，使用双端队列，**被窃取任务**线程从双端队列**头部**拿任务执行，而**窃取任务**线程从双端队列**尾部**拿任务。

{% asset_img 窃取任务.png This is an example image %}

下面将介绍JDK中的Executor框架

#### Executor框架

{% asset_img 框架.png This is an example image %}

Executor框架将任务的提交与运行进行分离，在Java标准库中提供了Executor、ExecutorService和ScheduledExecutorService三个接口和基础实现。如Executors类扮演**线程池工厂**的角色，通过Executors可以获得拥有特定功能的线程池。ThreadPoolExecutor类实现Executor接口，表示一个**线程池**，通过此接口，任何Runnable的对象均可以被ThreadPoolExecutor线程池调度。以上成员均在J.U.C包中。

#### J.U.C的三个Executor接口

##### Executor

运行新任务的简单接口，将任务提交与任务执行细节解耦。下面只有一个execute(Runnable command)方法，线程执行有多种可能

- 可能为创建一个新线程并立即启动
- 可能是用已有的工作线程来运行传入的任务
- 可能是根据设置线程池的容量或阻塞队列的容量来决定将线程放入阻塞队列或接收传入的线程

~~~java
void execute(Runnable command);
~~~

{% asset_img 接口1.png This is an example image %}

##### ExecutorService

具备管理执行器和任务声明周期的方法，提交任务机制更完善。扩展了Executor接口，如可以返回Future的submit方法，Callable弥补了Runnale没有返回值的短板

~~~java
Future<?> submit(Runnable task);
<T> Future<T> submit(Callable<T> task);
~~~

##### ScheduledExecutorService

扩展了ExecutorService，支持定期执行任务。

#### 线程池使用

展示固定大小的线程池的使用为例子，基本思路仍为创建任务类实现Runnable接口，实现run()方法，然后利用Executors线程工厂来获取线程池，利用线程池的submit(task)方法来执行任务。

~~~java
class MyTask implements Runnable{
    @Override
    public void run() {
        System.out.println(System.currentTimeMillis()+": Thread ID"+Thread.currentThread().getId());
        //休息一秒钟
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
public class ExecutorTest {
    public static void main(String[] args) {
        //1、新建线程池
        ExecutorService es = Executors.newFixedThreadPool(5);
        //将任务放入线程池，并执行10次
        MyTask task = new MyTask();
        for (int i = 0; i < 10; i++) {
            es.submit(task);
        }
    }
}
~~~

其中这里让一个线程执行后休眠1秒钟，然后线程池大小设置为5，让线程池执行10次任务，可以看到任务5个5个分批次执行，而且每一批都为相同的几个线程，结果如下所示。

{% asset_img 线程池演示1.png This is an example image %}

但是如果使用的是newCachedThreadPool()，则可以10个线程一批执行完。

但是有些时候，Executors工厂类中提供的线程池不能满足需求，这时候可以通过ThreadPoolExecutor构造函数去创建线程池。

#### ThreadPoolExecutor

{% asset_img threadpool原理.png.png This is an example image %}

线程池整个的应用逻辑为：线程池由工作队列WorkQueue来存储各个队列提交的工作任务。工作队列可以是容量为0的SynchronizedQueue，主要用于newCachedThreadPool；也可以是newFixedThreadPool中的LinkedBlockingQueue。队列接到任务后，排队提交给线程池，即工作队列的集合，该集合负责在运行的过程中管理线程的创建和销毁。线程池的**工作线程**被抽象为静态内部类WorkerThread，线程池维护的其实是一组**Worker对象**。

Worker类是ThreadPoolExecutor类中的内部类，继承自AQS，实现了Runnable，由firstTast保存传入的任务，thread保存创建出来的线程。

~~~java
private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable{
	Worker(Runnable firstTask) {
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
        }
}
~~~

当Worker启动的时候，调用run()方法来启动里面的逻辑。

ThreadPoolExecutor构造函数

~~~java
	public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
~~~

5个参数比较关键

- corePoolSize：核心线程数量（长期驻留的线程数，不同实现差别很大）
- maximumPoolSize：线程不够用时能够创建的最大线程数（有的固定于核心线程一样，有的可以创建更多）
- keepAliveTime：抢占的顺序不一定，看运气（线程池维护线程允许的空闲时间，当线程池中线程数量大于corePoolSize的时候，若没有新任务提交，核心线程外的线程不会立即被销毁，而是等待时间超过keepAliveTime）
- workQueue：任务等待队列（当任务提交时，若线程池中线程数量大于等于PoolSize，将任务封装为Worker对象放入等待队列中）
  - 直接提交的队列：SynchronousQueue**没有容量**，是**无缓冲等待队列**，是一个不存储元素的**阻塞**队列，一个插入操作要等待一个删除操作。提交的任务不会被真实保存，总是将新任务给线程执行，若没有空闲的线程，尝试创建新的线程。一般要求maximumPoolSizes设置很大，避免线程拒绝执行操作。
  - 有界的任务队列：ArrayBlockingQueue，构造函数必须传入其最大容量，当有新任务执行，线程数小于核心线程数，优先创建线程，若大于，将新任务加进等待队列。若队列满了，无法加入，在总线程数不大于最大线程数时，创建新线程执行任务；否则执行拒绝策略。因此有界队列仅在任务队列装满时才可能将线程数扩充到核心线程数之上。
  - 无界的任务队列：LinkedBlockingQueue，当有新任务执行，线程数小于设定核心线程数，生成新线程执行任务，当线程数达到核心线程数后，线程不会增加，若有任务没有被消费，放进队列等待，队列可以一直增长直到耗尽系统资源。每个线程完全独立于其他线程。生产者和消费者使用**独立的锁**来控制数据的同步，即在高并发的情况下可以并行操作队列中的数据。
  - 优先任务队列：PriorityBlockingQueue，可控制任务先后执行顺序，特殊的无界队列，ArrayBlockingQueue与LinkedBlockingQueue按照先进先出顺序执行，而此队列确保高优先级的任务先执行。
- threadFactory：创建新线程，Executors.defaultThreadFactory()（使用这个创建，新线程有一样的优先级，且是非守护线程，同时设置了线程的名称）

而其中的handle，是线程池的饱和策略

