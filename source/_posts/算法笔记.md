---
title: 算法笔记
date: 2020-02-25 09:51:49
tags: [左神算法, 剑指offer, leetcode]
categories: 算法
---

# OJ处理技巧

类名为public class Main

较好的做法是将要用到的类都封装好，不要放在Main类中，主类只需要持有要用到的类的对象，然后调用即可。

StringBuilder类的append方法，res.append(str1).append(str2)比res.append(str1+str2)效率高。

<!-- more -->

## 获取不知次数的输入

使用BufferedReader来获取，需要Import，主函数需要抛出异常

valueOf返回值类型为Integer，parseInt返回值类型为int

~~~java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class Main {
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s = null;
        while((s = br.readLine())!= null){
            //获取第一行输入，输入为一个数
            int len = Integer.valueOf(s);
            //获取第二行输入，输入为数组
            String[] arrStr = br.readLine().split(" ");
            int [] arr = new int[len];
            for (int i = 0; i < arr.length; i++) {
                arr[i] = Integer.valueOf(arrStr[i]);
            }
            System.out.println(要求的函数);
        }
    }
~~~

## 获取有限次数的输入

输出的结果先用StringBuilder类存起来，如果有多行，每一行最后要加上换行标识。最后要输出的时候，将stringbuilder转变为String类输出。

~~~java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main{
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        //要持有的写的类
        DogCatQueue dq = new DogCatQueue();
        String s = null;
        StringBuilder res = new StringBuilder();
        s = br.readLine();
        int count = Integer.valueOf(s);
        for (int i = 0; i < count; i++) {
            String[] strArr = br.readLine().split(" ");
            //if或者switch判断
            switch (strArr[0]){
                case "add":
                    String type=strArr[1];
                    dq.add(new Pet(type,Integer.valueOf(strArr[2])));
                    break;
                case "pollAll":
                    while(!dq.isEmpty()){
                        pet = dq.pollAll();
                        res.append(pet.getPetType()+" "+pet.getPetIndex()+"\n");
                    }
                    break;
                case "isDogEmpty" :
                    res.append(dq.isDogEmpty()?"yes\n":"no\n");
                    break;
            }
        }
        System.out.println(res.substring(0,res.length()-1));
    }
}
~~~

## 获取输入矩阵

~~~java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        //要持有的写的类
        //PringtEdge pe = new PringtEdge();
        String[] s = null;
        StringBuilder res = new StringBuilder();
        s = br.readLine().split(" ");
        //获取第一行的矩阵行与列
        int row = Integer.valueOf(s[0]);
        int col = Integer.valueOf(s[1]);
        int[][] arr = new int[row][col];
        //获取后面几行的矩阵数据
        for (int i = 0; i < row; i++) {
            s = br.readLine().split(" ");
            for (int j = 0; j < col; j++) {
                arr[i][j] = Integer.valueOf(s[j]);
            }
        }
        //通过自己编写方法获取结果
        //res = pe.printCircle(arr);
        System.out.println(res.substring(0,res.length()-1));
    }
~~~

## 获取数组

输入只有一行，为数组

~~~java
import java.util.Scanner;
	//交换数组中的数
    public static void swap(int[] arr,int i, int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
	//打印数组
    public static void printArr(int[] arr){
        for(int i = 0; i < arr.length; i++){
            System.out.print(arr[i]+" ");
        }
    }
	public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        String[] strArray = str.split(" ");
        int[] intArray = new int[strArray.length];
        for(int i = 0;i<strArray.length;i++) {
            intArray[i] = Integer.parseInt(strArray[i]);
        }
    	//要解决的
        Solution(intArray);
    	//输出数组
        for(int i = 0;i<intArray.length;i++) {
            System.out.print(intArray[i] + " ");
        }
    	//or
    	printArr(printArr);
    }
~~~

输入有两行，第一行为数组长度，第二行为数组

获取long类型的数组

~~~java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int len = Integer.parseInt(br.readLine());
        long[] arr = new long[len];
        String[] strArray = br.readLine().split(" ");
        for(int i = 0;i<len;i++) {
            arr[i] = Long.parseLong(strArray[i]);
        }
        LessMoney lm = new LessMoney();
        System.out.println(lm.getLessMoney(arr));
    }
~~~

## 获取链表

~~~java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

//链表结构
class Node{
    int value;
    Node next;
    Node pre;
    Node(int value){
        this.value = value;
    }
}

	//创建单向链表
	private static Node createNode(String[] str,int n){
        Node head = new Node(Integer.parseInt(str[0]));
        Node node = head;
        for(int i=1;i<n;i++){
            Node newNode = new Node(Integer.parseInt(str[i]));
            node.next = newNode;
            node = newNode;
        }
        return head;
    }
    //创建双向链表
    private static Node createNodeDL(String[] str,int n){
        Node head = new Node(Integer.parseInt(str[0]));
        Node node = head;
        for(int i=1;i<n;i++){
            Node newNode = new Node(Integer.parseInt(str[i]));
            node.next = newNode;
            node.next.pre = node;
            node = newNode;
        }
        return head;
    }
	//打印列表
	private static void printList(Node node){
        StringBuilder builder = new StringBuilder();
        while (node != null){
            builder.append(node.value).append(" ");
            node = node.next;
        }
        System.out.println(builder.toString());
    }
	//主函数部分
	public static void main(String[] args) throws IOException{
        BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
        //创建第一个链表
        int n = Integer.parseInt(input.readLine());
        String[] strings1 = input.readLine().split(" ");
        Node list1 = createNode(strings1,n);
        //创建第二个链表
        int m = Integer.parseInt(input.readLine());
        String[] strings2 = input.readLine().split(" ");
        Node list2 = createNode(strings2,m);
        //要操作的函数
        //printCommonPart(list1,list2);
    }
~~~

## 获取树

~~~java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Stack;

class Node{
    public int value;
    public Node left;
    public Node right;
    public Node(int value){
        this.value = value;
    }
}

	public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        //读取总的节点数与根节点数
        String[] s=reader.readLine().split(" ");
        int n = Integer.parseInt(s[0]);
        int rootIdx = Integer.parseInt(s[1]);
        //构造桶，将每个节点放入对应值，分别存其左、右结点的值
        int[][] arr = new int[n+1][2];
        int t;
        //将节点的数放入对应的桶中，构造得到数组
        for (int i = 1; i < n; i++){
            String[] sts = reader.readLine().split(" ");
            t = Integer.parseInt(sts[0]);
            arr[t][0] = Integer.parseInt(sts[1]);
            arr[t][1] = Integer.parseInt(sts[2]);
        }
        //拿出头节点
        Node head = new Node(rootIdx);
        createTree(head,arr);
        StringBuilder res = new StringBuilder();
        preOrderRecur(head,res);
        System.out.println(res.substring(0,res.length()-1));
        res.delete(0,res.length());
        inOrderRecur(head,res);
        System.out.println(res.substring(0,res.length()-1));
        res.delete(0,res.length());
        posOrderRecur(head,res);
        System.out.println(res.substring(0,res.length()-1));

    }
    //递归实现
    public static void createTree(Node root,int[][] a){
        //base case
        if(root==null){
            return ;
        }
        int i=root.value;
        int l=a[i][0];
        int r=a[i][1];
        //左子树不为空，构造左子树
        if(l!=0){
            Node leftNode=new Node(l);
            root.left=leftNode;
            //递归产生左子树
            createTree(leftNode,a);
        }
        //右子树不为空，构造右子树
        if(r!=0){
            Node rightNode=new Node(r);
            root.right=rightNode;
            createTree(rightNode,a);
        }
    }
~~~



# 左神算法笔记

## 排序问题

### 小和问题

题目描述：

数组小和的定义如下：

例如，数组s = [1, 3, 5, 2, 4, 6]，在s[0]的左边小于或等于s[0]的数的和为0；在s[1]的左边小于或等于s[1]的数的和为1；在s[2]的左边小于或等于s[2]的数的和为1+3=4；在s[3]的左边小于或等于s[3]的数的和为1；

在s[4]的左边小于或等于s[4]的数的和为1+3+2=6；在s[5]的左边小于或等于s[5]的数的和为1+3+5+2+4=15。所以s的小和为0+1+4+1+6+15=27

给定一个数组s，实现函数返回s的小和

[要求]

时间复杂度为O(nlogn)，空间复杂度为O(n)

思路：找小和，就是看当前数右边哪些数比他大 ，顺序并没有关系，因此可以用mergesort的思想，先分再合，产生小和的过程为merge的过程，如果右边数比左边大，那么总的小和个数为左边当前数*右边数个数，然后将两个数组sort中产生的数和当前merge共三部门数相加即可。

坑：

最后的小和可能很大，需要long类型才能过OJ，小和为小于等于，因此merge外排时判断为<=

~~~sql
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s = null;
        while((s=br.readLine())!=null){
            int len = Integer.valueOf(s);
            String[] arrStr = br.readLine().split(" ");
            int[] arr = new int[len];
            for(int i = 0;i < len;i++){
                arr[i] = Integer.parseInt(arrStr[i]);
            }
            System.out.println(smallSum(arr));
        }
    }
    public static long smallSum(int[] arr){
        if(arr == null || arr.length < 2)
            return 0;
        return sortProcess(arr,0,arr.length-1);
    }
    public static long sortProcess(int[] arr,int l,int r){
        if(l == r)
            return 0;
        int mid = l + (r - l)/2;
        return sortProcess(arr,l,mid)+sortProcess(arr,mid+1,r)+merge(arr,l,mid,r);
    }
    public static long merge(int[] arr,int l,int mid, int r){
        int p1 = l,p2 = mid+1,i = 0;
        int[] help = new int[r-l+1];
        long res = 0;
        while(p1<=mid && p2 <= r){
            if(arr[p1] <= arr[p2]){
                res += arr[p1] * (r-p2+1);
                help[i++] = arr[p1++];
            }else{
                help[i++] = arr[p2++];
            }
        }
        while(p1<=mid){
            help[i++] = arr[p1++];
        }
        while(p2<=r){
            help[i++] = arr[p2++];
        }
        for(i = 0;i<help.length;i++){
            arr[l+i] = help[i];
        }
        return res;
    }
}
~~~

### 数组排序后相邻数的最大差值

题目描述

给定一个整形数组arr，返回排序后相邻两数的最大差值

arr = [9, 3, 1, 10]。如果排序，结果为[1, 3, 9, 10]，9和3的差为最大差值，故返回6。

arr = [5, 5, 5, 5]。返回0。

[要求]

时间复杂度为O(n)，空间复杂度为O(n)

当要排序，然后时间复杂度给定O(n)，那么只能使用桶排序，思路为把n个数放在n+1个桶中，那么肯定有1个桶中没有数字，这样最大的差值一定出现在两个桶之间，那么桶中有哪些数字不重要，只需要关注桶中是否有数字，最大数字和最小数字即可，最大差值为当前非空桶的最小值减去上一个非空桶的最大值。将数字放入桶，依据为将min-max的数据，放入0-len的桶中，数据长度为为len，桶的个数为len+1。在计算时为了避免越界，采用long型，然后转换为int。可以优化的点在于，如果算出来数组的最大值和最小值相等，那么可以直接返回0，不用建立桶。

~~~java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s = null;
        while((s=br.readLine())!=null){
            int len = Integer.valueOf(s);
            int[] arr = new int[len];
            String[] arrStr = br.readLine().split(" ");
            for(int i = 0;i<len;i++){
                arr[i] = Integer.valueOf(arrStr[i]);
            }
            System.out.println(maxGap(arr));
        }
    }
    public static int maxGap(int[] arr){
        if(arr == null || arr.length < 2)
            return 0;
        //统计数组最大和最小值
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;
        int len = arr.length;
        for(int i = 0;i<len;i++){
            min = Math.min(min,arr[i]);
            max = Math.max(max,arr[i]);
        }
        //如果max=min，那么可以直接返回0
        if(max == min)
            return 0;
        //建立桶，范围是0-len
        //有三个属性，是否进来过数，最大值，最小值
        boolean[] hasNum = new boolean[len+1];
        int[] maxs = new int[len+1];
        int[] mins = new int[len+1];
        int bid = 0;
        //将每一个数装入桶
        for(int i = 0; i < len;i++){
            //计算当前数应该在哪个桶
            bid = bucket(arr[i],len,min,max);
            //统计桶的最大最小值，是否进去过数
            maxs[bid] = hasNum[bid]?Math.max(maxs[bid],arr[i]):arr[i];
            mins[bid] = hasNum[bid]?Math.min(mins[bid],arr[i]):arr[i];
            hasNum[bid] = true;//当前桶进去了数
        }
        //开始计算差值
        int res = 0;
        int lastMax = maxs[0];
        for(int i = 1;i < len;i++){
            if(hasNum[i]){
                res = Math.max(res,mins[i]-lastMax);
                lastMax = maxs[i];
            }
        }
        return res;
    }
    public static int bucket(long num,long len, long min, long max){
        //目的，让值为min的在0桶，让值为max的在len桶
        //范围变换，从min-max变化为0-len
        int res = (int)((num-min)*len/(max-min));
        return res;
    }
}
~~~

## 队列和栈

### 用数组实现栈和队列

用数组实现栈比较简单，此类需要持有一个数组和当前位置标记，有初始化构造函数，获取最上面一个数peek方法，入栈push方法，出栈pop方法，要注意的是执行者三个方法时第一步为判断index范围，pop方法返回类型要是Integer而不是int，因为换成int不能返回null

~~~java
public class ArrayStack {
    //用数组实现栈，应该持有数组，当前位置
    private int[] arr;
    private int index;
    public ArrayStack(int size){
        if (size < 0)
            throw new IllegalArgumentException("The init size is less than 0");
        arr = new int[size];
    }
    //peek，获取最上面的数
    //返回类型为Integer，不然不能返回NULL
    public Integer peek(){
        if (index == 0)
            return null;
        return arr[index-1];
    }
    //入栈
    public void push(int obj){
        //如果超出范围，报错
        if (index == arr.length)
            throw new ArrayIndexOutOfBoundsException("The stack is full");
        //如果正常，放入数据
        arr[index++] = obj;
    }
    //出栈
    public Integer pop(){
        if (index == 0)
            throw new ArrayIndexOutOfBoundsException("The stack is empty");
        return arr[--index];
    }
}
~~~

用数组实现队列，需要持有一个数组，一个入队列位置end，一个出队列位置start，一个队列大小size，用size来给end和start解耦

~~~java
public class ArrayQueue {
    //用数组实现队列，需要持有数组，队列末尾，队列开始，size
    private int[] arr;
    private int start;
    private int end;
    private int size;
    public ArrayQueue(int initSize){
        if (initSize < 0)
            throw new IllegalArgumentException("The init size is less than 0");
        arr = new int[initSize];
        size = 0;
        end = 0;
        start = 0;
    }
    //peek方法
    public Integer peek(){
        if (size == 0)
            return null;
        return arr[start];
    }
    //push方法
    public void push(int obj){
        if (size == arr.length)
            throw new ArrayIndexOutOfBoundsException("The queue is full");
        size++;
        arr[end] = obj;
        //循环队列
        end = (end + 1) % arr.length;
    }
    //poll方法
    public int poll(){
        if (size == 0)
            throw new ArrayIndexOutOfBoundsException("The queue is empty");
        size--;
        int temp = arr[start];
        start = (start+1)%arr.length;
        return temp;
    }
}
~~~

### getMin()功能的栈

实现一个特殊功能的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。

思路：持有两个栈，一个为数据栈，一个为最小栈，数据栈正常进出，而最小栈有两种方法实现。

方法一：当进来的数比最小数要小，直接入栈；当比最小数大，入栈最小数出栈时。两个栈正常出栈，返回data栈的值。

方法二：当进来的数比最小数要小，直接入栈；当比最小数大，min不入栈 。出栈时，当data出栈数等于最小数才出栈 ，其他时候min不出栈。

~~~java
import java.util.Stack;
public class MyStack2 {
    //第二种方法，入栈的时候，如果当前数比较大，则min栈不进
    //出栈的时候，如果当前数比min栈小，min栈不出
    private Stack<Integer> dataStack;
    private Stack<Integer> minStack;
    //初始化
    public MyStack2() {
        dataStack = new Stack<>();
        minStack = new Stack<>();
    }
    //getMin()方法
    public Integer getMin() {
        //如果栈为空，返回空
        if (minStack.empty())
            return null;
        return minStack.peek();
    }
    //入栈方法
    public void push(int num) {
        if (minStack.empty()) {
            minStack.push(num);
        } else if (num <= getMin()) {
            minStack.push(num);
        }
        dataStack.push(num);
    }
    //出栈方法
    public Integer pop() {
        if (dataStack.empty())
            return null;
        int num = dataStack.pop();
        //只有当前数等于getmin，min栈才出
        //只有等于，没有小于
        if (num == getMin())
            minStack.pop();
        return num;
    }    
}
~~~

### 用队列实现栈

用队列来实现栈的功能，要有2个队列，当push的时候，正常进入队列，当peek的时候，先弹出其他的进入辅助队列，然后获取剩下来的一个的值，再将其放入辅助队列，再交换两个的引用。

~~~java
import java.util.LinkedList;
import java.util.Queue;
public class TwoQueueStack {
    //用两个队列实现栈
    private Queue<Integer> queue;
    private Queue<Integer> help;
    public TwoQueueStack(){
        queue = new LinkedList<Integer>();
        help = new LinkedList<Integer>();
    }
    //push
    public void push(int num){
        queue.add(num);
    }
    public int peek(){
        if (queue.isEmpty()){
            throw new RuntimeException("Queue is empty");
        }
        while (queue.size()!=1){
            help.add(queue.poll());
        }
        int res = queue.poll();
        help.add(res);
        swap();
        return res;
    }
    public int pop(){
        if (queue.isEmpty()){
            throw new RuntimeException("Queue is empty");
        }
        while (queue.size()>1){
            help.add(queue.poll());
        }
        int res = queue.poll();
        swap();
        return res;
    }
    //交换两个队列引用
    public void swap(){
        Queue<Integer> temp = queue;
        queue = help;
        help = queue;
    }
}
~~~

### 用栈实现队列

准备两个栈，一个push栈只用于push数据进去，一个pop栈只用于pop数据出来。从push栈倒数据进pop栈有两个要求，一个是pop栈中不能有数据，另一个是倒就要全部倒完。

~~~java
import java.util.Stack;
public class TwoStackQueue {
    private Stack<Integer> stackPush;
    private Stack<Integer> stackPop;
    public TwoStackQueue(){
        stackPush = new Stack<>();
        stackPop = new Stack<>();
    }
    public void push(int num){
        stackPush.push(num);
        goTo();
    }
    //关键的倒数据步骤
    public void goTo(){
        while (stackPop.isEmpty()){
            //要倒完
            while (!stackPush.isEmpty()){
                stackPop.push(stackPush.pop());
            }
        }
    }
    //peek步骤
    public int peek(){
        if (stackPush.isEmpty() && stackPop.isEmpty())
            throw new RuntimeException("The stack is empty");
        goTo();
        return stackPop.peek();
    }
    public int pop(){
        if (stackPush.isEmpty() && stackPop.isEmpty())
            throw new RuntimeException("The stack is empty");
        goTo();
        return stackPop.pop();
    }
}
~~~

### 猫狗队列

实现一种猫狗队列的结构，要求如下：

1. 用户可以调用 add 方法将 cat 或者 dog 放入队列中

2. 用户可以调用 pollAll 方法将队列中的 cat 和 dog 按照进队列的先后顺序依次弹出

3. 用户可以调用 pollDog 方法将队列中的 dog 按照进队列的先后顺序依次弹出

4. 用户可以调用 pollCat 方法将队列中的 cat 按照进队列的先后顺序依次弹出

5. 用户可以调用 isEmpty 方法检查队列中是否还有 dog 或 cat

6. 用户可以调用 isDogEmpty 方法检查队列中是否还有 dog

7. 用户可以调用 isCatEmpty 方法检查队列中是否还有 cat

思路：将Pet封装上一个index数据项，这样使用一个新类将二者封装。然后持有一个狗队列，一个猫队列，持有index，初始为0，在add操作中，如果是狗，就加入狗队列，是猫就加入猫队列。从队列中弹出较早入队列的，比较猫、狗队列中较小的index，弹出即可。

坑点：牛客网上的题目相比于原始题目，Pet自己也需要封装上一个index项，而比较的时候，比的是封装后的宠物队列类自己定义的index，而不是pet的index。

~~~java
class Pet {
    private String type;
    private int x;
    public Pet(String type,int index){
        this.type = type;
        this.x = index;
    }
    public String getPetType(){
        return this.type;
    }
    public int getPetIndex(){
        return this.x;
    }
}
class PetEnterQueue {
    //持有Pet和index
    private Pet pet;
    private long index;
    public PetEnterQueue(Pet pet, long index){
        this.pet = pet;
        this.index = index;
    }
    //API：获取当前类型，index
    public Pet getPet() {
        return pet;
    }
    public long getIndex() {
        return index;
    }
    public String getPetType(){
        return pet.getPetType();
    }
}
class DogCatQueue {
    //猫狗队列，一个持有猫，，一个持有狗
    private Queue<PetEnterQueue> dogQueue;
    private Queue<PetEnterQueue> catQueue;
    private long index;
    public DogCatQueue(){
        dogQueue = new LinkedList<>();
        catQueue = new LinkedList<>();
        index = 0;
    }
    public void add(Pet pet){
        //如果为狗，加到狗；如果为猫，加到猫
        if ("dog".equals(pet.getPetType())){
            dogQueue.add(new PetEnterQueue(pet,index++));
        }else if ("cat".equals(pet.getPetType())){
            catQueue.add(new PetEnterQueue(pet,index++));
        }else{
            throw new RuntimeException("error, no dog or cat");
        }
    }
    //弹出猫或者狗中较小的
    public Pet pollAll(){
        //如果两个均不为空
        if (!dogQueue.isEmpty() && !catQueue.isEmpty()){
            if (dogQueue.peek().getIndex() < catQueue.peek().getIndex()){
                return dogQueue.poll().getPet();
            }else {
                return catQueue.poll().getPet();
            }
        }else if (!dogQueue.isEmpty()){
            //狗不为空
            return dogQueue.poll().getPet();
        }else if (!catQueue.isEmpty()){
            //猫不为空
            return catQueue.poll().getPet();
        }else{
            throw new RuntimeException("The queue is empty");
        }
    }
    //弹出狗队列
    public Pet pollDog(){
        if (dogQueue.isEmpty())
            throw new RuntimeException("Dog queue is empty");
        return dogQueue.poll().getPet();
    }
    //弹出猫队列
    public Pet pollCat(){
        if (catQueue.isEmpty())
            throw new RuntimeException("Dog queue is empty");
        return catQueue.poll().getPet();
    }
    public boolean isEmpty(){
        return isCatEmpty()&&isDogEmpty();
    }
    public boolean isCatEmpty(){
        return catQueue.isEmpty();
    }
    public boolean isDogEmpty(){
        return dogQueue.isEmpty();
    }
}
~~~

输入输出的处理比较麻烦，使用StringBuilder来添加结果，最后用substring方法将其转换为字符串，要记得添加换行。

~~~java
public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s = null;
        DogCatQueue dq = new DogCatQueue();
        Pet pet = null;
        StringBuilder res=new StringBuilder();
        s = br.readLine();
        int count = Integer.valueOf(s);
        for (int i = 0; i < count; i++) {
            String[] strArr = br.readLine().split(" ");
            switch (strArr[0]){
                case "add":
                    String type=strArr[1];
                    dq.add(new Pet(type,Integer.valueOf(strArr[2])));
                    break;
                case "pollAll":
                    while(!dq.isEmpty()){
                        pet = dq.pollAll();
                        res.append(pet.getPetType()+" "+pet.getPetIndex()+"\n");
                    }
                    break;
                case "pollCat":
                    while(!dq.isCatEmpty()){
                        pet = dq.pollCat();
                        res.append(pet.getPetType()+" "+pet.getPetIndex()+"\n");
                    }
                    break;
                case "pollDog":
                    while(!dq.isDogEmpty()){
                        pet = dq.pollDog();
                        res.append(pet.getPetType()+" "+pet.getPetIndex()+"\n");
                    }
                    break;
                case "isDogEmpty" :
                    res.append(dq.isDogEmpty()?"yes\n":"no\n");
                    break;
                case "isCatEmpty":
                    res.append(dq.isCatEmpty()?"yes\n":"no\n");
                    break;
                case "isEmpty":
                    res.append(dq.isEmpty()?"yes\n":"no\n");
                    break;
            }
        }
        System.out.println(res.substring(0,res.length()-1));
    }
~~~

## 哈希表

### RandomPool结构

题目：

设计一种结构，在该结构中加入如下三种功能

insert(key)：将某个key加入到该结构，做到不重复加入

delete(key)：将原本在结构中的某个key移除

getRandom()：等概率随机返回结构中的任何一个key

要求：这三种方法的时间复杂度均为O(1)

思路：一个不行就两个。持有两个哈希表，一个为key-index映射，一个为index-key映射，麻烦的地方在于删除后如何保证之后的随机性，解决方法为每次找到要删除的位置，然后获取其key，获取最后行的key和index，然后将最后行的数据存到要删除行，再删除最后行数据。

~~~java
import java.util.HashMap;
public class RandomPool<K> {
    //持有两个哈希表，一个索引
    private HashMap<K,Integer> keyIndexMap;
    private HashMap<Integer,K> indexKeyMap;
    private int index;
    public RandomPool(){
        keyIndexMap = new HashMap<>();
        indexKeyMap = new HashMap<>();
        index = 0;
    }
    //添加方法
    public void insert(K key){
        //如果已经存在了，返回
        if (keyIndexMap.containsKey(key))
            return;
        keyIndexMap.put(key,index);
        indexKeyMap.put(index++,key);
    }
    //随机返回方法
    public K getRandom(){
        //如果没有数据，返回空
        if (index == 0)
            return null;
        int res = (int)(Math.random()*index);
        return indexKeyMap.get(res);
    }
    //删除方法
    public void delete(K key){
        if (!keyIndexMap.containsKey(key))
            return;
        //1、找到要删除位置的index
        int deleteIndex = keyIndexMap.get(key);
        //2、找到最后的index和key
        int lastIndex = --index;
        K lastKey = indexKeyMap.get(lastIndex);
        //3、将待删除位置的值替换为最后行的值
        keyIndexMap.put(lastKey,deleteIndex);
        indexKeyMap.put(deleteIndex,lastKey);
        //4、删除最后行数据，将行数-1
        keyIndexMap.remove(key);
        indexKeyMap.remove(lastIndex);
    }
}
~~~

### 一致性哈希

解决问题

应用在多服务器的场合，为了解决负载均衡问题，即客户端的请求能较均衡的分配到每台服务器上。经典的服务器结构是若有n台机器，将前端获取信息计算一个哈希值，然后%n，得到对应服务器并访问，但当服务器个数变化时信息需要重新计算才能再次均衡。

如何做

而一致性哈希就是为了解决这个问题，将哈希域映射到一个圆环，将服务器信息计算出哈希值映射到圆上，客户端请求信息的key同样计算哈希值映射到圆上，将信息交给顺时针找到的第一台服务器进行处理。当减少一台服务器，将要访问此机器的数据交由顺时针的下一个机器即可。当增加一台服务器，将其映射到圆上，将此机器逆时针上一台机器到此机器之间的顺序交给本机器处理即可。

存在问题

但是这样当服务器个数较少的时候，不容易在环上均匀分配，这样无法实现负载均衡。可以采用虚拟节点的方式，给每台机器分配多个虚拟节点，让虚拟节点在环上均衡分配，数据的key寻找对应的虚拟节点，再由虚拟节点寻找对应的机器。

### 负载均衡算法

 1、轮训法

将请求按顺序轮流分配到后端服务器上，均衡对待每一台服务器，而不关心服务器本身的连接数和负载情况

2、随机法

通过系统随机计算，从后端服务器中随机选取一台来访问，当访问次数多了后，根据概率论，每台服务器上访问会均衡

3、源地址哈希

根据客户端的ip，计算哈希值，对服务器台数进行取模运算，得到的便是要访问的服务器。

4、加权轮训法

不同服务器抗压能力不同，给配置高、负载低的服务器更高的权重，处理更多的请求；而配置低、负载高的服务器更低权重，处理更少请求，降低负载

5、加权随机法

根据负载不同计算不同权重，按照权重随机请求服务器，而不是顺序的

6、最小连接数法

根据后端服务器当前连接情况，动态的选取当前积压连接数最少的服务器来处理当前请求，尽可能提高后端的利用率。

7、一致性哈希

在源地址哈希上改进，将哈希域映射为环，将计算器映射到环上，计算请求的key对应的哈希值，在顺时针找到的第一台服务器上进行请求。增加虚拟节点，来解决初始服务器数量少，负载不均衡的问题。

### 常见的hash算法

1、直接寻址法

取key的某个线性函数值作为散列地址，其哈希值为a*key+b

2、数字分析法

找出数字的规律，利用数据来构造冲突几率较低的散列地址

3、平方取中法

取key平方后的中间几位作为散列地址

4、折叠法

将key分割为位数相同的几部分，最后一部分位数可以不同，取这几份去除进位的叠加和来作为散列地址

5、随机数法

选择随机函数，取key的随机值作为散列地址，通常用在key长度不同的场合

6、除留余数法

将key对不大于散列表长的数p取余，得到的数为地址。不仅可以直接取模，也可以在折叠，平方取中后取模，一般将p取素数或散列表长

## 数组

### 转圈打印矩阵

{% asset_img 转圈打印矩阵.png This is an example image %}

思路：打印矩阵的思路一般都是宏观调度，用有限个变量去约束要打印的范围，然后循环调用打印函数。此处用左上角和右下角的点去约束范围，调用打印函数，然后将左上角和右下角的点进行收缩。打印矩阵函数为分别判断一行，一列和多行多列的情况，如果为单行单列的，用for循环控制行和列，如果为多行多列，分四次打印。

{% asset_img 转圈矩阵约束.png This is an example image %}

说明的是，在原方法中采用的是直接sout输出，此处使用StringBuilder进行添加。

~~~java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

class PringtEdge {
    //转圈打印矩阵
    public StringBuilder printCircle(int[][] arr){
        //1、找两个边界点
        int row1 = 0, col1 = 0;
        int row2 = arr.length-1,col2 = arr[0].length-1;
        StringBuilder sb = new StringBuilder();
        //只要满足边界条件，循环调用打印函数
        while (row1 <= row2 && col1 <= col2){
            printEdge(arr,sb,row1++,col1++,row2--,col2--);
        }
        return sb;
    }
    public void printEdge(int[][] arr, StringBuilder sb, int row1, int col1, int row2, int col2){
        //1、如果只有一行
        if (row1 == row2){
            for (int i = col1; i <= col2; i++) {
                sb.append(arr[row1][i]+" ");
            }
        }else if(col1 == col2){
            //2、如果只有一列
            for (int i = row1; i <= row2; i++) {
                sb.append(arr[i][col1]+" ");
            }
        }else{
            //3、分四部分打印
            int curR = row1;//当前行
            int curL = col1;//当前列
            while (curL < col2){
                sb.append(arr[curR][curL++]+" ");
            }
            while (curR < row2){
                sb.append(arr[curR++][curL]+" ");
            }
            while (curL > col1){
                sb.append(arr[curR][curL--]+" ");
            }
            while (curR > row1){
                sb.append(arr[curR--][curL]+" ");
            }
        }
    }
}
public class Main{
        public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        //要持有的写的类
        PringtEdge pe = new PringtEdge();
        String[] s = null;
        StringBuilder res = new StringBuilder();
        s = br.readLine().split(" ");
        int row = Integer.valueOf(s[0]);
        int col = Integer.valueOf(s[1]);
        int[][] arr = new int[row][col];
        for (int i = 0; i < row; i++) {
            s = br.readLine().split(" ");
            for (int j = 0; j < col; j++) {
                arr[i][j] = Integer.valueOf(s[j]);
            }
        }
        res = pe.printCircle(arr);
        System.out.println(res.substring(0,res.length()-1));
    }
}
~~~

### 之字型打印矩阵

{% asset_img 之打印矩阵.png This is an example image %}

思路：宏观调度，打印的是两个点之间的对角线的值，那么只要解决点的运动路径和打印对角线即可。要注意的是点在运动过程中时，如果变量A依靠变量B来约束其行为，要先改变变量A，再改变B，不然B先改变则A会缺少值。而对角线打印的时候有方向变化，可以用标记变量来控制。

这种题目依靠的是宏观调度，不要去想每个点到底怎么变。

~~~java
//之字型打印矩阵，找宏观规律
    public StringBuilder printZhi(int[][] m){
        //往右，再下
        int row1 = 0,col1 = 0;
        //往下，再右
        int row2 = 0,col2 = 0;
        int endR = m.length-1;
        int endC = m[0].length-1;
        StringBuilder res = new StringBuilder();
        //先下，再上
        boolean fromUp = false;
        while (row1 <= endR){
            printProcess(m,res,row1,col1,row2,col2,fromUp);
            //路径变化
            //关键为将引发判断的值后判断
            row1 = col1 == endC ? row1+1:row1;
            col1 = col1 == endC ? col1:col1+1;
            col2 = row2 == endR ? col2+1 : col2;
            row2 = row2 == endR ? row2:row2+1;
            fromUp = !fromUp;
        }
        return res;
    }
    public void printProcess(int[][] m,StringBuilder res, int row1,int col1, int row2, int col2,boolean fromUp){
        //如果fromUp为false，从左下向右上打印
        if (!fromUp){
            while (row1 <= row2){
                res.append(m[row2--][col2++]+" ");
            }
        }else{
            while (row1 <= row2){
                res.append(m[row1++][col1--]+" ");
            }
        }
    }
~~~

### 在行列都排好序的矩阵中找数

{% asset_img 排序矩阵找数.png This is an example image %}

思路：从右上角或者左下角开始找，此处选右上角，要是当前数小了就往下，当前数大了就往左。

精髓的点在于开始寻找的位置，利用矩阵的特征，可以将部分不可能的情况给排除掉，这题从右上角或者左下角开始找都可以。但是左上和右下不行，因为没办法缩小规模。核心在于右上或左下，**一边比它大，一边比它小**。这样子存在**要么去一边，要么另一边**的0 1情况，即非黑即白。

实质是将没有可能的数据直接舍弃，即将问题的规模进行缩小。

~~~java
    //在已排序的矩阵中找到数
    public boolean findNum(int[][] m,int k){
        //选择右上角的数
        int row = 0,col = m[0].length-1;
        int endR = m.length-1;
        while (row<=endR && col >=0){
            //如果当前数小，往下走
            if (m[row][col] == k){
                return true;
            }else if(m[row][col]>k){
                //当前数比较大，往左走
                col--;
            }else {
                row++;
            }
        }
        return false;
    }
~~~

## 链表

### 打印两个链表的公共部分

给定两个升序链表，打印两个升序链表的公共部分。

思路：类似于外排，谁小动谁，如果相等，打印并两个一起动

值得注意的点：将head1或者2为空的情况放在最上面，直接返回；将head1.value==head2.value的情况放在三种判断的第一个，这样可以缩短判断时间；整理链表基本结构及生成链表的套路。StringBuilder添加时候，使用两次append比一次append两个str效率高。原因是使用+的时候多了生成String的步骤，这样降低了效率。

~~~java
    //打印两个链表公共部分
    public static void printCommonPart(Node head1,Node head2){
        //将不可能的情况先列出
        if (head1 == null || head2 == null)
            return;
        StringBuilder res = new StringBuilder();
        //类似外排
        //谁小动谁，如果相等，添加并两个一起动
        while (head1 != null && head2 != null) {
            //将相等的判断放在最上面
            if (head1.value == head2.value) {
                //这样比直接append(value+" ")效率高
                res.append(head1.value).append(" ");
                head1 = head1.next;
                head2 = head2.next;
            } else if(head1.value < head2.value){
                head1 = head1.next;
            }else{
                head2 = head2.next;
            }
        }
        System.out.println(res.toString());
    }
~~~

### 合并两个有序的链表

给定两个升序的单链表的头节点 head1 和 head2，请合并两个升序链表， 合并后的链表依然升序，并返回合并后链表的头节点。

思路：类似于外排，如果两个均不为空，谁小动谁；如果哪个为空，把另一个不为空的接到新链表后即可。

小技巧：新链表自己先做一个头节点会比较方便，在动链表的时候，流程为让新链表的下一个指向小节点，新链表当前节点跳到下一个，小节点链表头节点跳到下一个。另外如果有一个链表已经为空了，则不需要一个个节点去添加，直接把整个加上去即可。

~~~java
 //合并链表
    public static Node mergeLink(Node head1, Node head2){
        //类似于外排
        Node res = new Node(0);
        Node cur = res;
        while (head1 != null && head2 != null){
            if (head1.value <= head2.value){
                cur.next = head1;
                cur = head1;
                head1 = head1.next;
            }else {
                cur.next = head2;
                cur = head2;
                head2 = head2.next;
            }
        }
        //将空的链表部分直接拼接到新链表后面即可
        cur.next = head1 == null ? head2 : head1;
        cur = res.next;
        res = null;
        return cur;
    }
~~~

### 判断链表是否为回文结构

给定链表的头结点，判断是否为回文链表

方式一：将链表元素全部存进栈中，利用栈先进后出的特点，与链表逐个比较，额外空间复杂度O(N)

```java
//解法1：将链表中的数据用栈存起来，然后一个个取出来进行对比
public boolean isPalindrome1(Node head){
    if (head == null || head.next == null)
        return true;
    //准备一个栈
    Stack<Node> stack = new Stack<>();
    Node node = head;
    while(node != null){
        stack.push(node);
        node = node.next;
    }
    //取出来比较
    node = head;
    while (!stack.isEmpty()){
        if (node.value != stack.pop().value)
            return false;
        node = node.next;
    }
    return true;
}
```

方法二：只放一半的元素进栈中，缩短一半的额外空间。

为了找到链表中点，用到的方法为快慢指针，是链表题目中比较常见的方法，慢指针一下子走一步，快指针走两步，当快指针走到末尾时，慢指针正好走到中间。注意：如果是要中点位置，慢指针从头结点开始，如果是中点位置下一个，慢指针从头节点下一个开始。此处慢指针的起始点就是头节点下一个。

~~~java
//解法2：只需要判断链表的一半即可，问题是如何找到链表的中点
    //用快慢指针
    public boolean isPalindrome2(Node head){
        if (head == null || head.next == null)
            return true;
        Node slow = head.next;
        Node fast = head;
        while (fast.next != null && fast.next.next != null){
            slow = slow.next;
            fast = fast.next;
        }
        //此时slow来到中点位置，将剩下的节点存入栈中
        Stack<Node> stack = new Stack<>();
        while (slow != null){
            stack.push(slow);
        }
        slow = head;
        while (!stack.isEmpty()){
            if (slow.value != stack.pop().value)
                return false;
            slow = slow.next;
        }
        return true;
    }
~~~

方法三：进阶方式，额外空间复杂度为O(1)，不依靠栈，而是先找到链表中点，将链表右半部分进行翻转，这里有个操作是将中点节点指向null，方便后面判断。然后从链表两端进行判断，注意不能直接返回值，因为还需要将链表还原。判断结束后，将链表右半部分还原。

注意：反转链表，删除链表节点需要利用3个指针，一个指向当前节点，一个指向当前节点的前序节点，一个指向当前节点的后序节点。先保存其下一个进行位置的，再进行操作。

~~~java
//解法3，不利用栈，先找到链表的中点，反转剩下的链表
    //进行判断，然后将链表还原
    public boolean isPalindrome3(Node head){
        if (head == null || head.next == null)
            return true;
        //找到链表中点
        Node n1 = head;
        Node n2 = head;
        while(n2.next != null && n2.next.next != null){
            n1 = n1.next;
            n2 = n2.next.next;
        }
        //此时n1来到中点，反转链表，先要记录n1下一个位置
        n2 = n1.next;
        n1.next = null;
        Node n3 = null;
        //反转链表
        while (n2 != null){
            n3 = n2.next;
            n2.next = n1;
            n1 = n2;
            n2 = n3;
        }
        //此时n1为链表末尾，进行记录
        n3 = n1;
        //开始判断头和尾的值是否相等
        n2 = head;
        boolean res = true;
        while (n2 != null && n1 != null){
            if (n2.value != n1.value){
                //不能直接返回假，这样链表没有被调整回来
                res = false;
                break;
            }
            n2 = n2.next;
            n1 = n1.next;
        }
        //还原链表
        n2 = n3.next;
        n3.next = null;
        while (n2 != null){
            n1 = n2.next;
            n2.next = n3;
            n3 = n2;
            n2 = n1;
        }
        return res;
    }
~~~

### 单向链表的基础partition

题目描述：

给定一个链表，再给定一个整数 pivot，请将链表调整为左部分都是值小于 pivot 的节点，中间部分都是值等于 pivot 的节点， 右边部分都是大于 pivot 的节点。

除此之外，对调整后的节点顺序没有更多要求。

思路：将链表用数组存起来，然后对数组partition，再将数组组合成链表，返回arr[0]，要注意的是将数组的最后个元素的next指向null，以及partition过程的约束条件是index<more，不能取等于，不然会越界。

~~~java
//单链表的partition基础问题，利用数组来实现
    public static Node listPartition(Node head,int pivot){
        if (head == null || head.next == null)
            return head;
        //1、统计链表长度
        int len = 0;
        Node node = head;
        while(node != null){
            len++;
            node = node.next;
        }
        //2、造数组，将链表中元素填充进去
        Node[] arr = new Node[len];
        node = head;
        int i = 0;
        while (node != null){
            arr[i++] = node;
            node = node.next;
        }
        //3、数组的partition问题
        //将其封装为函数
        partitionArr(arr,pivot);
        //将数组组合成链表
        for (i = 1; i < len; i++) {
            arr[i-1].next = arr[i];
        }
        //将最后个节点指针指向null
        arr[i-1].next = null;
        return arr[0];
    }
    public static void partitionArr(Node[] arr, int pivot){
        int less = -1;
        int more = arr.length;
        int i = 0;
        //约束条件为i < more或者i != more
        //如果是等于，当more为数组最后，会越界
        while (i < more){
            if (arr[i].value < pivot){
                swap(arr,i++,++less);
            }else if (arr[i].value > pivot){
                swap(arr,i,--more);
            }else {
                i++;
            }
        }
    }
~~~

### 单链表的partition进阶

要求：在原来基础之上，partition后每个部分的节点从左至右的顺序和原链表中节点的顺序一致。要时间复杂度O（N）,额外空间复杂度O（1）。

思路：将原链表拆分为小，等，大三个区域，遍历链表，来一个就丢到对应的位置中去（将节点从原链表中断开），最后将三个链表合并，考察的是扣边界能力。

~~~java
    //链表的复杂partition
    public static Node listPartition2(Node head,int pivot){
        if (head == null || head.next == null)
            return head;
        //分三个部分，小于、等于、大于区，来个节点就丢到对应的地方去
        //最后将三个部分合并
        Node sH = null;
        Node sT = null;
        Node eH = null;
        Node eT = null;
        Node bH = null;
        Node bT = null;
        Node next = null;
        while(head != null){
            next = head.next;
            head.next = null;
            //将当前节点丢到三个部分中
            if (head.value < pivot){
                //如果为空
                if (sH == null){
                    sH = head;
                    sT = head;
                }else{
                    sT.next = head;
                    sT = head;
                }
            }else if(head.value == pivot){
                if (eH == null){
                    eH = head;
                    eT = head;
                }else{
                    eT.next = head;
                    eT = head;
                }
            }else{
                if (bH == null){
                    bH = head;
                    bT = head;
                }else{
                    bT.next = head;
                    bT = head;
                }
            }
            head = next;
        }
        //将三个链表连接
        if (sT != null){
            sT.next = eH;
            eT = eT == null ? sT:eT;
        }
        if (eT != null){
            eT.next = bH;
        }
        return sH != null ? sH : eH != null ? eH : bH;
    }
~~~

### 复制含有随机节点的链表

方法一：用哈希表，将key为原链表节点，value为新链表节点，然后再复制下一个和rand指针关系

~~~java
public static Node copyListWithRand1(Node head){
    //创建存储用的HashMap，key与value均为Node
    HashMap<Node,Node> map = new HashMap<Node,Node>();
    Node cur = head;
    //对每个结点进行拷贝
    while(cur != null){
        map.put(cur, new Node(cur.value));
        cur = cur.next;
    }
    cur = head;
    while (cur != null){
        //将复制节点的next与random指向cur相同部分
        //get(x)为得到x节点的拷贝结点x'
        map.get(cur).next = map.get(cur.next);//1' 指向 2(1.next)的对应节点2'
        map.get(cur).random = map.get(cur.random);
        cur = cur.next;
    }
    return map.get(head);
}
~~~

方法二：不使用其他数据结构，在原来链表中每个节点后面复制一个新节点，然后复制rand指针关系，再将两个链表拆分开来

~~~java
public static Node copyListWithRand2(Node head){
    if(head == null)
        return null;
    Node cur = head;
    Node next = null;
    // copy node and link to every node
    while(cur != null){
        next = cur.next;
        cur.next = new Node(cur.value);
        cur.next.next = next;
        cur = next;
    }
    cur = head;
    Node curCopy = null;
    // set copy node rand
    while (cur != null){
        next = cur.next.next;
        curCopy = cur.next;
        curCopy.random = cur.random != null ? cur.random.next : null;
        cur = next;
    }
    Node res = head.next;//记录下复制链表的头结点
    cur = head;
    // split
    while(cur != null){
        next = cur.next.next;
        curCopy = cur.next;
        cur.next = next;
        curCopy.next = next != null ? next.next : null;
        cur = next;
    }
    return res;
}
~~~

### 反转链表

非递归实现

反转单链表和双链表，基本思路是持有三个节点，当前节点的前序节点，当前节点，下一个节点。

对于单链表，如果当前节点不为空，保存其下一个节点next，当前节点指向前序节点pre，pre=当前节点，当前节点=next，这样便实现了反转；对于双向链表，只是多了一步让当前节点的前序节点=next，其他和单向链表一样。

~~~java
	//反转单向链表
    public static Node reverseListSL(Node head){
        //准备三个节点
        Node pre = null;
        Node cur = head;
        Node next = null;
        while (cur != null){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
    //反转双向链表
    public static Node reverseListDL(Node head){
        //准备三个节点
        Node pre = null;
        Node cur = head;
        Node next = null;
        while (cur != null){
            next = cur.next;
            cur.next = pre;
            cur.pre = next;
            pre = cur;
            cur = next;
        }
        return pre;
    }
~~~

递归实现

看其是否可以分解成具有相同解决思路的子问题。反转链表1->2->3->4，如果把1以后的链表都反转好了，让2指向1,1指向空即可。对于1后面的子链表，也可以这样去处理。因此可以使用递归去解决

1. 定义递归函数，明确函数功能及返回值

   此递归函数实现的功能是反转某个节点开始的链表，返回的是反转后的新的结点

2. 寻找递归公式

   - 先反转当前节点以后的链表，这样1->2->3->4变为1->2<-3<-4
   - 将当前node(1)的下一个节点(node.next)的指向(node.next.next)改为当前节点(node)，node的后继结点变为空
   - 返回新的头结点

3. 将递推公式带入定义好的递归函数中

~~~java
    //反转链表的递归实现
    //递归函数要实现的功能是反转链表，返回的是反转后的链表头节点
    public static Node reverseList2(Node node){
        //base case
        if (node.next == null)
            return node;
        //对当前节点做操作
        //把后面的链表进行反转
        Node newHead = reverseList2(node.next);
        //把后面的反转好后，让当前node的下一个节点的下一个指向当前节点
        //让当前节点的下一个指向空
        node.next.next = node;
        node.next = null;
        //返回新的头节点
        return newHead;
    }
~~~

### 反转部分单向链表

给定一个单链表，在链表中把第 L 个节点到第 R 个节点这一部分进行反转。

思路：找到from-1,from,to,to+1处的四个链表，如果from或者to为空，直接返回，反转from-to之间的链表，然后让from-1指向to，from指向to+1。如果from-1为空，那么to变为新链表的头结点。

~~~java
	//反转from-to之间的链表
    public static Node reversePartList(Node head, int fromIndex, int toIndex){
        if (head == null || head.next == null)
            return head;
        //找到from-1,fro,to,to+1处的链表节点
        Node fromPre = null;
        Node from = null;
        Node to = null;
        Node toPos = null;
        Node cur = head;
        int count = 0;
        //如果from和to的距离超过了链表长度，就不进行操作
        while (cur != null){
            count++;
            if (count == fromIndex - 1){
                fromPre = cur;
            }else if (count == fromIndex){
                from = cur;
            }else if (count == toIndex){
                to = cur;
            }else if (count == toIndex + 1){
                toPos = cur;
            }
            cur = cur.next;
        }
        if (from == null || to == null)
            return head;
        //反转from-to之间的结点
        Node pre = null;
        cur = from;
        Node next = null;
        while (cur != toPos){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        //如果from为头结点，新的头结点为to
        if (fromPre == null){
            head = to;
        }else {
            fromPre.next = to;
        }
        from.next = toPos;
        return head;
    }
~~~

### 两链表相交问题（五星级）

在本题中，单链表可能有环，也可能无环。给定两个链表的头节点，实现函数，如果两链表相交，返回相交的第一个节点；如果不相交，返回null即可。

要求：如果链表1的长度为N，链表2的长度为M，时间复杂度达到O（N+M），额外空间复杂度达到O（1）。

思路：遇到复杂问题进行拆解，首先需要判断两个链表是否有环，如果两个都没有环，那就是两个无环链表的相交问题；如果两个都有环，那就是两个有环链表的相交问题；如果一个有环，一个无环，是没有这种结构的。因此将问题差结成了三个，首先需要求解链表的入环节点。

判断链表是否有环有两种方法，一种是利用哈希表，如果当前节点在哈希表中，返回当前节点，否则加入哈希表，并遍历到下一个节点，此方法额外空间复杂度不为O(1)。

~~~java
public static Node getFirstLoopNode(Node head){
    HashSet<Node> set = new HashSet<Node>();
    while(head != null){
        if(set.contains(head)){
            return head;
        }
        set.add(head);
        head = head.next;
    }
    return null;
}
~~~

第二种方法是利用快慢指针，如果快指针没有遇到慢指针，快指针走2步，慢指针走1步，如果快指针后面为空，返回空。当快慢指针相遇，让快指针从链表头开始，和慢指针一起每次走一步，二者相遇的地方即为链表的入环节点。

{% asset_img 链表入环.png This is an example image %}

假设起始点到入环处的长度为`a`，环的长度为`L`，当快指针与慢指针相遇时，设慢指针所走的路程为`b`，当慢指针入环时，快指针已经在环上了，设快指针距离入环点距离为c，这时候当慢指针继续走c步时，快指针就会赶上慢指针了，c<=L，此时慢指针还没有走一圈。

当快慢指针相遇时 ，两个指针走的距离为

p慢=a+b=n

p快=a+b+k*L=2n（快指针比慢指针多走k圈）

因此有`n=a+b=k*L`。此时若让快指针从头节点重新走a步，`a=k*L-b`，对于慢指针，因为其已经走了b步，此时再走a步，正好在环上走了k圈（a+b=k*L）,因此两个指针会在入环点相遇。

判断条件是快慢指针没有相遇，而一旦快指针后面为null，返回即可。

~~~java
public static Node getLoopNode(Node head){
    if(head == null || head.next == null || head.next.next == null)
        return null;
    Node slow = head.next;
    Node fast = head.next.next;
    while(slow != fast){
        if(fast.next == null || fast.next.next == null)
            return null;
        fast = fast.next.next;
        slow = slow.next;
    }
    fast = head;
    while(slow != fast){
        slow = slow.next;
        fast = fast.next;
    }
    return slow;
}
~~~

这样便可以判断出链表是否有环。对于两个都没有环的链表，如果他们相交，则最后个节点一定相等，让更长的链表先将多的部分走完，两个链表再一起走，便会在第一个相交的地方相遇。

~~~java
//两条链表没有环的情况
public static Node noLoop(Node head1, Node head2){
    if(head1 == null || head2 == null)
        return null;
    Node cur1 = head1;
    Node cur2 = head2;
    int n = 0;
    //找到最后个节点并求两条链表长度差
    while (cur1.next != null){
        n++;
        cur1 = cur1.next;
    }
    while (cur2.next != null){
        n--;
        cur2 = cur2.next;
    }
    //最后节点不相同，一定不相交
    if(cur1 != cur2)
        return null;
    //将cur1指向更长的链表
    cur1 = n > 0 ? head1 : head2;
    cur2 = cur1 == head1 ? head2 : head1;
    n = Math.abs(n);//得到较长链表需要多走的步数
    while (n != 0){
        n--;
        cur1 = cur1.next;
    }
    //共同走到相同的节点
    while (cur1 != cur2){
        cur1 = cur1.next;
        cur2 = cur2.next;
    }
    return cur1;
}
~~~

而对于两个都有环的链表，有如下的三种结构。

{% asset_img 链表结构.png This is an example image %}

其中如果两个链表的入环节点为同一个，则是第二种结构，可以简化为无环链表的相交问题；如果入环节点不为同一个，则让一个节点从环上走一圈，如果没有碰到另一个链表的入环节点，则说明是第一种，否则返回其中一个链表的入环节点即可。

~~~java
//两个链表都有环的情况
public static Node bothLoop(Node head1, Node loop1, Node head2, Node loop2){
    //有3种情况
    Node cur1 = null;
    Node cur2 = null;
    //演变为无环链表的相交问题
    if(loop1 == loop2){
        cur1 = head1;
        cur2 = head2;
        int n = 0;
        while(cur1 != loop1){
            n++;
            cur1 = cur1.next;
        }
        while(cur2 != loop2){
            n--;
            cur2 = cur2.next;
        }
        cur1 = n > 0 ? head1 : head2;
        cur2 = cur1 == head1 ? head2 : head1;
        n = Math.abs(n);
        while(n != 0){
            n--;
            cur1 = cur1.next;
        }
        while(cur1 != cur2){
            cur1 = cur1.next;
            cur2 = cur2.next;
        }
        return cur1;
    }else{
        //遍历loop1到自己，看是否遇到loop2
        cur1 = loop1.next;
        while(cur1 != loop1){
            if(cur1 == loop2){
                return loop1;
            }
            cur1 = cur1.next;
        }
        return null;
    }
}
~~~

剩下的主方法就比较简单，求两个链表的入环节点，然后对无环链表相交，有环链表相交和一个有环一个无环进行判断即可。

~~~java
//主方法
public static Node getIntersectNode(Node head1, Node head2){
    if(head1 == null || head2 == null){
        return null;
    }
    Node loop1 = getLoopNode(head1);
    Node loop2 = getLoopNode(head2);
    if(loop1 == null && loop2 == null)
        return noLoop(head1, head2);
    if(loop1 != null && loop2 != null)
        return bothLoop(head1,loop1,head2,loop2);
    return null;
}
~~~

## 堆

堆本质是一个二叉树 ，在Java中实现为优先级队列（PriorityQueue），默认为小根堆，即最小的在最上面。可以通过在新建堆时传入比较器对象来定义大根堆或者小根堆。其中如果比较器只用到一次，没有必要去专门定义一个类，可以用匿名内部类，实现compare()方法即可，更简单的是用lambda表达式，更简洁。

堆的结构很好用，在取中位数，第k大or第k小的数，前k大or前k小，贪心中经常用到。

### 随时找到数据流的中位数

题目描述：有一个源源不断的吐出整数的数据流，假设你有足够的空间来保存吐出的数。请设计一个名叫MedianHolder的结构，MedianHolder可以随时取得之前吐出所有数的中位数。

[要求]

1. 如果MedianHolder已经保存了吐出的N个数，那么将一个新数加入到MedianHolder的过程，其时间复杂度是O(logN)。

2. 取得已经吐出的N个数整体的中位数的过程，时间复杂度为O(1)

思路：持有两个堆，一个大根堆，一个小根堆，大根堆中存放较小的一半数，小根堆中存放较大的一半数，这样中位数就被大根堆和小根堆夹着。如果两个堆大小相等，则取平均；不然就返回较多的那个堆的堆顶元素。

其中比较关键的是将数加入堆的操作，如果大根堆为空或者当前数比大根堆顶的数小，则直接放入大根堆中，否则放入小根堆。然后进行堆的调整：哪个堆中的数据比另一个堆中数据多了2个，则拿一个到另一个堆中。这样将放数和调整堆进行了**解耦**，可以让代码变得更简洁。

其中牛客网要求格式化输出数据，可以用DecimalFormat类，进行一位小数的输出。

~~~java
public class MedianHolder {
    //随时找到数据流的中位数，需要持有两个堆
    //大根堆
    private PriorityQueue<Integer> maxHeap = null;
    //小根堆
    private PriorityQueue<Integer> minHeap = null;
    // 取出所有整数部分和一位小数，格式化输出
    DecimalFormat df = new DecimalFormat("#.0");
    //构造方法，初始化
    public MedianHolder(){
        maxHeap = new PriorityQueue<Integer>((o1,o2)->o2-o1);
        minHeap = new PriorityQueue<Integer>((o1,o2)->o1-o2);
    }
    //将数添加进堆中
    public void addNum(int num){
        //如果大根堆为空或者数比大根堆顶的数小，添加到大根堆
        if (maxHeap.isEmpty() || num <= maxHeap.peek()){
            maxHeap.add(num);
        }else{
            minHeap.add(num);
        }
        //堆的调整
        modifyTwoHeap();
    }
	//调整堆
    private void modifyTwoHeap() {
        //如果大根堆比小根堆多两个，放一个进小根堆
        if (maxHeap.size() == minHeap.size() + 2){
            minHeap.add(maxHeap.poll());
        }
        if (minHeap.size() == maxHeap.size() + 2){
            maxHeap.add(minHeap.poll());
        }
    }
    //查找中位数
    public void getMedian(){
        //如果两个为空，返回空
        if (maxHeap.size() == 0){
            System.out.println(-1);
            return;
        }
        //如果两个堆中数相等，取两个堆顶平均
        if (minHeap.size() == maxHeap.size()){
            System.out.println(df.format((maxHeap.peek()+minHeap.peek())/2.0));
        }else {
            //哪个多返回哪个的
            System.out.println(df.format(maxHeap.size() > minHeap.size() ? maxHeap.peek() : minHeap.peek()));
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s = null;
        StringBuilder res = new StringBuilder();
        s = br.readLine();
        int count = Integer.valueOf(s);
        //要持有的写的类
        MedianHolder m = new MedianHolder();
        for (int i = 0; i < count; i++) {
            //读一行数据
            String[] str = br.readLine().split(" ");
            if ("2".equals(str[0])){
                m.getMedian();
            }else {
                m.addNum(Integer.valueOf(str[1]));
            }
        }
    }
}
~~~

### 切金条

题目描述：给定一个正数数组arr，arr的累加和代表金条的总长度，arr的每个数代表金条要分成的长度。规定长度为k的金条分成两块，费用为k个铜板。返回把金条分出arr中的每个数字需要的最小代价。

要求：时间复杂度为O(n log n)，空间复杂度为O(n)

题目说明：

```
如果先分成40和20两块，将花费60个铜板，再把长度为40的金条分成10和30两块，将花费40个铜板，总花费为100个铜板；
如果先分成10和50两块，将花费60个铜板，再把长度为50的金条分成20和30两块，将花费50个铜板，总花费为110个铜板；
如果先分成30和30两块，将花费60个铜板，再把其中一根长度为30的金条分成10和20两块，将花费30个铜板，总花费为90个铜板；
因此最低花费为90
```

思路：哈夫曼编码问题，即每次选出权重最小的数，新节点权重为二者相加，将新节点加入，再拿出两个，直到之后只有一个数，其值就是总的权重。

哈夫曼编码的应用：给出传递的电文，计算每个字母的权重，选出较小的两个节点构造成一个二叉树（小的在左，大的在右），新二叉树的权重为二者权重之和，然后将新二叉树放入，再重新拿出两个权重最小的。树构造好后，进行编码，左边为0，右边为1，只有叶子节点在存储了信息，这样从头节点找到叶子节点，便可以找到每个字母对应的编码。当给定了编码后，要如何去找到对应的字母呢？可以从字符串中取出字符，然后在树中进行寻找，如果找到了叶子节点，就得到了一个字母，再继续找下去。



### 做项目

题目描述：

输入：

参数1：正数数组costs

参数2：正数数组profits

参数3：正数k

参数4：正数m

参数说明：cost[i]表示i号项目的花费，profits[i]表示i号项目在扣除花费后还能挣到的钱（利润），k表示你不能并行、只能串行的最多做k个项目，m表示你初始的资金。

说明：你每做完一个项目，马上获得的收益，可以支持你去做下一个项目

输出：你最后获得的最大钱数。

分析：标准的贪心问题，选择项目的标准是：在花费比资金小的项目中，选择利润最多的，积累利润后，再选择花费比当前资金小的项目，直到做了k个项目。

思路：持有两个堆，一个小根堆，一个大根堆，小根堆依照项目花费排序，大根堆中依靠项目利润排序，从小根堆中弹出花费比当前资金少的项目进大根堆，然后从大根堆中弹出一个项目来做，累积资金，直到做了k个项目。

坑点：返回的收益需要是**long**类型，**避免溢出**！！！

~~~java
//将项目的花费和利润封装为一个节点
class proNode{
    public int c;
    public int p;
    public proNode(int c,int p){
        this.c = c;
        this.p = p;
    }
}
public class FindMaximizedCapital {
    //持有两个堆
    private PriorityQueue<proNode> minHeap;
    private PriorityQueue<proNode> maxHeap;
    public FindMaximizedCapital(){
        minHeap = new PriorityQueue<proNode>((o1,o2)->o1.c-o2.c);
        maxHeap = new PriorityQueue<proNode>((o1,o2)->o2.p-o1.p);
    }
    //计算项目最大利润
    public long findMaximizedCapital(int[] costs,int[] profits,int k,long m){
        //将花费和利润封装放进小根堆
        for (int i = 0; i < costs.length; i++) {
            minHeap.add(new proNode(costs[i],profits[i]));
        }
        //进行k次循环做项目
        for (int i = 0; i < k; i++) {
            //知道小根堆不为空且堆顶项目花费比m少，弹进大根堆
            while (!minHeap.isEmpty() && minHeap.peek().c <= m){
                maxHeap.add(minHeap.poll());
            }
            //需要考虑到大根堆为空的情况，即虽然没有到k次，但没有项目可做
            if (maxHeap.isEmpty())
                return m;
            //选出一个项目来做
            m += maxHeap.poll().p;
        }
        return m;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] str = br.readLine().split(" ");
        int n = Integer.valueOf(str[0]);
        int w = Integer.valueOf(str[1]);
        int k = Integer.valueOf(str[2]);
        String[] strC = br.readLine().split(" ");
        String[] strP = br.readLine().split(" ");
        int[] costs = new int[n];
        int[] profits = new int[n];
        for(int i = 0;i<n;i++) {
            costs[i] = Integer.parseInt(strC[i]);
        }
        for(int i = 0;i<n;i++) {
            profits[i] = Integer.parseInt(strP[i]);
        }
        FindMaximizedCapital fm = new FindMaximizedCapital();
        long win = fm.findMaximizedCapital(costs,profits,k,w);
        System.out.println(win);
    }
}
~~~

### 字符串拼接

给定一个字符串类型的数组strs，找到一种拼接方式，使得把所有字符串拼起来之后形成的字符串具有最低的字典序。

​    字典序：每个字母相当于26进制的数，如果位数相同则比较字面值，长度不能的时候，把短的补到跟长的一样，补的内容相当于ASCII表中最小的内容，然后从最高位开始比较。

比较两个字符串，若str1+str2<= str2 + str1，则str1放前面，否则str2放前面。不要去证明贪心问题。

~~~java
//比较器
public static class MyComparator implements Comparator<String>{
    @Override
    public int compare(String o1, String o2) {
        //负数认为o1小，谁作为前缀小谁放前面
        return (o1 + o2).compareTo(o2 + o1);
    }
}
//用比较器来排序
public static String lowestString(String[] strs){
    if (strs == null || strs.length == 0)
        return "";
    Arrays.sort(strs,new MyComparator());
    StringBuilder sb = new StringBuilder();
    for (String s : strs){
        sb.append(s);
    }
    return sb.toString();
}
~~~

## 树

### 树的深度遍历

#### 递归遍历方法

先序遍历：先中、再左、再右。对每一个结点，先打印当前结点，再打印其左子树所有结点，再打印右子树所有结点。

中序遍历：先左、再中、再右。对每一个结点，先打印其左子树所有结点，再打印当前结点，再打印右子树所有结点。

后序遍历：先左、再右、再中。对每一个结点，先打印其左子树所有结点，再打印右子树所有结点，再打印当前结点。

~~~java
//先序打印二叉树的递归实现
public static void preOrderRecur(Node head){
    if(head == null)
        return;
    //先打印当前节点
    System.out.print(head.value+" ");
    //递归打印左子树
    preOrderRecur(head.left);
    //递归打印右子树
    preOrderRecur(head.right);
}
//中序打印二叉树的递归实现
public static void inOrderRecur(Node head){
    if(head == null)
        return;
    //先打印左子树，再打印中间，再打印右子树
    inOrderRecur(head.left);
    System.out.print(head.value +" ");
    inOrderRecur(head.right);
}
//后序打印二叉树的递归实现
public static void posOrderRecur(Node head){
    if (head == null)
        return;
    //先打印左子树，再打印右子树，再打印当前节点
    posOrderRecur(head.left);
    posOrderRecur(head.right);
    System.out.print(head.value + " ");
}
~~~

#### 非递归遍历方法

先序遍历用栈结构实现，顺序为先中，再左，再右。将头结点放入栈，如果栈不为空，弹出当前节点，弹出就打印。如果右不为空，把右边的放入栈中。如果左不为空，把左边的放入栈中。为了让先弹左，再弹右，因此放入栈的时候要先右再左。

~~~java
//先序遍历非递归实现
public static void preOrderUnRecur(Node head){
    System.out.print("pre-order: ");
    if(head != null){
        //准备一个栈
        Stack<Node> stack = new Stack<Node>();
        //将头结点压入
        stack.add(head);
        //只要栈不为空
        while (!stack.isEmpty()){
            //弹出并打印头结点
            head = stack.pop();
            System.out.print(head.value+" ");
            //如果右节点不为空，压入
            if(head.right != null){
                stack.push(head.right);
            }
            //如果左节点不为空，压入
            if(head.left != null){
                stack.push(head.left);
            }
        }
    }
    System.out.println();
}
~~~

中序遍历用栈结构实现，顺序为先左，再中，再右。栈中先放所有的左边界，head从头往左移动，直到空，这样所有的左边界都到栈中了。当往左移动不下去了，从栈中弹出一个并打印，并向右移动。

​    因为从中一直往左压栈，因此弹出的时候一定是从左到中，往右跑是因为要把右子树也按照这种方法压入栈。那么整个顺序是先左再中再右。

~~~java
//中序遍历非递归实现
public static void inOrderUnRecur(Node head){
    System.out.println("in-order: ");
    if(head != null){
        Stack<Node> stack = new Stack<>();
        //只要栈不为空或者head不为空就循环
        while (!stack.isEmpty() || head != null){
            //如果head不为空，一直将左节点压入栈
            if(head != null){
                stack.push(head);
                head = head.left;
            }
            //如果head为空，弹出并打印栈中元素，
            else{
                head = stack.pop();
                System.out.print(head.value + " ");
                head = head.right;
            }
        }
    }
    System.out.println();
}
~~~

后续遍历是先左再右再中。中左右，是先弹出中，然后压入右，压入左。那么中右左就是先弹出中，然后压入左，压入右。然后该打印的时候不打印，放入一个help，再弹出来，就是先左再右再中了。

~~~java
//后序遍历非递归实现
public static void posOrderUnRecur(Node head){
    System.out.println("pos order: ");
    if(head != null){
        Stack<Node> stack = new Stack<>();
        Stack<Node> help = new Stack<>();
        //先把头节点压入
        stack.push(head);
        while (!stack.isEmpty()){
            head = stack.pop();
            //该输出的时候弹入辅助栈
            help.push(head);
            //先压左后压右
            if(head.left != null){
                stack.push(head.left);
            }
            if(head.right != null){
                stack.push(head.right);
            }
        }
        //将辅助栈中数据弹出
        while (!help.isEmpty()){
            System.out.print(help.pop().value+" ");
        }
    }
    System.out.println();
}
~~~

#### 折纸问题

{% asset_img 折纸.png This is an example image %}

这个问题实质是二叉树的中序遍历问题，头结点为下，左孩子为下，右孩子为下，用递归方式解决，递归函数参数列表有当前树高度，为左还是右（左为下，右为上）

{% asset_img 折纸树.png This is an example image %}

~~~java
    //直观打印折纸
    //本质上是树的中序遍历，左结点为下，右结点为上，头节点为下
    //用递归实现，功能是中序打印二叉树，需要传入当前树的高度，左还是右
    //因为只有两种可能，所以可以用布尔类型的变量来表示
    public static void printAllFolds(int N){
        printProcess(1,N,true);
    }

    private static void printProcess(int i, int n, boolean b) {
        //base case
        if (i > n)
            return;
        //left,cur,right
        printProcess(i+1,n,true);
        System.out.println(b ? "下" : "上");
        printProcess(i+1,n,false);
    }
~~~

### 在二叉树中找到一个节点的后继节点

现在树结点多了一个parent结点，指向父节点，头节点的parent指向null。只给一个在二叉树中某个节点node，实现返回node的后继节点的函数。在二叉树的后序遍历的序列中，node的下一个节点叫做node的后继节点。

中序遍历为左、中、右，考虑当前节点为中的情况，因此如果有右子树，后继节点应该是右子树的最左结点。当前节点如果为左，其为父节点的左孩子，则父节点就是后继节点。如果当前节点为右，表明其所在的左子树已被遍历完，需要找到某个节点，其为父节点的左孩子，返回此父节点。

~~~java
public static Node getNextNode(Node node){
    if(node == null)
        return null;
    //node有右子树，找到右子树最左节点
    if(node.right != null){
        return getLeftMost(node.right);
    }
    //没有右子树
    else {
        Node parent = node.parent;//拿到父节点
        //只要此节点不为父节点的左子树
        //跳到node是parent左节点停，返回parent
        //加上Parent不为空是为了兼顾没有后继的情况
        //其中parent不为空要放在前面，不然就算空了，因为parent左孩子不为node，循环仍继续
        while (parent != null && parent.left != node){
            //当前节点不是父节点的左孩子则继续
            node = parent;
            parent = node.parent;
        }
        return parent;
    }
}
//找最左节点
public static Node getLeftMost(Node node){
    if(node == null){
        return node;
    }
    while (node.left != null){
        node = node.left;
    }
    return node;
}
~~~

### 树的序列化

#### 树的先序方式序列化与反序列化

中、左、右。将遍历的结果用字符串进行记录。当一个节点的左子树为空时，可以用一个特殊符号来记录，如#。

序列化思路：利用递归来进行中序遍历，如果是空节点，则添加#！，如果不为空，添加value!，然后遍历左子树与右子树。

~~~java
public static String serialByPre(Node head){
    if (head == null){
        return "#!";
    }
    //中、左、右的递归
    String res = head.value + "!";
    res += serialByPre(head.left);
    res += serialByPre(head.right);
    return res;
}
~~~

反序列化思路：将字符串用！进行分割，然后将数组中的字符一个个构造成节点，可以将其加入到队列中，也可以用index+数组来取，这样当为#，返回空，构造一个新节点，递归构造其左子树与右子树，然后返回头节点。

~~~java
//前序方式反序列化
public static Node reconByPreString(String preStr){
    //分割字符串
    String[] values = preStr.split("!");
    Queue<String> queue = new LinkedList<>();
    //将所有元素加入到队列，用数组也可以，需要传递下标
    for (int i = 0; i != values.length; i++) {
        queue.offer(values[i]);
    }
    return reconPreOrder(queue);
}
//给一个队列建立树
public static Node reconPreOrder(Queue<String> queue){
    String value = queue.poll();
    //空节点
    if (value.equals("#")){
        return null;
    }
    //建立新节点等于head
    Node head = new Node(Integer.valueOf(value));
    //左、右子树分别交给递归去实现
    head.left = reconPreOrder(queue);
    head.right = reconPreOrder(queue);
    return head;
}
~~~

#### 树的层序方式序列化与反序列化

层序方式也是广度优先遍历。

序列化思路：将头节点加入队列，并将其添加进StringBuilder，从队列中弹出一个节点，将其左右子树的值加入，没有就加入#，而不选择在弹出的时候添加是因为空节点无法加入队列。如果左子树不为空，加入队列；如果右子树不为空，加入队列。

~~~java
	//按层序列化
    public static String serialByLevel(Node head){
        if (head == null)
            return null;
        StringBuilder sb = new StringBuilder();
        Queue<Node> queue = new LinkedList<>();
        queue.offer(head);
        sb.append(head.value).append("!");
        while (!queue.isEmpty()){
            head = queue.poll();
            //在节点进去的时候就添加，不然添加不了空节点
            if (head.left != null){
                queue.offer(head.left);
                sb.append(head.left.value).append("!");
            }else {
                sb.append("#!");
            }
            if (head.right != null){
                queue.offer(head.right);
                sb.append(head.right.value).append("!");
            }else {
                sb.append("#!");
            }
        }
        return sb.toString();
    }
~~~

按层方式反序列化 思路：将字符串分割，建造头节点并放入队列中，记录头节点。从队列中弹出一个节点，建造其左子树与右子树，如果左子树不为空，加入队列；如果右子树不为空，加入队列。此处用index+数组来控制当前要利用的字符串。

~~~java
//按层方式反序列化
    public static Node reconByLevelString(String levelStr){
        //将字符串分割
        String[] str = levelStr.split("!");
        int value = 0;
        //产生头节点，并放进队列中
        Node res = generateNode(str[value++]);
        Node head = res;
        Queue<Node> queue = new LinkedList<>();
        queue.offer(head);
        while (!queue.isEmpty()){
            head = queue.poll();
            head.left = generateNode(str[value++]);
            head.right = generateNode(str[value++]);
            if (head.left != null){
                queue.offer(head.left);
            }
            if (head.right != null){
                queue.offer(head.right);
            }
        }
        return res;
    }
~~~

### 判断树的类型

#### 判断树是否为平衡二叉树

平衡二叉树中，在任何一个节点，左子树与右子树高度差，不超过1。

思路：以每一个节点为头节点的树为平衡二叉树，总体才是，对当前节点，需要其左子树为平衡二叉树，右子树为平衡二叉树，两个子树高度差不超过1，才是平衡二叉树。可以用树的后序遍历递归方式解决，当前函数需要给下一级函数传递当前子树是否平衡，树的高度，如果树不平衡，则高度没有用。可以将是否平衡与树的高度信息进行封装。关键是看函数功能是什么，需要传递什么参数。

平衡性用来解决效率问题。

~~~java
public static boolean isB(Node head){
    return process(head).isB;
}
public static ReturnData process(Node head){
    //空树是高度为0的平衡树
    if (head == null)
        return new ReturnData(true, 0);
    ReturnData leftData = process(head.left);
    //左子树不平衡，则直接不平衡
    //在不满足时高度为0是因为高度用不上
    if (!leftData.isB) {
        return new ReturnData(false, 0);
    }
    ReturnData rightData = process(head.right);
    if (!rightData.isB){
        return new ReturnData(false, 0);
    }
    //左、右树均平衡
    if (Math.abs(leftData.h - rightData.h) > 1){
        return new ReturnData(false, 0);
    }
    //在满足的时候，子结构要给父过程提供高度，为二者中较高的+1
    return new ReturnData(true,Math.max(leftData.h, rightData.h)+1);
}
~~~

#### 判断一棵二叉树是否是搜索二叉树

如果为搜索二叉树，则其中序遍历的输出一定是升序的，那么中序遍历树，如果当前节点的值小于上一个节点的值，则不为搜索二叉树，因此需要记录上一个节点的值 ，第一个节点的上一个节点为Integer的最小值，当遍历到节点比上一个节点小，返回假，否则更新上一个节点值为当前节点值，遍历下一个节点。当将树遍历完后，返回真。

~~~java
//判断是否是搜索二叉树，用中序遍历非递归改
//只要在返回的时候，判断是否比前一个数大即可
public static boolean isBST(Node head){
    if (head == null)
        return true;
    Stack<Node> stack = new Stack();
    int pre = Integer.MIN_VALUE;
    while (!stack.isEmpty() || head != null){
        if (head != null){
            stack.push(head);
            head = head.left;
        }else{
            //弹出一个元素
            head = stack.pop();
            if (head.value < pre){
                return false;
            }
            pre = head.value;
            head = head.right;
        }
    }
    return true;
}
~~~

#### 判断一棵二叉树是否为完全二叉树

思路：利用层级优先遍历，一个节点的左右子树有四种不同状态，如果左有且右有，则继续判断；如果左有，右没有，则后面不能出现叶子节点；如果左没有，右有，肯定不是；如果左没有，右没有，后面不能出现叶子节点。

因此有两种是绝对不可能的

- 左没有，右有
- 之前有右边没有的，后来有非空节点

~~~java
public static boolean isCBT(Node head){
    if (head == null)
        return true;
    //双端链表，实现队列
    Queue<Node> queue = new LinkedList<>();
    //表示是否开启了情况2
    boolean leaf = false;
    Node l = null;
    Node r = null;
    queue.offer(head);
    while (!queue.isEmpty()){
        head = queue.poll();
        l = head.left;
        r = head.right;
        //有右没左或子节点不全且之后有非叶节点
        if ((leaf && (l !=null || r != null)) || (l == null && r !=null)){
            return false;
        }
        if (l != null)
            queue.offer(l);
        if (r != null){
            queue.offer(r);
        }else{
            //右为空，开启状态2
            leaf = true;
        }
    }
    return true;
}
~~~



# 剑指Offer

## 数组

### 数组中重复数字

#### 允许修改数组

长度为n的数组里所有数字均出现在o~n-1的范围内，数组内某些数字是重复的，但不知道几个重复了，也不知道数字重复了几次。找出数组中任意一个重复的数字。如 ，长度为7的数组{2,3,1,0,2,5,3}，对应的输出为重复数字为2或者3。

方法1：使用哈希表，如果一个元素添加进哈希表了，就返回此元素，如果没有加入过，就加入。

时间复杂度O(n)，额外空间复杂度O(n)。

~~~java
    //使用哈希表
    public static Integer findNumHash(int[] arr){
        if (arr == null || arr.length < 2)
            return null;
        HashSet<Integer> set = new HashSet<>();
        for (int i = 0; i < arr.length; i++) {
            if (set.contains(arr[i]))
                return arr[i];
            else
                set.add(arr[i]);
        }
        return null;
    }
~~~

这种情况下解决的是找到第一个重复元素的问题，但是要额外建立一个哈希表。

方法2：抽屉原理

如果有n个数分布为0-n-1，在没有重复的时候，必然是一个萝卜一个坑，即可以将值为`i`的元素（i=0~n-1）放在第`i`个坑中，但是因为有重复的元素存在，会出现在第`i`个坑中值不为i的情况，这时候可以将它放在它原本应在的地方，直到当前坑中放了对应的萝卜，如果此时第`i`个坑中元素为`k`，但第`k`个坑中元素也为`k`，说明当前元素就是重复的。

总的时间复杂度为O(n)，额外空间复杂度O(1)。

~~~java
//找到第一个重复的数字，抽屉原理
    public static Integer findNum(int[] arr){
        if (arr == null || arr.length < 2)
            return null;
        //如果数组的长度不在0-arr.length-1之间，返回
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] < 0 || arr[i] > arr.length-1)
                return null;
        }
        //从第一个到最后一个
        //如果当前数和角标不等，交换，直到相等或和要交换角标处的值相等
        for (int i = 0; i < arr.length; i++) {
            while (arr[i] != i){
                if (arr[i] == arr[arr[i]]){
                    return arr[i];
                }
                //swap(arr,i,arr[i])
                int temp = arr[i];
                arr[i] = arr[arr[i]];
                //不能直接使用arr[arr[i]]，因为此时arr[i]已经变化了
                arr[temp] = temp;
            }
        }
        return null;
    }
~~~

#### 不修改数组找到重复数字

在长度为n+1的数组里的所有数字都在1~n的范围之内，因此数组中至少有一个数字是重复的。找出任意一个重复的数字，但不能修改输入的数组，如输入长度为8的数组{2,3,5,4,3,2,6,7}，输出为重复的数字2或者3。额外空间复杂度为O(1)。

不能使用哈希表，不能使用抽屉原理，这时候可以考虑二分。因为如果`1~n`的数字没有重复，那么`1~(n-1)/2`和`(n-1)/2+1~n`中元素个数应该和其角标left-right之间的范围相同，但是因为有重复的，那么假设重复数字为3，那么`1~7`分为`1~4`和`5~7`，这时候`1~4`中的元素个数肯定会多于4，然后再到`1~4`中进行寻找，直到找到left=right，如果这时候left值的数字出现个数>1，则输出left。

用到的为二分的模板

核心为

1. left与right的取值很重要，需要夹住所有可能的情况
2. while循环中用left < right，这样退出循环的时候一定有left==right，不用思考返回left还是right
3. mid选择左中位数（left + ((right - left) >> 1)）或者右中位数（left + ((right - left+1) >> 1)）
4. 只用两个判断，一次排除一半的结果
5. 可以选择是否在循环结束后对夹住的数进行判断

~~~java
int left = 数1, right = 数2;
while(left < right){
    int mid = left + ((right - left) >> 1);
    if(判断条件1){
        left = mid + 1;
    }else{
        right = mid;
    }
    //或者
    if(判断条件1){
        right = mid - 1;
    }else{
        left = mid;
    }
}
//在while结束后，对left处的值选择性进行判断
//多种输出可能
return left;
return arr[left];
return -1;
~~~

此题具体的实现代码如下

~~~java
//使用二分的思路
    public static Integer findNum2(int[] arr){
        if (arr == null || arr.length < 2)
            return null;
        //看是否在0-n-1范围之内
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] < 0 || arr[i] > arr.length-1)
                return null;
        }
        //二分，看哪边的数字更多，再继续找
        int left = 1, right = arr.length - 1;
        while (left < right){
            int mid = left + ((right-left) >> 1);
            //计算个数
            int count = getFre(arr,left,mid);
            if (count > mid + 1 - left){
                right = mid;
            }else {
                //去另一半
                left = mid+1;
            }
        }
        int count = getFre(arr,left,right);
        if (count > 1)
            return left;
        //没有找到
        return -1;
    }
    //统计在l-m之间出现的次数
    private static int getFre(int[] arr, int l, int m) {
        int count = 0;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] >= l && arr[i] <= m){
                count++;
            }
        }
        return count;
    }
~~~

### 矩阵中的路径【回溯】

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。

思路：回溯的经典案例。如果当前字符可以，则看其上下左右的是否符合，不进入已经去过的位置，如果匹配长度为字符串的长度，返回真，不然的话就返回假，并重置当前所做的操作。

关键在于要维护一个与矩阵大小相同的布尔型矩阵，表示当前字符是否已经遍历过，如果遍历过了则不进入，如果当前字符与要遍历的第i个字符相等，则将布尔型的矩阵相对应位置置为true，再看其上下左右的，如果失败了，则让当前位置的标志重置为false。

容易错的点为，base case判断不完全，应该有

1. 当前遍历到的(i,j)在矩阵范围内
2. 当前位置的字符与第k个字符相等
3. 当前位置没有进来过

同时需要注意的是一维到二维的映射关系，应该是第i行*列数+当前列j。

最后成功的base case条件为已经将所有的字符都判断完毕了，需要传递给下一级递归函数一个int变量。

递归函数实现的功能为，判断当前字符周围的字符是否可以找到所给的字符串。需要传递的参数有基本的矩阵的参数等，以及下一次寻找的起始位置(i,j)，下一次遍历的字符串位置len。为了不让重复的字符遍历到，当遍历一个字符后，需要将其标志变量置为true，这样下一次不会再遍历。同时回溯为了消除下一次的影响，需要将标志位重置。

回溯的小总结

1. 利用递归来处理子问题
2. base case（递归终止条件，包括失败与成功条件）
3. 改变当前位置状态，进行子问题的递归
4. 子问题递归失败，重置当前状态

~~~java
public static boolean hasPath(char[] matrix, int rows, int cols, char[] str) {
        //如果数据不相符，直接返回假
        if (matrix == null || str == null || matrix.length != rows * cols || str.length < 1)
            return false;
        //新建一个判断矩阵
        boolean[] isIn = new boolean[rows * cols];
        for (int i = 0; i < isIn.length; i++) {
            isIn[i] = false;
        }
        //用来检测现在判断字符串长度的变量
        int len = 0;
        //对每一个数都进行判断
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                //如果当前字符开头的数组可以，则返回真
                if (process(matrix, rows, cols, str, isIn, i, j, len)){
                    return true;
                }
            }
        }
        return false;
    }

    private static boolean process(char[] matrix, int rows, int cols, char[] str, boolean[] isIn, int i, int j, int len) {
        //一维映射到二维，很重要
        int index = i * cols + j;
        //base case
        //如果当前数据不再矩阵范围内，直接返回假
        //如果已经进入了当前位置，返回假
        //当前位置的数和str第len个字符不等
        if (i < 0 || i >= rows || j < 0 || j >= cols || matrix[index] != str[len] || isIn[index])
            return false;
        //如果已经将数字找完了，返回真
        if (len == str.length - 1)
            return true;
        //当前数字进入过了
        isIn[index] = true;
        //看当前数字的上下左右是否符合
        if (process(matrix,rows,cols,str,isIn,i-1,j,len+1)
        || process(matrix,rows,cols,str,isIn,i+1,j,len+1)
        || process(matrix,rows,cols,str,isIn,i,j-1,len+1)
        || process(matrix,rows,cols,str,isIn,i,j+1,len+1)){
            return true;
        }
        //还原当前状态
        isIn[index] = false;
        return false;
    }
~~~

### 机器人的行走路径

描述：地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？

思路：回溯法，从当前格子开始走，需要维护一个是否走过的矩阵。在递归中，如果超出范围，已经走过了，当前位置不适合，返回0，然后计算四个方向能走的个数+当前走的1步，进行返回。注意的是：因为之前的矩阵中的路径，当前位置走的路径是对其他位置开始的路径没有影响的，因此需要回溯消除当前影响，而这里因为走的位置不能重复，因此之前走的对其他步是有影响的，不能消除影响。

~~~java
public int movingCount(int threshold, int rows, int cols) {
        //基础判断
        if(rows <= 0 || cols <= 0 || threshold < 0)
            return 0;
        //准备是否进入的矩阵
        boolean[]  f = new boolean[rows * cols];
        for (int i = 0; i < f.length; i++) {
            f[i] = false;
        }
        int count = getCount(threshold,rows,cols,0,0,f);
        return count;
    }
    private int getCount(int threshold, int rows, int cols, int i, int j, boolean[] f) {
        int index = i * cols + j;
        //如果超出范围，已经进来过，得到的数不符合，返回0
        if (i < 0 || i >= rows || j < 0 || j >= cols || f[index] || getAllNum(i) + getAllNum(j) > threshold)
            return 0;
        //当前数字进来过了
        f[index] = true;
        //总的计数+1，返回其他四个方向的
        //因为这个路径走过的，其他也不能走，因此不用重置f的状态
        return 1 + getCount(threshold,rows,cols,i - 1,j,f)
                + getCount(threshold,rows,cols,i + 1,j,f)
                + getCount(threshold,rows,cols,i,j - 1,f)
                + getCount(threshold,rows,cols,i,j + 1,f);
    }
    private int getAllNum(int i) {
        //得到所有位数之和
        int sum = 0;
        while (i > 0){
            sum += i % 10;
            i = i / 10;
        }
        return sum;
    }
~~~

总结：对于矩阵上路径的遍历或者人物的行走，非常适合用回溯算法。

### 调整数组顺序使奇数位于偶数前面

题目1：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

思路：典型的partition过程。但没法保证相对位置不变。

~~~java
    //奇数放前面，偶数放后面，典型的partition问题
    //但是这样不能保证相对位置不变
    public void reOrderArray(int [] arr) {
        int less = -1;
        int more = arr.length;
        int cur = 0;
        while (cur < more){
            if ((arr[cur] & 1) != 0){
                swap(arr,++less,cur++);
            }else {
                swap(arr,--more,cur);
            }
        }
    }
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
~~~

题目2：

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

思路：找到第一个为偶数的数字，在其之后找到第一个为奇数的数字，让中间数字整体后移，空出来的原来偶数的位置放奇数。

~~~java
//保证数组元素是相对有序的
    public void reOrderArray2(int [] arr) {
        if (arr == null || arr.length < 2)
            return;
        //遍历数组，找到一个为偶数的，再找到后面为奇数的，将偶数-奇数段整体后移，空出来的放奇数
        int i = 0, j = 0;
        while (i < arr.length){
            //为奇数，则继续找
            while (!isEven(arr[i])){
                i++;
            }
            //从i+1开始找，为偶数继续找
            j = i + 1;
            while (j < arr.length && isEven(arr[j])){
                j++;
            }
            //如果j还在范围内，交换i+1-j-1之间的数
            if (j < arr.length){
                int temp = arr[j];
                for (int k = j-1; k >= i; k--) {
                    arr[k+1] = arr[k];
                }
                arr[i] = temp;
            }else {
                //超出了就结束
                break;
            }
        }
    }
~~~

## 栈

### 栈的压入、弹出序列

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1、2、3、4、5是某栈的压栈序列，序列4、5、3、2、1是该压栈序列对应的一个弹出序列，但4、3、5、1、2就不可能是该压栈序列的弹出序列。

思路：准备一个栈，两个指针，i指向数组1，j指向数组2，循环条件为i没有越界或栈不为空（i越界后 ，有可能j还可以往后继续判断），如果栈为空且栈顶元素与j位置不同，若i越界了，返回假，不然将i位置元素压入栈，i后移。如果栈顶元素与j位置相同，弹出栈顶元素，j后移。循环结束后，如果i与j都越界，说明是符合的，不然就返回假。

~~~java
public boolean isPopOrder(int [] pushA,int [] popA) {
        //base
        if (pushA == null || popA == null || pushA.length != popA.length)
            return false;
        //准备栈
        Stack<Integer> stack = new Stack<>();
        int i = 0, j = 0;
        while (i < pushA.length || !stack.isEmpty()){
            //如果栈为空或栈顶元素不为popA[j]，将pushA[i]压入栈
            if (stack.isEmpty() || stack.peek() != popA[j]){
                if (i == pushA.length)
                    return false;
                stack.push(pushA[i++]);
            }else {
                stack.pop();
                j++;
            }
        }
        if (i == pushA.length && j == i){
            return true;
        }else {
            return false;
        }
    }
~~~

## 字符串

### 替换空格

请实现一个函数，把字符串中的每个空格替换成“%20”，如输入“We are happy”，则输出“We%are%happy”

方法：先统计传入的字符串str中空格的个数，然后建造一个新的字符数组，其长度为str非空格字符长度+空格个数*待替换字符串长度，然后用两个指针，一个遍历str，一个指向新的字符数组末尾，如果str当前不为空格，直接复制到新数组，新数组指针移动；如果str当前为空格，新数组从后逐个拷贝传入的字符串，直到遍历完str。

其中要注意的是新数组长度，需要先将原数组长度减去空格，再加上空格长度乘待替换字符串长度。如果不减去空格长度，新数组前面会有空余。如果没有空格，直接返回输入字符串即可

~~~java
 //不用系统的split方法，先统计插入后的字符个数，再从最后一个开始插入
    public static String replaceBlank2(String str, String s){
        //统计str空格数量及s长度
        int spCount = 0;
        int sSize = s.length();
        //统计str中空格个数
        for (int i = 0; i < str.length(); i++) {
            if (' '==str.charAt(i)){
                spCount++;
            }
        }
        if (spCount == 0)
            return str;
        //非空格字符数+替换后的字符数
        int newSize = str.length() - spCount + spCount * sSize;
        char[] res = new char[newSize];
        //两个指针，一个指向strArr，一个指向res
        int p1 = str.length() - 1;
        int p2 = res.length - 1;
        for (; p1 >= 0; p1--) {
            char c = str.charAt(p1);
            if (' ' != c){
                //当前不为空格，直接复制
                res[p2--] = c;
            }else {
                //如果为空格，p2拷贝s
                for (int i = sSize - 1; i >= 0; i--) {
                    res[p2--] = s.charAt(i);
                }
            }
        }
        return new String(res);
    }
~~~

### 打印1到最大的n位数

输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。

思路：此题看上去很简单，其实真正的考点是大数问题，如超出了int和long类型长度的数字，这时候可以用字符串来手动模拟自增的过程，那么可以将这个问题进行拆解，一是字符串自增，二是打印字符串。

对于字符串自增，开辟长度为n的char数组，初始全部填充0，从最后位遍历到第一位。当前位的值是数组值-‘0’+进位，然后如果是最后一位自增+1模拟每次自增，然后判断当前位是否为10，如果当前位是第一位，说明到头了，可以返回真，如果不是，将当前位变成0，进位变成1。如果当前位小于10，说明没有进位，赋值后直接返回即可。

对于打印矩阵，找到第一个不是0的位置，然后将后面的数字全部打印即可。

~~~java
 	//打印从1-n所有的数
    public static void print1ToMaxOfNDigits(int n){
        if (n <= 0)
            return;
        char[] ch = new char[n];
        for (int i = 0; i < ch.length; i++) {
            ch[i] = '0';
        }
        //只要第一位没有进位，就继续
        while (!increacement(ch)){
            //打印矩阵
            printNum(ch);
        }
    }

    private static void printNum(char[] ch) {
        //如果当前位数不为0，就加入
        int n = 0;
        while (n < ch.length){
            if (ch[n] == '0'){
                n++;
            }else {
                break;
            }
        }
        for (int i = n; i < ch.length; i++) {
            System.out.print(ch[i]);
        }
        System.out.println();
    }

    private static boolean increacement(char[] ch) {
        //从最后一位开始，模拟自增
        int len = ch.length - 1;
        int sum = 0;//当前位数的和
        int addNum = 0;
        for (int i = len; i >= 0; i--) {
            //当前位加上进位
            sum = ch[i] - '0' + addNum;
            //如果是最低位，加一
            if (i == len){
                sum++;
            }
            //如果sum为10了，看是不是第一位，是的话返回true
            if (sum == 10){
                if (i == 0){
                    return true;
                }else {
                    //不是，需要当前位改成0，进位
                    sum = 0;
                    ch[i] = (char)(sum + '0');
                    addNum = 1;
                }
            }else {
                //没有进位，直接返回
                ch[i] = (char)(sum + '0');
                break;
            }
        }
        return false;
    }
~~~

### 字符串全部子序列

打印一个字符串的全部子序列，包括空字符串。子串是连在一起的，子序列中的字符在字符串中不一定是连在一起的。

思路：初始为一个空字符串，遍历每一个字符，可以选择要当前的字符或者不要，然后递归子字符串。最后输出的就是全部的子序列。

~~~java
	public static void printAllSebSeq(String str){
        if (str == null)
            System.out.println("");
        allSubSequence(str.toCharArray(),0,"");
    }

    private static void allSubSequence(char[] ch, int i, String s) {
        //base case
        if (i == ch.length){
            System.out.println(s);
            return;
        }
        //选择而要当前子串与不要
        allSubSequence(ch,i+1,s);
        allSubSequence(ch,i+1,s+ch[i]);
        return;
    }
~~~

### 打印字符串的全排列

打印一个字符串的全排列，如字符串123，有6种全排列，打印出来。

思路：递归。将所有的字符依次与第一个交换，然后递归变化交换后的子串。递归结束后，将字符交换回来，即回溯不影响下一次的结果。base case为没有子串为止，输出字符串。为了在遍历字符串进行交换的时候，不对重复的字符做操作，在每轮交换前定义一个set，只有没有出现过的字符才进行操作。

~~~java
	//字符串的全排列
    public static void printAllPermutations(String str) {
        if (str == null){
            System.out.println("");
            return;
        }
        process(str.toCharArray(),0);
    }
    //作用，打印出字符串的全排列
    private static void process(char[] ch, int i) {
        //base case
        if (i == ch.length){
            System.out.println(String.valueOf(ch));
            return;
        }
        HashSet<Character> set = new HashSet<>();
        //将当前字符与后面每一个交换，然后递归子串
        for (int j = i; j < ch.length; j++) {
            if (!set.contains(ch[j])){
                set.add(ch[j]);
                swap(ch,i,j);
                //处理子串
                process(ch,i+1);
                //回溯，交换回来
                swap(ch,i,j);
            }
        }
    }
    private static void swap(char[] ch, int i, int j) {
        char temp = ch[i];
        ch[i] = ch[j];
        ch[j] = temp;
    }
~~~

## 链表

### 反向打印链表

输入一个链表的头节点，从尾到头反过来打印出每个节点的值。

方法1：遍历链表，将值存入栈。遍历栈，弹出值。

~~~java
    //反向打印链表
    public static String reversePrint(Node node){
        if (node == null)
            return null;
        StringBuilder sb = new StringBuilder();
        Stack<Integer> stack = new Stack<>();
        while (node != null){
            stack.push(node.value);
            node = node.next;
        }
        while (!stack.isEmpty()){
            sb.append(stack.pop()).append(" ");
        }
        return sb.toString();
    }
~~~

方法2：既然有用到栈 ，那么也可以用递归来实现，递归函数的功能是打印此节点后面的节点。基本过程是调用递归函数，然后打印当前节点。

~~~java
    //既然有用到栈，那么就可以用递归来实现，先打印后面的，然后打印当前的
    public static String reversePrint2(Node node){
        if (node == null)
            return null;
        StringBuilder sb = new StringBuilder();
        process(node,sb);
        return sb.toString();
    }
    private static void process(Node node, StringBuilder sb) {
        //递归来实现
        //base case
        if (node == null){
            return;
        }
        //递归后面的节点
        process(node.next,sb);
        //打印当前节点
        sb.append(node.value).append(" ");
    }
~~~

### 删除链表中重复的节点

题目1：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5

思路：链表删除的，如果头节点不好处理，就新建一个，设立两个指针，一个指向上一个不重复的节点pre，一个指向当前的节点cur，遍历链表，如果当前节点下一个节点的值和当前节点相同，移动cur，直到cur到末尾或者cur指向最后一个相同的节点，让pre的下一个指向cur.next，这样可以将重复的节点全部删除，然后cur再到下一个。注意，此时pre不能移动，因为不能确定cur的下一个与下下个是否相同，如果pre直接移动，遇到1->2->2->3->3这种，虽然两个2被跳过了，但是后面的3会被包含进去。只有在确定了cur与cur.next值不同，pre才移动，cur也移动。

~~~java
public Node deleteDuplication(Node head){
        //基本判断
        if(head == null || head.next == null)
            return head;
        //在现在头节点前造一个
        Node newHead = new Node(0);
        newHead.next = head;
        Node pre = newHead;//一个不重复的节点
        Node cur = head;//当前节点
        //遍历链表
        while (cur != null){
            //如果下一个不为空且值跟当前相同，往后走
            if (cur.next != null && cur.next.value == cur.value){
                //让cur走到最后一个不重复的节点处
                while (cur.next != null && cur.next.value == cur.value){
                    cur = cur.next;
                }
                //若重复节点一个不要，让pre下一个指向cur.next
                //pre不能前进，防止后面还有重复的，只有没有重复的pre才走
                pre.next = cur.next;
                cur = cur.next;
            }else {
                //没有重复，正常走
                pre = pre.next;
                cur = cur.next;
            }
        }
        Node res = newHead.next;
        newHead = null;
        return res;
    }
~~~

题目2：删除链表中的重复节点，如给定1->2->2->3->3，返回1->2->3。

思路：比上一题简单，比如直观的做法是，让一个pre指针指向第一个，cur指针指向第二个，如果当前值与pre相等，删除当前节点。相同点是，删除节点的时候，pre均不移动。

~~~java
//这样更简单，只需要判断当前节点与前一个节点值是否相等，相等则删除
    public Node deleteDuplicates(Node head) {
        if(head == null || head.next == null)
            return head;
        Node pre = head;
        Node cur = head.next;
        Node next = null;
        while(cur != null){
            next = cur.next;
            //如果当前的值等于前一个节点，删除
            if(cur.value == pre.value){
                pre.next = cur.next;
                cur = cur.next;
            }else{
                //正常走
                pre = pre.next;
                cur = cur.next;
            }
        }
        return head;
    }
~~~

### 链表倒数第k个节点

题目1：找到链表倒数第k个节点

输入一个链表，输出该链表中倒数第k个结点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾结点是倒数第1个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个结点是值为4的结点。

思路：比较简单的做法是两次遍历，先知道链表长度n为多少，然后找到正着第n-k+1个节点即可，但是可以只用一次遍历来完成。用两个指针，指针1先走k-1步，然后让指针2与1一起走，当走到链表末尾时，便走到了倒数第k个节点。原因是1走到末尾，2为了是倒数第k个，与1之间的距离是k-1。需要注意的是要对k和链表head做判断，如果k<=0或者head为空，直接返回空，如果指针1还没走到k-1步就到了末尾，也返回空。

~~~java
    public Node findKthToTail(Node head,int k) {
        //基础判断，k不大于0或者头节点为空，返回空
        if(k <= 0 || head == null)
            return null;
        //增加一个头节点
        //两个指针，让一个指针先走k-1步
        Node pre = head, cur = head;
        k = k - 1;
        while (k > 0 && cur.next != null){
            cur = cur.next;
            k--;
        }
        //k比链表长，返回空
        if(k != 0)
            return null;
        //让两个链表一起走
        while (cur.next != null){
            cur = cur.next;
            pre = pre.next;
        }
        return pre;
    }
~~~

题目2：删除链表倒数第k个节点

思路：如果涉及到删除操作，因为可能删除的是头节点，因此自己造一个新的头节点会比较方便，让指针1,2都从新的头节点出发，让指针1先走k步，然后1与2一起走，当指针1走到链表末尾，2走到倒数第k+1个节点，然后执行删除操作即可。

~~~java
    //删除链表末尾的第k个节点
    public Node deleteKthToTail(Node head,int k) {
        //基础判断
        if(k <= 0 || head == null)
            return head;
        //增加一个头节点
        Node newHead = new Node(0);
        newHead.next = head;
        //两个指针，让一个指针先走k步
        Node pre = newHead, cur = newHead;
        while (k > 0 && cur.next != null){
            cur = cur.next;
            k--;
        }
        //k比链表长，返回空
        if(k != 0)
            return head;
        //让两个链表一起走
        while (cur.next != null){
            cur = cur.next;
            pre = pre.next;
        }
        //删除pre后一个节点
        pre.next = pre.next.next;
        head = newHead.next;
        newHead = null;
        return head;
    }
~~~

## 树

### 树的重构

根据先序和中序数组来重构一棵二叉树

思路：先序数组中，第一个值为头节点，从中序中找到与头节点相同的下标，构造头节点，然后拷贝数组，构造左子树，拷贝数组构造右子树，递归完成。

~~~java
//根据前序和中序构建二叉树
    public static Node reConstructBinaryTree(int[] arrPre, int[] arrIn){
        //如果两个长度不等或为空，直接返回
        if (arrPre.length != arrIn.length || arrPre.length < 1)
            return null;
        //base case
        if (arrPre.length == 1)
            return new Node(arrPre[0]);
        //在arrIn中找到与arrPre[0]相等的头节点
        int index = -1;
        for (int i = 0; i <arrIn.length; i++) {
            if (arrIn[i] == arrPre[0]){
                index = i;
                break;
            }
        }
        //没找到头节点，返回
        if (index == -1)
            return null;
        //构造头节点
        Node head = new Node(arrPre[0]);
        //左子树前序遍历
        int[] lPreChild = new int[index];
        System.arraycopy(arrPre,1,lPreChild,0,index);
        //左子树中序遍历
        int[] lInChild = new int[index];
        System.arraycopy(arrIn,0,lInChild,0,index);
        head.left = reConstructBinaryTree(lPreChild,lInChild);
        //右子树前序遍历
        int[] rPreChild = new int[arrPre.length-index-1];
        System.arraycopy(arrPre,index+1,rPreChild,0,rPreChild.length);
        //右子树中序遍历
        int[] rInChild = new int[rPreChild.length];
        System.arraycopy(arrIn,index+1,rInChild,0,rPreChild.length);
        head.right = reConstructBinaryTree(rPreChild,rInChild);
        return head;
    }
~~~

### 树的子结构

输入两棵二叉树A和B，判断B是不是A的子结构。

思路：遍历树A，找到与B相同值的节点。判断两个子树是否有一样的结构。递归的解法为：判断A树，A树的左子树，A树的右子树是否与B数结构相同。判断函数为：如果B树为空了，说明结构相同；如果A树空了，B树不空，肯定不同；如果当前节点的值不同，肯定不同；再判断左右子树是否相同。

~~~java
	//看一个树是不是另外一个树的子树
    public boolean HasSubtree(Node root1, Node root2) {
        //层序遍历root1，找到与root2头节点相同的节点
        //判断两个树是否相同
        if(root1 == null || root2 == null)
            return false;
        //看当前节点是否相同或者左子树或者右子树
        return isSameTree(root1,root2) || isSameTree(root1.left,root2)
                || isSameTree(root1.right,root2);
    }

    private boolean isSameTree(Node root1, Node root2) {
        //判断两个树是否相同
        //base case
        //如果root2为空，说明是真
        if (root2 == null)
            return true;
        //如果root1为空，且右子树不为空，说明是假
        if (root1 == null)
            return false;
        //判断当前
        if (root1.value != root2.value)
            return false;
        //判断左，右子树
        return isSameTree(root1.left,root2.left) && isSameTree(root1.right,root2.right);
    }
~~~

### 二叉树的镜像

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

思路：递归完成。如果树为空，返回；如果树的左右子树均为空，返回，否则交换左右子树；对左右子树进行同样操作。

~~~java
    //得到一个二叉树的镜像
    public void Mirror(Node root) {
        //base case
        if (root == null)
            return;
        //交换左右子树
        if (root.left == null && root.right == null)
            return;
        Node temp = root.left;
        root.left = root.right;
        root.right = temp;
        //递归左右子树
        Mirror(root.left);
        Mirror(root.right);
    }
~~~

### 对称的二叉树

请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

思路：比较这棵树与自己是否为镜像。递归解决，如果两个有一个为空，若是均为空，说明为真，若一个为空，另一个不为空，说明肯定不对称。判断当前节点值是否相同。判断root的左子树与root的右子树是否对称，判断root的右子树与root的左子树是否对称。

~~~java
	//判断一个树是否对称
    //可以判断两棵树是否为镜像树
    boolean isSymmetrical(Node root) {
        if (root == null)
            return true;
        //调用递归子函数
        return isSubSym(root,root);
    }

    private boolean isSubSym(Node root1, Node root2) {
        //base case
        if (root1 == null || root2 == null){
            if (root1 == null && root2 == null)
                return true;
            //一个为空，一个不是，返回假
            else
                return false;
        }
        //判断当前节点是否相同
        if (root1.value != root2.value)
            return false;
        //判断当前树的左子树与镜像的右子树
        return isSubSym(root1.left,root2.right) && isSubSym(root1.right,root2.left);
    }
~~~

### 从上往下打印二叉树

普通的就是层序遍历，有意思点的是从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。

思路：大体仍是层序遍历，但是需要一下子将同一层的全部加入或打印，这样就需要统计一层的节点个数，初始一层为1个，将每层的左右节点全部加入，统计当层的个数，然后更新下一层的个数。

~~~java
//按层打印，一层为一行
    ArrayList<ArrayList<Integer>> print(Node root) {
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        if (root == null)
            return res;
        ArrayList<Integer> list = null;
        int pre = 0, cur = 1;
        Queue<Node> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()){
            //不一下子只弹出一个，而是弹出上一层的个数
            list = new ArrayList<>();
            //更新当前个数，作为下一次的pre
            pre = 0;
            for (int i = 0; i < cur; i++) {
                root = queue.poll();
                list.add(root.value);
                if (root.left != null){
                    queue.offer(root.left);
                    pre++;
                }
                if (root.right != null){
                    queue.offer(root.right);
                    pre++;
                }
            }
            //循环完后，将一层结果加入，更新cur
            res.add(list);
            cur = pre;
        }
        return res;
    }
~~~

### 之字型打印二叉树

请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

思路：在之前从上往下打印的基础上增加了顺序判断，正常为从左到右打印，从右到左相当于是从左到右入栈的结果，因此在之前的基础上，加入判断即可，如果需要从右到左输出，加入栈中。然后将栈中元素全部添加至list中。

~~~java
	//按照之字型打印树
    public static ArrayList<ArrayList<Integer>> printZhiTree(Node root){
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        if (root == null)
            return res;
        //广度优先遍历
        Queue<Node> queue = new LinkedList<>();
        queue.offer(root);
        boolean flagZhi = true;
        int pre = 0, cur = 1;
        Stack<Integer> stack = new Stack<>();
        while (!queue.isEmpty()){
            //当层元素
            ArrayList<Integer> list = new ArrayList<>();
            pre = 0;
            for (int i = 0; i < cur; i++) {
                //弹出元素
                //如果是true，直接加入list
                //如果是false，加入栈
                root = queue.poll();
                if (flagZhi){
                    list.add(root.value);
                }else {
                    stack.add(root.value);
                }
                if (root.left != null) {
                    queue.offer(root.left);
                    pre++;
                }
                if (root.right != null) {
                    queue.offer(root.right);
                    pre++;
                }
            }
            //将栈中或队列中元素信息取出
            if (!flagZhi){
                while (!stack.isEmpty()){
                    list.add(stack.pop());
                }
            }
            //更新一层信息
            res.add(list);
            cur = pre;
            flagZhi = !flagZhi;
        }
        return res;
    }
~~~

## 二分

### 找旋转数组的最小值

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

思路：先判断，如果最左边数比最右边树小，那么最左边的是最小的。如果最左边的与中间和最右边数相等，那么没法二分，只能顺序查找。

用二分模板，左边指向左侧升序数组，右边指向右侧升序数组，当左右相邻，说明左边到了升序数组末尾，右边到了右边升序数组的开头，这样右边的数为最小数。不然，当左边数比中间数小，说明左边为升序，那么将左边移动到中间；否则将右边移动到中间。判断依据是，在旋转数组中，最小的数一定不是出现在升序数组中。

~~~java
    public static int minNumberInRotatedArray(int[] arr){
        //错误情况
        if (arr == null || arr.length < 1)
            return 0;
        if (arr.length == 1)
            return arr[0];
        int l = 0, r = arr.length - 1;
        int mid = l + (r - l) / 2;
        //如果为顺序，返回第一个
        if (arr[l] < arr[r])
            return arr[l];
        //如果三个相等，顺序查找
        if (arr[l] == arr[mid] && arr[mid] == arr[r]){
            for (int i = l+1; i <= r; i++) {
                if (arr[i] < arr[i-1])
                    return arr[i];
            }
            return arr[l];
        }
        //二分模板
        while (l < r){
            //base case
            //r为右边的递增数组开头，l为左边递增数组末尾
            if (r - l == 1)
                return arr[r];
            mid = l + (r - l) / 2;
            //若左边有序，往右边找
            if (arr[l] <= arr[mid]){
                l = mid;
            }else {
                r = mid;
            }
        }
        return arr[l];
    }
~~~

## 动态规划

### 剪绳子

描述：给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n>1并且m>1），每段绳子的长度记为k[0],k[1],...,k[m]。请问k[0]xk[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

思路：如果长度小于等于3的，必须要切，单独给出结果，如果长度为4的，可以切成1,3，也可以切成2,2，这样得到的递归公式为f(n)=max(f(i)*f(n-i))，拆分为小问题解决。

~~~java
public int cutRope(int target) {
        //数据不和规格的情况
        if (target < 0)
            return 0;
        //如果是1-3的情况，只能再分，对应的数字较小
        if (target <= 2)
            return 1;
        if (target == 3)
            return 2;
        //如果是大于3的情况，1，2,3可以不用再分，这时候值会更大
        int[] dp = new int[target+1];
        dp[1] = 1;
        dp[2] = 2;
        dp[3] = 3;
        for (int i = 4; i <= target; i++) {
            int res = 0;
            for (int j = 1; j <= i / 2; j++) {
                res = Math.max(res,dp[j] * dp[i - j]);
            }
            dp[i] = res;
        }
        return dp[target];
    }
~~~

## 二进制

二进制的用法：

&：

- 将所有位清零 n & 0
- 取指定位置上的数，如取二进制的后四位，n & 00001111

|：

- 将某些位数置为1：n | 00001111

^

- 将某些位置取反：n ^ 00001111，将后四位取反
- 保留原值：n ^ 0
- 交换两个数：`a=a^b;b=a^b;a=a^b`，完成a与b的交换

### 1的个数

输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

如9的二进制为1001，得到的输出为2.

方法一：逐位相与。一个数为1的地方，与1与不为0，统计这个数每个位都与1相与，不为0的次数即可。有两种选择，一种是右移这个数，一种是左移1。如果是右移这个数，需要使用无符号位右移，因为如果是带符号的，对于负数会有死循环。而左移1，需要进行32次判断。

需要注意的是n&1结果不为0，进行统计。

~~~java
    //将要计算的数右移
	public static int NumberOf1_Solution1(int n) {
        int count = 0;
        while (n != 0){
            if ((n & 1) != 0)
                ++count;
            n = n >>> 1;
        }
        return count;
    }
	//将1左移
    //看有多少个1，可以每一位与1相与，然后统计
    public static int NumberOf1_Solution2(int n) {
        int count = 0;
        int flag = 1;
        //计算32次
        while (flag != 0){
            if ((n & flag) != 0)
                ++count;
            flag = flag << 1;
        }
        return count;
    }
~~~

方法二：将当前数与减去1后的数相与，得到的数会将最右侧的1变为0，这样有几个1进行几次操作，最后会得到0。

~~~java
    public static int NumberOf1_Solution3(int n) {
        //将一个数和其减一后的数相与，会把最右边为1的数后均变为0
        //有几个1，进行几次这样的操作
        int count = 0;
        while (n != 0){
            ++count;
            n = n & (n-1);
        }
        return count;
    }
~~~

扩展：用一条语句判断整数是不是2的整数次方，如果是，则只有一个数为1，那么将其与减去1的数相与，如果得到0，说明只有一个1。

输入两个数m与n，统计需要改变m的二进制中多少个数才能得到n

- 得到m与n的异或，不同的位置为1
- 统计1的个数

## 数学

### 数值的整数次方

实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。

思路：需要考虑指数为整数，负数，及0的情况，同时要区分下base是不是0。0的负数次方是没有意义的。

求指数的时候，可以用递归的方式，如果是偶数，`f(n)=f(n/2)*f(n/2)`，如果是奇数，`f(n)=f(n-1)/2*f(n-1)/2*base`。

~~~java
    //自定义power函数
    public double power(double base, int exponent) {
        double res = 0;
        //分三种情况，指数大于0，小于0，等于0的情况
        if (exponent > 0){
            //大于0正常计算
            res = getPower(base,exponent);
        }else if (exponent < 0){
            //小于0，看是否为0,
            if (base == 0){
                //0的负数次方没有意义
                return 0;
            }else {
                res = 1 / getPower(base,-exponent);
            }
        }else {
            //指数为0，返回1
            res = 1;
        }
        return res;
    }
    private double getPower(double base, int exponent) {
        //递归解决
        if (exponent == 0)
            return 1;
        if (exponent == 1)
            return base;
        double res = getPower(base,exponent >> 1);
        res *= res;
        //如果是奇数，再乘上base
        if ((exponent & 1) == 1)
            res *= base;
        return res;
    }
~~~

# leetcode

## 栈

### 有效的括号

题目描述：给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

注意空字符串可被认为是有效字符串。

思路：先将左右括号的对应关系放入一个map中，然后如果是左括号，放入栈中；如果是右括号，若栈为空，则返回假，若不为空，弹出一个元素，如果在map中弹出元素对应的括号与当前括号不同，则返回假。遍历完字符串后，若栈不为空，返回假，否则返回真。

~~~java
public boolean isValid(String s) {
        //准备一个栈和一个哈希表
        HashMap<Character,Character> map = new HashMap<>();
        map.put('(',')');
        map.put('[',']');
        map.put('{','}');
        Stack<Character> stack = new Stack<>();
        for(Character c : s.toCharArray()){
            //如果是左括号，压入栈
            if(map.containsKey(c)){
                stack.push(c);
            }else{
                //不存在，先判断栈是否为空
                if(stack.isEmpty())
                    return false;
                //如果不符合，直接返回
                if(map.get(stack.pop()) != c)
                    return false;
            }
        }
        return stack.isEmpty() ? true : false;
    }
~~~

## 字符串

### 无重复字符的最长子串

描述：给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 :**

```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

方法：滑动窗口

因为要求不能重复，因此想到可以用哈希表跟双指针来维护一个窗口，如果右边的元素跟窗口内元素不重复，移动窗口，并更新最大窗口值；如果右边的元素重复了，则将窗口往左滑动，直到没有重复的。

精髓在于双指针跟哈希表。

~~~java
    public static int lengthOfLongestSubstring(String str){
        int l = 0, r = 0;
        int ans = 0;
        Set<Character> set = new HashSet<>();
        while (r < str.length()){
            //如果没有进来过，移动右窗口
            if (!set.contains(str.charAt(r))){
                set.add(str.charAt(r++));
                //更新结果
                ans = Math.max(ans,r-l);
            }else {
                //如果包含了，则缩小窗口
                set.remove(str.charAt(l++));
            }
        }
        return ans;
    }
~~~

### 最长回文子串

给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。

字符串这种要输出最大长度的子串的，可以用**子串长度**及**开始位置**来确定其子串。

方法一：中间扩散法

遍历字符串，找到其最左边的与当前位置相同的位置，找到最右边与中间位置相同的位置，然后两边指针左右的字符如果相等，指针分别左右移动，统计两个指针夹住的最大长度及起始位置即可。

~~~java
	//中心扩散法
    //先找到最左跟最右的，然后向两端开始比较
    public static String longestPalindrome1(String s) {
        if(s == null || s.length() < 2)
            return s;
        //最大数，默认第一个为最大的
        int maxNum = 1;
        //可以不用哈希表，记录起始位置就可以
        int start = 0;
        //两个指针
        int p1 = 0, p2 = 0;
        //循环去找
        for (int i = 0; i < s.length(); i++) {
            //找出最左的
            p1 = i;
            while (p1 >= 1 && s.charAt(p1-1) == s.charAt(p1)){
                //记录开始位置
                p1--;
            }
            //找到最右的
            p2 = i;
            while (p2 < s.length() - 1 && s.charAt(p2+1) == s.charAt(p2)){
                //记录开始位置
                p2++;
            }
            //向两边扩展
            while(p1 >= 1 && p2 < s.length() - 1 && s.charAt(p1-1) == s.charAt(p2+1)){
                p1--;
                p2++;
            }
            //p1-p2为回文子串的长度
            if(maxNum < p2 - p1 + 1){
                maxNum = p2 - p1 + 1;
                start = p1;
            }
            //更新i
        }
        //取出最大长度对应的子串
        return s.substring(start,start+maxNum);
    }
~~~

方法二：动态规划法

用二维数组统计哪些角标处的是回文子串，如`dp[2][0]`代表0-2角标处的是回文子串，用两个指针遍历，一个从1开始往后，第二个从0开始到第一个指针，如果第二个指针与第一个指针处字符相等，如果角标差小于等于2，说明子串长度在3以内，不用判断dp数组，不然就需要`dp[i-1][j+1]`之间为真，即其子串是回文的。然后统计长度及起始信息即可。

~~~java
//dp
    //如果某两个角标之间的已经是回文的了，那么可以不用寻找
    public static String longestPalindrome4(String s) {
        if(s == null || s.length() < 2)
            return s;
        int maxNum = 1;
        //可以不用哈希表，记录起始位置就可以
        int start = 0;
        boolean[][] dp = new boolean[s.length()][s.length()];
        //统计j-i之间的情况
        for (int i = 1; i < s.length(); i++) {
            for (int j = 0; j < i; j++) {
                //如果相等，且之间距离在2之间（3个以内），或j+1-i-1为回文，计算
                if (s.charAt(j) == s.charAt(i) && (i-j<=2 || dp[i-1][j+1])){
                    //更改dp状态
                    dp[i][j] = true;
                    //统计信息
                    if (maxNum < i-j+1){
                        maxNum = i-j+1;
                        start = j;
                    }
                }
            }
        }
        return s.substring(start,start+maxNum);
    }
~~~

## 链表

### LRU缓存机制

运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。

获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。
写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。时间复杂度O(1)。

思路：这种数据结构要求的特点是插入删除快，获取快。获取时间复杂度O(1)，想到哈希表，但是哈希表是无序的，没办法做到找到最近操作的数。为了让插入删除快，想到链表。因此将二者结合，便想到了LinkedHashMap，先自己造轮子，代码思路来自于[leetcode评论区解法](https://leetcode-cn.com/problems/lru-cache/solution/lru-ce-lue-xiang-jie-he-shi-xian-by-labuladong/)。

方法一：自己造轮子

为了让链表与哈希表相结合，需要让哈希表与链表进行映射，哈希表存储key和对应的节点，链表为了方便删除操作，使用双向链表，链表的节点定义如下

~~~java
class DoubleNode{
    int key;
    int value;
    DoubleNode pre;
    DoubleNode next;
    public DoubleNode(int key, int value){
        this.key = key;
        this.value = value;
    }
}
~~~

对于链表的操作，需要实现的功能有，在链表前面插入节点，删除一个节点，删除末尾节点，获取链表容量，双向链表的实现如下。维护头节点与尾节点，方便进行插入与删除的操作，对于插入一个元素，需要改变4个指向的关系，让size自增。对于删除一个节点，需要改变2个指向的关系，size递减，返回删除元素的key。对于删除末尾节点，调用删除节点的方法即可。

~~~java
class DoubleList{
    //头节点与尾节点
    private DoubleNode head;
    private DoubleNode tail;
    private int size;
    public DoubleList(){
        head = new DoubleNode(0,0);
        tail = new DoubleNode(0,0);
        head.next = tail;
        tail.pre = head;
        size = 0;
    }
    //往链表头节点添加元素
    public void addFirst(DoubleNode node){
        //添加当前节点的指向
        node.next = head.next;
        node.pre = head;
        head.next.pre = node;
        head.next = node;
        size++;
    }
    //在链表中移除元素，其中节点一定在链表中
    public int remove(DoubleNode node){
        //删除2个关系
        node.pre.next = node.next;
        node.next.pre = node.pre;
        size--;
        return node.key;
    }
    //移除链表末尾元素
    public int removeLast(){
        if (size == 0)
            return 0;
        return remove(tail.pre);
    }
    //得到长度
    public int getSize(){
        return size;
    }
}
~~~

对于LRU缓存，需要维护一个哈希表和一个双向链表，同时需要设置一个阈值容量。get方法的逻辑为，如果哈希表中不存在key，返回-1；如果存在，调用put方法，更新哈希表和链表，返回对应的value。对于put方法，逻辑为，构造一个新节点，当这个key存在于map中，在链表中将此key对应的节点删除，将新节点插入到链表头部，更新map。如果不存在于map中，当容量满了，删除链表最后的元素，在哈希表中删除其对应的key，然后将节点添加至链表头部，更新哈希表。实现如下：

~~~java
public class LRUCache {
    //持有一个map和一个双向链表，根据key找到对应Node,然后在链表中操作
    private HashMap<Integer,DoubleNode> map;
    private DoubleList list;
    private int cap;//容量
    public LRUCache(int cap){
        map = new HashMap<>();
        list = new DoubleList();
        this.cap = cap;
    }
    //get方法
    public int get(int key){
        //如果不存在，返回-1
        if (!map.containsKey(key)){
            return -1;
        }
        int res = map.get(key).value;
        //更新链表
        put(key,res);
        return res;
    }

    public void put(int key, int value) {
        DoubleNode node = new DoubleNode(key,value);
        //如果已经存在了，进行替换
        if (map.containsKey(key)){
            //在链表中删除
            list.remove(map.get(key));
            //将新节点加入
            list.addFirst(node);
            //更新哈希表
            map.put(key,node);
        }else {
            //如果链表长度等于容量，删除末尾节点，然后将新节点添加至头部
            if (list.getSize() == cap){
                //记录被删除节点的key，便于从哈希表中移出
                int temp = list.removeLast();
                map.remove(temp);
            }
            list.addFirst(node);
            map.put(key,node);
        }
    }
}
~~~

方法二：用轮子

Java中有序的哈希表为LinkedHashMap，直接用一个类去继承，初始化的时候为了让取出顺序为访问顺序，传入true，然后get方法调用父类的getOrDefault方法，put方法调用父类的put方法，为了删除超出容量的节点，需要覆写removeEldestEntry方法。

~~~java
public class LRUCache2 extends LinkedHashMap<Integer,Integer> {
    private int cap;
    public LRUCache2(int cap){
        //当为true的时候,get的顺序为访问的顺序
        super(cap,0.75F,true);
        this.cap = cap;
    }
    public int get(int key){
        return getOrDefault(key,-1);
    }
    public void put(int key,int value){
        super.put(key,value);
    }
    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer,Integer> eldest){
        return size() > cap;
    }
}
~~~

