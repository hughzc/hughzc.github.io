---
title: 算法笔记
date: 2020-02-25 09:51:49
tags: [左神算法, 剑指offer, leetcode]
categories: 算法
---

# OJ处理技巧

类名为public class Main

较好的做法是将要用到的类都封装好，不要放在Main类中，主类只需要持有要用到的类的对象，然后调用即可。

StringBuilder类的append方法，res.append(str1).append(str2)比res.append(str1+str2)效率高。

<!-- more -->

## 获取不知次数的输入

使用BufferedReader来获取，需要Import，主函数需要抛出异常

valueOf返回值类型为Integer，parseInt返回值类型为int

~~~java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class Main {
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s = null;
        while((s = br.readLine())!= null){
            //获取第一行输入，输入为一个数
            int len = Integer.valueOf(s);
            //获取第二行输入，输入为数组
            String[] arrStr = br.readLine().split(" ");
            int [] arr = new int[len];
            for (int i = 0; i < arr.length; i++) {
                arr[i] = Integer.valueOf(arrStr[i]);
            }
            System.out.println(要求的函数);
        }
    }
~~~

## 获取有限次数的输入

输出的结果先用StringBuilder类存起来，如果有多行，每一行最后要加上换行标识。最后要输出的时候，将stringbuilder转变为String类输出。

~~~java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main{
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        //要持有的写的类
        DogCatQueue dq = new DogCatQueue();
        String s = null;
        StringBuilder res = new StringBuilder();
        s = br.readLine();
        int count = Integer.valueOf(s);
        for (int i = 0; i < count; i++) {
            String[] strArr = br.readLine().split(" ");
            //if或者switch判断
            switch (strArr[0]){
                case "add":
                    String type=strArr[1];
                    dq.add(new Pet(type,Integer.valueOf(strArr[2])));
                    break;
                case "pollAll":
                    while(!dq.isEmpty()){
                        pet = dq.pollAll();
                        res.append(pet.getPetType()+" "+pet.getPetIndex()+"\n");
                    }
                    break;
                case "isDogEmpty" :
                    res.append(dq.isDogEmpty()?"yes\n":"no\n");
                    break;
            }
        }
        System.out.println(res.substring(0,res.length()-1));
    }
}
~~~

## 获取输入矩阵

~~~java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        //要持有的写的类
        //PringtEdge pe = new PringtEdge();
        String[] s = null;
        StringBuilder res = new StringBuilder();
        s = br.readLine().split(" ");
        //获取第一行的矩阵行与列
        int row = Integer.valueOf(s[0]);
        int col = Integer.valueOf(s[1]);
        int[][] arr = new int[row][col];
        //获取后面几行的矩阵数据
        for (int i = 0; i < row; i++) {
            s = br.readLine().split(" ");
            for (int j = 0; j < col; j++) {
                arr[i][j] = Integer.valueOf(s[j]);
            }
        }
        //通过自己编写方法获取结果
        //res = pe.printCircle(arr);
        System.out.println(res.substring(0,res.length()-1));
    }
~~~

## 获取数组

输入只有一行，为数组

~~~java
import java.util.Scanner;
	//交换数组中的数
    public static void swap(int[] arr,int i, int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
	//打印数组
    public static void printArr(int[] arr){
        for(int i = 0; i < arr.length; i++){
            System.out.print(arr[i]+" ");
        }
    }
	public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        String[] strArray = str.split(" ");
        int[] intArray = new int[strArray.length];
        for(int i = 0;i<strArray.length;i++) {
            intArray[i] = Integer.parseInt(strArray[i]);
        }
    	//要解决的
        Solution(intArray);
    	//输出数组
        for(int i = 0;i<intArray.length;i++) {
            System.out.print(intArray[i] + " ");
        }
    	//or
    	printArr(printArr);
    }
~~~

输入有两行，第一行为数组长度，第二行为数组

获取long类型的数组

~~~java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int len = Integer.parseInt(br.readLine());
        long[] arr = new long[len];
        String[] strArray = br.readLine().split(" ");
        for(int i = 0;i<len;i++) {
            arr[i] = Long.parseLong(strArray[i]);
        }
        LessMoney lm = new LessMoney();
        System.out.println(lm.getLessMoney(arr));
    }
~~~



## 获取链表

~~~java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

//链表结构
class Node{
    int value;
    Node next;
    Node pre;
    Node(int value){
        this.value = value;
    }
}

	//创建单向链表
	private static Node createNode(String[] str,int n){
        Node head = new Node(Integer.parseInt(str[0]));
        Node node = head;
        for(int i=1;i<n;i++){
            Node newNode = new Node(Integer.parseInt(str[i]));
            node.next = newNode;
            node = newNode;
        }
        return head;
    }
    //创建双向链表
    private static Node createNodeDL(String[] str,int n){
        Node head = new Node(Integer.parseInt(str[0]));
        Node node = head;
        for(int i=1;i<n;i++){
            Node newNode = new Node(Integer.parseInt(str[i]));
            node.next = newNode;
            node.next.pre = node;
            node = newNode;
        }
        return head;
    }
	//打印列表
	private static void printList(Node node){
        StringBuilder builder = new StringBuilder();
        while (node != null){
            builder.append(node.value).append(" ");
            node = node.next;
        }
        System.out.println(builder.toString());
    }
	//主函数部分
	public static void main(String[] args) throws IOException{
        BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
        //创建第一个链表
        int n = Integer.parseInt(input.readLine());
        String[] strings1 = input.readLine().split(" ");
        Node list1 = createNode(strings1,n);
        //创建第二个链表
        int m = Integer.parseInt(input.readLine());
        String[] strings2 = input.readLine().split(" ");
        Node list2 = createNode(strings2,m);
        //要操作的函数
        //printCommonPart(list1,list2);
    }
~~~

## 获取树

~~~java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Stack;

class Node{
    public int value;
    public Node left;
    public Node right;
    public Node(int value){
        this.value = value;
    }
}

	public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        //读取总的节点数与根节点数
        String[] s=reader.readLine().split(" ");
        int n = Integer.parseInt(s[0]);
        int rootIdx = Integer.parseInt(s[1]);
        //构造桶，将每个节点放入对应值，分别存其左、右结点的值
        int[][] arr = new int[n+1][2];
        int t;
        //将节点的数放入对应的桶中，构造得到数组
        for (int i = 1; i < n; i++){
            String[] sts = reader.readLine().split(" ");
            t = Integer.parseInt(sts[0]);
            arr[t][0] = Integer.parseInt(sts[1]);
            arr[t][1] = Integer.parseInt(sts[2]);
        }
        //拿出头节点
        Node head = new Node(rootIdx);
        createTree(head,arr);
        StringBuilder res = new StringBuilder();
        preOrderRecur(head,res);
        System.out.println(res.substring(0,res.length()-1));
        res.delete(0,res.length());
        inOrderRecur(head,res);
        System.out.println(res.substring(0,res.length()-1));
        res.delete(0,res.length());
        posOrderRecur(head,res);
        System.out.println(res.substring(0,res.length()-1));

    }
    //递归实现
    public static void createTree(Node root,int[][] a){
        //base case
        if(root==null){
            return ;
        }
        int i=root.value;
        int l=a[i][0];
        int r=a[i][1];
        //左子树不为空，构造左子树
        if(l!=0){
            Node leftNode=new Node(l);
            root.left=leftNode;
            //递归产生左子树
            createTree(leftNode,a);
        }
        //右子树不为空，构造右子树
        if(r!=0){
            Node rightNode=new Node(r);
            root.right=rightNode;
            createTree(rightNode,a);
        }
    }
~~~



# 左神算法笔记

## 排序问题

### 小和问题

题目描述：

数组小和的定义如下：

例如，数组s = [1, 3, 5, 2, 4, 6]，在s[0]的左边小于或等于s[0]的数的和为0；在s[1]的左边小于或等于s[1]的数的和为1；在s[2]的左边小于或等于s[2]的数的和为1+3=4；在s[3]的左边小于或等于s[3]的数的和为1；

在s[4]的左边小于或等于s[4]的数的和为1+3+2=6；在s[5]的左边小于或等于s[5]的数的和为1+3+5+2+4=15。所以s的小和为0+1+4+1+6+15=27

给定一个数组s，实现函数返回s的小和

[要求]

时间复杂度为O(nlogn)，空间复杂度为O(n)

思路：找小和，就是看当前数右边哪些数比他大 ，顺序并没有关系，因此可以用mergesort的思想，先分再合，产生小和的过程为merge的过程，如果右边数比左边大，那么总的小和个数为左边当前数*右边数个数，然后将两个数组sort中产生的数和当前merge共三部门数相加即可。

坑：

最后的小和可能很大，需要long类型才能过OJ，小和为小于等于，因此merge外排时判断为<=

~~~sql
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s = null;
        while((s=br.readLine())!=null){
            int len = Integer.valueOf(s);
            String[] arrStr = br.readLine().split(" ");
            int[] arr = new int[len];
            for(int i = 0;i < len;i++){
                arr[i] = Integer.parseInt(arrStr[i]);
            }
            System.out.println(smallSum(arr));
        }
    }
    public static long smallSum(int[] arr){
        if(arr == null || arr.length < 2)
            return 0;
        return sortProcess(arr,0,arr.length-1);
    }
    public static long sortProcess(int[] arr,int l,int r){
        if(l == r)
            return 0;
        int mid = l + (r - l)/2;
        return sortProcess(arr,l,mid)+sortProcess(arr,mid+1,r)+merge(arr,l,mid,r);
    }
    public static long merge(int[] arr,int l,int mid, int r){
        int p1 = l,p2 = mid+1,i = 0;
        int[] help = new int[r-l+1];
        long res = 0;
        while(p1<=mid && p2 <= r){
            if(arr[p1] <= arr[p2]){
                res += arr[p1] * (r-p2+1);
                help[i++] = arr[p1++];
            }else{
                help[i++] = arr[p2++];
            }
        }
        while(p1<=mid){
            help[i++] = arr[p1++];
        }
        while(p2<=r){
            help[i++] = arr[p2++];
        }
        for(i = 0;i<help.length;i++){
            arr[l+i] = help[i];
        }
        return res;
    }
}
~~~

### 数组排序后相邻数的最大差值

题目描述

给定一个整形数组arr，返回排序后相邻两数的最大差值

arr = [9, 3, 1, 10]。如果排序，结果为[1, 3, 9, 10]，9和3的差为最大差值，故返回6。

arr = [5, 5, 5, 5]。返回0。

[要求]

时间复杂度为O(n)，空间复杂度为O(n)

当要排序，然后时间复杂度给定O(n)，那么只能使用桶排序，思路为把n个数放在n+1个桶中，那么肯定有1个桶中没有数字，这样最大的差值一定出现在两个桶之间，那么桶中有哪些数字不重要，只需要关注桶中是否有数字，最大数字和最小数字即可，最大差值为当前非空桶的最小值减去上一个非空桶的最大值。将数字放入桶，依据为将min-max的数据，放入0-len的桶中，数据长度为为len，桶的个数为len+1。在计算时为了避免越界，采用long型，然后转换为int。可以优化的点在于，如果算出来数组的最大值和最小值相等，那么可以直接返回0，不用建立桶。

~~~java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Main{
    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s = null;
        while((s=br.readLine())!=null){
            int len = Integer.valueOf(s);
            int[] arr = new int[len];
            String[] arrStr = br.readLine().split(" ");
            for(int i = 0;i<len;i++){
                arr[i] = Integer.valueOf(arrStr[i]);
            }
            System.out.println(maxGap(arr));
        }
    }
    public static int maxGap(int[] arr){
        if(arr == null || arr.length < 2)
            return 0;
        //统计数组最大和最小值
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;
        int len = arr.length;
        for(int i = 0;i<len;i++){
            min = Math.min(min,arr[i]);
            max = Math.max(max,arr[i]);
        }
        //如果max=min，那么可以直接返回0
        if(max == min)
            return 0;
        //建立桶，范围是0-len
        //有三个属性，是否进来过数，最大值，最小值
        boolean[] hasNum = new boolean[len+1];
        int[] maxs = new int[len+1];
        int[] mins = new int[len+1];
        int bid = 0;
        //将每一个数装入桶
        for(int i = 0; i < len;i++){
            //计算当前数应该在哪个桶
            bid = bucket(arr[i],len,min,max);
            //统计桶的最大最小值，是否进去过数
            maxs[bid] = hasNum[bid]?Math.max(maxs[bid],arr[i]):arr[i];
            mins[bid] = hasNum[bid]?Math.min(mins[bid],arr[i]):arr[i];
            hasNum[bid] = true;//当前桶进去了数
        }
        //开始计算差值
        int res = 0;
        int lastMax = maxs[0];
        for(int i = 1;i < len;i++){
            if(hasNum[i]){
                res = Math.max(res,mins[i]-lastMax);
                lastMax = maxs[i];
            }
        }
        return res;
    }
    public static int bucket(long num,long len, long min, long max){
        //目的，让值为min的在0桶，让值为max的在len桶
        //范围变换，从min-max变化为0-len
        int res = (int)((num-min)*len/(max-min));
        return res;
    }
}
~~~

## 队列和栈

### 用数组实现栈和队列

用数组实现栈比较简单，此类需要持有一个数组和当前位置标记，有初始化构造函数，获取最上面一个数peek方法，入栈push方法，出栈pop方法，要注意的是执行者三个方法时第一步为判断index范围，pop方法返回类型要是Integer而不是int，因为换成int不能返回null

~~~java
public class ArrayStack {
    //用数组实现栈，应该持有数组，当前位置
    private int[] arr;
    private int index;
    public ArrayStack(int size){
        if (size < 0)
            throw new IllegalArgumentException("The init size is less than 0");
        arr = new int[size];
    }
    //peek，获取最上面的数
    //返回类型为Integer，不然不能返回NULL
    public Integer peek(){
        if (index == 0)
            return null;
        return arr[index-1];
    }
    //入栈
    public void push(int obj){
        //如果超出范围，报错
        if (index == arr.length)
            throw new ArrayIndexOutOfBoundsException("The stack is full");
        //如果正常，放入数据
        arr[index++] = obj;
    }
    //出栈
    public Integer pop(){
        if (index == 0)
            throw new ArrayIndexOutOfBoundsException("The stack is empty");
        return arr[--index];
    }
}
~~~

用数组实现队列，需要持有一个数组，一个入队列位置end，一个出队列位置start，一个队列大小size，用size来给end和start解耦

~~~java
public class ArrayQueue {
    //用数组实现队列，需要持有数组，队列末尾，队列开始，size
    private int[] arr;
    private int start;
    private int end;
    private int size;
    public ArrayQueue(int initSize){
        if (initSize < 0)
            throw new IllegalArgumentException("The init size is less than 0");
        arr = new int[initSize];
        size = 0;
        end = 0;
        start = 0;
    }
    //peek方法
    public Integer peek(){
        if (size == 0)
            return null;
        return arr[start];
    }
    //push方法
    public void push(int obj){
        if (size == arr.length)
            throw new ArrayIndexOutOfBoundsException("The queue is full");
        size++;
        arr[end] = obj;
        //循环队列
        end = (end + 1) % arr.length;
    }
    //poll方法
    public int poll(){
        if (size == 0)
            throw new ArrayIndexOutOfBoundsException("The queue is empty");
        size--;
        int temp = arr[start];
        start = (start+1)%arr.length;
        return temp;
    }
}
~~~

### getMin()功能的栈

实现一个特殊功能的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。

思路：持有两个栈，一个为数据栈，一个为最小栈，数据栈正常进出，而最小栈有两种方法实现。

方法一：当进来的数比最小数要小，直接入栈；当比最小数大，入栈最小数出栈时。两个栈正常出栈，返回data栈的值。

方法二：当进来的数比最小数要小，直接入栈；当比最小数大，min不入栈 。出栈时，当data出栈数等于最小数才出栈 ，其他时候min不出栈。

~~~java
import java.util.Stack;
public class MyStack2 {
    //第二种方法，入栈的时候，如果当前数比较大，则min栈不进
    //出栈的时候，如果当前数比min栈小，min栈不出
    private Stack<Integer> dataStack;
    private Stack<Integer> minStack;
    //初始化
    public MyStack2() {
        dataStack = new Stack<>();
        minStack = new Stack<>();
    }
    //getMin()方法
    public Integer getMin() {
        //如果栈为空，返回空
        if (minStack.empty())
            return null;
        return minStack.peek();
    }
    //入栈方法
    public void push(int num) {
        if (minStack.empty()) {
            minStack.push(num);
        } else if (num <= getMin()) {
            minStack.push(num);
        }
        dataStack.push(num);
    }
    //出栈方法
    public Integer pop() {
        if (dataStack.empty())
            return null;
        int num = dataStack.pop();
        //只有当前数等于getmin，min栈才出
        //只有等于，没有小于
        if (num == getMin())
            minStack.pop();
        return num;
    }    
}
~~~

### 用队列实现栈

用队列来实现栈的功能，要有2个队列，当push的时候，正常进入队列，当peek的时候，先弹出其他的进入辅助队列，然后获取剩下来的一个的值，再将其放入辅助队列，再交换两个的引用。

~~~java
import java.util.LinkedList;
import java.util.Queue;
public class TwoQueueStack {
    //用两个队列实现栈
    private Queue<Integer> queue;
    private Queue<Integer> help;
    public TwoQueueStack(){
        queue = new LinkedList<Integer>();
        help = new LinkedList<Integer>();
    }
    //push
    public void push(int num){
        queue.add(num);
    }
    public int peek(){
        if (queue.isEmpty()){
            throw new RuntimeException("Queue is empty");
        }
        while (queue.size()!=1){
            help.add(queue.poll());
        }
        int res = queue.poll();
        help.add(res);
        swap();
        return res;
    }
    public int pop(){
        if (queue.isEmpty()){
            throw new RuntimeException("Queue is empty");
        }
        while (queue.size()>1){
            help.add(queue.poll());
        }
        int res = queue.poll();
        swap();
        return res;
    }
    //交换两个队列引用
    public void swap(){
        Queue<Integer> temp = queue;
        queue = help;
        help = queue;
    }
}
~~~

### 用栈实现队列

准备两个栈，一个push栈只用于push数据进去，一个pop栈只用于pop数据出来。从push栈倒数据进pop栈有两个要求，一个是pop栈中不能有数据，另一个是倒就要全部倒完。

~~~java
import java.util.Stack;
public class TwoStackQueue {
    private Stack<Integer> stackPush;
    private Stack<Integer> stackPop;
    public TwoStackQueue(){
        stackPush = new Stack<>();
        stackPop = new Stack<>();
    }
    public void push(int num){
        stackPush.push(num);
        goTo();
    }
    //关键的倒数据步骤
    public void goTo(){
        while (stackPop.isEmpty()){
            //要倒完
            while (!stackPush.isEmpty()){
                stackPop.push(stackPush.pop());
            }
        }
    }
    //peek步骤
    public int peek(){
        if (stackPush.isEmpty() && stackPop.isEmpty())
            throw new RuntimeException("The stack is empty");
        goTo();
        return stackPop.peek();
    }
    public int pop(){
        if (stackPush.isEmpty() && stackPop.isEmpty())
            throw new RuntimeException("The stack is empty");
        goTo();
        return stackPop.pop();
    }
}
~~~

### 猫狗队列

实现一种猫狗队列的结构，要求如下：

1. 用户可以调用 add 方法将 cat 或者 dog 放入队列中

2. 用户可以调用 pollAll 方法将队列中的 cat 和 dog 按照进队列的先后顺序依次弹出

3. 用户可以调用 pollDog 方法将队列中的 dog 按照进队列的先后顺序依次弹出

4. 用户可以调用 pollCat 方法将队列中的 cat 按照进队列的先后顺序依次弹出

5. 用户可以调用 isEmpty 方法检查队列中是否还有 dog 或 cat

6. 用户可以调用 isDogEmpty 方法检查队列中是否还有 dog

7. 用户可以调用 isCatEmpty 方法检查队列中是否还有 cat

思路：将Pet封装上一个index数据项，这样使用一个新类将二者封装。然后持有一个狗队列，一个猫队列，持有index，初始为0，在add操作中，如果是狗，就加入狗队列，是猫就加入猫队列。从队列中弹出较早入队列的，比较猫、狗队列中较小的index，弹出即可。

坑点：牛客网上的题目相比于原始题目，Pet自己也需要封装上一个index项，而比较的时候，比的是封装后的宠物队列类自己定义的index，而不是pet的index。

~~~java
class Pet {
    private String type;
    private int x;
    public Pet(String type,int index){
        this.type = type;
        this.x = index;
    }
    public String getPetType(){
        return this.type;
    }
    public int getPetIndex(){
        return this.x;
    }
}
class PetEnterQueue {
    //持有Pet和index
    private Pet pet;
    private long index;
    public PetEnterQueue(Pet pet, long index){
        this.pet = pet;
        this.index = index;
    }
    //API：获取当前类型，index
    public Pet getPet() {
        return pet;
    }
    public long getIndex() {
        return index;
    }
    public String getPetType(){
        return pet.getPetType();
    }
}
class DogCatQueue {
    //猫狗队列，一个持有猫，，一个持有狗
    private Queue<PetEnterQueue> dogQueue;
    private Queue<PetEnterQueue> catQueue;
    private long index;
    public DogCatQueue(){
        dogQueue = new LinkedList<>();
        catQueue = new LinkedList<>();
        index = 0;
    }
    public void add(Pet pet){
        //如果为狗，加到狗；如果为猫，加到猫
        if ("dog".equals(pet.getPetType())){
            dogQueue.add(new PetEnterQueue(pet,index++));
        }else if ("cat".equals(pet.getPetType())){
            catQueue.add(new PetEnterQueue(pet,index++));
        }else{
            throw new RuntimeException("error, no dog or cat");
        }
    }
    //弹出猫或者狗中较小的
    public Pet pollAll(){
        //如果两个均不为空
        if (!dogQueue.isEmpty() && !catQueue.isEmpty()){
            if (dogQueue.peek().getIndex() < catQueue.peek().getIndex()){
                return dogQueue.poll().getPet();
            }else {
                return catQueue.poll().getPet();
            }
        }else if (!dogQueue.isEmpty()){
            //狗不为空
            return dogQueue.poll().getPet();
        }else if (!catQueue.isEmpty()){
            //猫不为空
            return catQueue.poll().getPet();
        }else{
            throw new RuntimeException("The queue is empty");
        }
    }
    //弹出狗队列
    public Pet pollDog(){
        if (dogQueue.isEmpty())
            throw new RuntimeException("Dog queue is empty");
        return dogQueue.poll().getPet();
    }
    //弹出猫队列
    public Pet pollCat(){
        if (catQueue.isEmpty())
            throw new RuntimeException("Dog queue is empty");
        return catQueue.poll().getPet();
    }
    public boolean isEmpty(){
        return isCatEmpty()&&isDogEmpty();
    }
    public boolean isCatEmpty(){
        return catQueue.isEmpty();
    }
    public boolean isDogEmpty(){
        return dogQueue.isEmpty();
    }
}
~~~

输入输出的处理比较麻烦，使用StringBuilder来添加结果，最后用substring方法将其转换为字符串，要记得添加换行。

~~~java
public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s = null;
        DogCatQueue dq = new DogCatQueue();
        Pet pet = null;
        StringBuilder res=new StringBuilder();
        s = br.readLine();
        int count = Integer.valueOf(s);
        for (int i = 0; i < count; i++) {
            String[] strArr = br.readLine().split(" ");
            switch (strArr[0]){
                case "add":
                    String type=strArr[1];
                    dq.add(new Pet(type,Integer.valueOf(strArr[2])));
                    break;
                case "pollAll":
                    while(!dq.isEmpty()){
                        pet = dq.pollAll();
                        res.append(pet.getPetType()+" "+pet.getPetIndex()+"\n");
                    }
                    break;
                case "pollCat":
                    while(!dq.isCatEmpty()){
                        pet = dq.pollCat();
                        res.append(pet.getPetType()+" "+pet.getPetIndex()+"\n");
                    }
                    break;
                case "pollDog":
                    while(!dq.isDogEmpty()){
                        pet = dq.pollDog();
                        res.append(pet.getPetType()+" "+pet.getPetIndex()+"\n");
                    }
                    break;
                case "isDogEmpty" :
                    res.append(dq.isDogEmpty()?"yes\n":"no\n");
                    break;
                case "isCatEmpty":
                    res.append(dq.isCatEmpty()?"yes\n":"no\n");
                    break;
                case "isEmpty":
                    res.append(dq.isEmpty()?"yes\n":"no\n");
                    break;
            }
        }
        System.out.println(res.substring(0,res.length()-1));
    }
~~~

## 哈希表

### RandomPool结构

题目：

设计一种结构，在该结构中加入如下三种功能

insert(key)：将某个key加入到该结构，做到不重复加入

delete(key)：将原本在结构中的某个key移除

getRandom()：等概率随机返回结构中的任何一个key

要求：这三种方法的时间复杂度均为O(1)

思路：一个不行就两个。持有两个哈希表，一个为key-index映射，一个为index-key映射，麻烦的地方在于删除后如何保证之后的随机性，解决方法为每次找到要删除的位置，然后获取其key，获取最后行的key和index，然后将最后行的数据存到要删除行，再删除最后行数据。

~~~java
import java.util.HashMap;
public class RandomPool<K> {
    //持有两个哈希表，一个索引
    private HashMap<K,Integer> keyIndexMap;
    private HashMap<Integer,K> indexKeyMap;
    private int index;
    public RandomPool(){
        keyIndexMap = new HashMap<>();
        indexKeyMap = new HashMap<>();
        index = 0;
    }
    //添加方法
    public void insert(K key){
        //如果已经存在了，返回
        if (keyIndexMap.containsKey(key))
            return;
        keyIndexMap.put(key,index);
        indexKeyMap.put(index++,key);
    }
    //随机返回方法
    public K getRandom(){
        //如果没有数据，返回空
        if (index == 0)
            return null;
        int res = (int)(Math.random()*index);
        return indexKeyMap.get(res);
    }
    //删除方法
    public void delete(K key){
        if (!keyIndexMap.containsKey(key))
            return;
        //1、找到要删除位置的index
        int deleteIndex = keyIndexMap.get(key);
        //2、找到最后的index和key
        int lastIndex = --index;
        K lastKey = indexKeyMap.get(lastIndex);
        //3、将待删除位置的值替换为最后行的值
        keyIndexMap.put(lastKey,deleteIndex);
        indexKeyMap.put(deleteIndex,lastKey);
        //4、删除最后行数据，将行数-1
        keyIndexMap.remove(key);
        indexKeyMap.remove(lastIndex);
    }
}
~~~

## 数组

### 转圈打印矩阵

{% asset_img 转圈打印矩阵.png This is an example image %}

思路：打印矩阵的思路一般都是宏观调度，用有限个变量去约束要打印的范围，然后循环调用打印函数。此处用左上角和右下角的点去约束范围，调用打印函数，然后将左上角和右下角的点进行收缩。打印矩阵函数为分别判断一行，一列和多行多列的情况，如果为单行单列的，用for循环控制行和列，如果为多行多列，分四次打印。

{% asset_img 转圈矩阵约束.png This is an example image %}

说明的是，在原方法中采用的是直接sout输出，此处使用StringBuilder进行添加。

~~~java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

class PringtEdge {
    //转圈打印矩阵
    public StringBuilder printCircle(int[][] arr){
        //1、找两个边界点
        int row1 = 0, col1 = 0;
        int row2 = arr.length-1,col2 = arr[0].length-1;
        StringBuilder sb = new StringBuilder();
        //只要满足边界条件，循环调用打印函数
        while (row1 <= row2 && col1 <= col2){
            printEdge(arr,sb,row1++,col1++,row2--,col2--);
        }
        return sb;
    }
    public void printEdge(int[][] arr, StringBuilder sb, int row1, int col1, int row2, int col2){
        //1、如果只有一行
        if (row1 == row2){
            for (int i = col1; i <= col2; i++) {
                sb.append(arr[row1][i]+" ");
            }
        }else if(col1 == col2){
            //2、如果只有一列
            for (int i = row1; i <= row2; i++) {
                sb.append(arr[i][col1]+" ");
            }
        }else{
            //3、分四部分打印
            int curR = row1;//当前行
            int curL = col1;//当前列
            while (curL < col2){
                sb.append(arr[curR][curL++]+" ");
            }
            while (curR < row2){
                sb.append(arr[curR++][curL]+" ");
            }
            while (curL > col1){
                sb.append(arr[curR][curL--]+" ");
            }
            while (curR > row1){
                sb.append(arr[curR--][curL]+" ");
            }
        }
    }
}
public class Main{
        public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        //要持有的写的类
        PringtEdge pe = new PringtEdge();
        String[] s = null;
        StringBuilder res = new StringBuilder();
        s = br.readLine().split(" ");
        int row = Integer.valueOf(s[0]);
        int col = Integer.valueOf(s[1]);
        int[][] arr = new int[row][col];
        for (int i = 0; i < row; i++) {
            s = br.readLine().split(" ");
            for (int j = 0; j < col; j++) {
                arr[i][j] = Integer.valueOf(s[j]);
            }
        }
        res = pe.printCircle(arr);
        System.out.println(res.substring(0,res.length()-1));
    }
}
~~~

### 之字型打印矩阵

{% asset_img 之打印矩阵.png This is an example image %}

思路：宏观调度，打印的是两个点之间的对角线的值，那么只要解决点的运动路径和打印对角线即可。要注意的是点在运动过程中时，如果变量A依靠变量B来约束其行为，要先改变变量A，再改变B，不然B先改变则A会缺少值。而对角线打印的时候有方向变化，可以用标记变量来控制。

这种题目依靠的是宏观调度，不要去想每个点到底怎么变。

~~~java
//之字型打印矩阵，找宏观规律
    public StringBuilder printZhi(int[][] m){
        //往右，再下
        int row1 = 0,col1 = 0;
        //往下，再右
        int row2 = 0,col2 = 0;
        int endR = m.length-1;
        int endC = m[0].length-1;
        StringBuilder res = new StringBuilder();
        //先下，再上
        boolean fromUp = false;
        while (row1 <= endR){
            printProcess(m,res,row1,col1,row2,col2,fromUp);
            //路径变化
            //关键为将引发判断的值后判断
            row1 = col1 == endC ? row1+1:row1;
            col1 = col1 == endC ? col1:col1+1;
            col2 = row2 == endR ? col2+1 : col2;
            row2 = row2 == endR ? row2:row2+1;
            fromUp = !fromUp;
        }
        return res;
    }
    public void printProcess(int[][] m,StringBuilder res, int row1,int col1, int row2, int col2,boolean fromUp){
        //如果fromUp为false，从左下向右上打印
        if (!fromUp){
            while (row1 <= row2){
                res.append(m[row2--][col2++]+" ");
            }
        }else{
            while (row1 <= row2){
                res.append(m[row1++][col1--]+" ");
            }
        }
    }
~~~

### 在行列都排好序的矩阵中找数

{% asset_img 排序矩阵找数.png This is an example image %}

思路：从右上角或者左下角开始找，此处选右上角，要是当前数小了就往下，当前数大了就往左。

精髓的点在于开始寻找的位置，利用矩阵的特征，可以将部分不可能的情况给排除掉，这题从右上角或者左下角开始找都可以。但是左上和右下不行，因为没办法缩小规模。核心在于右上或左下，**一边比它大，一边比它小**。这样子存在**要么去一边，要么另一边**的0 1情况，即非黑即白。

实质是将没有可能的数据直接舍弃，即将问题的规模进行缩小。

~~~java
    //在已排序的矩阵中找到数
    public boolean findNum(int[][] m,int k){
        //选择右上角的数
        int row = 0,col = m[0].length-1;
        int endR = m.length-1;
        while (row<=endR && col >=0){
            //如果当前数小，往下走
            if (m[row][col] == k){
                return true;
            }else if(m[row][col]>k){
                //当前数比较大，往左走
                col--;
            }else {
                row++;
            }
        }
        return false;
    }
~~~

## 链表

### 打印两个链表的公共部分

给定两个升序链表，打印两个升序链表的公共部分。

思路：类似于外排，谁小动谁，如果相等，打印并两个一起动

值得注意的点：将head1或者2为空的情况放在最上面，直接返回；将head1.value==head2.value的情况放在三种判断的第一个，这样可以缩短判断时间；整理链表基本结构及生成链表的套路。StringBuilder添加时候，使用两次append比一次append两个str效率高。原因是使用+的时候多了生成String的步骤，这样降低了效率。

~~~java
    //打印两个链表公共部分
    public static void printCommonPart(Node head1,Node head2){
        //将不可能的情况先列出
        if (head1 == null || head2 == null)
            return;
        StringBuilder res = new StringBuilder();
        //类似外排
        //谁小动谁，如果相等，添加并两个一起动
        while (head1 != null && head2 != null) {
            //将相等的判断放在最上面
            if (head1.value == head2.value) {
                //这样比直接append(value+" ")效率高
                res.append(head1.value).append(" ");
                head1 = head1.next;
                head2 = head2.next;
            } else if(head1.value < head2.value){
                head1 = head1.next;
            }else{
                head2 = head2.next;
            }
        }
        System.out.println(res.toString());
    }
~~~

### 合并两个有序的链表

给定两个升序的单链表的头节点 head1 和 head2，请合并两个升序链表， 合并后的链表依然升序，并返回合并后链表的头节点。

思路：类似于外排，如果两个均不为空，谁小动谁；如果哪个为空，把另一个不为空的接到新链表后即可。

小技巧：新链表自己先做一个头节点会比较方便，在动链表的时候，流程为让新链表的下一个指向小节点，新链表当前节点跳到下一个，小节点链表头节点跳到下一个。另外如果有一个链表已经为空了，则不需要一个个节点去添加，直接把整个加上去即可。

~~~java
 //合并链表
    public static Node mergeLink(Node head1, Node head2){
        //类似于外排
        Node res = new Node(0);
        Node cur = res;
        while (head1 != null && head2 != null){
            if (head1.value <= head2.value){
                cur.next = head1;
                cur = head1;
                head1 = head1.next;
            }else {
                cur.next = head2;
                cur = head2;
                head2 = head2.next;
            }
        }
        //将空的链表部分直接拼接到新链表后面即可
        cur.next = head1 == null ? head2 : head1;
        cur = res.next;
        res = null;
        return cur;
    }
~~~

### 判断链表是否为回文结构

给定链表的头结点，判断是否为回文链表

方式一：将链表元素全部存进栈中，利用栈先进后出的特点，与链表逐个比较，额外空间复杂度O(N)

```java
//解法1：将链表中的数据用栈存起来，然后一个个取出来进行对比
public boolean isPalindrome1(Node head){
    if (head == null || head.next == null)
        return true;
    //准备一个栈
    Stack<Node> stack = new Stack<>();
    Node node = head;
    while(node != null){
        stack.push(node);
        node = node.next;
    }
    //取出来比较
    node = head;
    while (!stack.isEmpty()){
        if (node.value != stack.pop().value)
            return false;
        node = node.next;
    }
    return true;
}
```

方法二：只放一半的元素进栈中，缩短一半的额外空间。

为了找到链表中点，用到的方法为快慢指针，是链表题目中比较常见的方法，慢指针一下子走一步，快指针走两步，当快指针走到末尾时，慢指针正好走到中间。注意：如果是要中点位置，慢指针从头结点开始，如果是中点位置下一个，慢指针从头节点下一个开始。此处慢指针的起始点就是头节点下一个。

~~~java
//解法2：只需要判断链表的一半即可，问题是如何找到链表的中点
    //用快慢指针
    public boolean isPalindrome2(Node head){
        if (head == null || head.next == null)
            return true;
        Node slow = head.next;
        Node fast = head;
        while (fast.next != null && fast.next.next != null){
            slow = slow.next;
            fast = fast.next;
        }
        //此时slow来到中点位置，将剩下的节点存入栈中
        Stack<Node> stack = new Stack<>();
        while (slow != null){
            stack.push(slow);
        }
        slow = head;
        while (!stack.isEmpty()){
            if (slow.value != stack.pop().value)
                return false;
            slow = slow.next;
        }
        return true;
    }
~~~

方法三：进阶方式，额外空间复杂度为O(1)，不依靠栈，而是先找到链表中点，将链表右半部分进行翻转，这里有个操作是将中点节点指向null，方便后面判断。然后从链表两端进行判断，注意不能直接返回值，因为还需要将链表还原。判断结束后，将链表右半部分还原。

注意：反转链表，删除链表节点需要利用3个指针，一个指向当前节点，一个指向当前节点的前序节点，一个指向当前节点的后序节点。先保存其下一个进行位置的，再进行操作。

~~~java
//解法3，不利用栈，先找到链表的中点，反转剩下的链表
    //进行判断，然后将链表还原
    public boolean isPalindrome3(Node head){
        if (head == null || head.next == null)
            return true;
        //找到链表中点
        Node n1 = head;
        Node n2 = head;
        while(n2.next != null && n2.next.next != null){
            n1 = n1.next;
            n2 = n2.next.next;
        }
        //此时n1来到中点，反转链表，先要记录n1下一个位置
        n2 = n1.next;
        n1.next = null;
        Node n3 = null;
        //反转链表
        while (n2 != null){
            n3 = n2.next;
            n2.next = n1;
            n1 = n2;
            n2 = n3;
        }
        //此时n1为链表末尾，进行记录
        n3 = n1;
        //开始判断头和尾的值是否相等
        n2 = head;
        boolean res = true;
        while (n2 != null && n1 != null){
            if (n2.value != n1.value){
                //不能直接返回假，这样链表没有被调整回来
                res = false;
                break;
            }
            n2 = n2.next;
            n1 = n1.next;
        }
        //还原链表
        n2 = n3.next;
        n3.next = null;
        while (n2 != null){
            n1 = n2.next;
            n2.next = n3;
            n3 = n2;
            n2 = n1;
        }
        return res;
    }
~~~

### 单向链表的基础partition

题目描述：

给定一个链表，再给定一个整数 pivot，请将链表调整为左部分都是值小于 pivot 的节点，中间部分都是值等于 pivot 的节点， 右边部分都是大于 pivot 的节点。

除此之外，对调整后的节点顺序没有更多要求。

思路：将链表用数组存起来，然后对数组partition，再将数组组合成链表，返回arr[0]，要注意的是将数组的最后个元素的next指向null，以及partition过程的约束条件是index<more，不能取等于，不然会越界。

~~~java
//单链表的partition基础问题，利用数组来实现
    public static Node listPartition(Node head,int pivot){
        if (head == null || head.next == null)
            return head;
        //1、统计链表长度
        int len = 0;
        Node node = head;
        while(node != null){
            len++;
            node = node.next;
        }
        //2、造数组，将链表中元素填充进去
        Node[] arr = new Node[len];
        node = head;
        int i = 0;
        while (node != null){
            arr[i++] = node;
            node = node.next;
        }
        //3、数组的partition问题
        //将其封装为函数
        partitionArr(arr,pivot);
        //将数组组合成链表
        for (i = 1; i < len; i++) {
            arr[i-1].next = arr[i];
        }
        //将最后个节点指针指向null
        arr[i-1].next = null;
        return arr[0];
    }
    public static void partitionArr(Node[] arr, int pivot){
        int less = -1;
        int more = arr.length;
        int i = 0;
        //约束条件为i < more或者i != more
        //如果是等于，当more为数组最后，会越界
        while (i < more){
            if (arr[i].value < pivot){
                swap(arr,i++,++less);
            }else if (arr[i].value > pivot){
                swap(arr,i,--more);
            }else {
                i++;
            }
        }
    }
~~~

### 单链表的partition进阶

要求：在原来基础之上，partition后每个部分的节点从左至右的顺序和原链表中节点的顺序一致。要时间复杂度O（N）,额外空间复杂度O（1）。

思路：将原链表拆分为小，等，大三个区域，遍历链表，来一个就丢到对应的位置中去（将节点从原链表中断开），最后将三个链表合并，考察的是扣边界能力。

~~~java
    //链表的复杂partition
    public static Node listPartition2(Node head,int pivot){
        if (head == null || head.next == null)
            return head;
        //分三个部分，小于、等于、大于区，来个节点就丢到对应的地方去
        //最后将三个部分合并
        Node sH = null;
        Node sT = null;
        Node eH = null;
        Node eT = null;
        Node bH = null;
        Node bT = null;
        Node next = null;
        while(head != null){
            next = head.next;
            head.next = null;
            //将当前节点丢到三个部分中
            if (head.value < pivot){
                //如果为空
                if (sH == null){
                    sH = head;
                    sT = head;
                }else{
                    sT.next = head;
                    sT = head;
                }
            }else if(head.value == pivot){
                if (eH == null){
                    eH = head;
                    eT = head;
                }else{
                    eT.next = head;
                    eT = head;
                }
            }else{
                if (bH == null){
                    bH = head;
                    bT = head;
                }else{
                    bT.next = head;
                    bT = head;
                }
            }
            head = next;
        }
        //将三个链表连接
        if (sT != null){
            sT.next = eH;
            eT = eT == null ? sT:eT;
        }
        if (eT != null){
            eT.next = bH;
        }
        return sH != null ? sH : eH != null ? eH : bH;
    }
~~~

### 复制含有随机节点的链表

方法一：用哈希表，将key为原链表节点，value为新链表节点，然后再复制下一个和rand指针关系

~~~java
public static Node copyListWithRand1(Node head){
    //创建存储用的HashMap，key与value均为Node
    HashMap<Node,Node> map = new HashMap<Node,Node>();
    Node cur = head;
    //对每个结点进行拷贝
    while(cur != null){
        map.put(cur, new Node(cur.value));
        cur = cur.next;
    }
    cur = head;
    while (cur != null){
        //将复制节点的next与random指向cur相同部分
        //get(x)为得到x节点的拷贝结点x'
        map.get(cur).next = map.get(cur.next);//1' 指向 2(1.next)的对应节点2'
        map.get(cur).random = map.get(cur.random);
        cur = cur.next;
    }
    return map.get(head);
}
~~~

方法二：不使用其他数据结构，在原来链表中每个节点后面复制一个新节点，然后复制rand指针关系，再将两个链表拆分开来

~~~java
public static Node copyListWithRand2(Node head){
    if(head == null)
        return null;
    Node cur = head;
    Node next = null;
    // copy node and link to every node
    while(cur != null){
        next = cur.next;
        cur.next = new Node(cur.value);
        cur.next.next = next;
        cur = next;
    }
    cur = head;
    Node curCopy = null;
    // set copy node rand
    while (cur != null){
        next = cur.next.next;
        curCopy = cur.next;
        curCopy.random = cur.random != null ? cur.random.next : null;
        cur = next;
    }
    Node res = head.next;//记录下复制链表的头结点
    cur = head;
    // split
    while(cur != null){
        next = cur.next.next;
        curCopy = cur.next;
        cur.next = next;
        curCopy.next = next != null ? next.next : null;
        cur = next;
    }
    return res;
}
~~~

### 反转链表

非递归实现

反转单链表和双链表，基本思路是持有三个节点，当前节点的前序节点，当前节点，下一个节点。

对于单链表，如果当前节点不为空，保存其下一个节点next，当前节点指向前序节点pre，pre=当前节点，当前节点=next，这样便实现了反转；对于双向链表，只是多了一步让当前节点的前序节点=next，其他和单向链表一样。

~~~java
	//反转单向链表
    public static Node reverseListSL(Node head){
        //准备三个节点
        Node pre = null;
        Node cur = head;
        Node next = null;
        while (cur != null){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
    //反转双向链表
    public static Node reverseListDL(Node head){
        //准备三个节点
        Node pre = null;
        Node cur = head;
        Node next = null;
        while (cur != null){
            next = cur.next;
            cur.next = pre;
            cur.pre = next;
            pre = cur;
            cur = next;
        }
        return pre;
    }
~~~

递归实现

看其是否可以分解成具有相同解决思路的子问题。反转链表1->2->3->4，如果把1以后的链表都反转好了，让2指向1,1指向空即可。对于1后面的子链表，也可以这样去处理。因此可以使用递归去解决

1. 定义递归函数，明确函数功能及返回值

   此递归函数实现的功能是反转某个节点开始的链表，返回的是反转后的新的结点

2. 寻找递归公式

   - 先反转当前节点以后的链表，这样1->2->3->4变为1->2<-3<-4
   - 将当前node(1)的下一个节点(node.next)的指向(node.next.next)改为当前节点(node)，node的后继结点变为空
   - 返回新的头结点

3. 将递推公式带入定义好的递归函数中

~~~java
    //反转链表的递归实现
    //递归函数要实现的功能是反转链表，返回的是反转后的链表头节点
    public static Node reverseList2(Node node){
        //base case
        if (node.next == null)
            return node;
        //对当前节点做操作
        //把后面的链表进行反转
        Node newHead = reverseList2(node.next);
        //把后面的反转好后，让当前node的下一个节点的下一个指向当前节点
        //让当前节点的下一个指向空
        node.next.next = node;
        node.next = null;
        //返回新的头节点
        return newHead;
    }
~~~

### 反转部分单向链表

给定一个单链表，在链表中把第 L 个节点到第 R 个节点这一部分进行反转。

思路：找到from-1,from,to,to+1处的四个链表，如果from或者to为空，直接返回，反转from-to之间的链表，然后让from-1指向to，from指向to+1。如果from-1为空，那么to变为新链表的头结点。

~~~java
	//反转from-to之间的链表
    public static Node reversePartList(Node head, int fromIndex, int toIndex){
        if (head == null || head.next == null)
            return head;
        //找到from-1,fro,to,to+1处的链表节点
        Node fromPre = null;
        Node from = null;
        Node to = null;
        Node toPos = null;
        Node cur = head;
        int count = 0;
        //如果from和to的距离超过了链表长度，就不进行操作
        while (cur != null){
            count++;
            if (count == fromIndex - 1){
                fromPre = cur;
            }else if (count == fromIndex){
                from = cur;
            }else if (count == toIndex){
                to = cur;
            }else if (count == toIndex + 1){
                toPos = cur;
            }
            cur = cur.next;
        }
        if (from == null || to == null)
            return head;
        //反转from-to之间的结点
        Node pre = null;
        cur = from;
        Node next = null;
        while (cur != toPos){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        //如果from为头结点，新的头结点为to
        if (fromPre == null){
            head = to;
        }else {
            fromPre.next = to;
        }
        from.next = toPos;
        return head;
    }
~~~

### 两链表相交问题（五星级）

在本题中，单链表可能有环，也可能无环。给定两个链表的头节点，实现函数，如果两链表相交，返回相交的第一个节点；如果不相交，返回null即可。

要求：如果链表1的长度为N，链表2的长度为M，时间复杂度达到O（N+M），额外空间复杂度达到O（1）。

思路：遇到复杂问题进行拆解，首先需要判断两个链表是否有环，如果两个都没有环，那就是两个无环链表的相交问题；如果两个都有环，那就是两个有环链表的相交问题；如果一个有环，一个无环，是没有这种结构的。因此将问题差结成了三个，首先需要求解链表的入环节点。

判断链表是否有环有两种方法，一种是利用哈希表，如果当前节点在哈希表中，返回当前节点，否则加入哈希表，并遍历到下一个节点，此方法额外空间复杂度不为O(1)。

~~~java
public static Node getFirstLoopNode(Node head){
    HashSet<Node> set = new HashSet<Node>();
    while(head != null){
        if(set.contains(head)){
            return head;
        }
        set.add(head);
        head = head.next;
    }
    return null;
}
~~~

第二种方法是利用快慢指针，如果快指针没有遇到慢指针，快指针走2步，慢指针走1步，如果快指针后面为空，返回空。当快慢指针相遇，让快指针从链表头开始，和慢指针一起每次走一步，二者相遇的地方即为链表的入环节点。

{% asset_img 链表入环.png This is an example image %}

假设起始点到入环处的长度为`a`，环的长度为`L`，当快指针与慢指针相遇时，设慢指针所走的路程为`b`，当慢指针入环时，快指针已经在环上了，设快指针距离入环点距离为c，这时候当慢指针继续走c步时，快指针就会赶上慢指针了，c<=L，此时慢指针还没有走一圈。

当快慢指针相遇时 ，两个指针走的距离为

p慢=a+b=n

p快=a+b+k*L=2n（快指针比慢指针多走k圈）

因此有`n=a+b=k*L`。此时若让快指针从头节点重新走a步，`a=k*L-b`，对于慢指针，因为其已经走了b步，此时再走a步，正好在环上走了k圈（a+b=k*L）,因此两个指针会在入环点相遇。

判断条件是快慢指针没有相遇，而一旦快指针后面为null，返回即可。

~~~java
public static Node getLoopNode(Node head){
    if(head == null || head.next == null || head.next.next == null)
        return null;
    Node slow = head.next;
    Node fast = head.next.next;
    while(slow != fast){
        if(fast.next == null || fast.next.next == null)
            return null;
        fast = fast.next.next;
        slow = slow.next;
    }
    fast = head;
    while(slow != fast){
        slow = slow.next;
        fast = fast.next;
    }
    return slow;
}
~~~

这样便可以判断出链表是否有环。对于两个都没有环的链表，如果他们相交，则最后个节点一定相等，让更长的链表先将多的部分走完，两个链表再一起走，便会在第一个相交的地方相遇。

~~~java
//两条链表没有环的情况
public static Node noLoop(Node head1, Node head2){
    if(head1 == null || head2 == null)
        return null;
    Node cur1 = head1;
    Node cur2 = head2;
    int n = 0;
    //找到最后个节点并求两条链表长度差
    while (cur1.next != null){
        n++;
        cur1 = cur1.next;
    }
    while (cur2.next != null){
        n--;
        cur2 = cur2.next;
    }
    //最后节点不相同，一定不相交
    if(cur1 != cur2)
        return null;
    //将cur1指向更长的链表
    cur1 = n > 0 ? head1 : head2;
    cur2 = cur1 == head1 ? head2 : head1;
    n = Math.abs(n);//得到较长链表需要多走的步数
    while (n != 0){
        n--;
        cur1 = cur1.next;
    }
    //共同走到相同的节点
    while (cur1 != cur2){
        cur1 = cur1.next;
        cur2 = cur2.next;
    }
    return cur1;
}
~~~

而对于两个都有环的链表，有如下的三种结构。

{% asset_img 链表结构.png This is an example image %}

其中如果两个链表的入环节点为同一个，则是第二种结构，可以简化为无环链表的相交问题；如果入环节点不为同一个，则让一个节点从环上走一圈，如果没有碰到另一个链表的入环节点，则说明是第一种，否则返回其中一个链表的入环节点即可。

~~~java
//两个链表都有环的情况
public static Node bothLoop(Node head1, Node loop1, Node head2, Node loop2){
    //有3种情况
    Node cur1 = null;
    Node cur2 = null;
    //演变为无环链表的相交问题
    if(loop1 == loop2){
        cur1 = head1;
        cur2 = head2;
        int n = 0;
        while(cur1 != loop1){
            n++;
            cur1 = cur1.next;
        }
        while(cur2 != loop2){
            n--;
            cur2 = cur2.next;
        }
        cur1 = n > 0 ? head1 : head2;
        cur2 = cur1 == head1 ? head2 : head1;
        n = Math.abs(n);
        while(n != 0){
            n--;
            cur1 = cur1.next;
        }
        while(cur1 != cur2){
            cur1 = cur1.next;
            cur2 = cur2.next;
        }
        return cur1;
    }else{
        //遍历loop1到自己，看是否遇到loop2
        cur1 = loop1.next;
        while(cur1 != loop1){
            if(cur1 == loop2){
                return loop1;
            }
            cur1 = cur1.next;
        }
        return null;
    }
}
~~~

剩下的主方法就比较简单，求两个链表的入环节点，然后对无环链表相交，有环链表相交和一个有环一个无环进行判断即可。

~~~java
//主方法
public static Node getIntersectNode(Node head1, Node head2){
    if(head1 == null || head2 == null){
        return null;
    }
    Node loop1 = getLoopNode(head1);
    Node loop2 = getLoopNode(head2);
    if(loop1 == null && loop2 == null)
        return noLoop(head1, head2);
    if(loop1 != null && loop2 != null)
        return bothLoop(head1,loop1,head2,loop2);
    return null;
}
~~~

## 堆

堆本质是一个二叉树 ，在Java中实现为优先级队列（PriorityQueue），默认为小根堆，即最小的在最上面。可以通过在新建堆时传入比较器对象来定义大根堆或者小根堆。其中如果比较器只用到一次，没有必要去专门定义一个类，可以用匿名内部类，实现compare()方法即可，更简单的是用lambda表达式，更简洁。

堆的结构很好用，在取中位数，第k大or第k小的数，前k大or前k小，贪心中经常用到。

### 随时找到数据流的中位数

题目描述：有一个源源不断的吐出整数的数据流，假设你有足够的空间来保存吐出的数。请设计一个名叫MedianHolder的结构，MedianHolder可以随时取得之前吐出所有数的中位数。

[要求]

1. 如果MedianHolder已经保存了吐出的N个数，那么将一个新数加入到MedianHolder的过程，其时间复杂度是O(logN)。

2. 取得已经吐出的N个数整体的中位数的过程，时间复杂度为O(1)

思路：持有两个堆，一个大根堆，一个小根堆，大根堆中存放较小的一半数，小根堆中存放较大的一半数，这样中位数就被大根堆和小根堆夹着。如果两个堆大小相等，则取平均；不然就返回较多的那个堆的堆顶元素。

其中比较关键的是将数加入堆的操作，如果大根堆为空或者当前数比大根堆顶的数小，则直接放入大根堆中，否则放入小根堆。然后进行堆的调整：哪个堆中的数据比另一个堆中数据多了2个，则拿一个到另一个堆中。这样将放数和调整堆进行了**解耦**，可以让代码变得更简洁。

其中牛客网要求格式化输出数据，可以用DecimalFormat类，进行一位小数的输出。

~~~java
public class MedianHolder {
    //随时找到数据流的中位数，需要持有两个堆
    //大根堆
    private PriorityQueue<Integer> maxHeap = null;
    //小根堆
    private PriorityQueue<Integer> minHeap = null;
    // 取出所有整数部分和一位小数，格式化输出
    DecimalFormat df = new DecimalFormat("#.0");
    //构造方法，初始化
    public MedianHolder(){
        maxHeap = new PriorityQueue<Integer>((o1,o2)->o2-o1);
        minHeap = new PriorityQueue<Integer>((o1,o2)->o1-o2);
    }
    //将数添加进堆中
    public void addNum(int num){
        //如果大根堆为空或者数比大根堆顶的数小，添加到大根堆
        if (maxHeap.isEmpty() || num <= maxHeap.peek()){
            maxHeap.add(num);
        }else{
            minHeap.add(num);
        }
        //堆的调整
        modifyTwoHeap();
    }
	//调整堆
    private void modifyTwoHeap() {
        //如果大根堆比小根堆多两个，放一个进小根堆
        if (maxHeap.size() == minHeap.size() + 2){
            minHeap.add(maxHeap.poll());
        }
        if (minHeap.size() == maxHeap.size() + 2){
            maxHeap.add(minHeap.poll());
        }
    }
    //查找中位数
    public void getMedian(){
        //如果两个为空，返回空
        if (maxHeap.size() == 0){
            System.out.println(-1);
            return;
        }
        //如果两个堆中数相等，取两个堆顶平均
        if (minHeap.size() == maxHeap.size()){
            System.out.println(df.format((maxHeap.peek()+minHeap.peek())/2.0));
        }else {
            //哪个多返回哪个的
            System.out.println(df.format(maxHeap.size() > minHeap.size() ? maxHeap.peek() : minHeap.peek()));
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s = null;
        StringBuilder res = new StringBuilder();
        s = br.readLine();
        int count = Integer.valueOf(s);
        //要持有的写的类
        MedianHolder m = new MedianHolder();
        for (int i = 0; i < count; i++) {
            //读一行数据
            String[] str = br.readLine().split(" ");
            if ("2".equals(str[0])){
                m.getMedian();
            }else {
                m.addNum(Integer.valueOf(str[1]));
            }
        }
    }
}
~~~

### 切金条

题目描述：给定一个正数数组arr，arr的累加和代表金条的总长度，arr的每个数代表金条要分成的长度。规定长度为k的金条分成两块，费用为k个铜板。返回把金条分出arr中的每个数字需要的最小代价。

要求：时间复杂度为O(n log n)，空间复杂度为O(n)

题目说明：

```
如果先分成40和20两块，将花费60个铜板，再把长度为40的金条分成10和30两块，将花费40个铜板，总花费为100个铜板；
如果先分成10和50两块，将花费60个铜板，再把长度为50的金条分成20和30两块，将花费50个铜板，总花费为110个铜板；
如果先分成30和30两块，将花费60个铜板，再把其中一根长度为30的金条分成10和20两块，将花费30个铜板，总花费为90个铜板；
因此最低花费为90
```

思路：哈夫曼编码问题，即每次选出权重最小的数，新节点权重为二者相加，将新节点加入，再拿出两个，直到之后只有一个数，其值就是总的权重。

哈夫曼编码的应用：给出传递的电文，计算每个字母的权重，选出较小的两个节点构造成一个二叉树（小的在左，大的在右），新二叉树的权重为二者权重之和，然后将新二叉树放入，再重新拿出两个权重最小的。树构造好后，进行编码，左边为0，右边为1，只有叶子节点在存储了信息，这样从头节点找到叶子节点，便可以找到每个字母对应的编码。当给定了编码后，要如何去找到对应的字母呢？可以从字符串中取出字符，然后在树中进行寻找，如果找到了叶子节点，就得到了一个字母，再继续找下去。



### 做项目

题目描述：

输入：

参数1：正数数组costs

参数2：正数数组profits

参数3：正数k

参数4：正数m

参数说明：cost[i]表示i号项目的花费，profits[i]表示i号项目在扣除花费后还能挣到的钱（利润），k表示你不能并行、只能串行的最多做k个项目，m表示你初始的资金。

说明：你每做完一个项目，马上获得的收益，可以支持你去做下一个项目

输出：你最后获得的最大钱数。

分析：标准的贪心问题，选择项目的标准是：在花费比资金小的项目中，选择利润最多的，积累利润后，再选择花费比当前资金小的项目，直到做了k个项目。

思路：持有两个堆，一个小根堆，一个大根堆，小根堆依照项目花费排序，大根堆中依靠项目利润排序，从小根堆中弹出花费比当前资金少的项目进大根堆，然后从大根堆中弹出一个项目来做，累积资金，直到做了k个项目。

坑点：返回的收益需要是**long**类型，**避免溢出**！！！

~~~java
//将项目的花费和利润封装为一个节点
class proNode{
    public int c;
    public int p;
    public proNode(int c,int p){
        this.c = c;
        this.p = p;
    }
}
public class FindMaximizedCapital {
    //持有两个堆
    private PriorityQueue<proNode> minHeap;
    private PriorityQueue<proNode> maxHeap;
    public FindMaximizedCapital(){
        minHeap = new PriorityQueue<proNode>((o1,o2)->o1.c-o2.c);
        maxHeap = new PriorityQueue<proNode>((o1,o2)->o2.p-o1.p);
    }
    //计算项目最大利润
    public long findMaximizedCapital(int[] costs,int[] profits,int k,long m){
        //将花费和利润封装放进小根堆
        for (int i = 0; i < costs.length; i++) {
            minHeap.add(new proNode(costs[i],profits[i]));
        }
        //进行k次循环做项目
        for (int i = 0; i < k; i++) {
            //知道小根堆不为空且堆顶项目花费比m少，弹进大根堆
            while (!minHeap.isEmpty() && minHeap.peek().c <= m){
                maxHeap.add(minHeap.poll());
            }
            //需要考虑到大根堆为空的情况，即虽然没有到k次，但没有项目可做
            if (maxHeap.isEmpty())
                return m;
            //选出一个项目来做
            m += maxHeap.poll().p;
        }
        return m;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] str = br.readLine().split(" ");
        int n = Integer.valueOf(str[0]);
        int w = Integer.valueOf(str[1]);
        int k = Integer.valueOf(str[2]);
        String[] strC = br.readLine().split(" ");
        String[] strP = br.readLine().split(" ");
        int[] costs = new int[n];
        int[] profits = new int[n];
        for(int i = 0;i<n;i++) {
            costs[i] = Integer.parseInt(strC[i]);
        }
        for(int i = 0;i<n;i++) {
            profits[i] = Integer.parseInt(strP[i]);
        }
        FindMaximizedCapital fm = new FindMaximizedCapital();
        long win = fm.findMaximizedCapital(costs,profits,k,w);
        System.out.println(win);
    }
}
~~~

### 字符串拼接

给定一个字符串类型的数组strs，找到一种拼接方式，使得把所有字符串拼起来之后形成的字符串具有最低的字典序。

​    字典序：每个字母相当于26进制的数，如果位数相同则比较字面值，长度不能的时候，把短的补到跟长的一样，补的内容相当于ASCII表中最小的内容，然后从最高位开始比较。

比较两个字符串，若str1+str2<= str2 + str1，则str1放前面，否则str2放前面。不要去证明贪心问题。

~~~java
//比较器
public static class MyComparator implements Comparator<String>{
    @Override
    public int compare(String o1, String o2) {
        //负数认为o1小，谁作为前缀小谁放前面
        return (o1 + o2).compareTo(o2 + o1);
    }
}
//用比较器来排序
public static String lowestString(String[] strs){
    if (strs == null || strs.length == 0)
        return "";
    Arrays.sort(strs,new MyComparator());
    StringBuilder sb = new StringBuilder();
    for (String s : strs){
        sb.append(s);
    }
    return sb.toString();
}
~~~

## 树

### 树的深度遍历

#### 递归遍历方法

先序遍历：先中、再左、再右。对每一个结点，先打印当前结点，再打印其左子树所有结点，再打印右子树所有结点。

中序遍历：先左、再中、再右。对每一个结点，先打印其左子树所有结点，再打印当前结点，再打印右子树所有结点。

后序遍历：先左、再右、再中。对每一个结点，先打印其左子树所有结点，再打印右子树所有结点，再打印当前结点。

~~~java
//先序打印二叉树的递归实现
public static void preOrderRecur(Node head){
    if(head == null)
        return;
    //先打印当前节点
    System.out.print(head.value+" ");
    //递归打印左子树
    preOrderRecur(head.left);
    //递归打印右子树
    preOrderRecur(head.right);
}
//中序打印二叉树的递归实现
public static void inOrderRecur(Node head){
    if(head == null)
        return;
    //先打印左子树，再打印中间，再打印右子树
    inOrderRecur(head.left);
    System.out.print(head.value +" ");
    inOrderRecur(head.right);
}
//后序打印二叉树的递归实现
public static void posOrderRecur(Node head){
    if (head == null)
        return;
    //先打印左子树，再打印右子树，再打印当前节点
    posOrderRecur(head.left);
    posOrderRecur(head.right);
    System.out.print(head.value + " ");
}
~~~

#### 非递归遍历方法

先序遍历用栈结构实现，顺序为先中，再左，再右。将头结点放入栈，如果栈不为空，弹出当前节点，弹出就打印。如果右不为空，把右边的放入栈中。如果左不为空，把左边的放入栈中。为了让先弹左，再弹右，因此放入栈的时候要先右再左。

~~~java
//先序遍历非递归实现
public static void preOrderUnRecur(Node head){
    System.out.print("pre-order: ");
    if(head != null){
        //准备一个栈
        Stack<Node> stack = new Stack<Node>();
        //将头结点压入
        stack.add(head);
        //只要栈不为空
        while (!stack.isEmpty()){
            //弹出并打印头结点
            head = stack.pop();
            System.out.print(head.value+" ");
            //如果右节点不为空，压入
            if(head.right != null){
                stack.push(head.right);
            }
            //如果左节点不为空，压入
            if(head.left != null){
                stack.push(head.left);
            }
        }
    }
    System.out.println();
}
~~~

中序遍历用栈结构实现，顺序为先左，再中，再右。栈中先放所有的左边界，head从头往左移动，直到空，这样所有的左边界都到栈中了。当往左移动不下去了，从栈中弹出一个并打印，并向右移动。

​    因为从中一直往左压栈，因此弹出的时候一定是从左到中，往右跑是因为要把右子树也按照这种方法压入栈。那么整个顺序是先左再中再右。

~~~java
//中序遍历非递归实现
public static void inOrderUnRecur(Node head){
    System.out.println("in-order: ");
    if(head != null){
        Stack<Node> stack = new Stack<>();
        //只要栈不为空或者head不为空就循环
        while (!stack.isEmpty() || head != null){
            //如果head不为空，一直将左节点压入栈
            if(head != null){
                stack.push(head);
                head = head.left;
            }
            //如果head为空，弹出并打印栈中元素，
            else{
                head = stack.pop();
                System.out.print(head.value + " ");
                head = head.right;
            }
        }
    }
    System.out.println();
}
~~~

后续遍历是先左再右再中。中左右，是先弹出中，然后压入右，压入左。那么中右左就是先弹出中，然后压入左，压入右。然后该打印的时候不打印，放入一个help，再弹出来，就是先左再右再中了。

~~~java
//后序遍历非递归实现
public static void posOrderUnRecur(Node head){
    System.out.println("pos order: ");
    if(head != null){
        Stack<Node> stack = new Stack<>();
        Stack<Node> help = new Stack<>();
        //先把头节点压入
        stack.push(head);
        while (!stack.isEmpty()){
            head = stack.pop();
            //该输出的时候弹入辅助栈
            help.push(head);
            //先压左后压右
            if(head.left != null){
                stack.push(head.left);
            }
            if(head.right != null){
                stack.push(head.right);
            }
        }
        //将辅助栈中数据弹出
        while (!help.isEmpty()){
            System.out.print(help.pop().value+" ");
        }
    }
    System.out.println();
}
~~~

#### 折纸问题

{% asset_img 折纸.png This is an example image %}

这个问题实质是二叉树的中序遍历问题，头结点为下，左孩子为下，右孩子为下，用递归方式解决，递归函数参数列表有当前树高度，为左还是右（左为下，右为上）

{% asset_img 折纸树.png This is an example image %}

~~~java
    //直观打印折纸
    //本质上是树的中序遍历，左结点为下，右结点为上，头节点为下
    //用递归实现，功能是中序打印二叉树，需要传入当前树的高度，左还是右
    //因为只有两种可能，所以可以用布尔类型的变量来表示
    public static void printAllFolds(int N){
        printProcess(1,N,true);
    }

    private static void printProcess(int i, int n, boolean b) {
        //base case
        if (i > n)
            return;
        //left,cur,right
        printProcess(i+1,n,true);
        System.out.println(b ? "下" : "上");
        printProcess(i+1,n,false);
    }
~~~

#### 在二叉树中找到一个节点的后继节点

现在树结点多了一个parent结点，指向父节点，头节点的parent指向null。只给一个在二叉树中某个节点node，实现返回node的后继节点的函数。在二叉树的后序遍历的序列中，node的下一个节点叫做node的后继节点。

中序遍历为左、中、右，考虑当前节点为中的情况，因此如果有右子树，后继节点应该是右子树的最左结点。当前节点如果为左，其为父节点的左孩子，则父节点就是后继节点。如果当前节点为右，表明其所在的左子树已被遍历完，需要找到某个节点，其为父节点的左孩子，返回此父节点。

~~~java
public static Node getNextNode(Node node){
    if(node == null)
        return null;
    //node有右子树，找到右子树最左节点
    if(node.right != null){
        return getLeftMost(node.right);
    }
    //没有右子树
    else {
        Node parent = node.parent;//拿到父节点
        //只要此节点不为父节点的左子树
        //跳到node是parent左节点停，返回parent
        //加上Parent不为空是为了兼顾没有后继的情况
        //其中parent不为空要放在前面，不然就算空了，因为parent左孩子不为node，循环仍继续
        while (parent != null && parent.left != node){
            //当前节点不是父节点的左孩子则继续
            node = parent;
            parent = node.parent;
        }
        return parent;
    }
}
//找最左节点
public static Node getLeftMost(Node node){
    if(node == null){
        return node;
    }
    while (node.left != null){
        node = node.left;
    }
    return node;
}
~~~

#### 树的先序方式序列化与反序列化

中、左、右。将遍历的结果用字符串进行记录。当一个节点的左子树为空时，可以用一个特殊符号来记录，如#。

序列化思路：利用递归来进行中序遍历，如果是空节点，则添加#！，如果不为空，添加value!，然后遍历左子树与右子树。

~~~java
public static String serialByPre(Node head){
    if (head == null){
        return "#!";
    }
    //中、左、右的递归
    String res = head.value + "!";
    res += serialByPre(head.left);
    res += serialByPre(head.right);
    return res;
}
~~~

反序列化思路：将字符串用！进行分割，然后将数组中的字符一个个构造成节点，可以将其加入到队列中，也可以用index+数组来取，这样当为#，返回空，构造一个新节点，递归构造其左子树与右子树，然后返回头节点。

~~~java
//前序方式反序列化
public static Node reconByPreString(String preStr){
    //分割字符串
    String[] values = preStr.split("!");
    Queue<String> queue = new LinkedList<>();
    //将所有元素加入到队列，用数组也可以，需要传递下标
    for (int i = 0; i != values.length; i++) {
        queue.offer(values[i]);
    }
    return reconPreOrder(queue);
}
//给一个队列建立树
public static Node reconPreOrder(Queue<String> queue){
    String value = queue.poll();
    //空节点
    if (value.equals("#")){
        return null;
    }
    //建立新节点等于head
    Node head = new Node(Integer.valueOf(value));
    //左、右子树分别交给递归去实现
    head.left = reconPreOrder(queue);
    head.right = reconPreOrder(queue);
    return head;
}
~~~

#### 树的层序方式序列化与反序列化

层序方式也是广度优先遍历。

序列化思路：将头节点加入队列，并将其添加进StringBuilder，从队列中弹出一个节点，将其左右子树的值加入，没有就加入#，而不选择在弹出的时候添加是因为空节点无法加入队列。如果左子树不为空，加入队列；如果右子树不为空，加入队列。

~~~java
	//按层序列化
    public static String serialByLevel(Node head){
        if (head == null)
            return null;
        StringBuilder sb = new StringBuilder();
        Queue<Node> queue = new LinkedList<>();
        queue.offer(head);
        sb.append(head.value).append("!");
        while (!queue.isEmpty()){
            head = queue.poll();
            //在节点进去的时候就添加，不然添加不了空节点
            if (head.left != null){
                queue.offer(head.left);
                sb.append(head.left.value).append("!");
            }else {
                sb.append("#!");
            }
            if (head.right != null){
                queue.offer(head.right);
                sb.append(head.right.value).append("!");
            }else {
                sb.append("#!");
            }
        }
        return sb.toString();
    }
~~~

按层方式反序列化 思路：将字符串分割，建造头节点并放入队列中，记录头节点。从队列中弹出一个节点，建造其左子树与右子树，如果左子树不为空，加入队列；如果右子树不为空，加入队列。此处用index+数组来控制当前要利用的字符串。

~~~java
//按层方式反序列化
    public static Node reconByLevelString(String levelStr){
        //将字符串分割
        String[] str = levelStr.split("!");
        int value = 0;
        //产生头节点，并放进队列中
        Node res = generateNode(str[value++]);
        Node head = res;
        Queue<Node> queue = new LinkedList<>();
        queue.offer(head);
        while (!queue.isEmpty()){
            head = queue.poll();
            head.left = generateNode(str[value++]);
            head.right = generateNode(str[value++]);
            if (head.left != null){
                queue.offer(head.left);
            }
            if (head.right != null){
                queue.offer(head.right);
            }
        }
        return res;
    }
~~~

#### 判断树是否为平衡二叉树

平衡二叉树中，在任何一个节点，左子树与右子树高度差，不超过1。

思路：以每一个节点为头节点的树为平衡二叉树，总体才是，对当前节点，需要其左子树为平衡二叉树，右子树为平衡二叉树，两个子树高度差不超过1，才是平衡二叉树。可以用树的后序遍历递归方式解决，当前函数需要给下一级函数传递当前子树是否平衡，树的高度，如果树不平衡，则高度没有用。可以将是否平衡与树的高度信息进行封装。关键是看函数功能是什么，需要传递什么参数。

平衡性用来解决效率问题。

~~~java
public static boolean isB(Node head){
    return process(head).isB;
}
public static ReturnData process(Node head){
    //空树是高度为0的平衡树
    if (head == null)
        return new ReturnData(true, 0);
    ReturnData leftData = process(head.left);
    //左子树不平衡，则直接不平衡
    //在不满足时高度为0是因为高度用不上
    if (!leftData.isB) {
        return new ReturnData(false, 0);
    }
    ReturnData rightData = process(head.right);
    if (!rightData.isB){
        return new ReturnData(false, 0);
    }
    //左、右树均平衡
    if (Math.abs(leftData.h - rightData.h) > 1){
        return new ReturnData(false, 0);
    }
    //在满足的时候，子结构要给父过程提供高度，为二者中较高的+1
    return new ReturnData(true,Math.max(leftData.h, rightData.h)+1);
}
~~~

# 剑指Offer

## 数组

### 数组中重复数字

#### 允许修改数组

长度为n的数组里所有数字均出现在o~n-1的范围内，数组内某些数字是重复的，但不知道几个重复了，也不知道数字重复了几次。找出数组中任意一个重复的数字。如 ，长度为7的数组{2,3,1,0,2,5,3}，对应的输出为重复数字为2或者3。

方法1：使用哈希表，如果一个元素添加进哈希表了，就返回此元素，如果没有加入过，就加入。

时间复杂度O(n)，额外空间复杂度O(n)。

~~~java
    //使用哈希表
    public static Integer findNumHash(int[] arr){
        if (arr == null || arr.length < 2)
            return null;
        HashSet<Integer> set = new HashSet<>();
        for (int i = 0; i < arr.length; i++) {
            if (set.contains(arr[i]))
                return arr[i];
            else
                set.add(arr[i]);
        }
        return null;
    }
~~~

这种情况下解决的是找到第一个重复元素的问题，但是要额外建立一个哈希表。

方法2：抽屉原理

如果有n个数分布为0-n-1，在没有重复的时候，必然是一个萝卜一个坑，即可以将值为`i`的元素（i=0~n-1）放在第`i`个坑中，但是因为有重复的元素存在，会出现在第`i`个坑中值不为i的情况，这时候可以将它放在它原本应在的地方，直到当前坑中放了对应的萝卜，如果此时第`i`个坑中元素为`k`，但第`k`个坑中元素也为`k`，说明当前元素就是重复的。

总的时间复杂度为O(n)，额外空间复杂度O(1)。

~~~java
//找到第一个重复的数字，抽屉原理
    public static Integer findNum(int[] arr){
        if (arr == null || arr.length < 2)
            return null;
        //如果数组的长度不在0-arr.length-1之间，返回
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] < 0 || arr[i] > arr.length-1)
                return null;
        }
        //从第一个到最后一个
        //如果当前数和角标不等，交换，直到相等或和要交换角标处的值相等
        for (int i = 0; i < arr.length; i++) {
            while (arr[i] != i){
                if (arr[i] == arr[arr[i]]){
                    return arr[i];
                }
                //swap(arr,i,arr[i])
                int temp = arr[i];
                arr[i] = arr[arr[i]];
                //不能直接使用arr[arr[i]]，因为此时arr[i]已经变化了
                arr[temp] = temp;
            }
        }
        return null;
    }
~~~

#### 不修改数组找到重复数字

在长度为n+1的数组里的所有数字都在1~n的范围之内，因此数组中至少有一个数字是重复的。找出任意一个重复的数字，但不能修改输入的数组，如输入长度为8的数组{2,3,5,4,3,2,6,7}，输出为重复的数字2或者3。额外空间复杂度为O(1)。

不能使用哈希表，不能使用抽屉原理，这时候可以考虑二分。因为如果`1~n`的数字没有重复，那么`1~(n-1)/2`和`(n-1)/2+1~n`中元素个数应该和其角标left-right之间的范围相同，但是因为有重复的，那么假设重复数字为3，那么`1~7`分为`1~4`和`5~7`，这时候`1~4`中的元素个数肯定会多于4，然后再到`1~4`中进行寻找，直到找到left=right，如果这时候left值的数字出现个数>1，则输出left。

用到的为二分的模板

核心为

1. left与right的取值很重要，需要夹住所有可能的情况
2. while循环中用left < right，这样退出循环的时候一定有left==right，不用思考返回left还是right
3. mid选择左中位数（left + ((right - left) >> 1)）或者右中位数（left + ((right - left+1) >> 1)）
4. 只用两个判断，一次排除一半的结果
5. 可以选择是否在循环结束后对夹住的数进行判断

~~~java
int left = 数1, right = 数2;
while(left < right){
    int mid = left + ((right - left) >> 1);
    if(判断条件1){
        left = mid + 1;
    }else{
        right = mid;
    }
    //或者
    if(判断条件1){
        right = mid - 1;
    }else{
        left = mid;
    }
}
//在while结束后，对left处的值选择性进行判断
//多种输出可能
return left;
return arr[left];
return -1;
~~~

此题具体的实现代码如下

~~~java
//使用二分的思路
    public static Integer findNum2(int[] arr){
        if (arr == null || arr.length < 2)
            return null;
        //看是否在0-n-1范围之内
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] < 0 || arr[i] > arr.length-1)
                return null;
        }
        //二分，看哪边的数字更多，再继续找
        int left = 1, right = arr.length - 1;
        while (left < right){
            int mid = left + ((right-left) >> 1);
            //计算个数
            int count = getFre(arr,left,mid);
            if (count > mid + 1 - left){
                right = mid;
            }else {
                //去另一半
                left = mid+1;
            }
        }
        int count = getFre(arr,left,right);
        if (count > 1)
            return left;
        //没有找到
        return -1;
    }
    //统计在l-m之间出现的次数
    private static int getFre(int[] arr, int l, int m) {
        int count = 0;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] >= l && arr[i] <= m){
                count++;
            }
        }
        return count;
    }
~~~

## 字符串

### 替换空格

请实现一个函数，把字符串中的每个空格替换成“%20”，如输入“We are happy”，则输出“We%are%happy”

方法一：一开始的思路是直接将字符串利用空格split，得到用空格隔开的字符串数组，再将字符串数组添加进StringBuilder，然后添加一个%20，最后一个字符串则不添加，如果是w空格空格w，得到的字符串数组为“w”、“”、“w”，这样输入n个空格，得到n-1个为空的字符串，然后w后添加一个%20，再添加空添加%20，最后添加一个w，是符合要求的。

其中如果没有空格，直接返回当前字符串即可。

~~~java
    public static String replaceBlank(String str){
        String[] strAf = str.split(" ");
        if (strAf.length == 1)
            return strAf[0];
        StringBuilder res = new StringBuilder();
        for (int i = 0; i < strAf.length-1; i++) {
            res.append(strAf[i]).append("%20");
        }
        res.append(strAf[strAf.length - 1]);
        return res.toString();
    }
~~~

方法二：如果不依赖Java的split函数，可以先统计传入的字符串str中空格的个数，然后建造一个新的字符数组，其长度为str非空格字符长度+空格个数*待替换字符串长度，然后用两个指针，一个遍历str，一个指向新的字符数组末尾，如果str当前不为空格，直接复制到新数组，新数组指针移动；如果str当前为空格，新数组从后逐个拷贝传入的字符串，直到遍历完str。

其中要注意的是新数组长度，需要先将原数组长度减去空格，再加上空格长度乘待替换字符串长度。如果不减去空格长度，新数组前面会有空余。如果没有空格，直接返回输入字符串即可

~~~java
 //不用系统的split方法，先统计插入后的字符个数，再从最后一个开始插入
    public static String replaceBlank2(String str, String s){
        //统计str空格数量及s长度
        int spCount = 0;
        int sSize = s.length();
        //统计str中空格个数
        for (int i = 0; i < str.length(); i++) {
            if (' '==str.charAt(i)){
                spCount++;
            }
        }
        if (spCount == 0)
            return str;
        //非空格字符数+替换后的字符数
        int newSize = str.length() - spCount + spCount * sSize;
        char[] res = new char[newSize];
        //两个指针，一个指向strArr，一个指向res
        int p1 = str.length() - 1;
        int p2 = res.length - 1;
        for (; p1 >= 0; p1--) {
            char c = str.charAt(p1);
            if (' ' != c){
                //当前不为空格，直接复制
                res[p2--] = c;
            }else {
                //如果为空格，p2拷贝s
                for (int i = sSize - 1; i >= 0; i--) {
                    res[p2--] = s.charAt(i);
                }
            }
        }
        return new String(res);
    }
~~~

## 链表

### 反向打印链表

输入一个链表的头节点，从尾到头反过来打印出每个节点的值。

方法1：遍历链表，将值存入栈。遍历栈，弹出值。

~~~java
    //反向打印链表
    public static String reversePrint(Node node){
        if (node == null)
            return null;
        StringBuilder sb = new StringBuilder();
        Stack<Integer> stack = new Stack<>();
        while (node != null){
            stack.push(node.value);
            node = node.next;
        }
        while (!stack.isEmpty()){
            sb.append(stack.pop()).append(" ");
        }
        return sb.toString();
    }
~~~

方法2：既然有用到栈 ，那么也可以用递归来实现，递归函数的功能是打印此节点后面的节点。基本过程是调用递归函数，然后打印当前节点。

~~~java
    //既然有用到栈，那么就可以用递归来实现，先打印后面的，然后打印当前的
    public static String reversePrint2(Node node){
        if (node == null)
            return null;
        StringBuilder sb = new StringBuilder();
        process(node,sb);
        return sb.toString();
    }
    private static void process(Node node, StringBuilder sb) {
        //递归来实现
        //base case
        if (node == null){
            return;
        }
        //递归后面的节点
        process(node.next,sb);
        //打印当前节点
        sb.append(node.value).append(" ");
    }
~~~





