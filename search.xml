<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>前端学习</title>
    <url>/2020/02/13/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<blockquote>
<p>html与css相关学习</p>
</blockquote>
<p>​    HTML用于描述页面的结构，CSS用于控制页面中元素的样式，JavaScript用于响应用户操作</p>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="HTML简介"><a href="#HTML简介" class="headerlink" title="HTML简介"></a>HTML简介</h3><p>HTML（Hypertext Markup Language）为超文本标记语言，负责结构，使用标签的形式来标识网页中的不同组成部分，所谓超文本指的是超链接，使用超链接可以实现页面间的跳转。</p>
<a id="more"></a>

<ul>
<li><p>纯文本：只能保持文本内容，图片、音频、视频等格式化的内容都不能设置，网页就是纯文本编写的。</p>
</li>
<li><p>标签：给组成部分做标记，标签一般是成对出现的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>文本<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>网页标准标签：</p>
<ul>
<li><p>根标签：html，网页所有内容应该写在根标签里面</p>
</li>
<li><p>两个子标签</p>
<ul>
<li><p>head</p>
<p>设置网页头部信息，有title子标签，title中内容不会在网页中直接显示，默认显示在浏览器的标题栏中，搜索引擎在检索页面时，会首先检索title中的内容，是网页中对于搜索引擎最重要的内容，会影响到网页在搜索引擎中的排名。title一般为SEU写。</p>
<p>head帮助浏览器解析</p>
</li>
<li><p>body</p>
<p>网页主体，页面中所有可见内容应写在body中</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span></span><br><span class="line">        好网页</span><br><span class="line">		<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">		第一个网页</span><br><span class="line">		<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/2020/02/13/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5.png" class title="This is an example image">

<h3 id="HTML注释"><a href="#HTML注释" class="headerlink" title="HTML注释"></a>HTML注释</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释 --&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>可以通过属性来处理标签中的内容。可以在开始标签中添加属性，在标签后空格，然后key=“value”。实际为名值对的结构，值一定要加引号。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"red"</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">font</span>&gt;</span>网页</span><br></pre></td></tr></table></figure>

<p>​    可以通过文档查阅标签中具体属性。</p>
<h3 id="HTML版本"><a href="#HTML版本" class="headerlink" title="HTML版本"></a>HTML版本</h3><p>最早为HTML，中间有XHTML，现在为HTML5，为了让浏览器识别正确版本，在head前面需要加上文档说明。</p>
<p>H5的文档说明为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    编写网页时要将H5的文档说明写在网页最上面，如果不写声明，可能会让某些浏览器进入怪异模式，浏览器解析页面可能会无法正常显示。怪异模式是网页为了兼容旧的模式设置的。</p>
<h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><p>几进制就是满几进1。</p>
<p>16进制：0-9，a-f</p>
<h3 id="乱码"><a href="#乱码" class="headerlink" title="乱码"></a>乱码</h3><p>编码与解码字符集不一样。</p>
<p>中文系统默认GB2312，UTF-8万国码，支持地球上所有的文字，开发时使用UTF-8。</p>
<p>在中文的浏览器中，默认都是使用GB2312进行解码。</p>
<p>​    或者告诉浏览器网页采用的编码字符集,meta标签用来设置网页的元数据，如网页的字符集，关键字，简介，meta是自结束标签。编写自结束标签时，可以在开始标签中添加一个/</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>放在title前。ANSI为智能编码，采用系统的默认编码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>网页的标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个漂亮的网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span>	</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>html,css</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2020/02/09/MySQL/</url>
    <content><![CDATA[<blockquote>
<p>尚硅谷MySQL课程笔记</p>
</blockquote>
<h1 id="数据库操作基础"><a href="#数据库操作基础" class="headerlink" title="数据库操作基础"></a>数据库操作基础</h1><h2 id="数据库概述"><a href="#数据库概述" class="headerlink" title="数据库概述"></a>数据库概述</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><strong>可将数据持久化到硬盘</strong></li>
<li><strong>可存储大量数据</strong></li>
<li><strong>方便检索</strong></li>
<li>保证数据的一致性，完整性</li>
<li>安全，可共享</li>
<li>通过组合分析，可以产生新数据</li>
</ul>
<a id="more"></a>

<h3 id="常见数据库产品"><a href="#常见数据库产品" class="headerlink" title="常见数据库产品"></a>常见数据库产品</h3><ul>
<li>Oracle：甲骨文（产品免费，服务收费）</li>
<li>DB2：IBM（兼容性相对不好）</li>
<li>SQL Server：微软（兼容性不好）</li>
<li>MySQL：甲骨文（开源，免费，性能高）</li>
</ul>
<h3 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h3><ul>
<li><p>DB</p>
<p>数据库（database）：存储数据的“仓库”，保存了一系列有组织的数据</p>
</li>
<li><p>DBMS</p>
<p>数据库管理系统（Database Management System）：数据库是通过DBMS创建和操作的容器</p>
</li>
<li><p>SQL</p>
<p>结构化查询语言（Structure Query Language）：专门用来与数据库软件通信的语言</p>
</li>
</ul>
<h3 id="数据库存储数据特点"><a href="#数据库存储数据特点" class="headerlink" title="数据库存储数据特点"></a>数据库存储数据特点</h3><ul>
<li>将数据放到<strong>表</strong>中，表再放到库中</li>
<li>一个数据库可以有多个表，每个表有唯一性的用于标识的表名</li>
<li>表的<strong>特性</strong>定义了数据在表中如何存储，类似java中“类”的设计</li>
<li>表由<strong>列</strong>组成，也称为字段。所有表都是由一个或多个列组成，每一列类似java中的“<strong>属性</strong>”</li>
<li>表中的数据按<strong>行</strong>存储，每一行类似java中的“<strong>对象</strong>”</li>
</ul>
<h2 id="MySQL数据库介绍"><a href="#MySQL数据库介绍" class="headerlink" title="MySQL数据库介绍"></a>MySQL数据库介绍</h2><p>​    MySQL是一种开源的关系型数据库管理系统，广泛应用在中小型网站中。</p>
<h3 id="DBMS分类"><a href="#DBMS分类" class="headerlink" title="DBMS分类"></a>DBMS分类</h3><ul>
<li><p>基于共享文件系统的DBMS（Access）</p>
</li>
<li><p>基于客户机–服务器的DBMS   C/S  （MySQL，Oracle，SqlServer）</p>
<p>主要安装服务端。</p>
</li>
</ul>
<h3 id="MySQL安装与启动"><a href="#MySQL安装与启动" class="headerlink" title="MySQL安装与启动"></a>MySQL安装与启动</h3><p>​    默认端口号3306，要先开启服务端，以管理员身份开cmd输入net start mysql5.5，后面为自定义的mysql服务名，然后开启mysql服务，普通用户打开cmd，输入mysql -u用户名 -p密码，即可。</p>
<p>使用exit退出，也可以mysql -uroot -p，然后再输入密码，这样可以隐藏密码。</p>
<p>连接其他主机上的数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -h主机名 -P端口号 -u用户名 -p密码</span><br></pre></td></tr></table></figure>

<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="demo：创建表并添加信息"><a href="#demo：创建表并添加信息" class="headerlink" title="demo：创建表并添加信息"></a>demo：创建表并添加信息</h3><p>命令要以分号 ; 或者 \g 结尾，建议;</p>
<ul>
<li><p>show databases; 看数据库有哪些</p>
<ul>
<li><p>information_schema 服务端基本信息数据</p>
</li>
<li><p>mysql 用户信息，表信息等</p>
</li>
<li><p>performance_schema 性能分析</p>
<p><strong>前三个都不要改动！！！</strong></p>
</li>
<li><p>test </p>
<p>默认为空</p>
</li>
</ul>
</li>
<li><p>use mysql; 使用某个数据库</p>
</li>
<li><p>show tables; 显示表</p>
</li>
<li><p>show tables from test; 直接看某个数据库的表 不影响当前库，因为<strong>没有使用use切换库</strong>。</p>
</li>
<li><p>select database();查看当前所在库</p>
</li>
<li><p>建立类来存学生信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stuinfo(  换行</span><br><span class="line">//相当于新建类</span><br><span class="line">stuid <span class="built_in">int</span>,  //学生<span class="keyword">id</span>，<span class="built_in">int</span>类型，用逗号隔开</span><br><span class="line">stuname <span class="built_in">varchar</span>(<span class="number">20</span>),  //学生姓名，字符串或者字符均为<span class="built_in">varchar</span>类型，需要 指定长度</span><br><span class="line">gender <span class="built_in">char</span>,  //性别，单个字符</span><br><span class="line">borndate datetime);   //生日，不存年龄是因为年龄会变，最后一个加反括号和分号结束</span><br></pre></td></tr></table></figure>
</li>
<li><p>desc stuinfo; 看表结构  describe</p>
</li>
<li><p>select * from stuinfo; 查看表中数据</p>
</li>
<li><p>set names gbk; 更改服务端编码集</p>
</li>
<li><p>insert into stuinfo values(1,’张无忌’,’男’,’1998-3-3’);</p>
<p>插入数据，如果客户端与服务端编码格式不符，需要更改，除了数字均用引号括起来</p>
</li>
<li><p>update stuinfo set borndate=‘1980-1-1’ where stuid = 2;</p>
<p>更新表格设置生日，只更改id=2的。</p>
</li>
<li><p>delete from stuinfo where stuid = 1;</p>
<p>删除id=1的数据。</p>
</li>
<li><p>alter table stuinfo add column email varchar(20);</p>
<p>alter(改变)修改表结构，添加列column email 类型为varchar(20)。</p>
</li>
<li><p>drop table stuinfo; 干掉表</p>
</li>
</ul>
<h3 id="语法注意事项"><a href="#语法注意事项" class="headerlink" title="语法注意事项"></a>语法注意事项</h3><ol>
<li><p>不区分大小写，但建议关键字大写，表名、列名小写</p>
</li>
<li><p>每条命令最好用分号结尾</p>
</li>
<li><p>每条命令如果根据需要，可以进行缩进或换行</p>
<p>关键字最好单独一行</p>
</li>
<li><p>注释</p>
<ul>
<li>单行注释：#注释文字</li>
<li>单行注释：– 注释文字，中间要有空格</li>
<li>多行注释：/* 注释文字 */</li>
</ul>
</li>
</ol>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>DDL（Data Definition Language）：数据定义语言，用来定义数据库对象：库、表、列等；</p>
<p>create/drop/alter</p>
</li>
<li><p><strong>DML</strong>（Data Manipulation Language）：数据操作语言，用来定义数据库记录（数据）；</p>
<p><strong>insert/update/delete</strong></p>
</li>
<li><p>DCL（Data Control Language）：数据控制语言，用来定义访问权限和安全级别；</p>
<p>TCL(Transaction Control Language)</p>
</li>
<li><p><strong>DQL</strong>（Data Query Language）：数据查询语言，用来查询记录（数据）。</p>
<p><strong>select</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM学习</title>
    <url>/2020/01/16/JVM%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<blockquote>
<p>JVM从入门到精通</p>
<p><a href="https://www.bilibili.com/video/av83622425?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/av83622425?p=1</a></p>
</blockquote>
<h1 id="内存与垃圾回收"><a href="#内存与垃圾回收" class="headerlink" title="内存与垃圾回收"></a>内存与垃圾回收</h1><p>​    程序构建在基础框架，Java的API和JVM之上，需要关注底层的实现方式。</p>
<a id="more"></a>

<h2 id="JVM与Java体系结构"><a href="#JVM与Java体系结构" class="headerlink" title="JVM与Java体系结构"></a>JVM与Java体系结构</h2><h3 id="面向人群"><a href="#面向人群" class="headerlink" title="面向人群"></a>面向人群</h3><ul>
<li>参与现有系统的性能优化，重构，保证平台性能和稳定性</li>
<li>根据业务场景和需求，决定即使方向，做技术选型</li>
<li>能够独立架构和设计海量数据下高并发式解决方案，满足功能和非功能需求</li>
<li>解决各类潜在系统风险，核心功能的架构与代码编写</li>
<li>分析系统瓶颈，解决各项疑难杂症，性能调优等</li>
</ul>
<h1 id="字节码与类的加载"><a href="#字节码与类的加载" class="headerlink" title="字节码与类的加载"></a>字节码与类的加载</h1><h1 id="性能监控与调优"><a href="#性能监控与调优" class="headerlink" title="性能监控与调优"></a>性能监控与调优</h1><h1 id="大厂面试"><a href="#大厂面试" class="headerlink" title="大厂面试"></a>大厂面试</h1>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记</title>
    <url>/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>黑马程序员视频学习笔记</p>
</blockquote>
<h1 id="视频笔记"><a href="#视频笔记" class="headerlink" title="视频笔记"></a>视频笔记</h1><h2 id="面对对象"><a href="#面对对象" class="headerlink" title="面对对象"></a>面对对象</h2><h3 id="零碎"><a href="#零碎" class="headerlink" title="零碎"></a>零碎</h3><p>javac先编译，生成class文件然后java运行类，一个类中运行需要有一个主函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">pulic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>类名首字母必须大写，如果设定了CLASSPATH，则不用在类名前面加上pulic</p>
<p>Javadoc.exe可以提取java中的注释文档，在写程序的时候，注意在最前面加上注释，包括程序用途，算法说明，在没有思路的时候可以一步一步写出每一步需要实现的功能，代码只是算法功能的<strong>另一种表述</strong>。</p>
<p>若不知道错误出在哪里可以部分注释用来缩小出错范围</p>
<p>8进制是三位的二进制，用0开头，16进制是四位的二进制，用0x开头。</p>
<p>一个2进制为一个bit，一个byte字节为8个二进制位</p>
<p>整数默认<strong>int</strong> 小数默认<strong>double</strong></p>
<p>java里面+号可以表示运算符也可以表示成连接符，如Systen.out.println(a+’,’+b)；</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li><p>^异或，两边结果不同才为真，两边结果相同则为假</p>
</li>
<li><p>&amp;&amp;双与，只要左边为假，右边不运算，若想让右边参与运算，用&amp;</p>
</li>
<li><p>||双或，只要左边为真，右边不运算，若想让右边参与运算，用|</p>
<p>进行循环条件判断的时候，用&amp;&amp;和||效率会更高</p>
</li>
</ul>
<p>而对于位运算符，6&amp;3代表转换为二进制110&amp;011，则全为1则与后为1，否则为0，结果为010，所以6 &amp; 3 = 2；6|3 ，只要二进制位有一个为1则结果为1，所以6|3 = 111(2进制)=7（10进制）</p>
<p>一个数异或同一个数两次，结果还是这个数（<strong>数据加密</strong>）</p>
<p><del>6，相当于对6的每一位进行取反，6全部取反加一得到-6，所以</del>6 = -7</p>
<p>3&lt;&lt;2，表示3左移两位，即0011变为1100,3&lt;&lt;2=12，左移几位就是该数乘以2的几次方，即为&lt;&lt;可以完成2的次幂运算；而对于&gt;&gt;，右移几位就是除以2的几次幂，对于高位保持原来的数字，以保证符号不变。而对于&gt;&gt;&gt;，无论原来高位是什么，都用0来补</p>
<p>想要运算变得高效，首选位运算</p>
<p>​    三元运算符</p>
<blockquote>
<p> （条件表达式）？表达式1：表达式2；</p>
</blockquote>
<p><strong>a)</strong> <strong>判断条件表达式，结果为一个布尔值。</strong></p>
<p><strong>b) true**</strong>，运算结果为表达式<strong>**1</strong></p>
<p><strong>c) false**</strong>，运算结果为表达式<strong>**2</strong></p>
<p>​    局部代码块可以定义局部变量的生命周期</p>
<p>​    switch关键字：switch,case,break,default，可以处理的数据类型是byte,short,int,char</p>
<p>​    break 跳出当前循环，并结束此次循环</p>
<p>​    do while相比while，无论条件是否满足，至少执行一次循环内容，应用相对比较少。</p>
<p>​    for(初始化表达式；循环条件表达式；循环后的操作表达式)</p>
<p>​    其中初始化表达式只在最开始进行执行（执行一次），然后运行条件表达式判断是否循环，如果是则进入循环内执行语句，然后运行循环后的操作表达式。</p>
<h3 id="制表符"><a href="#制表符" class="headerlink" title="制表符"></a>制表符</h3><p>\t为制表符，用于将数据对齐  \n回车  \b退格  \r按下回车键</p>
<p>windows系统中，回车符由两个符号组成，为\r\n linux中回车符为\n</p>
<p>转义字符对后面的字符含义进行转义，如果想输出”，则需要使用\”，在前面加上\</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="定义函数格式"><a href="#定义函数格式" class="headerlink" title="定义函数格式"></a>定义函数格式</h4><p> 修饰符 返回值类型 函数名（参数类型 形式参数1，参数类型 形式参数2，…）</p>
<p>{</p>
<p>   执行语句；</p>
<p>   return 返回值；</p>
<p>}</p>
<p> 如果函数名字有两个以上的单词，第一个单词首字母小写，从第二个单词开始要大写，需要去区分是类还是函数。</p>
<p> 如果函数中没有返回值类型，则用void，可以省略return。</p>
<p> 函数中可以调用其他函数，但是不可以定义其他函数</p>
<p>在内存中，java内存为栈的形式，先进后出，调用的函数结束后即被清理出内存</p>
<h4 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h4><ol>
<li><p>同一个类</p>
</li>
<li><p>同名</p>
</li>
<li><p>参数个数不同or参数类型不同</p>
</li>
</ol>
<p>利用好函数的重载，同样功能的函数起一样的名字，利用传递参数的不同加以区分，同时利用之前已有的函数功能，进行调用，提高代码的复用性。</p>
<h3 id="查表法"><a href="#查表法" class="headerlink" title="查表法"></a>查表法</h3><p>查表法：在数据中出现对应关系，而且对应关系的一方是有序的数字编号，并作为角标使用，这时候就要想到数组的使用。可以将这些数据存储到数组中，根据运算的结果作为角标直接去查数组中对应的元素即可</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组的格式"><a href="#数组的格式" class="headerlink" title="数组的格式"></a>数组的格式</h4><p> 元素类型[] 数组名 = new 元素类型[元素个数或数组长度]</p>
<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC.png" class title="This is an example image">

<p>在栈中开辟内存给arr，在堆中开辟内存，产生一个实体存放每个小数组的地址，初始值为null，然后新建三个小数组实体，每个小数组的初始值为0，将每个小数组的地址赋给大数组，将null改变为三个地址，然后将arr指向大数组的地址，这样二维数组初始化完毕</p>
<p>二维数组赋值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][]arr = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">3</span>][]; arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][]arr = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h3><ol>
<li><p>成员变量定义在类中，整个类中都可以访问；局部变量定义在函数，语句，局部代码块中，只在所属的区域有效。</p>
</li>
<li><p>成员变量存在于堆内存的对象中；局部变量存在于栈内存的方法中。</p>
</li>
<li><p>成员变量随着对象的创建而存在，随着对象的消失而消失；局部变量随着所属区域的执行而存在，随着所属区域的结束而释放。</p>
</li>
<li><p>成员变量都有默认初始化值；局部变量没有默认初始化值。</p>
</li>
</ol>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>​    隐藏对象的属性和实现细节，仅对外提供公共访问方式，笔记本就是种封装</p>
<p>​    将类中变量定义为private，为了改变变量的值，必须要经过类所规定的方法（对设置的变量给予约束）</p>
<p>​    封装原则：将不需要对外提供的内容全都隐藏起来；把属性都隐藏，提供公共方法（set,get）对其访问，使得对数据可控，set一般为viod，而get返回类型和属性相同</p>
<p>​    private为权限修饰符，修饰成员，不能修饰局部。私有的内容只在本类中有效。</p>
<p>​    私有只是封装的一种体现，java中最小的封装体是函数</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>​    名称与类相同，不需要返回值，用于给对象初始化，构造创造对象时调用的函数，<strong>首字母大写</strong>，构造函数里面可以return用以结束函数，但是很少见</p>
<p>​    创建对象都必须要通过构造函数进行初始化；如果一个类中没有定义过构造函数，那么该类中会有一个默认的空参数构造函数。如果在类中定义了指定的构造函数，那么类中的默认构造函数就没有了。</p>
<p>​    当方法中的成员变量和局部变量重名，那么成员变量会变成局部变量，当方法结束调用后出栈，没有改变成员变量的值，可以用this来区分，如this.name = name。this就是<strong>所在函数所属对象的引用</strong>。简单说，哪个对象调用了this所在的函数，this就代表哪个对象。</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><p>​    如果要在构造函数中调用构造函数，不能直接用Person();，因为这句话相当于this.Person，对象还没有初始化不可被调用，这时候可用this(待传入参数)，相当于直接给这个对象进行初始化。</p>
<p>​    this可在构造函数中调用其他构造函数，但是只能定义在构造函数的第一行，因为初始化动作要先执行</p>
<p>​    只要在本类中调用了本类的对象，一般都要用this</p>
<h4 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h4><p>​    修饰数据，可实现数据共享，在对象之前出现，可以被类名调用</p>
<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><ol>
<li><p>static是一个修饰符，用于修饰成员（成员变量和成员函数）。</p>
</li>
<li><p>static修饰的成员被所有的对象共享。</p>
</li>
<li><p>static优先于对象存在，因为static的成员随着类的加载就已经存在了。</p>
</li>
<li><p>static修饰的成员多了一种调用方式，即可以直接被类名所调用，调用格式为类名.静态成员。</p>
</li>
<li><p>静态修饰的数据是共享数据，对象中存储的是特有数据。</p>
</li>
</ol>
<h5 id="成员变量（实例变量）与静态变量（类变量）的区别："><a href="#成员变量（实例变量）与静态变量（类变量）的区别：" class="headerlink" title="成员变量（实例变量）与静态变量（类变量）的区别："></a>成员变量（实例变量）与静态变量（类变量）的区别：</h5><ol>
<li>两个变量的生命周期不一样（静态变量生命周期太长，用以减少占用内存空间）</li>
</ol>
<p>随着对象的创建而存在，随着对象的回收而释放；静态变量随着类的加载而存在，随着类的消失而消失</p>
<ol start="2">
<li>调用方式不同</li>
</ol>
<p>成员变量只能被对象调用，静态变量可以被对象和类调用，不建议用对象调用</p>
<ol start="3">
<li><p>别名不同</p>
<p>成员变量也成为实例变量，静态变量成为类变量</p>
</li>
<li><p>数据存储位置不同</p>
</li>
</ol>
<p>成员变量数据存储在堆内存（堆中存储的都是实体）的对象中，所以也叫对象的特有数据。静态变量数据存储在方法区（的静态区），也叫对象的共享数据</p>
<p>​    静态变量前省略了类名，非静态变量前省略了this</p>
<h5 id="静态使用注意事项"><a href="#静态使用注意事项" class="headerlink" title="静态使用注意事项"></a>静态使用注意事项</h5><ol>
<li><p>静态方法只能访问静态成员（因为其先于对象存在，无法访问对象中存在的成员变量和函数），静态方法可直接被类名调用。非静态既可以访问静态，又可以访问非静态。</p>
</li>
<li><p>静态方法中不可使用this或者super关键字</p>
</li>
<li><p>主函数是静态的（不要在主函数中定义其他函数，要将其他函数封装在类中，在主函数中创建对象，调用对象的函数即可）</p>
</li>
</ol>
<h5 id="主函数特殊之处"><a href="#主函数特殊之处" class="headerlink" title="主函数特殊之处"></a>主函数特殊之处</h5><p>public static void main(String[],args)</p>
<ol>
<li><p>格式是固定的</p>
</li>
<li><p>被jvm所识别和调用</p>
</li>
</ol>
<p>public：因为权限是最大的</p>
<p>static: 不需要对象的，直接用主函数所属类名调用即可</p>
<p>void：主函数没有具体的返回值</p>
<p>main: 函数名，不是关键字，只是一个jvm识别的固定的名字</p>
<p>String[] args：这是主函数的参数列表，是一个数组类型的参数，而且元素都是字符串类型</p>
<p>​    主函数所留了一个args，相当于new String args[0]，留给使用者指定参数，直接java 类名 加所要传入参数</p>
<p>​    类被加载进方法区，方法区用来存放类和静态方法的代码，也加方法表，运行时候进栈存储局部变量</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%B1%BB%E8%A2%AB%E5%8A%A0%E8%BD%BD%E8%BF%9B%E6%96%B9%E6%B3%95%E5%8C%BA.png" class title="This is an example image">

<h4 id="protected关键字"><a href="#protected关键字" class="headerlink" title="protected关键字"></a>protected关键字</h4><p>​    指明“就类用户而言，这是private的，但对于任何继承于此类的导出类或其他任何位于同一个包内的类来说，它却是可以访问的”。（protected提供了包内访问权限。）</p>
<h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><p>final 关键字：</p>
<p>1、 final是一个修饰符，可以修饰类，方法，变量</p>
<p>2、 final修饰的类不可以被继承</p>
<p>3、 final修饰的方法不可以被覆盖</p>
<p>4、 final修饰的变量是一个常量，只能赋值一次变量命名与函数一样，常量所有字母都大写，单词之间用_连接）成员一旦被final ，一般会加静态 static final int x = 7;</p>
<p> public static final 全局变量</p>
<p>​    用final修饰变量原因</p>
<p>其实在程序中如果一个数据是固定的，那么直接使用这个数据就可以了，但是这样阅读性差，所以给该数据起个名称，而且这个变量名称的值不能变化，所以加上final固定。固定常量一律用final修饰</p>
<p>写法规范</p>
<p>常量所有字母都大写，多个单词，中间用_连接。</p>
<p>可能使用到final的三种情况：数据、方法和类</p>
<h5 id="final数据"><a href="#final数据" class="headerlink" title="final数据"></a>final数据</h5><p>不能改变的数据需要是基本数据类型，以final关键字表示，在对常量定义的时候，必须对其赋值。</p>
<p>​    一个既是static又是final的域只占据一段不能改变的存储空间。</p>
<p>​    对对象的引用用final修饰，使其不能指向另一个对象，但是对象本身可以被修改。</p>
<p>​    不能因为某数据是final类型就认为可以在编译时知道它的值，final指向只是不能再次指向另一个新的对象，不代表值不能被改变。</p>
<p>​    如果数据是static的，在装载时已被初始化，而不是每次创建新对象时都初始化。</p>
<p>​    允许生成空白final，即被声明为final但又未给定初值的域。必须在域的定义处或者每个构造器中用表达式对final进行赋值。（如果不在构造器处初始化空白final，会编译报错。）</p>
<h5 id="final参数"><a href="#final参数" class="headerlink" title="final参数"></a>final参数</h5><p>​    允许在参数列表中以生命的方式将参数指明为final，意味着无法在方法中更改参数引用所指向的对象。</p>
<p>​    可以读参数，却无法修改参数，主要用来向匿名内部类传递数据。</p>
<h5 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h5><p>使用final方法原因：</p>
<p>​    一：把方法锁定，以防任何继承类修改它的定义。处于设计的考虑：想要确保在继承中使方法行为保持不变，并且不会被覆盖。</p>
<p>​    二：效率。以前会为了效率，将一个方法指明为final，同意编译器将针对该方法的所有调用都转为内嵌调用。应该让编译器和jvm去处理效率的问题，只有想要明确禁止覆盖时，才将方法设置成final。</p>
<h5 id="final和private关键字"><a href="#final和private关键字" class="headerlink" title="final和private关键字"></a><strong>final和private关键字</strong></h5><p>​    类中所有的private方法都隐式地指定为是final的。“覆盖”只有在某方法是基类的接口的一部分时才会出现，即必须能将一个对象向上转型为它的基本类型并调用相同的方法。如果方法为private，它就不是基类接口的一部分。它仅是一些隐藏于类中的程序代码，只不过是具有相同名称而已。</p>
<h5 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h5><p>​    当某各类的整体定义为final时（将关键字final置于它的定义之前），就表明了不打算继承该类，也不允许其他人这么做。</p>
<p>​    在final类中可以给方法添加final修饰词，但不会增添任何意义。</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h4 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h4><ol>
<li><p>寄存器  CPU处理</p>
</li>
<li><p>本地方法区 和操作系统相关 </p>
</li>
<li><p>方法区</p>
</li>
<li><p>栈内存 存储局部变量，而且变量所属的作用域一旦结束，变量自动释，方法（函数）进栈</p>
</li>
<li><p>堆内存 存储数组（数组就是对象）和对象，凡是new建立在堆中</p>
</li>
</ol>
<p>​    堆的特点：</p>
<ol>
<li>每一个实体都有首地址值</li>
<li>堆内存中的每一个变量都有默认初始化值，根据类型的不同而不同。整数0，小数0.0或0.0f，boolean false，char ‘\u0000’相当于空格的空位</li>
<li>垃圾回收机制，由程序控制不定时清理</li>
</ol>
<h4 id="内存过程"><a href="#内存过程" class="headerlink" title="内存过程"></a>内存过程</h4><p>​    StaticDemo2这个类被加载进方法区，因为其为非静态方法，有一个this用于表示当前对象，同时还有一个默认的空构造函数，因为这个类中有非静态方法，于是static main进入静态方法区，存储相应代码。运行main函数，main进栈。加载Person.method()，jvm寻找Person.class文件，找到后将Person类加载进方法区中非静态方法中，包括Person的代码，也包括一个this，存放非静态方法Person(),show()，将静态方法method存放金静态方法区，其中也包括country这个静态变量。运行method，method进栈，输出静态变量，没有在堆中开辟空间，运行结束后弹栈。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%85%E5%AD%98%E8%BF%87%E7%A8%8B.png" class title="This is an example image">

<p>​    建立新对象p，在堆中开辟内存空间地址为0x0056，初始化name=null,age=0。然后执行Person的构造函数，构造函数进栈，this赋值为此对象地址，将name和age赋值，接下来执行this.name=name和this.age=age，将堆中对象的name和age赋值改变。初始化结束后构造函数弹栈，将p指向0x0056。执行show()，在方法区中寻找show，show进栈，有一个this所属，输出类所属的静态变量country，this所属(对象)的name和age，进行输出，结束后show弹栈。Main执行return后，main也弹栈。</p>
<h3 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h3><p>​    变量在任何方法（包括构造器）被调用前初始化。</p>
<p>​    初始化的顺序是先静态对象（如果他们未因前面的对象创建过程而被初始化），然后是“非静态”对象，然后是构造器。</p>
<p>​    静态对象会随着类的加载而初始化，之后不会再次初始化。</p>
<p>​    实例初始化在构造器之前。</p>
<p>假设有个Dog类</p>
<ol>
<li><p>即使没有显式地使用static关键字，构造器实际上也是静态方法。因此，当首次创建爱你类为Dog的对象时（构造器可以看成静态方法），或者Dog类的静态方法/静态域首次被访问时，Java解释器必须查找类路径，以定位Dog.class文件。</p>
</li>
<li><p>然后载入Dog.class（创建一个Class对象），有关静态初始化的所有动作都会执行。因此静态初始化只在Class对象首次加载的时候执行一次。</p>
</li>
<li><p>当用new Dog()创建对象的时候，首先将在堆上为Dog对象分配足够的存储空间。</p>
</li>
<li><p>这块存储空间就会被清零，这就自动地将Dog对象中的所有基本类型数据都设置成了默认值，引用被设置成null。</p>
</li>
<li><p>执行所有出现于字段定义处的初始化动作。</p>
</li>
<li><p>执行构造器。</p>
</li>
</ol>
<h3 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h3><p>静态什么时候用？</p>
<p>1、 静态变量</p>
<p>当分析对象中所具备的成员变量的值都是相同的，这时这个成员就可以被静态修饰。只要数据在对象中都是不同的，那就是对象的特有数据，必须在对象中是非静态的。如果是相同的数据，对象不需要做修改，只需要使用即可，不需要存储在对象中，定义成静态的。</p>
<p>2、 静态函数</p>
<p>函数是否用静态修饰，就参考一点，就是该函数功能是否有访问到对象的特有数据。简单点即从代码中看，该功能是否需要访问非静态的成员变量，如果需要，该功能就是非静态的；如果不需要，就可以将该功能定义成静态的。当然也可以定义为非静态，但是非静态需要被对象调用，而仅创建对象调用非静态的没有访问对象特有数据的方法，该对象的创建没有意义。</p>
<p>3、静态代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span></span><br><span class="line">&#123;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随着类的加载而执行</p>
<p>作用：用于给类进行初始化。</p>
<p>一般用于全静态变量的类</p>
<p>构造代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造代码块为在类中的代码块，不加static修饰符，用以给所有对象初始化。与构造函数区别是构造函数是给对应的对象有针对性的初始化。构造代码块为对象的通用部分，构造函数为对象的特性部分。</p>
<p>若在函数中为局部代码块，用以限制变量的周期。</p>
<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><p>强制不让创建对象</p>
<p>private ArrayToll(){}该类中的方法都是静态的，所以该类是不需要创建对象的。为了保证不让其他成员创建该类对象，可以将构造函数私有化</p>
<p>设计模式：对问题行之有效的解决方式。其实是一种思想</p>
<p>​    单例设计模式解决问题：可以保证一个类在内存中的对象唯一性</p>
<p>​    必须对多个程序使用同一个配置对象时，就需要保证该对象的唯一性</p>
<p>如何保证对象唯一性？</p>
<p>（1）   不允许其他程序用new创建该类对象</p>
<p>（2）   在该类中创建一个本类实例</p>
<p>（3）   对外提供一个方法让其他程序可以获取该对象</p>
<p>步骤</p>
<p>（1）   私有化该类的构造函数</p>
<p>（2）   通过new在本类中创建一个本类的对象</p>
<p>（3）   定义一个公有的方法，将创建的对象返回</p>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p><strong>开发更多</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类一加载，对象就已经存在了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;  </span><br><span class="line">	<span class="comment">//静态方法只能调用静态变量,为了避免用户直接访问设置权限</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Single s = <span class="keyword">new</span> Single(); </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125; </span><br><span class="line">	<span class="comment">//静态方法可以直接被类调用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 Single ss = Single.getInstance();</p>
<p>当调用getInstance()的时候，此函数进栈，将s的地址赋值给ss，然后弹栈，这样ss就指向了s所指向的对象</p>
<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><p><strong>面试更多</strong> 延迟加载形式（懒汉式）问题：如果被<strong>多线程</strong>调用，可能<strong>不能保证唯一性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类加载进来，没有对象，只有调用了getInstance方法才创建对象，延迟加载形式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single2</span> </span>&#123;   </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Single2 s = <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Single2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;   </span><br><span class="line">		<span class="keyword">if</span>(s==<span class="keyword">null</span>)</span><br><span class="line">			s = <span class="keyword">new</span> Single2();</span><br><span class="line">		 <span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>class Student <strong>extends</strong> Person</p>
<p>Student 子类  Person父类（超类，基类）</p>
<p>继承弊端：打破封装性</p>
<h4 id="继承的好处"><a href="#继承的好处" class="headerlink" title="继承的好处"></a>继承的好处</h4><ol>
<li><p>提高了代码的复用性</p>
</li>
<li><p>让类和类之间产生了关系，给第三个特征多态提供了前提</p>
</li>
</ol>
<p>java中支持单继承，不直接支持多继承，但对C++中的多继承机制进行了改良</p>
<p>单继承：一个子类只能有一个直接父类</p>
<p>多继承：一个子类可以有多个直接父类（java中不允许，进行改良）</p>
<p>​    不直接支持，因为多个父类中有相同成员，会产生调用不确定性,在java中通过“<strong>多实现</strong>”的方式来实现</p>
<p>​    java支持多层（多重）继承</p>
<p>​    C继承B，B继承A。就会出现继承体系。</p>
<h4 id="使用一个继承体系"><a href="#使用一个继承体系" class="headerlink" title="使用一个继承体系"></a>使用一个继承体系</h4><ol>
<li><p>查看该体系中的顶层类，了解该体系的基本功能</p>
</li>
<li><p>创建体系中的最子类对象，完成功能的使用</p>
</li>
</ol>
<p>在子父类中，成员的特点体现</p>
<ol>
<li>成员变量</li>
</ol>
<p>子类中与父类同名变量，值与子类相同。当本类中的成员和局部变量同名用this区分。</p>
<p>当子父类中的成员变量同名可用super区分父类。</p>
<p>this 和 super的用法很相似</p>
<p>this：代表一个本类对象的引用</p>
<p>super：代表一个父类空间</p>
<ol start="2">
<li>成员函数</li>
</ol>
<p>当子父类中出现成员函数一模一样的情况，会运行子类的函数，这种现象称为覆盖操作。</p>
<p>这是函数在子父类中的特性。</p>
<p>​    函数两个特性：</p>
<p>（1）   重载 同一个类中</p>
<p>（2）   覆盖 子类中，覆盖也称为重写，覆写。override,函数声明需要一致</p>
<p>​    覆盖注意事项</p>
<ul>
<li><p>子类方法覆盖父类方法时，子类权限必须要大于等于父类的权限</p>
</li>
<li><p>静态只能覆盖静态，或被静态覆盖</p>
<p>什么时候使用覆盖操作</p>
<p>当对一个类进行子类的扩展时，子类需要保留父类的功能声明，但是要定义子类中该功能的特有内容时，就使用覆盖功能完成</p>
</li>
</ul>
<ol start="3">
<li>构造函数</li>
</ol>
<p>在子类构造对象时，发现访问子类构造函数时，父类也运行。原因：在子类的 构造函数中第一行有一个默认的隐式语句。super()；</p>
<p>子类的实例化过程：子类中所有的构造函数默认都会访问父类中的空参数的构造函数</p>
<p>子类实例化访问父类构造函数原因：</p>
<p>​    子类继承了父类，获取到了父类中的内容（属性），所以在使用父类内容之前要先看父类是如何对自己的内容进行初始化的，所以子类在构造对象时必须访问父类的构造函数。为了完成这个必须的动作，就在子类的构造函数函数中加入了super();语句.如果父类中没有定义空参数构造函数.那么子类的构造函数必须用super明确要调用父类中哪个构造函数。同时子类构造函数中如果使用this()调用了本类构造函数时，super就没有了，因为this和super都只能定义在第一行，所以只能有一个。但是可以保证的是，子类中肯定会有其他的构造函数访问父类的构造函数。</p>
<p>​    注意：super语句必须要定义在子类构造函数的第一行，因为父类的初始化动作要先完成。</p>
<p>所有的类都有 extends Object</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%A7%E6%89%BF%E5%86%85%E5%AD%98%E5%9B%BE%E8%A7%A3.png" class title="This is an example image">

<p>继承内存图解，子类对象中继承了父类对象的num，用super关键字进行引用</p>
<p>子类中不能直接访问父类中私有的内容</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Zi.png" class title="This is an example image">

<p>运行Zi的构造函数，super()为Fu()，此时的show()被子类覆盖，运行zi show…0。通过父类super初始化父类内容时，子类的成员变量并未显示初始化，等父类super（）父类初始化完毕后，才进行子类的成员变量显示初始化。即super后num=8</p>
<h4 id="一个对象实例化过程"><a href="#一个对象实例化过程" class="headerlink" title="一个对象实例化过程"></a>一个对象实例化过程</h4><p>Person p = new Person();</p>
<ol>
<li><p>JVM会读取指定路径下的Person.class文件，并加载进内存，并会先加载Person的父类（如果有直接的父类的情况下）</p>
</li>
<li><p>在堆内存中开辟空间，分配地址</p>
</li>
<li><p>并在对象空间中，对对象的属性进行默认初始化</p>
</li>
<li><p>调用对应的构造函数，进行初始化</p>
</li>
<li><p>在构造函数中，第一行会调用父类中的构造函数进行初始化</p>
</li>
<li><p>父类初始化完毕后，再对子类的属性进行显示初始化</p>
</li>
<li><p>再进行子类构造函数的特定初始化</p>
</li>
<li><p>初始化完毕后，将地址值赋值给引用变量</p>
</li>
</ol>
<h4 id="组合与继承"><a href="#组合与继承" class="headerlink" title="组合与继承"></a>组合与继承</h4><p>​    组合：在一个类中持有另一个类的引用。</p>
<p>“is-a”（是一个）的关系是用继承表达的，而“has-a”（有一个）的关系则是用组合来表达的。</p>
<p> 判断要用组合还是继承，看是否需要从新类向基类进行向上转型，如果必须向上转型，则继承是必要的。</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>​    如果使用继承，会将父类所有方法暴露给子类，可以使用代理，可以选择只提供在成员对象中的方法的某个子集。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>abstract class Demo</p>
<p>{ abstract void show();</p>
<p>}</p>
<p>1、 方法只有声明没有实现时，该方法就是抽象方法，需要被abstract修饰。抽象方法必须定义在抽象类中，该类也必须要被abstract修饰</p>
<p>2、 抽象类不可以被实例化（不可以被new）,调用抽象方法没意义。</p>
<p>3、 抽象类必须有其子类覆盖了所有的抽象方法后，该子类才可以实例化。否则，该子类还是抽象类</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>当一个抽象类中的方法都是抽象的时候，这时可以将该抽象类用另一种形式定义和表示，就是接口 interface。</p>
<p>定义接口用的关键字不是class，是interface</p>
<p>接口中常见的成员：而且这些成员都有固定的修饰符</p>
<ol>
<li><p>全局常量 public static final</p>
</li>
<li><p>抽象方法 public abstract</p>
</li>
</ol>
<p>由此有接口中的成员都是公共的权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;   </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">4</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    类与类之间是继承关系，类与接口之间是实现关系，接口与接口之前是继承关系，而且可以多继承</p>
<p>​    接口不可以实例化，只能由实现了接口的子类并覆盖了接口中所有的抽象方法后，该子类才可以实例化。否则，这个子类就是一个抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoImpl</span> <span class="keyword">implements</span> /*实现*/<span class="title">Demo</span></span>&#123;   </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在java中不直接支持多继承，因为会出现调用的不确定性。所以java将多继承机制进行了改良，在java中变成了多实现。</p>
<p>​    一个类可以有多个接口。</p>
<p>class Test implements A,Z  多实现，如果A,Z中方法名一样，也不会报错，因为A,Z中无方法体，若Test中覆盖此同名方法，则A,Z中方法会被同时覆盖，不会产生不确定性，而继承中因为存在方法体，所以不能多继承。</p>
<p>一个类在继承另一个类的时候，还可以实现多个接口。先继承，再实现接口。</p>
<p>class Test extends Q implements A,Z</p>
<p>​    <strong>接口的出现避免了单继承的局限性</strong>。接口与接口之前是继承关系，而且可以多继承</p>
<p>interface QQ extends CC,MM</p>
<h4 id="接口的特点"><a href="#接口的特点" class="headerlink" title="接口的特点"></a>接口的特点</h4><ul>
<li><p>接口是对外暴露的规则</p>
</li>
<li><p>接口是程序的功能扩展</p>
</li>
<li><p>接口的出现降低耦合性</p>
</li>
<li><p>接口可以用来多实现</p>
</li>
<li><p>类与接口之间是实现关系，而且类可以继承一个类的同时实现多个接口</p>
</li>
<li><p>接口与接口之间可以有继承关系</p>
</li>
</ul>
<h4 id="抽象类和接口的异同点"><a href="#抽象类和接口的异同点" class="headerlink" title="抽象类和接口的异同点"></a>抽象类和接口的异同点</h4><p>相同点：都是不断向上抽取而来的</p>
<p>不同点：</p>
<ol>
<li><p>抽象类需要被继承，而且只能单继承。</p>
<p>接口需要被实现，而且可以多实现</p>
</li>
<li><p>抽象类中可以定义抽象方法和非抽象方法，子类继承后可以直接使用非抽象方法。</p>
<p>接口中只能定义抽象方法，必须由子类去实现</p>
</li>
<li><p>抽象类的继承，是is a 关系。在定义该体系的基本共性内容，基本功能</p>
<p>接口的实现是like a 关系。在定义体系额外功能</p>
</li>
</ol>
<p>在不同的领域中，有不同的分析方式</p>
<p>接口类型对象指向自己的子类对象。接口类型的引用，用于接收（指向）接口的子类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">useUSB(<span class="keyword">null</span>);  </span><br><span class="line">useUSB(<span class="keyword">new</span> Upan());</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useUSB</span><span class="params">(USB u)</span> <span class="comment">//使用了多态，相当于USB u = new Upan()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		u.open();</span><br><span class="line">		u.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>​    在某些情况下，一个类的属性是有限而且固定的，如下面的棋子类，只有两个对象，白棋和黑棋。这种实例有限而且固定的类，在java中称为枚举类，枚举类的关键字是enum，此类中有两个枚举属性BLACK和WHITE，代表黑子与白子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//棋子类，枚举类，为构造器私有，不能直接创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  Chessman &#123;</span><br><span class="line">    BLACK(<span class="string">"●"</span>), WHITE(<span class="string">"○"</span>);</span><br><span class="line">    <span class="keyword">private</span> String chessman;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Chessman</span><span class="params">(String chessman)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.chessman = chessman;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *获取棋子类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 黑棋或者白棋</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getChessman</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.chessman;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    此枚举的构造器权限使用private表明子类不可以通过外部创建，只能通过此类的内部创建，为了保证此对象只有黑子与白子两种类型。红色代码列出了枚举值，实际上是调用私有构造器创建此对象，等效于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Chessman BLACK = <span class="keyword">new</span> Chessman(<span class="string">"●"</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Chessman WHITE = <span class="keyword">new</span> Chessman(<span class="string">"○"</span>);</span><br></pre></td></tr></table></figure>

<p>因为BLACK与WHITE两个属性是静态的，要获取黑子或白字，可使用以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Chessman.BLACK.getChessman();</span><br><span class="line">Chessman.WHITE.getChessman();</span><br></pre></td></tr></table></figure>

<h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><p>对自己所写类添加说明文档，用javadoc</p>
<p>类的文档描述应该包括：</p>
<ol>
<li><p>这个类的作用，包含的内容</p>
</li>
<li><p>@author Hugh</p>
</li>
<li><p>@version V1.0</p>
</li>
</ol>
<p>注释格式为</p>
<p>/**</p>
<p>*/</p>
<p>对于每一个方法，描述其作用，@param arr 接收对象描述  @return 返回值描述</p>
<p>为了能使用javadoc，要将class前面加上public，这样类名和文件名必须要一致</p>
<p>使用语句为 javadoc -d myhelp(自己要放的文件名) –author –version ArrayTool.java（要查看的java文件）然后查看index网页，只提供公有权限的</p>
<p>使用时候若class文件与测试用java文件不在同一目录，使用set classpath=.;c:\myclass（相应目录）.;表示当前目录（用以编译当前测试文件），然后再设置对方所给class文件存放目录。若已经设置好对方classpath目录，则使用set classpath=.;%classpath%</p>
<p>若要清楚classpath，使用 set classpath=,查看路径为set classpath</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态：某一类事物的多种存在形态</p>
<p>用父类类型指向子类对象，猫这类事物既具备了猫的形态，又具备了动物的形态，这就是对象的多态性。一个对象对应着不同类型</p>
<p>在代码中体现：父类或接口的引用指向了其子类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal c = <span class="keyword">new</span> pig();</span><br></pre></td></tr></table></figure>

<p>多态的好处：</p>
<p>​    提高了代码的扩展性，前期定义的代码可以使用后期的内容</p>
<p>多态的弊端：</p>
<p>​    前期定义的内容不能使用（调用）后期子类的特有内容</p>
<p>多态的前提：</p>
<ol>
<li><p>必须有关系，继承，实现。</p>
</li>
<li><p>要有覆盖</p>
</li>
</ol>
<p>Animal a = new cat();//自动类型提升，猫对象提升为了动物类型，但特有功能无法访问，</p>
<p>作用为限制对特有功能的访问</p>
<p>专业讲：向上转型，将子类型隐藏，就不能使用子类型的特有方法</p>
<p>若父类中的内容被子类覆盖，调用向上转型对象的方法所实现的为子类的内容</p>
<p>若想使用特有内容，则将对象进行向下转型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cat c = (Cat)a；<span class="comment">//向下转型的目的是使用子类中的特有方法</span></span><br><span class="line">Animal a1 = <span class="keyword">new</span> dog();</span><br><span class="line">Cat c1 = (Cat)a1;<span class="comment">//  ClassCastException类型转换异常</span></span><br></pre></td></tr></table></figure>

<p>注意：对于转型，自始至终都是子类对象在做着类型的变化</p>
<p>对对象类型的判断</p>
<p>instanceof：用于判断对象的具体类型,只能用于引用数据类型判断，通常在向下转型前用于健壮性的判断。</p>
<p>if(a instanceof Cat){}</p>
<p>转型之前加入逻辑判断，加强代码的健壮性</p>
<h4 id="多态时成员的特点"><a href="#多态时成员的特点" class="headerlink" title="多态时成员的特点"></a>多态时成员的特点</h4><ol>
<li>成员变量</li>
</ol>
<p>编译时：参考引用型变量所属的类中是否有调用的成员变量，有，编译通过；没有，编译失败。</p>
<p>运行时：参考引用型变量所属的类中是否有调用的成员变量，并运行所属类中的成员变量</p>
<p>简单说：编译和运行都参考等号的左边</p>
<ol start="2">
<li>成员函数（非静态，重点）</li>
</ol>
<p>编译时：参考引用型变量所属的类中是否有调用的函数，有，编译通过；没有，编译失败。</p>
<p>运行时：参考的是对象所属的类中是否有调用的函数</p>
<p>简单说：编译看左边，运行看右边</p>
<ol start="3">
<li>静态函数</li>
</ol>
<p>编译时：参考引用型变量所属的类中是否有调用的静态方法</p>
<p>运行时：参考引用型变量所属的类中是否有调用的静态方法</p>
<p>简单说：编译和运行都参考等号的左边</p>
<p>​    其实静态方法是不需要对象的，直接类名调用即可</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类：将一个类定义在另一个类里面，对里面那个类成为内部类（内置类，嵌套类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;   </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;   </span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;print(“show”+num);&#125;</span><br><span class="line">   		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;print(“function”+num);&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主函数中编译，产生Outer.class和Outer$Inner.class文件</p>
<p>若要访问一个类中私有变量，最简单方法是在该类中定义内部类，则可以直接访问该私有变量</p>
<p>内部类访问特点</p>
<ol>
<li><p>内部类可以直接访问外部类中的成员</p>
</li>
<li><p>外部类要访问内部类，必须建立内部类的对象</p>
</li>
</ol>
<p>一般用于类的设计。分析事物时发现该事物描述中还有事物，而且该事物还在访问该事物的内容，这时把这个事物定义为内部类来描述</p>
<p>直接访问外部类中的内部类成员</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.Inner in = <span class="keyword">new</span> Outer().<span class="keyword">new</span> Inner();in.show();<span class="comment">//必须先建立外部类对象</span></span><br></pre></td></tr></table></figure>

<p>如果内部类是静态的，相当于一个外部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.Inner in = <span class="keyword">new</span> Outer.Inner();in.show();<span class="comment">//不需建立内部类对象，此静态方法中只能使用静态变量</span></span><br></pre></td></tr></table></figure>

<p>如果内部类是静态的，成员是静态的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.Inner.function();</span><br></pre></td></tr></table></figure>

<p>当内部类中定义了静态成员，该内部类必须被静态修饰，或者该成员被final修饰</p>
<p>外部类只能用public和default默认修饰符，内部类四种修饰符都可以用</p>
<p>内部类可以直接访问外部类中成员的原因：内部类持有外部类的引用，外部类名.this</p>
<p>外部类和内部类拥有同名的变量和方法时，内部类有需要进行访问外部的同名变量或方法，可以通过<strong>外部类.this.方法名/变量名</strong>进行访问</p>
<ol>
<li>成员内部类</li>
</ol>
<p>当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：</p>
<ul>
<li>外部类.this.成员变量</li>
<li>外部类.this.成员方法</li>
</ul>
<p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。</p>
<ol start="2">
<li>局部内部类</li>
</ol>
<p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。</p>
<ol start="3">
<li>匿名内部类</li>
</ol>
<p>匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p>
<ol start="4">
<li>静态内部类</li>
</ol>
<p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字<strong>static</strong>。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。<strong>只有静态内部类，才能在类中申明静态方法</strong>，普通内部类申明静态方法会报错。</p>
<h4 id="内部类问题解释"><a href="#内部类问题解释" class="headerlink" title="内部类问题解释"></a>内部类问题解释</h4><ol>
<li><p>为什么成员内部类可以无条件访问外部类的成员？</p>
<p>编译器会默认为成员内部类添加了一个指向外部类对象的引用（this）。从这里可以看出，虽然我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用，所以成员内部类中的Outter this&amp;0 指针便指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员。从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法对Outter this&amp;0引用进行初始化赋值，也就无法创建成员内部类的对象了。</p>
</li>
<li><p>为什么局部内部类和匿名内部类只能访问局部final变量？</p>
<p>如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。为了避免在内部类的方法中改变参数造成数据不一致性，局部内部类和匿名内部类中访问成员变量需要被final修饰。</p>
<p>一个类文件中，<strong>只能有一个公共的（**</strong>public<strong>**）外部类</strong>，但可以有多个(public、default、private)内部类，多个（default）外部类，private不能用来修饰外部类！</p>
</li>
</ol>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类。就是内部类的简写格式</p>
<p>​    必须有前提：内部类必须继承或者实现一个外部类或者接口</p>
<p>匿名内部类：其实就是一个匿名子类对象（因此如果父类中无此方法会报错）</p>
<p>格式： new 父类or接口 () { 子类内容 }</p>
<p>new demo()即为匿名内部类，因为是对象所以可以直接调用方法</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB.png" class title="This is an example image">

<p>注意：在匿名内部类中，要将方法权限设置为public，否则无法被实现</p>
<p>通常使用场景之一：当函数参数是接口类型时，而且接口中的方法不超过三个。可以利用匿名内部类作为实际参数进行传递 </p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Object%E7%BC%96%E8%AF%91%E5%A4%B1%E8%B4%A5.png" class title="This is an example image">

<p>new Object(){}相当于创立了子类对象，而Object obj=子类对象，相当于向上转型（多态），隐藏了子类特有属性，编译看左边，Object类中无show方法，因此会编译失败</p>
<p>对象构造：显示初始化在构造器初始化之后</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC10%E5%A4%A91.png" class title="This is an example image">

<p>new Zi()对象后，先执行Zi构造函数，默认第一行为super()，此时调用super中的show，因为子类中show被覆盖，因此输出show…，而此时num还没有被显示初始化，因此num为0.然后执行显示的初始化，这时候num为9</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC10%E5%A4%A92.png" class title="This is an example image">

<p>创立对象时，先默认初始化，即num=0，然后Zi()进栈，执行父类构造函数，show函数在子类对象中被覆盖，执行子类show，父类构造函数出栈后进行显示初始化，此时num=9，然后进行构造代码块输出化，然后才是自定义构造函数语句输出</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC10%E5%A4%A93.png" class title="This is an example image">

<p>​    首先为Fu和Zi开辟内存空间，然后执行子类的构造函数，先执行super()，Fu中super为Object，然后进行显示初始化，此时Fu中num=9，再执行父类中构造代码块初始化，因此<strong>第1个输出Fu</strong>。然后执行show()方法，因为父类中show被覆盖，所以执行子类的，而子类中还未进行显示初始化，因此子类中num=0，<strong>第2步</strong>子类show()输出<strong>zi show num=0</strong>。然后子类中父类构造函数执行完毕出栈，执行子类显示初始化，num=8，然后执行构造代码块初始化，因此<strong>第三步输出Zi</strong>.然后进行Zi类中show方法，<strong>第4步输出zi show num=8</strong>。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常：运行时期发生的不正常情况</p>
<p>java中用类的形式对不正常情况进行了描述和封装对象。描述不正常的类，成为异常类。以前正常流程代码和问题处理代码相结合，现在将正常流程代码和和问题处理代码分离，提高阅读性。</p>
<p>不同的问题用不同的类进行具体的描述，比如角标越界，空指针等。</p>
<p>​    问题很多，意味着描述的类也很多，将其共性向上抽取，形成了异常体系。最终问题（不正常情况）就分成了两大类。</p>
<p>Throwable:无论是error，还是异常，问题，问题发生就应该可以抛出，让调用者知道并处理。</p>
<p>//该体系的特点就在于Throwable及其所有的子类都具有可抛性。</p>
<p>可抛性：通过两个关键字来体现的。throws，throw，凡是可以被这两个关键字所操作的类和对象都具有可抛性。<br>|–1、一般不可处理的。Error</p>
<p>特点：是由jvm抛出的严重性的问题。这种问题发生一般不针对性处理。直接修改程序</p>
<p>|–2、可以处理的。Exception</p>
<p>​    发生错误时，对错误地方进行对象封装， throw一个新错误对象给调用者，虚拟机，然后在控制台输出，实际开发时会以日志的形式存储起来。错误地方后面的功能不予执行，因此抛出错误对象可以结束函数。</p>
<p>throw 抛出对象 throw new …某Exception()</p>
<p>​    对于角标是正数不存在，可以用角标越界表示；对于负数为角标的情况，准备用负数角标异常来表示。负数角标这种异常在java中并没有定义过，那就按照java异常的创建思想，面向对象，将负数角标进行自定义描述，并封装成对象。这种自定义的问题描述称为<strong>自定义异常</strong>。  </p>
<p>​    注意：如果让一个类成为异常类，必须要继承异常体系，因为只有成为异常体系的子类才有资格具备可抛性。才可以被两个关键字所操作。throws throw。 </p>
<p>extends RuntimeException</p>
<p>如果在函数内发生了异常，应该在函数中进行声明 throws 引用在函数声明上，throw用在函数内；调用发生异常函数，必须要处理，处理方式之一为抛出。因为继承了父类的异常体系，在重载自定义的异常构造函数时，若要进行String提示输出，可以用super(Str)来进行相关语言提示。</p>
<h4 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h4><ol>
<li><p>编译时被检测异常：只要是Exception和其子类都是，除了特殊子类RuntimeException体系。这种问题一旦出现，希望在编译时就进行检测，让这种问题有对应的处理方式。</p>
</li>
<li><p>编译时不检测异常（运行时异常）就是Exception中的RuntimeException和其子类</p>
<p>这种问题的发生无法让功能继续，运算无法进行，更多是因为调用者的原因导致的或者引发了内部状态的改变导致的。这种问题一般不处理，直接编译通过，在运行时让调用者调用时的程序强制停止，让调用者对代码进行修正。</p>
</li>
</ol>
<p>如果不需要将问题暴露，编译通过在运行时停止；若需要将问题暴露，则在编译时报错    因此自定义异常时，继承Exception或者RuntimeException</p>
<h4 id="throws和throw区别"><a href="#throws和throw区别" class="headerlink" title="throws和throw区别"></a>throws和throw区别</h4><ol>
<li><p>throws使用在函数上，throw使用在函数内</p>
</li>
<li><p>throws抛出的是异常类，可以抛出多个，用逗号隔开。throw抛出的是异常对象，一次只能抛出一个</p>
</li>
</ol>
<h4 id="异常处理的捕捉形式"><a href="#异常处理的捕捉形式" class="headerlink" title="异常处理的捕捉形式"></a>异常处理的捕捉形式</h4><p>这是可以对异常进行针对性处理的方式。</p>
<p>具体形式是：</p>
<p>try{需要被检测异常的代码}</p>
<p>catch(异常类 变量){处理异常的代码}//该变量用于接收发生的异常对象</p>
<p>finally{一定会被执行的代码}</p>
<p>这个代码块是一个整体</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC11%E5%A4%A91.png" class title="This is an example image">

<p>​    在try中放入待检测代码块（其中为局部变量），此对象调用方法抛出一个异常对象，此对象被catch捕捉，e = new异常对象，然后继续输出负数角标异常，因为问题已经被解决，因此程序可以向下运行输出over</p>
<p>​    如果输出e.getMessage()，则可以输出此异常详细信息。getMessage()为父类throwable中的方法。一般直接打印对象，输出为对象地址和哈希值，但是异常对象相当于使用e.toString()，输出为异常类名加信息。</p>
<p>​    e.printStachTrace()，将其追踪输出至标准错误流（jvm默认的异常处理机制）</p>
<p>该体系的特点：子类的后缀名都是用其父类名作为后缀，阅读性很强</p>
<p>如果有多个catch的情况，在抛出的时候throws 多个异常，然后写多个catch即可。</p>
<p>​    如果在多catch情况下，出现了父类Exception e的处理情况，一定要放在多catch的最后，不然放在最前面其他catch永远不执行(多catch下父类的catch放在最后，否则编译失败)</p>
<p>​    只要使用到了声明异常的方法，就要try</p>
<h4 id="异常处理的原则"><a href="#异常处理的原则" class="headerlink" title="异常处理的原则"></a>异常处理的原则</h4><ol>
<li><p>函数内容如果抛出需要检测的异常，那么函数上必须要声明。否则必须在函数内用try,catch捕捉，否则编译失败。</p>
</li>
<li><p>如果调用到了声明异常到的函数，要么try,catch，要么throws，否则编译失败</p>
</li>
<li><p>什么时候catch，什么时候throws</p>
<p>功能内部可以解决，用catch。解决不了用throws告诉调用者，由调用者解决。</p>
</li>
<li><p>一个功能如果抛出了多个异常，那么调用时必须有对应多个catch进行针对性的处理。</p>
</li>
</ol>
<p>内部有几个需要检测的异常就抛几个异常。抛出几个，就catch几个</p>
<p>finally是一定会被执行到的，除非在catch中用到了System.exit(1)，直接退出jvm。</p>
<p>​    finally通常用于关闭（释放）资源，如数据库查询出异常后要关闭连接，关闭连接就在finally中</p>
<p>​    没catch就没处理</p>
<p>try catch finally代码块组合特点：</p>
<ol>
<li><p>try catch finally</p>
</li>
<li><p>try catch(多个) 当没有必要资源需要释放时，可以不用定义finally</p>
</li>
<li><p>try finally 异常无法直接catch处理，但是资源需要关闭</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> show <span class="keyword">throws</span> <span class="title">Exception</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;<span class="comment">//开启资源</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> Exception();&#125;</span><br><span class="line">	<span class="keyword">finally</span>&#123;<span class="comment">//关闭资源&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常转换：捕捉一个异常，暴露出来的是另一个异常，因为此捕捉异常无法被处理，因此转换为可以被处理的异常</p>
<p>catch(MaoYanException e){</p>
<p>​           System.out.println(e.toString());</p>
<p>​           test();</p>
<p>​           //可以对电脑进行维修</p>
<p>​           //throw e;</p>
<p>​           throw new NoPlanException(“课时进度无法完成”+e.getMessage());</p>
<p>​       }</p>
<p>如果发生问题，内部解决，没有给外部抛出，就是隐藏了问题。异常的封装：解决那些内部解决的，抛出需要被外界知道的异常类信息。</p>
<h4 id="异常的注意事项"><a href="#异常的注意事项" class="headerlink" title="异常的注意事项"></a>异常的注意事项</h4><ol>
<li><p>子类在覆盖父类方法时，如果父类的方法抛出了异常，那么子类的方法只能抛出父类的异常或该异常的子类（可以不抛）</p>
</li>
<li><p>如果父类抛出多个异常，那么子类只能抛出父类异常的子集</p>
</li>
</ol>
<p>简单说，子类覆盖父类，子类只能抛出父类的异常或者子类或者子集</p>
<p>注意：如果父类的方法没有抛出异常，子类覆盖时绝对不能抛，就只能try</p>
<p>子类重写的方法可以抛出任何运行时异常（RuntimeException和ArithmeticException属于运行时异常）</p>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>Object:所有类的根类</p>
<p>Object是不断抽取而来，具备着所有对象都具备的共性内容</p>
<p>常用的共性功能:</p>
<p>boolean equals(Object obj):判断两个对象是否相等，仅当引用同一个对象才返回true，比较的也是地址</p>
<p>​    一般都会覆盖此方法，根据对象的特有内容，建立判断对象是否相同的依据</p>
<p>一般向下转型要进行健壮性判断 用instanceof进行判断，扔出异常（运行时异常）告诉用户</p>
<p>if(classA instanceof classB)</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC11%E5%A4%A92.png" class title="This is an example image">

<p>hashCode()，获得哈希地址值，直接输出对象引用=Integer.toHexString(对象.hashCode())；</p>
<p>​    可以根据对象的特性不同，输出不同的哈希值</p>
<p>比较对象equals是否相同：1、判断哈希值是否相同。2、判断内容是否相同</p>
<p>重写equals时候，一般要重写hashCode()，使得相同的对象要有相同的哈希地址值</p>
<p>getClass() 返回此Object的运行时类，即当前对象所属的字节码对象,类型为Class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span></span>&#123;<span class="comment">//字节码文件</span></span><br><span class="line">	name;名称</span><br><span class="line">    field;字段（属性、成员变量）</span><br><span class="line">    constructor;构造器</span><br><span class="line">    method;方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person p = new Person(20)；</p>
<p>​    先在堆里面产生一个Person.class字节码文件对象，再根据字节码文件对象产生Person对象</p>
<p>​    Class clazz1 = p.getClass();</p>
<p>​    可以使用clazz1.getname()即getConstructor()等方法。</p>
<p>toString()方法</p>
<p>​    输出为p.getclass().getName+”@”+Inthger.toHexString(p.hashCode())</p>
<p>如果想建立每个对象特有的字符串输出方法，就可以将toString()方法覆写</p>
<h3 id="包（package）"><a href="#包（package）" class="headerlink" title="包（package）"></a>包（package）</h3><p>对类文件进行分类管理；对类提供多层命名（名称）空间；写在程序的第一行；类名的全程是 包名.类名；包也是一种封装形式</p>
<p>在java文件第一行写package zc.Demo;</p>
<p>编译时候 javac -d . Hello.java，自动生成相应目录，然后运行java zc.Demo.Hello</p>
<p>​    如果两个java文件在不同的包下，一个需要用到另一个类，则如果直接用类名来新建对象会出错，因为类已经有包的所属，所以必须要明确其包名。记住：Demo这个名称是错的，正确名称是包名.类名 packa.Demo。如果两个java文件不在一个目录下，则编译有主函数的类时会找不到调用类，此时需要将被调用类包所在的路径设置为路径</p>
<p> set classpath=.;+路径。在包中，如果没有写public，就是被封装了。方法也不能使用默认权限，要使用public。</p>
<p>​    总结：包与包之间的类访问，被访问的包中的类必须是public的，被访问的包中的类的方法也必须是public的。</p>
<p>​    protected权限，第四种，只有在不同包中的子类才能使用，即必须要继承才能使用，直接在不同包中创建对象无法使用被保护的方法，其实也叫封装。</p>
<table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>default</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同一类中</td>
<td>ok</td>
<td>ok</td>
<td>ok</td>
<td>ok</td>
</tr>
<tr>
<td>同一包中</td>
<td>ok</td>
<td>ok</td>
<td>ok</td>
<td>no</td>
</tr>
<tr>
<td>子类中</td>
<td>ok</td>
<td>ok</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>不同包中</td>
<td>ok</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
</tbody></table>
<p>不同包中能使用的;1、public 2、不同包中子类的protected</p>
<p>使用import，导入指定包中的类，import packa.<em>；导入packa中的所有类,并不导入其中的包，如果packa下面还有包，则需要加入packa.abc.*；真实开发中不建议写</em></p>
<p>​    使用import可以导入包中的类，不用写包名.类名</p>
<p>​    导包的原则：用到哪个类就导入哪个类。</p>
<p>​    import作用：为了简化类名书写，导入的是包中的类。</p>
<p>Jar：java的压缩包，可以压缩</p>
<p>压缩命令：jar -cvf 压缩包名称.jar 被压缩包名</p>
<p>解压缩命令：jar -xvf 压缩包名称</p>
<p>​    将工具包打包为jar文件，不用解压缩，将jar文件添加到classpath下，然后变可以执行，利用java 包名.类名执行。</p>
<h3 id="外部类与内部类修饰符"><a href="#外部类与内部类修饰符" class="headerlink" title="外部类与内部类修饰符"></a>外部类与内部类修饰符</h3><p>如果类可以使用private来修饰，表示该包下的这个类不能被其它类访问，那么该类也失去了存在的意义，所以不能使用private来修饰类。</p>
<p>如果类可以使用protected来修饰，表示该类所在的包的其它类可以访问该类；该类所在的包的子包的类可以访问该类，但是包没有继承的概念，所以后一句是不对。所以用protected来修饰类也是没有意义的。</p>
<p>​    外部类的修饰权限只能是public或者包访问权限，但是内部类可以是private或者protected。</p>
<p>​    如果没能为访问权限指定一个访问修饰符，它就会默认得到包访问权限，意味着该类的对象可以由包内任何其他类来创建，在包外是不行的。相同目录下所有不明确package声明的文件，都被视作是该目录下默认包的一部分。</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>进程：正在进行中的程序（直译）</p>
<p>线程：负责进程中程序执行的一个控制单元，也称为执行路径，执行情景。</p>
<p>一个进程中可以有多个执行路径，称之为多线程。</p>
<p>一个进程中至少要有一个线程。</p>
<p>开启多个线程是为了同时运行多部分代码；每一个线程都有自己运行的内容，这个内容可以称为线程要执行的内容。</p>
<p>多线程弊端：线程太多导致运行效率低。应用线程的执行都是CPU在做着快速的切换完成的，CPU切换是随机的。</p>
<p>JVM启动时启动了多个线程，至少有2个可以分析出来。</p>
<ol>
<li>执行main函数的线程</li>
</ol>
<p>该线程的任务代码都定义在main函数中。</p>
<ol start="2">
<li>负责垃圾回收的线程</li>
</ol>
<p>​    每个对象都有finalize()方法，当垃圾回收器确定不存在该对象的更多引用时，由对象的垃圾回收器调用此方法。</p>
<h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC13%E5%A4%A91.png" class title="This is an example image">

<p>sleep(time)时间到，线程便从冻结状态变为运行状态。如果使用wait()方法，使用notify()方法才能唤醒线程。</p>
<p>运行状态：具备执行资格，具备执行权</p>
<p>冻结状态：释放执行权的同时释放执行资格</p>
<p>临时阻塞状态：具备着执行资格但是不具备执行权</p>
<p>CPU的执行资格：可以被CPU处理，在处理队列中排队</p>
<p>CPU的执行权：正在被cpu处理</p>
<p>​    如果类已经有父类，要拓展此类的功能，让其中的内容可以作为线程的任务执行，通过接口的形式完成</p>
<h4 id="创建线程方式一"><a href="#创建线程方式一" class="headerlink" title="创建线程方式一"></a>创建线程方式一</h4><p>方式一：继承Thread类</p>
<ol>
<li><p>定义一个类继承Thread类</p>
</li>
<li><p>覆盖Thread类中的run()方法。Thread类用于描述线程，因此Thread类也有对任务的描述，这个任务就是通过Thread类中的run()方法来体现，因此   run()方法就是封装自定义线程运行任务的函数。run方法中定义的是线程要运行的任务代码。</p>
</li>
<li><p>直接创建Thread的子类对象创建线程</p>
</li>
<li><p>调用start()方法，作用为启动线程，调用run()方法</p>
</li>
</ol>
<p>开启线程是为了运行指定代码，所以只有继承Thread类，并覆写run()方法，将运行的代码定义在run()方法中。</p>
<p>​    可以通过Thread的getName(0方法来获取线程的名称 Thread-编号（从0开始），线程一被创建就调用super()，被赋予编号。</p>
<p>​    Thread.currentThread().getName()，获取正在运行的线程名字，主线程的名字就是main。如果想对线程起名，可以用Thread(String name)，用super(“名字”)父类构造器来起名字。</p>
<p>​    对于多线程的内存图解，相当于main函数中开启了多条通道</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC12%E5%A4%A91.png" class title="This is an example image">

<p>​    不同的线程有不同的工作区，每个放大的进栈弹栈在单独的空间内完成，每个方法中的变量互不冲突。</p>
<p>​    只要有一个前台进程还在运行，程序就不会结束。</p>
<p>​    在异常中，会显示异常出现的具体线程，在哪个线程出异常，就显示哪个线程。</p>
<h4 id="创建线程方式二"><a href="#创建线程方式二" class="headerlink" title="创建线程方式二"></a>创建线程方式二</h4><p>方式二：实现Runnable接口</p>
<ol>
<li><p>定义类实现Runnable接口</p>
</li>
<li><p>覆盖接口中的run()方法，将线程的任务代码封装到run()方法中</p>
</li>
<li><p>通过Thread类创建对象，并将Runnable接口的子类对象作为Thread类构造函数的参数进行传递</p>
<p>原因：因为线程的任务都封装在Runnable子类对象run()方法中，所以要在线程对象创建时明确要运行的任务。</p>
</li>
<li><p>调用线程对象的start()方法启动线程</p>
</li>
</ol>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC13%E5%A4%A92.png" class title="This is an example image">

<p>​    实现Runnable接口，如果使用无参数的Thread构造方法，则run()方法不做动作，如果传入Runnable子类，则调用的是子类中的方法。如果使用继承Thread类，则此类将父类中的run()方法覆盖，也没有影响。</p>
<p>​    使用多线程的目的是讲线程任务进行执行，如果直接继承Thread，将所有的线程类中的方法继承没有必要；如果只是实现Runnable接口，则它的出现仅仅是将线程的任务进行了对象的封装。为了运行创建Thread对象并明确线程的任务。</p>
<p>​    Thread类实现Runnable接口原因，此类与其他线程类都有共性：线程方法，但是此方法不是必须的，而是额外的功能，因此被抽取成一个接口。</p>
<h4 id="实现Runnable接口的好处"><a href="#实现Runnable接口的好处" class="headerlink" title="实现Runnable接口的好处"></a>实现Runnable接口的好处</h4><ol>
<li><p>将线程的任务从线程的子类中分离出来，进行了单独的封装。按照面向对象的思想将任务封装成了对象。</p>
</li>
<li><p>避免了java单继承的局限性</p>
</li>
</ol>
<p>所以创建线程的<strong>第二种方式</strong>较为常见</p>
<p>异常：所属线程+异常名称+异常信息+异常位置</p>
<p>​    卖票程序中，如果使用继承，新建多个Thread子类对象，每个对象都有票信息，没实现信息共享。需要利用实现Runnable接口，这样只产生一个对象，将线程任务封装成对象传递给Thread类，然后新建多个Thread类对象调用start()方法，因为只有一个Runnable子类对象，因此在堆内存中只存在一个票数信息。</p>
<p>​    卖票时候会出现，一个线程获取票数准备-1，此时切到另一个线程也获取票数，此时票数仍然符合要求，也准备-1，这样会出现票数&lt;=0的情况，会出现线程安全问题。</p>
<h4 id="线程安全问题产生原因"><a href="#线程安全问题产生原因" class="headerlink" title="线程安全问题产生原因"></a>线程安全问题产生原因</h4><ol>
<li><p>多个线程在操作共享的数据。</p>
</li>
<li><p>操作共享数据的线程代码有多条。（操作共享数据代码在2行以上容易出事）</p>
</li>
</ol>
<p>当一个线程在执行操作共享数据的多条代码中，其他线程参与了运算，就会导致线程安全问题的产生。</p>
<p>​    解决思路：将多条操作共享数据的线程代码封装起来；当有线程在执行这些代码的时候，其他线程是不可以参与运算的。必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算。</p>
<h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><p>​    在java中用同步代码块可以解决这个问题。</p>
<p>格式为：</p>
<p>sysnchronized(对象){需要被同步的代码}</p>
<p>​    此对象不能每次新建 对象，不然不是同一个锁</p>
<p>同步时设置对象相当于一个标志位，所有线程要运行任务时候要先进行状态判断，如果有线程正在进行此任务则需要等待此线程任务执行完毕。后期对同步中的线程进行监视，线程要判断同步锁。</p>
<p>同步的好处：解决了线程的安全问题</p>
<p>同步的弊端：相对降低了效率，因为同步外的线程都会判断同步锁。</p>
<p>Thread.sleep()需要进行try,catch，如果此类实现了接口，则不能抛出错误，只能解决，接口的异常对象为InterruptedException</p>
<p>​    同步的前提：同步中必须有多个线程并使用同一个锁。</p>
<p>如果同步锁的对象是成员变量，一个对象堆中只有一个，可以同步；如果此对象在run()方法中定义，则每个线程栈中都有一个，则不能实现同步。</p>
<p>线程开启必须有任务</p>
<p>​    使用同步函数也能解决线程的安全问题，将函数中加上synchronized修饰符。同步函数使用的锁是this。</p>
<p>​    同步函数和同步代码块的区别：</p>
<p>同步函数的锁是固定的this，同步代码块的锁是任意的对象。建议使用同步代码块。</p>
<p>如果同步函数使用静态修饰，因为静态方法中没有this，所以此时同步代码块中的同步锁对象为该函数所属字节码文件对象，可以用getClass方法获取，也可以用类名.class表示。</p>
<p>​    获取字节码文件：</p>
<p>Class clazz = t.getClass();</p>
<p>Class clazz = Ticket.class;`</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC13%E5%A4%A93.png" class title="This is an example image">

<p>​    使用懒汉式，在第一次的时候进行实例化，如果多个线程进来，先进行s的判断，可能会初始多个对象，这时候就有多线程的安全隐患，将getInstance()方法加上synchronized修饰即可。但是这样每个线程进来都要判断同步锁，降低了效率，可以使用同步代码块，其中同步对象为Single.class。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC13%E5%A4%A94.png" class title="This is an example image">

<p>​    线程0进来，此时s==null，开启同步锁，此时进入if判断，CPU切走，然后线程1进来，进入if判断，同步锁进不去，等线程0切回来，创建一个s对象，再切回到线程1，此时因为不满足if判断，因此结束。如果再有其他线程进来，不满足最外层s==null判断，因此也不会降低效率。</p>
<p>​    加一层同步，是为了解决线程安全问题；加一层判断，是为了解决效率问题。利用双重判断来解决懒汉式的安全和效率问题，因此开发式饿汉式更好。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>常见情形一：同步的嵌套</p>
<p>设置两个状态，同步嵌套，线程A同步锁为a，b；线程B同步锁为b，a。如果两个线程进去时候一个持有锁a，另一个持有锁b，这样就会出错。</p>
<h4 id="线程间通讯"><a href="#线程间通讯" class="headerlink" title="线程间通讯"></a>线程间通讯</h4><p>线程间通讯：多个线程在处理同一资源，但是任务却不同。</p>
<p>需求：有一资源，有输入与输出的方法，要求一个输入就一个输出，这样便涉及到了多线程。</p>
<p>​    设计思路：将资源封装成对象，输出实现Runnable接口，设置循环输出资源的信息；输入实现Runnable方法，设置循环获得资源的信息。因为输入与输出为2个类，而且都要获得资源对象，如果两个分别new资源对象，这样资源没有实现共享。因此要让输入输出 操作同一个对象，可以使用单例设计，也可以采用传参的形式，对输入输出进行构造函数传入参数对象，进行参数的设置。在主函数中，先创建资源，然后创建任务，再创建线程，执行路径，最后开启线程。</p>
<p>​    实现0,1的切换，利用x%2，在输入端进行2种设置，利用x值的不同来切换，如果张三，男；李四，女。</p>
<p>​    在主函数中运行，会出现张三，女和李四，男的情况，这是因为输入在设置的时候，便进行了输出。如果直接使用同步，则无法解决，这时候要思考同步的前提：一个同步锁中是否有多个线程。不符合，因为输入线程中只有一个线程，输出线程不在同步中。如果两边同时加入同步，但是不使用同一个锁，因此还是无法解决。这时候考虑到资源对象是唯一的，使用资源对象作为锁。这样便解决了对象输出错误的问题，但是输出的结果不是一个男，一个女。是因为输入拿到资源，不会只赋值一次，便一直在赋值；输出也一样，不会只输出一次，因此一直输出最后一次赋值结果。需求的效果是一个输入完后就进行输出。</p>
<p>​    为了解决这个问题，应该在资源中加入标记，如果有数据，那么便不进行覆盖，如果没有数据，再进行输入。加入一个数据后，标志位改变，这时候要等待输出线程进行输出。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E5%A4%A91.png" class title="This is an example image">

<p>​    在输入中，如果标记位为false，则没有信息，应该写入信息，将flag置为true，唤醒output线程，如果flag为真（还有信息，没有输出），则冻结input线程。在输出中，如果标记位为true，则有信息，应该输出信息，将flag置为false，唤醒input线程，如果flag为假（没有信息，还没输入），则冻结output线程。</p>
<h4 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h4><p>涉及的方法：</p>
<ol>
<li><p>wait();让线程处于冻结状态，被wait的线程会被存储到线程池中。</p>
</li>
<li><p>notify();唤醒线程池中的一个线程（任意）。</p>
</li>
<li><p>notifyAll();唤醒线程池中的所有线程。</p>
</li>
</ol>
<p>这些方法都必须定义在同步中，因为这些方法是用于操作线程状态的方法。必须要明确到底操作的是哪个锁上的线程。</p>
<p> 其中wait()和notify()方法要有所属，应该是同步锁的对象.wait()和同步锁的对象.notify()。在哪个对象中被等待和唤醒，就用哪个线程唤醒和等待.</p>
<p> 操作线程的方法wait,notify,notifyAll定义在Object类中原因是：因为这些方法是监视器的放法，监视器其实就是锁。锁可以是任意的对象，任意的对象调用的方式一定定义在Object类中。</p>
<p> 其中wait()抛出了InterruptedException异常，要有try,catch。</p>
<p>​    然后利用面向对象的思想，将姓名性别设置为私有属性，设置专门的set和out方法来设置和获取其属性。而因为定义在了资源这一个类中，可以直接利用同步方法来实现同步，同步锁为this，然后加进去flag判断和x切换输入，转变flag并唤醒线程池中线程。其中输出直接调用out方法即可。</p>
<p>​    单生产不会出问题，但是多生产多消费出问题。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E5%A4%A92.png" class title="This is an example image">

<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E5%A4%A93.png" class title="This is an example image">

<p>​    如果t0,t1是生产，t2,t3是消费，那么第一下t0进行生产了第1只烤鸭，此时烤鸭数为2，flag=true，这是t0进入了休眠状态，此时临时阻塞状态的线程有t1,t2,t3。这时候如果t1被CPU执行到，flag=true，t1也进入休眠状态。这时候剩下t2,t3线程。t2被CPU执行到，消费烤鸭1,flag=false，唤醒线程池中的线程，这时线程池中线程有t0和t1，这时候要随机唤醒安全锁中的线程，假设t0被唤醒，这时候t2仍然有执行权，因为flag=false，t2进入休眠，此时有执行权的线程有t0与t3。假设t3抢到了CPU的执行权，因为flag=false，这时候t3也进入等待，只有t0活着。线程唤醒后直接接着执行，不用重新判断flag，因此t0生产烤鸭2。count=3，这时候flag=true。线程池中有3个线程，t0,t2,t3。这时候如果t0被唤醒，活的有t0,t1。这时候如果t0又抢到了CPU运行权，因为flag=true，t0进入休眠。因为t1不用再判断flag，因此直接生产烤鸭3，count=4。到现在为止，生产了烤鸭1,2,3，但是只消费了烤鸭1，产生了安全问题，烤鸭2没有被消费到。</p>
<p>​    原因在线程醒来后<strong>没有重新判断flag标记</strong>。因为if只判断一次标记，因此将if更改为<strong>while</strong>，结束后还会判断条件，便可以解决烤鸭没有被消费到问题。但是会出现<strong>死锁</strong>的问题。当一个烤鸭被生产，flag=true，唤醒另一个生产线程，这时候活的有t0,t1，进入while判断，因为flag均会进入等待，便没有活的线程。</p>
<p>​    解决死锁：没有唤醒对方才导致死锁。不能指定唤醒的线程，但是可以唤醒所有的线程，这样本方的继续等待，对方的进行工作。这样可以使用notifyAll()方法。</p>
<p>​    while判断标记，解决了线程获取执行权后，是否要运行！原因：if判断标记只有一次，会导致不该运行的线程运行了，出现了数据错误的情况。    </p>
<p>​    notifyAll()解决了本方线程一定会唤醒对方线程。原因：notify()只能唤醒1个线程，如果本方唤醒本方，没有意义。而且while判断标记+notify()会导致死锁。</p>
<p>​    仍然存在的问题：还会唤醒本方线程，而唤醒本方是没有意义的。这样便降低了效率。</p>
<h4 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h4><p>​    <strong>JDK1.5后</strong>。同步代码块对于锁的操作是隐式的。后期把锁封装成对象，获取锁与释放锁是锁对象最清楚，变成显示的。现在有lock()与unlock()来对锁进行操作。因此lock对synchronized进行了替代，代码进行改写。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E5%A4%A94.png" class title="This is an example image">

<p>​    之前使用synchronized依靠自定义的obj对象作为锁，现在可以利用自定义的锁对象，语法为Lock lock = new ReentrantLock();。如果代码中发生了异常，释放锁不能执行，因此释放锁一定要进行执行，放在finally中。</p>
<p>​    以前的锁是this.wait()与this.notify()，用哪个锁，就用哪个锁上的方法。因此要利用lock来使用wait()与notify()。以前如果锁是this，那么锁上只有1组方法。当锁变成对象，可以有多个锁，将监视器方法封装成Condition对象。可以将多个Condition挂在锁上。</p>
<p>​    Condition因素出Object监视器方法（ wait ， notify和notifyAll ）成不同的对象，以得到具有多个等待集的每个对象，通过将它们与使用任意的组合的效果Lock来实现。 <strong>Lock替换synchronized方法和语句的使用， Condition取代了对象监视器方法的使用</strong>。可以随时和锁进行绑定，通过lock.newCondition()获取一个Condition对象。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E5%A4%A95.png" class title="This is an example image">

<p>​    将原来的this.wait()替换成con.await()，将this.notify()替换成con.signal()，将this.notifyAll()替换成con.signalAll()。</p>
<p>​    之前只有1个监视器，对生产者消费者区分不开。因此现在可以有2个监视器，1组监视生产者，1组监视消费者（以前这么实现需要生产者与消费者分别有个锁，因为一个锁上只有1个监视器）。因此生产者上唤醒消费者，消费者上唤醒生产者。因此可以不用使用signalAll来避免死锁，只要唤醒相应的线程即可。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E5%A4%A96.png" class title="This is an example image">

<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E5%A4%A97.png" class title="This is an example image">

<p>​    生产者如果不满足，则让生产者进行等待，生产者唤醒的时候要唤醒消费者的线程。即以前只有1个线程池，但是现在有2个监视器，具有不同的线程池。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E5%A4%A98.png" class title="This is an example image">

<p>​    Lock接口：出现替代了同步代码块或者同步函数。将同步的隐式锁操作变成显示锁操作。同时更为灵活，可以一个锁上挂多个监视器。</p>
<p>lock()：获取锁</p>
<p>unlock()：释放锁，通常需要定义在finally代码块中。</p>
<p>​    Condition接口：出现替代了Object中的wait notify notifyAll方法。将这些监视器方法单独进行了封装，变成Condition监视器对象，可以任意锁进行组合。</p>
<p>await():相当于wait()</p>
<p>signal():相当于notify()</p>
<p>signal()All:相当于notify()All</p>
<p><strong>判断条件一定要用while()，因为安全</strong>。</p>
<p>​    使用流程：</p>
<ol>
<li><p>上锁；</p>
</li>
<li><p>try{运行代码，判断条件使用while，满足条件，await，不满足继续进行。然后signal相应监视器}</p>
</li>
<li><p>finally{ 开锁 }</p>
</li>
</ol>
<h4 id="wait与sleep的区别"><a href="#wait与sleep的区别" class="headerlink" title="wait与sleep的区别"></a>wait与sleep的区别</h4><ol>
<li><p>wait可以指定时间也可以不指定，sleep必须指定时间。</p>
</li>
<li><p>在同步中，对cpu的执行权和锁的处理不同。</p>
<p>wait():释放执行权，<strong>释放锁</strong>。</p>
<p>sleep():释放执行权，不释放锁。</p>
</li>
</ol>
<p>不释放执行权，那么电脑就卡死了。</p>
<p>​    在同步中有执行资格不一定能执行，持有相应的锁才能执行。同步中只有一个线程能够执行，但是同步中活着的线程不一定只有一个。</p>
<h4 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h4><ol>
<li><p>stop()方法，已过时</p>
</li>
<li><p>run()方法结束</p>
</li>
</ol>
<p>如何控制线程的任务结束</p>
<p>​    任务中都有循环结构，只要控制住循环，就可以结束任务。</p>
<p>​    控制循环通常用定义标记来完成。while(flag)，然后st.setFlag()来改变标识。但是如果线程在同步中wait()释放执行权与锁，这样便没办法去读标记。</p>
<p>​    线程处于冻结状态就无法读取标记，结束方法是：interrupt()方法，将线程从冻结状态强制恢复到运行状态中来，让线程具备CPU的执行资格，会抛出中断异常。强制执行会发生InterruptedException，记得要处理。   </p>
<p>线程中常见方法</p>
<p>setDaemon(boolean on)：将该线程标记为守护（后台）线程，当所有线程都是守护线程时，jvm退出运行，必须在    线程启动前设置。后台线程与前台线程只有结束时候不一样，前台线程要设置手动结束，后台线程只要所有前台线程结束，则后台线程自动结束。如果想让一个线程依赖于其他线程，则可以设置为后台线程。</p>
<p>join()，常用于临时加入一个线程运算时，先将此对象运行完，将调用此方法的线程冻结，只有在join的方法运行结束后才恢复。</p>
<p>setPriority(优先级1-10)，设置线程运行优先级，1最低，10最高，默认为5。</p>
<p>Thread(ThreadGroup group) 设置线程组</p>
<p>yield()暂停当前线程，执行其他线程。礼让 </p>
<p>线程与匿名内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x ,<span class="number">50</span>;x++)&#123;</span><br><span class="line">			System.out.println(<span class="string">"x="</span>+x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure>

<p>开启一个匿名的线程子类对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable r = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x ,<span class="number">50</span>;x++)&#123;</span><br><span class="line">			System.out.println(<span class="string">"z="</span>+x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Thread(r).start();</span><br></pre></td></tr></table></figure>

<p>新建一个匿名的Runnable子类对象，然后新建线程对象并调用start()方法。</p>
<h3 id="方法定义完整格式"><a href="#方法定义完整格式" class="headerlink" title="方法定义完整格式"></a>方法定义完整格式</h3><p>Java中方法定义的完整格式</p>
<p>访问权限{ public | default | protected | private }[final] [static] [ synchronized]</p>
<p>返回值类型 | void 方法名称{参数类型 参数名称,…}[throws Exception1, Exception2]{</p>
<p>​    [return [返回值|返回调用处]]</p>
<p>}</p>
<h2 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h2><p>从面对对象的思想转变为<strong>使用对象</strong></p>
<h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>​    字符串是一个特殊的对象，字符串一旦初始化就不可以被改变。</p>
<p>​    有字符串常量池，池中没有就建立，池中有，直接用。因为字符串对象不可改变，因此可以实现共享</p>
<p>字符串建立的方式</p>
<ol>
<li><p>String s = “abc”; 创建一个字符串对象在常量池中</p>
</li>
<li><p>String s = new String(“abc”); 创建两个对象一个new一个字符串对象在堆内存中被new对象维护</p>
</li>
</ol>
<p>String类中的equals覆写了Object中的equals建立了String类自己的判断字符串对象是否相同的依据，其实就是比较字符串内容。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC15%E5%A4%A91.png" class title="This is an example image">

<p>​    将字节数组变成字符串，把数字进行ASII码的对应。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC15%E5%A4%A92.png" class title="This is an example image">

<p>String的构造器，可以将数组变成字符串（byte[]与char[]）,传入数字变成对应的字符</p>
<ol>
<li><p>String(byte[] bytes)；String(byte[] bytes, int offset, int length);定义起始位置，长度</p>
</li>
<li><p>String(char[] value);   String(char[] value, int offset, int count)</p>
</li>
</ol>
<p>寻找方法的思路：思考返回类型和传入类型</p>
<p>按照面向对象的思想对字符串功能进行分类</p>
<h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><p>  1.1 获取字符串中字符的个数（长度）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>  1.2 根据位置获取字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br></pre></td></tr></table></figure>

<p>  1.3 根据字符获取在字符串中第一次出现的位置(重点)我们可以根据-1，来判断该字符或者字符串是否存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> 从指定位置进行ch的查找第一次出现位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span> 找字符串的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span></span></span><br></pre></td></tr></table></figure>

<p>​    根据字符获取在字符串中最后一次出现的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> 从指定位置进行ch的查找最后一次出现位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span> 找字符串的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span></span></span><br></pre></td></tr></table></figure>

<p>  1.4 获取字符串中一部分字符串，也叫子串。<strong>包括begin,不包括end</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> 子串开始于指定beginIndex并延伸到字符索引endIndex-1 </span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> 从指定位置到结束</span></span><br></pre></td></tr></table></figure>

<h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><p>  2.1 将字符串变成字符串数组(字符串的切割)按照指定规则切割</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] split(String regex) ,不能直接用.切割，要转义成\\.，涉及到正则表达式</span><br></pre></td></tr></table></figure>

<p>  2.2 将字符串转成字符数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] toCharArray()</span><br></pre></td></tr></table></figure>

<p>  2.3 将字符串转成字节数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] getBytes() 一个中文<span class="number">2</span>字节，ascii为美国的编码表，GB2312中文的编码表最大为<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>  2.4 将字符串中的字母转成大小写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">()</span> 大写</span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">()</span> 大写</span></span><br></pre></td></tr></table></figure>

<p>  2.5 将字符串中的内容进行替换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> 没替换成功，仍然返回原来的字符串</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(String s1,String s2)</span></span></span><br></pre></td></tr></table></figure>

<p>  2.6 将字符串两端的空格去除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>  2.7 将字符串进行连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><p>  3.1 两个字符串是否相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span> 忽略大小写比较字符串是否相同</span></span><br></pre></td></tr></table></figure>

<p>  3.2 字符串中是否包含指定字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span></span></span><br></pre></td></tr></table></figure>

<p>  3.3 字符串是否以指定字符串开头，是否以指定字符串结尾</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>​     int compareTo(String anotherString) 如果参数字符串等于此字符串，则返回值0；如果此字符串按字典顺序小于字符串参数，则返回一个小于0的值；如果此字符串按字典顺序大于字符串参数，则返回一个大于0的值。</p>
<p>​    String intern()当调用intern方法时，如果池已经包含与[equals(Object)](mk:@MSITStore:D:\java学习资料\jdk api 1.8_google.CHM::/java/lang/String.html#equals-java.lang.Object-)方法确定的相当于此String对象的字符串，则返回来自池的字符串。 否则，此String对象将添加到池中，并返回对此String对象的引用。 由此可见，对于任何两个字符串s和t ， s.intern() == t.intern()是true当且仅当s.equals(t)是true 。可以将堆中的数据存到字符串池中去。</p>
<h3 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h3><p>StringBuffer:就是字符串缓冲区，用于存储数据的容器</p>
<p>特点：</p>
<ol>
<li><p>长度是可变的</p>
</li>
<li><p>可以存储不同类型的数据</p>
</li>
<li><p>最终要转成字符串进行使用</p>
</li>
<li><p>可以对字符串进行修改</p>
</li>
</ol>
<p>既然是一个容器对象，应该具备的功能有 </p>
<ol>
<li><p>添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">StringBuffer <span class="title">append</span><span class="params">(data)</span></span>;可以继续在append后面继续添加</span><br><span class="line"><span class="function">StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, <span class="keyword">char</span> c)</span> 在指定位置进行添加</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span>：包含头，不包含尾</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">deleteCharAt</span><span class="params">(<span class="keyword">int</span> index)</span> ：删除指定位置的元素</span></span><br><span class="line"><span class="function">sb.<span class="title">delete</span><span class="params">(<span class="number">0</span>, sb.length()</span>)</span>;清空缓冲区</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">StringBuffer <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCharAt</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span> ch)</span> 不返回本类对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">int</span> newLength)</span> 设置长度</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>增删改查C(create)U(update)R(read)D(delete)</strong></p>
<p>可变长度数组原理，如果长度超出，则新建一个长度与原数组相同的数组，然后将两个数组长度相加，原有的数据复制。</p>
<h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><p>jdk1.5以后出现了功能和StringBuffer一模一样的对象，就是StringBuilder。</p>
<p>不同之处，</p>
<p>StringBuilder是线程同步的,通常用于多线程</p>
<p>StringBuffer是线程不同步的。通常用于单线程，它的出现提高效率</p>
<p>StringBuilder因为没有判断锁，因此单线程使用StringBuilder，如果多线程使用StringBuffer。如果操作全部是字符串，那么就用StringBuilder</p>
<h3 id="jdk升级原则"><a href="#jdk升级原则" class="headerlink" title="jdk升级原则"></a>jdk升级原则</h3><ol>
<li><p>简化书写（可能有弊端）</p>
</li>
<li><p>提高效率（可能有弊端）</p>
</li>
<li><p>提高安全性（书写麻烦）</p>
</li>
</ol>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>8种：byte,int,short,long,double,float,char,Boolean</p>
<p>将基本数据类型包装成类</p>
<p>​    用基本数值类型和字符串做转换</p>
<p>基本数据类型包装类</p>
<p>为了方便操作数据类型值，将其封装成了对象，在对象中定义了属性和行为，丰富了该数据的操作</p>
<p>  用于描述该对象的类就称为基本数据类型包装类</p>
<p>  byte    Byte</p>
<p>  short   Short</p>
<p>  int    Integer   静态方法parseInt(String s)</p>
<p>  long    Long</p>
<p>  float   Float</p>
<p>  double   Double</p>
<p>  char    Character</p>
<p>  boolean Boolean</p>
<p>  该包装对象主要用于基本类型和字符串之间的转换</p>
<h4 id="基本类型—-gt-字符串"><a href="#基本类型—-gt-字符串" class="headerlink" title="基本类型—&gt;字符串"></a>基本类型—&gt;字符串</h4><ol>
<li><p>基本数值类型+””</p>
</li>
<li><p>用String类中的静态方法valueOf(基本数值类型)</p>
</li>
<li><p>用Integer的静态方法toString(int i, int radix)</p>
</li>
</ol>
<h4 id="字符串—-gt-基本类型"><a href="#字符串—-gt-基本类型" class="headerlink" title="字符串—&gt;基本类型"></a>字符串—&gt;基本类型</h4><ol>
<li><p>使用包装类中的静态方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">xxx <span class="title">parseXxx</span><span class="params">(<span class="string">"xxx类型的字符串"</span>)</span></span>;***最常用</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(<span class="string">"intString"</span>)</span></span>;Integer.parseInt()</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">parseLong</span><span class="params">(<span class="string">"longString"</span>)</span></span>;Long.parseInt()</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">parseBoolean</span><span class="params">(<span class="string">"booleanString"</span>)</span></span>; Boolean.parseBoolean()</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果字符串被Integer进行对象的封装。可使用另一个非静态的方法：intValue()</p>
<p>将一个Integer对象转成基本数据类型值</p>
<p>Integer j = new Integer(“123”);</p>
<p>System.out.println(j.intValue());</p>
</li>
</ol>
<h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h4><ul>
<li>十进制–&gt;其他进制</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> String Integer.toBinaryString(<span class="keyword">int</span> i);<span class="comment">//2进制</span></span><br><span class="line"><span class="keyword">static</span> String Integer.toOctalString(<span class="keyword">int</span> i);<span class="comment">//8进制</span></span><br><span class="line"><span class="keyword">static</span> String Integer.toHexString(<span class="keyword">int</span> i);<span class="comment">//16进制</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> radix)</span> 任意进制</span></span><br></pre></td></tr></table></figure>

<ul>
<li>其他进制–&gt;十进制</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s, <span class="keyword">int</span> radix)</span></span></span><br></pre></td></tr></table></figure>

<p>Integer中比较的是数值是否相同。如果用equals方法就是返回boolean，如果用compareTo方法返回的是数值，可以知道哪个比较大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">i +</span>= <span class="number">6</span>;<span class="comment">//i = new Integer(i.intvalue()+6);//i.intvalue()自动拆箱</span></span><br></pre></td></tr></table></figure>

<p>而因为i为对象，因此i可能为null，如果空的调用intvalue()方法会出错，因此在自动拆箱的时候要进行健壮性判断。</p>
<h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><p>集合类的由来</p>
<p>​    对象用于封装特有数据，对象多了就需要存储，如果对象的个数不确定，</p>
<p>​    就使用集合容器进行存储</p>
<h4 id="集合特点："><a href="#集合特点：" class="headerlink" title="集合特点："></a>集合特点：</h4><ol>
<li><p>用于存储对象的容器</p>
</li>
<li><p>集合的长度是可变的</p>
</li>
<li><p>集合中不可以存储基本数据类型</p>
</li>
</ol>
<p>集合容器因为内部的数据结构不同，有多种具体容器。</p>
<p>不断向上抽取，就形成了集合框架</p>
<p>框架的顶层Collection接口：</p>
<h4 id="Collection的常见方法："><a href="#Collection的常见方法：" class="headerlink" title="Collection的常见方法："></a>Collection的常见方法：</h4><ol>
<li>添加</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object obj)</span></span>;添加一个对象</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection coll)</span></span>;添加一堆对象</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>删除</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>;删除一个对象，利用equals方法判断</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection coll)</span></span>;删除一堆对象，将两个集合中的相同元素从调用removeAll的集合中删除</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;将集合中的元素都删掉</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object obj)</span></span>;判断是否有此对象，利用equals方法判断</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection coll)</span></span>;判断是否有一堆对象</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;判断集合中是否有元素</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;获取长度</span><br><span class="line"><span class="function">Iterator <span class="title">iterator</span><span class="params">()</span></span>;取出元素的方式：迭代器</span><br></pre></td></tr></table></figure>

<p>  该对象必须依赖于具体的容器，因为每一个容器的数据结构都不同。</p>
<p>  所以该迭代器对象是在容器中进行内部实现的。</p>
<p>  对于使用容器者而言，具体的实现不重要，只要通过容器获取到该实现的迭代器对象即可，也就是iterator方法。</p>
<ol start="5">
<li>其他</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection coll)</span></span>;取交集，取交集，保留和指定集合相同的元素，而删除不同的元素。与removeAll相反</span><br><span class="line">Object[] toArray();将集合转成数组</span><br></pre></td></tr></table></figure>

<h4 id="集合判断元素依据"><a href="#集合判断元素依据" class="headerlink" title="集合判断元素依据"></a>集合判断元素依据</h4><p>对于ArrayList这样的集合，判断元素的方式是依据equals方法，而对于HashSet这样的集合，依靠的是equals和hashCode方法</p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>取出元素的两种方法</p>
<p>Collection coll = new ArrayList();</p>
<ol>
<li><p>使用while循环，结束后it占用内存空间，开发中不推荐</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator it = coll.iterator();</span><br><span class="line">	<span class="keyword">while</span>(it.hasNext())</span><br><span class="line">		System.out.println(it.next());</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用for循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator it = coll.iterator();it.hasNext();) &#123;</span><br><span class="line">	System.***out\***.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>iterator是一个内部类。类比于娃娃机的夹子，娃娃机是容器，夹子是迭代器，迭代器不能直接new，只能通过容器来操作夹子，但是统一的有移动和按钮。</p>
<p>集成框架的构成</p>
<h4 id="常见集合关系图"><a href="#常见集合关系图" class="headerlink" title="常见集合关系图"></a>常见集合关系图</h4><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC16%E5%A4%A91.png" class title="This is an example image">

<p>虚线框都是接口</p>
<p>Collection</p>
<pre><code>|--List: 有序，(存入和存出的数据一致)，元素都有索引(角标)，元素可以重复。</code></pre><p>​     |–Set: 元素不能重复，无序。</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List特有的常见方法:有一个共性特点就是都可以<strong>操作角标</strong></p>
<ol>
<li><p>添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(index,collection)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">remove</span><span class="params">(index)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">set</span><span class="params">(index,element)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object)</span></span>;</span><br><span class="line"><span class="function">List <span class="title">subList</span><span class="params">(from,to)</span></span>;包含头不包含尾</span><br></pre></td></tr></table></figure>

<p>List集合是可以完成对元素的增删改查</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一般集合的取出方式</span></span><br><span class="line">Iterator it = list.iterator();   </span><br><span class="line">	<span class="keyword">while</span>(it.hasNext())</span><br><span class="line">		System.out.println(it.next());</span><br><span class="line">	<span class="comment">//list特有的取出方式</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;list.size();x++)</span><br><span class="line">		System.out.println(<span class="string">"get:"</span>+list.get(x));</span><br></pre></td></tr></table></figure>

<p>当迭代器与集合同时操作元素，就会产生异常，这样是并发操作。</p>
<p>在迭代过程中不要使用集合操作元素，容易出现异常</p>
<p>可以使用Iterator接口的子接口ListIterator来完成迭代中对元素进行更多的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListIterator it = list.listIterator();<span class="comment">//获取列表迭代器对象</span></span><br><span class="line">		<span class="comment">//它可以实现在迭代过程中完成对元素的增删改查</span></span><br><span class="line">		<span class="comment">//注意：只有List集合具有该迭代功能。</span></span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			Object obj = it.next();</span><br><span class="line">			<span class="keyword">if</span>(obj.equals(<span class="string">"abc2"</span>))</span><br><span class="line">				it.set(<span class="string">"abc9"</span>);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>ListIterator listIterator()从头返回列表迭代器</p>
<p>ListIterator listIterator(int index)从指定位置返回列表迭代器</p>
<p>不仅有hasNext()和next()，还有hasPrevious()和previous()方法</p>
<p>List接口中比较常用的有：<strong>ArrayList</strong>，<strong>LinkList</strong>。</p>
<p>List</p>
<p>​    |–Vector:内部是数组数据结构，是同步的。效率低。增删、查询都很慢！</p>
<p>​    |–ArrayList:内部是数组数据接口，是不同步的。替代了Vector。查询的速度快。</p>
<p>​    |–LinkedList:内部是链表数据结构，是不同步的。增删元素的速度很快。</p>
<p>​    数组增删慢的原因是增加删除一个元素，该元素之后的内存空间均要发生变化，而查询快是因为内存空间是连续的。而链表存储是不连续的，而链表的增删只需要将此对象的地址存给上一个对象或者将此对象所存的下一个对象的地址存入上一个对象即可完成。查询慢是因为要遍历链表才能完成查询，而链表存储空间不是连续的（作为List的子类也有下标索引）。</p>
{% asset_img 第16天2.png This is an example image %}

<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(element)</span> 在链表的开头加入指定的元素</span></span><br><span class="line"><span class="function"><span class="title">getFirst</span><span class="params">()</span> <span class="comment">//获取第一个元素但不删除</span></span></span><br><span class="line"><span class="function"><span class="title">removeFirst</span><span class="params">()</span>)</span>;<span class="comment">//获取第一个元素并删除，remove()会改变长度</span></span><br></pre></td></tr></table></figure>

<h5 id="遍历链表的一种方式"><a href="#遍历链表的一种方式" class="headerlink" title="遍历链表的一种方式"></a>遍历链表的一种方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!link.isEmpty())&#123;<span class="comment">//判断是否为空，为空则为真</span></span><br><span class="line">			System.out.println(link.removeLast());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Linkedist常用方法与1-6改进"><a href="#Linkedist常用方法与1-6改进" class="headerlink" title="Linkedist常用方法与1.6改进"></a>Linkedist常用方法与1.6改进</h5><p>添加</p>
<p>​    addFirst();</p>
<p>​    addLast();</p>
<p><strong>jdk1.6</strong></p>
<p>​    offerFirst();</p>
<p>​    offerLast();</p>
<p>  获取</p>
<pre><code>getFirst();//获取但不移除。如果链表为空，抛出NoSuchElementException

getLast();</code></pre><p> <strong>jdk1.6</strong></p>
<p>​    peekFirst();//获取但不移除。如果链表为空，返回null</p>
<p>​    peekLast();</p>
<p>移除</p>
<p>​    removeFirst();//获取并移除。如果链表为空，抛出NoSuchElementException</p>
<p>​    removeLast();</p>
<p>  <strong>jdk1.6</strong></p>
<p>​    pollFirst();//获取并移除。如果链表为空，返回null</p>
<p>​    pollLast();</p>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>默认新建ArrayList对象的时候，开辟的空间为10。</p>
<p>((Person)it.next()).getName()+”::”+((Person) it.next()).getAge());</p>
<p>//不能直接调用Person的方法，因为此时被提升为了Object，父类中没有此方法,可以使用强制类型转换。如果不给it.next加括号， 那么因为.优先级太高而没有先完成强制转换。</p>
<p>如果在循环中多次调用it.next，那么会出错，因为next一直在往下走。 </p>
<p>  因此如果使用自定义对象，一直要使用强制类型转换，才能获取该对象的特有方法。直接打印it.next()，出现的是类名加哈希值，因为该对象没有覆写toString()方法。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC17%E5%A4%A91.png" class title="This is an example image">

<p>内存图解，集合中存储的均为堆内存对象的引用，迭代器取出元素，也是使用的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList al = <span class="keyword">new</span> ArrayList();</span><br><span class="line">al.add(<span class="number">5</span>);<span class="comment">//al.add(new Integer(5))</span></span><br><span class="line">add()方法不能接受基本数据类型，但是在jdk1<span class="number">.4</span>后可以使用自动装箱。</span><br></pre></td></tr></table></figure>

<p>  当基本数据类型赋值给引用数据类型的时候，会发生自动装箱。因为集合中需要添加对象，直接用数字相当于对5进行了Integer装箱。当引用数据类型与基本数据类型做运算，会发生自动拆箱。</p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><h4 id="枚举-1"><a href="#枚举-1" class="headerlink" title="枚举"></a>枚举</h4><p>使用element方法获取枚举。</p>
<p>Vector中有枚举接口Enumeration，功能与Iterator一样，但是Iterator名称更简单。</p>
<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p>Set:元素不可重复，是无序。</p>
<p>  Set接口中的方法和Collection一致。</p>
<p>|–<strong>HashSet</strong>:内部数据结构是哈希表，是不同步的。</p>
<ul>
<li><p>保证集合元素的唯一性</p>
</li>
<li><p>是通过对象的hashCode和equals方法来完成对象的唯一性的。</p>
</li>
<li><p>如果对象的hashCode值不同，那么不用判断equals方法，就直接存储到哈希表中。</p>
</li>
<li><p>如果对象的hashCode值相同，那么要再次判断对象的equals方法是否为true。</p>
</li>
<li><p>如果为true，视为相同元素，不存。如果 为false，视为不同元素，进行存储。</p>
<pre><code>  **记住：如果元素要存储到HashSet集合中，必须覆盖hashCode方法和equals方法**。

一般情况下，如果定义的类会产生很多对象，比如学生，人，书，通常都要覆盖equals，hashCode方法。

建立对象判断是否相同的依据。</code></pre></li>
</ul>
<p>|–<strong>TreeSet</strong>:可以对Set集合中的元素排序。是不同步的。</p>
<p>​        判断元素唯一性的方式:就是根据比较方法的返回结果是否为0，是0，就是相同元素，不存。</p>
<pre><code>TreeSet对元素进行排序的**方式一**:</code></pre><ul>
<li><p>让<strong>元素自身具备比较功能</strong>，元素就需要实现Comparable接口，覆盖compareTo方法。</p>
</li>
<li><p>如果不要按照对象中具备的自然顺序排序。如果对象中不具备自然顺序。怎么办？</p>
<p> TreeSet对元素进行排序的<strong>方式二</strong>:</p>
</li>
<li><p>让集合自身具备比较功能。定义一个类实现Comparator接口，覆盖compare方法。</p>
</li>
<li><p>将该类对象作为参数传递给TreeSet集合的构造函数。</p>
</li>
<li><p>比较器发开中更为常用，如果有比较器和类自己的compareTo方法，优先使用比较器。</p>
</li>
</ul>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>优化过的数组，根据存的元素的特点来获取其数组中的位置。查找的时候，根据这个元素再计算其对应的位置值，然后直接取出即可。算法为哈希算法。hashCode()为计算对象的哈希值，自定义对象可以覆盖方法。</p>
{% asset_img 第17天2.png This is an example image %}

<p>如自定义哈希算法，根据ab的特点算出一个值，再将值%数组长度，必定会得到数组长度之内的一个值，这样就可以获取到ab的位置。当要寻找ab的时候，再计算ab的哈希值，这样直接在相应的位置去寻找即可。</p>
<p>​    Set的获取只能使用迭代器。</p>
<p>​    哈希算法提高了数组的查询效率，但是不能重复。</p>
<h4 id="哈希表确定元素是否相同"><a href="#哈希表确定元素是否相同" class="headerlink" title="哈希表确定元素是否相同"></a>哈希表确定元素是否相同</h4><ol>
<li><p>判断的是两个元素的哈希值是否相同。如果相同，再判断两个对象的内容是否相同。</p>
</li>
<li><p>判断哈希值相同，其实判断的是对象的hashCode()方法。判断内容相同，用的是equals()方法。</p>
</li>
</ol>
<p>注意：如果哈希值不同，是不需要判断equals的。</p>
<p>哈希值一样，但是对象不一样，称之为哈希冲突。如果冲突则顺延或者串联。在相同位置挂一个出来。</p>
<p>当存入的是自定义对象时候，需要覆写hashCode方法和equals方法。如果是字符串则调用字符串的hashCode()，如果是数字，则乘上一个常数。进行比较的时候，首先判断位置是否相同，然后向下转型之前进行健壮性判断，然后比较对应的信息。为了便于输出信息，可以覆写对象的toString方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="keyword">this</span>+<span class="string">"......hashCode"</span>);</span><br><span class="line">	<span class="keyword">return</span> name.hashCode()+age*<span class="number">27</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>==obj)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Person))</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();<span class="comment">//健壮性判断</span></span><br><span class="line">	Person p = (Person)obj;<span class="comment">//向下转型	</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name.equals(p.name)&amp;&amp; <span class="keyword">this</span>.age==p.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哈希集合中判断元素是否相同的依据是hashCode方法和equals方法。</p>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>哈希表和链表实现了Set接口，具有可预测的迭代次序。 这种实现不同于HashSet，它维持于所有条目的运行双向链表。 该链表定义了迭代排序，它是将元素插入集合（插入顺序 ） 的顺序 。</p>
<p>​    怎么样存就怎么取出来。</p>
<p>​    如果要<strong>唯一而且要有序</strong>，就用LinkedHashSet。</p>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>如果要存入自定义对象，需要此对象<strong>实现Comparable接口</strong>并<strong>覆盖compareTo方法</strong>。</p>
<h4 id="二叉树图解"><a href="#二叉树图解" class="headerlink" title="二叉树图解"></a>二叉树图解</h4>{% asset_img 第17天3.png This is an example image %}

<p>​    28进来不用比较，21进来比28小放在左边，29进来比28大放在右边。25比28小进左边，比21大生叉放在21右边，以此类推。</p>
<p>​    节点的特点：最多持有3个引用，左、右、父。二叉树为了提高效率，会在每次添加新元素时候进行二分查找。</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型:</p>
<p>  jdk1.5后出现的安全机制。</p>
<p>好处:</p>
<ol>
<li><p>将运行时期的问题ClassCastException转到了编译时期。</p>
</li>
<li><p>避免了强制转换的麻烦。</p>
</li>
</ol>
<p>&lt;&gt;:什么时候用？当操作的引用数据类型不确定的时候，就使用&lt;&gt;，将要操作的引用数据类型传入即可。</p>
<p>​     其实&lt;&gt;就是一个用于接收具体引用数据类型的参数范围。</p>
<p>在程序中，只要用到了带有&lt;&gt;的类或者接口，就要明确传入的具体引用数据类型。</p>
<p>泛型技术是给编译期使用的技术，用于编译时期。确保了类型的安全。</p>
<p>运行时，会将泛型去掉，生成的class文件中是不带泛型的，这个称为泛型的擦除。</p>
<p>擦除的原因：为了去兼容运行时的类加载器。</p>
<p>泛型的补偿:在运行时，通过获取元素的类型进行转换动作，不用使用者再强制</p>
<p>泛型中不能使用基本数据类型，只能传入引用数据类型。</p>
<p>Comparable接口上定义了泛型，指定进行比较的参数类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = <span class="keyword">this</span>.age - p.age;</span><br><span class="line">		<span class="keyword">return</span> temp==<span class="number">0</span>?<span class="keyword">this</span>.name.compareTo(p.name):temp;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>​    如果不指定，默认为Object，而且在compareTo方法中还要向下转型。</p>
<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>在jdk1.5后，使用泛型来接收类中要操作的引用数据类型。</p>
<p>泛型类，什么时候用？当类中的操作的引用数据类型不确定的时候，就使用泛型来表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tool</span>&lt;<span class="title">Q</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Q q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>&lt;W&gt; <span class="keyword">void</span> <span class="title">show</span><span class="params">(W str)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"show"</span>+str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将泛型定义在方法上，W为类型名称，待传入，而W要进行声明。</p>
<p>​    当方法静态时，不能访问类上定义的泛型，如果静态方法使用泛型，只能将<strong>泛型定义在方法上</strong>。</p>
<p>泛型一定要放在<strong>返回值的前面</strong>，<strong>修饰符的后面</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;Y&gt;<span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(Y obj)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"method"</span>+obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用泛型，则有些对象才有的方法则不能使用，但是部分方法可以使用，即Object中的方法必定可以使用</p>
<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>实现一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterImp</span> <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InterImp in = <span class="keyword">new</span> InterImp();</span><br><span class="line">in.show(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>

<p>实现二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterImp2</span>&lt;<span class="title">Q</span>&gt; <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">Q</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Q q)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"show"</span>+q);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InterImp2&lt;Integer&gt; in2 = <span class="keyword">new</span> InterImp2&lt;Integer&gt;();</span><br><span class="line">in2.show(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><p>泛型的通配符:?未知类型。</p>
<p>当不能明确传入泛型的类型时候使用。仅在类型不明确并不对这类型操作来表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCollection</span><span class="params">(Collection&lt;?&gt; al)</span> </span>&#123;</span><br><span class="line">		Iterator&lt;?&gt; it = al.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			System.out.println(it.next());</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;Q&gt;<span class="function"><span class="keyword">void</span> <span class="title">printCollection</span><span class="params">(Collection&lt;Q&gt; al)</span> </span>&#123;</span><br><span class="line">		Iterator&lt;Q&gt; it = al.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			System.out.println(it.next());</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是比较麻烦 </p>
<h4 id="泛型限定"><a href="#泛型限定" class="headerlink" title="泛型限定"></a>泛型限定</h4><p>只能有一部分类型能进来</p>
<p>可以对类型进行限定</p>
<p>? <strong>extends</strong> E:接收E类型或者E的子类型对象。上限！    </p>
<p>? <strong>super</strong> E:接收E类型或者E的父类型，下限！</p>
<p>迭代器的泛型和获取迭代器集合的泛型一致。</p>
<p><strong>泛型上限</strong>：</p>
<p>如果有不同的集合，分别创建Person类的子类，一个方法要接收Person类子类的集合，不能直接接收Collection<Person>，因为Person为一具体类型。</Person></p>
<p>  一般两边泛型类型要一致。这样要如果限定只能接收某一对象的子类，可以使用</p>
<p><strong>&lt;? extends Person&gt;</strong>，即只接收Person或者Person的子类。这样<strong>可以直接新建Person类对象</strong>。</p>
<p><strong>泛型下限</strong>:</p>
<p>使用&lt;? super Student&gt;，只能接收学生类及其父类</p>
<p>addAll(Collection&lt;? extends E&gt; e)原因，可以接收该集合类型及子类类型，提高了拓展性和安全性。一般只要写了E就可以接收该类的集合对象，但是为了能接收其子类对象，增加了泛型的上限。</p>
<p><strong>使用情况：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">addAll(Collection&lt;? extends E&gt; e)</span><br><span class="line">		ArrayList&lt;Person&gt; al1 = <span class="keyword">new</span> ArrayList&lt;Person&gt;();		</span><br><span class="line">		ArrayList&lt;Student&gt; al2 = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line">		al1.addAll(al2);</span><br></pre></td></tr></table></figure>

<p>一般存储元素的时候都使用上限，因为这样取出都是按照上限类型来运算的，不会出现类型安全隐患。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span><br><span class="line">		TreeSet&lt;Person&gt; al1 = <span class="keyword">new</span> TreeSet&lt;Person&gt;(<span class="keyword">new</span> CompByName());</span><br><span class="line">		TreeSet&lt;Student&gt; al2 = <span class="keyword">new</span> TreeSet&lt;Student&gt;(<span class="keyword">new</span> CompByName());</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompByName</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = o1.getName().compareTo(o2.getName());</span><br><span class="line">		<span class="keyword">return</span> temp==<span class="number">0</span>?o1.getAge()-o2.getAge():temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>学生的集合中，比较器可以用学生的也可以用父类的，因为其使用的方法源于父类。</p>
<p>  通常<strong>对集合中的元素取出操作</strong>时，可以使用下限。存什么类型，我可以用其类型和父类类型来进行接收。</p>
<p>包含containsAll(Collection&lt;?&gt;coll)为什么用？</p>
<p>  因为Collection的原理为equals，任何对象都具有其方法，因此接收的集合类型可以是任意类型，因此用?来进行接收。只要全部使用Object方法，因此就可以使用?。</p>
<h3 id="集合框架查询技巧"><a href="#集合框架查询技巧" class="headerlink" title="集合框架查询技巧"></a>集合框架查询技巧</h3><p>需要唯一吗？</p>
<p>需要：Set</p>
<p>​    需要指定顺序吗？</p>
<p>​           需要：TreeSet</p>
<p>​           不需要：HashSet</p>
<p>​           但是想要一个和存储一致的顺序（有序）：LinkedHashSet</p>
<p>不需要：List</p>
<p>​    需要频繁增删吗？</p>
<p>​           需要：LinkedList</p>
<p>​           不需要：ArrayList</p>
<p>如何记住每一个容器的结构和所属体系呢？</p>
<p>看名字！</p>
<p>List:</p>
<p>​        |–ArrayList</p>
<p>​        |–LinkedList</p>
<p>Set:</p>
<p>​        |–HashSet</p>
<p>​        |–TreeSet</p>
<p>后缀名就是该集合所属的体系。</p>
<p>前缀名就是该集合的数据结构。</p>
<p>看到arrays：就要想到数组，就要想到查询快，有角标。</p>
<p>看到link：就要想到链表，就要想到增删快，就要想到add get remove+first  last的方法</p>
<p>看到hash：就要想到哈希表，就要想到唯一性，就要想到元素需要覆盖hashCode方法和equals方法。</p>
<p>看到tree：就要想到二叉树，就要想到排序，就要想到两个 接口Comparable，Comparator（比较器）</p>
<p>而且这些通常这些常用的集合容器都是不同步的。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map:一次添加一对元素。Collection:一次添加一个元素。</p>
<p>Map也称为双列集合，Collection称为单列集合。</p>
<p>其实Map集合中存储的是键值对。Map集合中必须保证键的唯一性。</p>
<p>常用方法:</p>
<ol>
<li><p>添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">value <span class="title">put</span><span class="params">(key,value)</span></span>;返回前一个和key关联的值，如果没有返回<span class="keyword">null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;清空map集合</span><br><span class="line"><span class="function">value <span class="title">remove</span><span class="params">(key)</span></span>;根据指定的key删除这个键值对</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">value <span class="title">get</span><span class="params">(key)</span></span>;通过键获取值，如果没有该键，返回<span class="keyword">null</span>。</span><br><span class="line">				当然可以通过返回<span class="keyword">null</span>,来判断是否包含指定键。</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;获取键值对的个数。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="取出Map中所有元素"><a href="#取出Map中所有元素" class="headerlink" title="取出Map中所有元素"></a>取出Map中所有元素</h4><p>方式一：取出丈夫，再取出妻子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line"><span class="comment">//取出Map中的所有元素</span></span><br><span class="line"><span class="comment">//原理，通过keySet方法获取map中所有的键所在的Set集合，再通过Set的迭代器获取到每一个键。</span></span><br><span class="line"><span class="comment">//再对每一个键获取其对应的值即可。</span></span><br><span class="line">Set&lt;Integer&gt; keySet = map.keySet();</span><br><span class="line">Iterator&lt;Integer&gt; it = keySet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	Integer key = it.next();</span><br><span class="line">	String value = map.get(key);</span><br><span class="line">	System.out.println(key+<span class="string">":"</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

{% asset_img 第18天1.png This is an example image %}

<p>首先利用keySet()方法将Map中的键映射到Set集合中，然后通过迭代器可以得到每一个键key，再利用Map的get(key)方法得到每一个键对应的值。</p>
<p>其中被注释的两句相当于下面一句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//		Set&lt;Student&gt; keyset = hm.keySet();</span></span><br><span class="line"><span class="comment">//		Iterator&lt;Student&gt; it = keyset.iterator();</span></span><br><span class="line">		Iterator&lt;Student&gt; it = hm.keySet().iterator();</span><br></pre></td></tr></table></figure>

<p>方式二：得到结婚证书</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 通过Map转成Set就可以迭代，找到了另一个方法	entrySet.</span></span><br><span class="line"><span class="comment">		 * 该方法将键和值的映射关系作为对象存储到了Set集合中，而这个映射关系的类型就是Map.Entry类型(结婚证)</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">		Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = entrySet.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			Map.Entry&lt;Integer, String&gt; me = it.next();</span><br><span class="line">			Integer key = me.getKey();</span><br><span class="line">			String value = me.getValue();</span><br><span class="line">			System.out.println(key+<span class="string">":"</span>+value);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>​    通过entrySet()方法将键值的映射投射到Set集合中，其中将键和值封装成一个对象。</p>
{% asset_img 第18天2.png This is an example image %}

<p>其中上面两句相当于下面一句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//		Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entrySet = map.entrySet();</span></span><br><span class="line"><span class="comment">//		Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = entrySet.iterator();</span></span><br><span class="line">	Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = map.entrySet().iterator();</span><br></pre></td></tr></table></figure>

<p>只获取value值</p>
<p>Collection values();返回value所有值的Collection集合</p>
<h3 id="Map常用的子类"><a href="#Map常用的子类" class="headerlink" title="Map常用的子类"></a>Map常用的子类</h3><p>​    |–Hashtable:内部结构是哈希表，是同步的。不允许null作为键，不允许null作为值。</p>
<p>​    |–Properties:用来存储键值对型的配置文件的信息。可以和IO技术相结合。</p>
<p>​    |–HashMap:内部结构是哈希表，不是同步的。允许null作为键，允许null作为值。</p>
<p>​    |–TreeMap:内部结构是二叉树，不是同步的。可以对Map集合中的键进行排序。 </p>
<p>HashSet是HashMap的一个实例。</p>
<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>​    可以将存储的元素有序输出，即存入什么顺序，取出什么顺序。</p>
<h4 id="Map应用"><a href="#Map应用" class="headerlink" title="Map应用"></a>Map应用</h4><p>  Map集合在有映射关系时可以优先考虑</p>
<p>​    键值关系多，往Map里面存储，不一定需要有序编号，只是建立对象间的关系。</p>
<p>​    Map中的值也可以是集合，如List,Set</p>
<p>​    在查表法中的应用较为多见</p>
<h3 id="集合框架工具类"><a href="#集合框架工具类" class="headerlink" title="集合框架工具类"></a>集合框架工具类</h3><h4 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a>Collections类</h4><p>Collections:是集合框架的工具类，里面的方法都是静态的，<strong>操作集合</strong>。</p>
<p>1、 排序</p>
<p>自然顺序排序</p>
<p>Collections sort(List) </p>
<p>​    如果只对一种类型进行排序，那么就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mySort</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size()-<span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; list.size(); j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(list.get(i).compareTo(list.get(j))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">					String temp = list.get(i);</span><br><span class="line">					list.set(i, list.get(j));</span><br><span class="line">					list.set(j,temp);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>如果想对任意类型的集合进行排序，那么需要使用泛型，可以使用&lt;?&gt;或<T>，但是要对泛型的类型进行限制，因此变成</T></p>
<p>  <strong>public</strong> <strong>static</strong> <T><strong>void</strong> mySort(List<T> list)</T></T></p>
<p>  但是排序中用到了compareTo方法，只有实现了此接口才具有，因此对T进行限定，必须是Comparable接口的子类，则变成</p>
<p><strong>public</strong> <strong>static</strong> &lt;T <strong>extends</strong> Comparable<T>&gt; <strong>void</strong> mySort(List<T> list)</T></T></p>
<p>  而Comparable也要指出泛型的类型，可以使用T。为了提高拓展性，为了可以让T的父类也能接收T，因此Comparable的泛型使用&lt;? super T&gt;，即可以使用T或者T的父类进行接收，因此最终变成</p>
<p><strong>public</strong> <strong>static</strong> &lt;T <strong>extends</strong> Comparable&lt;? <strong>super</strong> T&gt;&gt; <strong>void</strong> mySort(List<T> list)</T></p>
<p>  指定顺序排序</p>
<p><strong>static</strong> <T> <strong>void</strong> sort(List<T> list, Comparator&lt;? <strong>super</strong> T&gt; c) </T></T></p>
<p>  可以使用自定期的比较器进行排序，泛型使用&lt;? super T&gt;是为了让子类能使用父类的比较器，因为可以用父类对象来接收子类。</p>
<p>  <strong>static</strong> <T> <strong>void</strong> sort(List<T> list, Comparator&lt;? <strong>super</strong> T&gt; c) </T></T></p>
<p>  sort还可以利用比较器进行排序。原理是增加一个比较器，然后比较的方法使用比较器中的compare方法，获取元素利用List集合中的get()方法。这时候就不要求List具备比较方法，为了可以用父类对象接收被比较元素，使用&lt;? super T&gt;。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  &lt;T&gt;<span class="function"><span class="keyword">void</span> <span class="title">mySort</span><span class="params">(List&lt;T&gt; list,Comparator&lt;? <span class="keyword">super</span> T&gt; comp)</span></span>&#123;<span class="comment">//不需要list具备比较功能 </span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size()-<span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; list.size(); j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(comp.compare(list.get(i), list.get(j))&gt;<span class="number">0</span>)&#123;<span class="comment">//调用比较器的compare方法，返回一个int值</span></span><br><span class="line">					Collections.swap(list, i, j);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>1.1交换顺序</p>
<p><strong>static</strong> <strong>void</strong> swap(List&lt;?&gt; list, <strong>int</strong> i, <strong>int</strong> j) </p>
<p>1.2折半查找</p>
<p>需要先对元素进行自然排序或者比较器排序后才能使用</p>
<p><strong>static</strong> <T> <strong>int</strong> binarySearch(List&lt;? <strong>extends</strong> Comparable&lt;? <strong>super</strong> T&gt;&gt; list, T key) </T></p>
<p> 如果返回-2，负数表示没有找到，-2为-1减去1，意思是如果插入进去要在角标1处插入元素。减一的目的是避免插入点为0时候不知道是没有找到还是这个点在角标为0的地方。</p>
<p> 可以按照比较器排序然后索引。</p>
<p><strong>public</strong> <strong>static</strong> <T> <strong>int</strong> binarySearch(List&lt;? <strong>extends</strong> T&gt; list,T key,</T></p>
<p>​    Comparator&lt;? <strong>super</strong> T&gt; c)  </p>
<p>2、 求最大值</p>
<p><strong>static</strong> &lt;T <strong>extends</strong> Object &amp; Comparable&lt;? <strong>super</strong> T&gt;&gt; T max(Collection&lt;? <strong>extends</strong> T&gt; coll)</p>
<p>也可以使用比较器进行取最大值。</p>
<p><strong>static</strong> <T> T max(Collection&lt;? <strong>extends</strong> T&gt; coll, Comparator&lt;? <strong>super</strong> T&gt; comp) </T></p>
<p>3、 比较器反向</p>
<p>如果要将一个集合中的元素反向输出，使用TreeSet实现，要加载比较器重新实现，原理如下，其实就是将o1,o2进行互换。</p>
<p>​    TreeSet<String> ts = <strong>new</strong> TreeSet<String>(<strong>new</strong> Comparator<String>() {</String></String></String></p>
<p>​      //匿名内部类</p>
<p>​      @Override</p>
<p>​      <strong>public</strong> <strong>int</strong> compare(String o1, String o2) {</p>
<p>​       <strong>int</strong> temp = o2.compareTo(o1);</p>
<p>​       <strong>return</strong> temp;</p>
<p>​      }</p>
<p>​    });</p>
<p>这样就可以实现反向输出，但是比较麻烦</p>
<p>  <strong>static</strong> <T> Comparator<T> reverseOrder() </T></T></p>
<p>  <strong>static</strong> <T> Comparator<T> reverseOrder(Comparator<T> cmp) //将已有的比较器进行逆转 </T></T></T></p>
<p>实际演示：</p>
<p>TreeSet<String> ts = <strong>new</strong> TreeSet<String>(Collections.<em>reverseOrder</em>());</String></String></p>
<p>  如果自己有比较器，就将比较器输入进去</p>
<p>TreeSet<String> ts = <strong>new</strong> TreeSet<String>(Collections.<em>reverseOrder</em>(<strong>new</strong> ComparatorByLength()));</String></String></p>
<p>反转集合中的元素</p>
<p>  <strong>static</strong> <strong>void</strong> reverse(List&lt;?&gt; list) </p>
<p>4、 初始化集合</p>
<p>用指定元素替代集合中所有元素。</p>
<p> <strong>static</strong> <T> <strong>void</strong> fill(List&lt;? <strong>super</strong> T&gt; list, T obj) </T></p>
<p>5、 随机集合元素</p>
<p>使用默认的随机源随机排列指定的列表</p>
<p> <strong>static</strong> <strong>void</strong> shuffle(List&lt;?&gt; list) </p>
<p>使用指定的随机源随机排列指定的列表</p>
<p><strong>static</strong> <strong>void</strong> shuffle(List&lt;?&gt; list, Random rnd) </p>
<p>就是扑克牌的洗牌。或者掷骰子，只取第一个即可。</p>
<p>6、 枚举的转换</p>
<p>返回指定集合的枚举</p>
<p><strong>static</strong> <T> Enumeration<T> enumeration(Collection<T> c) </T></T></T></p>
<p>返回一个数组列表，其中包含由枚举返回的顺序由指定的枚举返回的元素。</p>
<p><strong>static</strong> <T> ArrayList<T> list(Enumeration<T> e) </T></T></T></p>
<p>7、 <strong>同步！！！！重点</strong></p>
<p>如果要在多线程中使用集合，则自己在集合中加锁，Collections工具类中提供有synchronizedxxx方法，如：</p>
<p><strong>static</strong> <T> Collection<T> synchronizedCollection(Collection<T> c) </T></T></T></p>
<p>返回由指定集合支持的同步（线程安全）集合。 </p>
<p><strong>static</strong> <T> List<T> synchronizedList(List<T> list) </T></T></T></p>
<p>返回由指定列表支持的同步（线程安全）列表。 </p>
<p><strong>static</strong> &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) </p>
<p>返回由指定地图支持的同步（线程安全）映射。</p>
<p>具体的实现原理为</p>
<p>给非同步的集合加锁</p>
<p>List list = new ArrayList();//非同步的</p>
<p>list = MyCollections.synList(list);//返回一个同步的List</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCollections</span></span>&#123;<span class="comment">//将非同步集合变为同步集合</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title">synList</span><span class="params">(List list)</span></span>&#123;<span class="comment">//静态方法</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyList(list);<span class="comment">//多态</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span> <span class="keyword">implements</span> <span class="title">List</span></span>&#123;<span class="comment">//私有内部类，实现List接口</span></span><br><span class="line">	<span class="comment">//目的是实现以后MyList就是List的一个子类，将所有的方法进行覆盖，使得可以同步。具体实现还是调用其具体的方式，只是加锁而已。</span></span><br><span class="line">	<span class="comment">//然后返回自定义的加锁后的集合</span></span><br><span class="line">	<span class="keyword">private</span> List list;<span class="comment">//持有要操作的集合引用</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">	MyList(List list)&#123;<span class="comment">//构造器传入要操作的集合引用</span></span><br><span class="line">		<span class="keyword">this</span>.list = list;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">			<span class="keyword">return</span> list.add(obj);<span class="comment">//具体方法还是调用操作集合自身的方法，只是加锁而已！！！</span></span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">			<span class="keyword">return</span> list.remove(obj);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只是加锁，只是加锁，只是加锁，具体实现方式还是调用其自身的方式。</p>
<p>8、 转数组</p>
<p>集合转成数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用的就是Collection接口中的toArray()方法</span><br><span class="line">	集合转成数组可以对集合中的元素操作的方法进行限定。不允许对其进行增删。</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * toArray方法需要传入一个指定类型的数组。</span></span><br><span class="line"><span class="comment">		 * 长度该如何定义呢？</span></span><br><span class="line"><span class="comment">		 * 如果长度小于集合的size，那么该方法会创建一个同类型并和集合相同size的数组</span></span><br><span class="line"><span class="comment">		 * 如果长度大于集合的size，那么该方法就会使用指定的数组，存储集合中的元素，其他位置默认为null。</span></span><br><span class="line"><span class="comment">		 * 所以建议，最后长度就定为，集合的size。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		String[] arr = list.toArray(<span class="keyword">new</span> String[list.size()]);</span><br><span class="line">		System.out.println(Arrays.toString(arr));<span class="comment">//数组打印调用toString方法</span></span><br></pre></td></tr></table></figure>

<h4 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h4><p>操作数组的工具类</p>
<p>Arrays:集合框架的工具类。里面的方法都是静态的。</p>
<p>1、 二分查找</p>
<p><strong>static</strong> <strong>int</strong> binarySearch(<strong>byte</strong>[] a, <strong>byte</strong> key) </p>
<p><strong>static</strong> <strong>int</strong> binarySearch(<strong>byte</strong>[] a, <strong>int</strong> fromIndex, <strong>int</strong> toIndex, <strong>byte</strong> key)</p>
<p>基本数据类型数组大多都能二分查找，除了boolean</p>
<p>2、 复制</p>
<p>复制全部长度的数组</p>
<p><strong>static</strong> <strong>boolean</strong>[] copyOf(<strong>boolean</strong>[] original, <strong>int</strong> newLength) </p>
<p>复制指定范围的数组</p>
<p><strong>static</strong> <strong>boolean</strong>[] copyOfRange(<strong>boolean</strong>[] original, <strong>int</strong> from, <strong>int</strong> to) </p>
<p>8种基本数据类型数组都能复制 </p>
<p>3、 比较</p>
<p>比较两个数组彼此是否相同，需要传入两个参数，不是Object中的比较。如果两个数组都包含相同数量的元素，则两个数组被认为是相等的，并且两个数组中所有对应的元素对都相等。 换句话说，如果两个数组以相同的顺序包含相同的元素，则它们是相等的。 另外，如果两者都是null ，则两个数组引用被认为是相等的 。</p>
<p> <strong>static</strong> <strong>boolean</strong> equals(<strong>char</strong>[] a, <strong>char</strong>[] a2) </p>
<p>深度比较，不仅比较数组中的对象，还比较对象中的内容</p>
<p>  <strong>static</strong> <strong>boolean</strong> deepEquals(Object[] a1, Object[] a2) </p>
<p>4、 替换</p>
<p>将数组中的全部元素替换为指定元素</p>
<p> <strong>static</strong> <strong>void</strong> fill(<strong>char</strong>[] a, <strong>char</strong> val) </p>
<p>将数组中指定范围的元素替换为指定元素</p>
<p> <strong>static</strong> <strong>void</strong> fill(<strong>char</strong>[] a, <strong>int</strong> fromIndex, <strong>int</strong> toIndex, <strong>char</strong> val) </p>
<p>5、 排序</p>
<p> <strong>static</strong> <strong>void</strong> sort(<strong>char</strong>[] a) </p>
<p>对指定范围的数组进行排序</p>
<p><strong>static</strong> <strong>void</strong> sort(<strong>char</strong>[] a, <strong>int</strong> fromIndex, <strong>int</strong> toIndex)</p>
<p>  对对象进行自然顺序的排序</p>
<p> <strong>static</strong> <strong>void</strong> sort(Object[] a)  </p>
<p>  对泛型数组进行排序</p>
<p> <strong>static</strong> <T> <strong>void</strong> sort(T[] a, Comparator&lt;? <strong>super</strong> T&gt; c)</T></p>
<p>6、 toString</p>
<p>  返回指定数组的字符串表现形式，如果想直接输出字符串，就调用toString</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">char</span>[] a)</span>   </span></span><br><span class="line"><span class="function">	<span class="comment">//toString的经典实现</span></span></span><br><span class="line"><span class="function">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myToString</span><span class="params">(<span class="keyword">int</span>[]a)</span></span>&#123;</span><br><span class="line">		<span class="comment">//健壮性判断</span></span><br><span class="line">		<span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">        <span class="keyword">int</span> iMax = a.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (iMax == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line">        <span class="comment">//利用StringBuilder来增加字符串</span></span><br><span class="line">        StringBuilder b = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        b.append(<span class="string">'['</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;<span class="comment">//中间省略了条件判断，提高了效率</span></span><br><span class="line">            b.append(a[i]);</span><br><span class="line">            <span class="comment">//只要一到末尾，就添加反括号结束</span></span><br><span class="line">            <span class="keyword">if</span> (i == iMax)</span><br><span class="line">                <span class="keyword">return</span> b.append(<span class="string">']'</span>).toString();</span><br><span class="line">            b.append(<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>7、 转成集合</p>
<p>将数组转成List集合</p>
<p>该方法作为基于数组和基于集合的API之间的桥梁，与Collection.toArray()相[结合](mk:@MSITStore:D:\java学习资料\jdk api 1.8_google.CHM::/java/util/Collection.html#toArray–) 。</p>
<p><strong>public</strong> <strong>static</strong> <T> List<T> asList(T… a)</T></T></p>
<p>重点:List asList(数组)将数组转成集合。</p>
<p>好处：可以使用集合的方法操作数组的元素。</p>
<p>注意：数组的长度是固定的，所以 对于集合的增删方法是不可以使用的。如add,remove,clear。否则会发生UnsupportedOperationException</p>
<p>可以使用contains,indexOf,indexOfLast,set等方法，只要不改变数组的长度即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如果数组中的元素是对象，那么转成集合时，直接将数组中的元素作为集合中的元素进行集合存储。</span></span><br><span class="line"><span class="comment">* 如果数组中的元素是基本数据类型，那么会将该数组作为集合中的元素进行存储。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">31</span>,<span class="number">11</span>,<span class="number">51</span>,<span class="number">61</span>&#125;;</span><br><span class="line">		List&lt;<span class="keyword">int</span>[]&gt; list = Arrays.asList(arr);</span><br><span class="line">	存储的是一个数组，因此list.size()=<span class="number">1</span>。如果想要将数组中的元素存进去，写：</span><br><span class="line">		Integer[] arr2 = &#123;<span class="number">31</span>,<span class="number">11</span>,<span class="number">51</span>,<span class="number">61</span>&#125;;</span><br><span class="line">		List&lt;Integer&gt; list2 = Arrays.asList(arr2);</span><br></pre></td></tr></table></figure>

<h3 id="jdk1-5新特性"><a href="#jdk1-5新特性" class="headerlink" title="jdk1.5新特性"></a>jdk1.5新特性</h3><h4 id="foreach语句"><a href="#foreach语句" class="headerlink" title="foreach语句"></a>foreach语句</h4><p>简化书写，底层利用的迭代器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * foreach语句：</span></span><br><span class="line"><span class="comment"> * 格式</span></span><br><span class="line"><span class="comment"> * for(类型 变量 : Collection集合|数组)</span></span><br><span class="line"><span class="comment"> * &#123;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//迭代器可以对元素迭代时候进行操作</span></span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 只用于遍历或迭代</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span>(String s : list)&#123; <span class="comment">//简化书写</span></span><br><span class="line">	System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i: arr)&#123;</span><br><span class="line">	System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历Map集合，要将map转成单列的Set</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以使用高级for遍历map集合吗？不能直接用，但是可以将map转成单列的set，就可以用了。</span></span><br><span class="line">		Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,String&gt;();</span><br><span class="line">		<span class="keyword">for</span>(Integer key : map.keySet())&#123;</span><br><span class="line">			String value = map.get(key);</span><br><span class="line">			System.out.println(key+<span class="string">"::"</span>+value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(Map.Entry&lt;Integer, String&gt; me : map.entrySet())&#123;</span><br><span class="line">			Integer key = me.getKey();</span><br><span class="line">			String value = me.getValue();</span><br><span class="line">			System.out.println(key+<span class="string">"::"</span>+value);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 函数的可变参数</span></span><br><span class="line"><span class="comment">	 * 其实就是一个数组，但是接受的是数组的元素。</span></span><br><span class="line"><span class="comment">	 * 自动将这些元素封装成数组，简化了调用者的书写。	</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 注意：可变参数类型必须定义在参数列表的结尾处。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">newAdd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span>... arr)</span></span></span><br></pre></td></tr></table></figure>

<p>如果使用普通的数组接收，流程为先创建数组，然后将数组传入要调用的方法，即</p>
<p>​    <strong>int</strong>[] arr = {1,4,2,1};</p>
<p>​    <strong>int</strong> sum3 = <em>add</em>(arr);</p>
<p>而如果使用可变参数，则变成</p>
<p>​    <strong>int</strong> sum4 = <em>newAdd</em>(5,1,3,2,1);</p>
<p>简化了书写，但是可变参数不能放在第一个（有两个以上变量时），而数组可以。</p>
<h4 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h4><p><strong>import</strong> <strong>static</strong> java.util.Collections.<em>sort</em>;//静态导入，其实导入的是类中的静态成员</p>
<p>以前要写Collections.sort();</p>
<p>现在写sort();</p>
<hr>
<h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><p>​    不能被实例化，方法通常为静态的。</p>
<p>out：“标准”输出流</p>
<p>in：“标准”输入流</p>
<p>1、 获取系统时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> l1 = <span class="number">1549696253272l</span>;</span><br><span class="line">System.out.println(l1/<span class="number">1000</span>/<span class="number">60</span>/<span class="number">60</span>/<span class="number">24</span>);<span class="comment">//换算成天</span></span><br><span class="line"><span class="keyword">long</span> l2 = System.currentTimeMillis();</span><br><span class="line">System.out.println(l2-l1);<span class="comment">//计算时间差</span></span><br></pre></td></tr></table></figure>

<p>2、 获取系统信息</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取系统的属性信息，并存储到Properties集合中，键和值都是字符串类型</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * properties集合中存储的都是String类型的键和值。</span></span><br><span class="line"><span class="comment">		 * 最好使用它自己的存储和取出的方法来完成元素的操作。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Properties prop = System.getProperties();<span class="comment">//获取所有的键值对信息，返回Properties对象</span></span><br><span class="line">		Set&lt;String&gt; nameSet = prop.stringPropertyNames();<span class="comment">//返回一组键的集合</span></span><br><span class="line">		<span class="keyword">for</span>(String name : nameSet)&#123;</span><br><span class="line">			String value = prop.getProperty(name);<span class="comment">//由键获取值</span></span><br><span class="line">			System.out.println(name+<span class="string">"::"</span>+value);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h4 id="跨平台使用技巧"><a href="#跨平台使用技巧" class="headerlink" title="跨平台使用技巧"></a>跨平台使用技巧</h4><p>不同平台一些符号不一样，在jvm加载的时候会获取系统信息，因此可以将这些不同平台的符号定义为一个全局常量，然后根据系统信息获取</p>
<p>  //获取换行符号</p>
<p><strong>private</strong> <strong>static</strong> <strong>final</strong> String <strong>LINE_SEPERATOR</strong> = System.<em>getProperty</em>(“line.separator”);</p>
<p>也可以自己给系统设置属性信息。</p>
<h3 id="Runtime类（单例设计）"><a href="#Runtime类（单例设计）" class="headerlink" title="Runtime类（单例设计）"></a>Runtime类（单例设计）</h3><p>​    应用程序不能创建自己的Runtime类实例，可以 通过getRuntime()方法获取当前运行时。单例设计的模式。</p>
<h4 id="开启一个程序进程"><a href="#开启一个程序进程" class="headerlink" title="开启一个程序进程"></a>开启一个程序进程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Runtime:没有构造方法摘要，说明该类不可以创建对象。</span></span><br><span class="line"><span class="comment">		 * 又发现还有非静态的方法，说明该类应该提供静态的返回该类对象的方法。</span></span><br><span class="line"><span class="comment">		 * 而且只有一个，说明Runtime类使用了单例设计模式。 </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Runtime r = Runtime.getRuntime();</span><br><span class="line">		<span class="comment">//execute:执行。xxx.exe</span></span><br><span class="line">		<span class="comment">//可以调用本地程序去执行空格后面的文件，需要格式对应</span></span><br><span class="line">		Process p = r.exec(<span class="string">"D:\\迅雷影音\\XMP\\V5.4.0.6151\\Bin\\XMP.exe c:\\lalaland.rmvb"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="杀死子进程"><a href="#杀死子进程" class="headerlink" title="杀死子进程"></a>杀死子进程</h4><p>只能杀死由Runtime r开启的进程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Process p = r.exec(<span class="string">"notepad.exe"</span>);</span><br><span class="line">p.destroy();</span><br></pre></td></tr></table></figure>

<h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p>PI : double类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Math:提供了操作数学运算的方法。都是静态的。</span></span><br><span class="line"><span class="comment"> * 常用的方法:</span></span><br><span class="line"><span class="comment"> * abs()，求绝对值</span></span><br><span class="line"><span class="comment"> * ceil():返回大于参数的最小整数</span></span><br><span class="line"><span class="comment"> * floor():返回小于参数的最大整数</span></span><br><span class="line"><span class="comment"> * round():返回四舍五入的整数</span></span><br><span class="line"><span class="comment"> * max(int a,int b):求两个数中的大数</span></span><br><span class="line"><span class="comment"> * min(int a,int b):求两个数中的小数</span></span><br><span class="line"><span class="comment"> * pow(double a,double b):返回幂值，即a的b次方</span></span><br><span class="line"><span class="comment"> * random():随机数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="comment">//将随机苏转变为1-10之间的整数，应用：骰子</span></span><br><span class="line">	<span class="keyword">double</span> d = Math.ceil(<span class="number">10</span>*Math.random());</span><br><span class="line">	<span class="keyword">double</span> d = (<span class="keyword">int</span>)(Math.random()*<span class="number">10</span>+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><p>获取随机数还可以使用Random对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">			Random r = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="comment">//			double d = (int)(r.nextDouble()*6+1);</span></span><br><span class="line">			<span class="keyword">int</span> d = r.nextInt(<span class="number">6</span>)+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><p>在类的所有方法Date接受或返回年，月，日，小时，分钟和秒值，以下表述中使用：</p>
<ul>
<li><p>y年代表整数y - 1900 。 </p>
</li>
<li><p>一个月由0到11的整数表示; 0是1月，1是2月，等等; 11月12日。 </p>
</li>
<li><p>日期（月的一天）以通常的方式从1到31的整数表示。 </p>
</li>
<li><p>一小时由0到23之间的整数表示。因此，从午夜到凌晨1点的时间是小时0，从中午到下午1点的小时是12小时。 </p>
</li>
<li><p>分钟一般以0〜59的整数表示。 </p>
</li>
<li><p>秒由0到61的整数表示; 值60和61仅发生在闰秒上，甚至仅在实际上正确跟踪闰秒的Java实现中发生。 由于目前引入闰秒的方式，在同一分钟内不会发生两个闰秒，但是本规范遵循ISO C的日期和时间约定。</p>
</li>
</ul>
<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>Date()</p>
<p>Date(long mills)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();<span class="comment">//将当前日期和时间封装成Date对象</span></span><br><span class="line">System.out.println(date);<span class="comment">//Sat Feb 09 18:46:03 CST 2019	</span></span><br><span class="line">Date date2 = <span class="keyword">new</span> Date(<span class="number">1549709125956l</span>);<span class="comment">////将指定毫秒值封装成Date对象</span></span><br></pre></td></tr></table></figure>

<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>比较两个日期</p>
<p>  <strong>int</strong> compareTo(Date anotherDate) </p>
<p>测试此日期是否在指定日期之后。</p>
<p>  <strong>boolean</strong> after(Date when) </p>
<p>测试此日期是否在指定日期之前。 </p>
<p>  <strong>boolean</strong> before(Date when)</p>
<p><strong>日期与毫秒转换</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 日期对象和毫秒值之间的转换</span></span><br><span class="line"><span class="comment"> * 毫秒值--&gt;日期对象:</span></span><br><span class="line"><span class="comment"> * 1、通过Date对象的构造方法完成 new Date(timeMills);</span></span><br><span class="line"><span class="comment"> * 2、还可以通过setTime(long time)设置。</span></span><br><span class="line"><span class="comment"> * 	 因为可以通过日期对象的方法对该日期中的各个字段（年月日等）进行操作。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 日期对象--&gt;毫秒值</span></span><br><span class="line"><span class="comment"> * 1、getTime()方法	</span></span><br><span class="line"><span class="comment"> * 	因为可以通过具体的数值进行运算。</span></span><br><span class="line"><span class="comment"> * 	</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h3><p>​    对日期进行格式化，不能直接创建对象，需要使用DateFormat.getInstance()，在其中加入其字段，可以使用规定的格式，如默认的，LONG等。如果想要使用自定义的格式，就需要new其子类，SimpleDateFormat。</p>
<h4 id="对日期对象进行格式化"><a href="#对日期对象进行格式化" class="headerlink" title="对日期对象进行格式化"></a>对日期对象进行格式化</h4><p>工厂：生产对象的地方</p>
<p>将日期对象—-&gt;日期格式的字符串</p>
<p>返回String，使用DateFormat方法（或其子类），接收Date对象</p>
<p>使用的是<strong>DateFormat类</strong>中的<strong>format方法</strong></p>
<p>即DateFormat.getDateInstance()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		Date date = <span class="keyword">new</span> Date();</span><br><span class="line">		<span class="comment">//获取日期格式对象，具备着默认的风格。</span></span><br><span class="line"><span class="comment">//		DateFormat dateFormat = DateFormat.getDateInstance();//2019-2-11</span></span><br><span class="line">		<span class="comment">//可以指定风格 FULL LONG SHORT等可以指定风格</span></span><br><span class="line"><span class="comment">//		DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.FULL);//2019年2月11日 星期一</span></span><br><span class="line">		DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.LONG);<span class="comment">//2019年2月11日 </span></span><br><span class="line"><span class="comment">//		DateFormat dateFormat2 = DateFormat.getDateTimeInstance();//2019-2-11 11:11:21</span></span><br><span class="line">		<span class="comment">//指定日期和时间格式。2019年2月11日 上午11时20分04秒</span></span><br><span class="line">		DateFormat dateFormat2 = DateFormat.getDateTimeInstance(DateFormat.LONG,DateFormat.LONG);</span><br><span class="line">		<span class="comment">//结果应该是String格式，格式器最清楚，应该要输入日期对象</span></span><br><span class="line">		String str_data = dateFormat.format(date);</span><br><span class="line">		String str_data_time = dateFormat2.format(date);</span><br><span class="line">		System.out.println(str_data);<span class="comment">//2019-2-11</span></span><br><span class="line">		System.out.println(str_data_time);<span class="comment">//2019-2-11 11:11:21</span></span><br></pre></td></tr></table></figure>

<p>自定义日期时间格式</p>
{% asset_img 第20天1.png This is an example image %}

<p>范例：在指定格式的时候使用字符串，具体的规则见上表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		<span class="comment">//风格是自定义的的解决方式，使用DateFormat的子类</span></span><br><span class="line">		DateFormat dateFormat3 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy--MM--dd"</span>);</span><br><span class="line">		String str_data_own = dateFormat3.format(date);</span><br><span class="line">		System.out.println(str_data_own);</span><br><span class="line">将日期格式的字符串--&gt;日期对象</span><br><span class="line">返回Date对象，使用DateFormat方法（或其子类），接收String</span><br><span class="line">使用的是DateFormat类中的parse方法</span><br><span class="line"><span class="comment">//		String str_date = "2012-4-19";//使用默认格式</span></span><br><span class="line">		String str_date = <span class="string">"2012年4月19日"</span>;</span><br><span class="line">		String str = <span class="string">"2011---8---27"</span>;</span><br><span class="line">		DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.LONG);</span><br><span class="line">		<span class="comment">//如果要使用自定义的风格，则使用DateFormat子类</span></span><br><span class="line">		DateFormat dateFormat2 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy---MM---dd"</span>);</span><br><span class="line">		Date date2 = dateFormat2.parse(str);</span><br><span class="line">		System.out.println(date2);</span><br><span class="line">		Date date = dateFormat.parse(str_date);</span><br><span class="line">		System.out.println(date);</span><br></pre></td></tr></table></figure>

<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p>通过Calendar.getInstance来获取其对象</p>
<p>使用的是键值对</p>
<h4 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h4><p>1、 get()获取时间</p>
<p>2、 add()指定时间的偏移</p>
<p>3、 set()设置时间</p>
<h4 id="日期显示"><a href="#日期显示" class="headerlink" title="日期显示"></a>日期显示</h4><p>使用get方法，其中月份、星期要进行转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Calendar c = Calendar.getInstance();</span><br><span class="line">		showDate(c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showDate</span><span class="params">(Calendar c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> year = c.get(Calendar.YEAR);</span><br><span class="line">		<span class="keyword">int</span> month = c.get(Calendar.MONTH)+<span class="number">1</span>;<span class="comment">//月份从0开始</span></span><br><span class="line">		<span class="keyword">int</span> day = c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">		<span class="keyword">int</span> week = c.get(Calendar.DAY_OF_WEEK);<span class="comment">//星期日是第一天,即1为星期日</span></span><br><span class="line">		System.out.println(year+<span class="string">"年"</span>+month+<span class="string">"月"</span>+day+<span class="string">"日"</span>+getWeek(week));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getWeek</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		String[] weeks =&#123;<span class="string">" "</span>,<span class="string">"星期日"</span>,<span class="string">"星期一"</span>,<span class="string">"星期二"</span>,<span class="string">"星期三"</span>,<span class="string">"星期四"</span>,<span class="string">"星期五"</span>,<span class="string">"星期六"</span>&#125;;</span><br><span class="line">		<span class="keyword">return</span> weeks[i];<span class="comment">//因为是一一对应的角标，所以可以利用数组。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="日期设置"><a href="#日期设置" class="headerlink" title="日期设置"></a>日期设置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置指定日期</span></span><br><span class="line">c.set(<span class="number">2019</span>,<span class="number">10</span>, <span class="number">14</span>);</span><br><span class="line"><span class="comment">//在指定日期上偏移</span></span><br><span class="line">c.add(Calendar.MONTH, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>​    可以先设置时间，然后再利用add进行日期偏移，可以知道每一年哪个月有多少天，即设置那一年，然后将set设置为目标月的下一个月，然后偏移量为日期-1即可，再获取天数即可以。注意月份是从0开始！！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showDays</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">		Calendar c= Calendar.getInstance();</span><br><span class="line">		<span class="comment">//设置指定日期</span></span><br><span class="line">		c.set(year,<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//在指定日期上偏移</span></span><br><span class="line">		c.add(Calendar.DAY_OF_MONTH, -<span class="number">1</span>);</span><br><span class="line">		showDate(c);		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>如果要获取昨天的时分秒，直接将日期偏移量设置为日期偏移-1即可。</p>
<h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><p>​    记得关流，除非是System.in或者System.out</p>
<p>​    IO流用来处理设备之间的数据传输，Java对数据的传输通过流的方式，Java用于操作流的的对象都在IO包中。</p>
<p>流按操作数据分为两种：字节流与字符流。流按流向分为：输入流（将硬盘中的数据读入内存），输出流（将内存中的数据写入硬盘）。</p>
<h4 id="输入流与输出流"><a href="#输入流与输出流" class="headerlink" title="输入流与输出流"></a>输入流与输出流</h4><p>相对于内存设备而言。</p>
<p>将外设中的数据读取到内存中：输入。</p>
<p>将内存中的数据写入到外设中：输出。</p>
<p>构造函数可以接收文件对象，也可以接收字符串，接收文件对象使用更多。</p>
<h4 id="字符流的由来"><a href="#字符流的由来" class="headerlink" title="字符流的由来"></a>字符流的由来</h4><p>其实就是：字节流读取文字字节数据后，不直接操作而是先查指定的编码表。获取对应的文字。再对这个文字进行操作。</p>
<h4 id="IO流基类"><a href="#IO流基类" class="headerlink" title="IO流基类"></a>IO流基类</h4><p>字节流的两个顶层父类：</p>
<p>1，InputStream 2，OutputStream</p>
<p>字符流的两个顶层父类</p>
<p>1，Reader 2,Writer</p>
<p>这些体系的子类都以父类名作为后缀。</p>
<p>而子类名的前缀就是该对象的功能。</p>
<p>从熟悉的文字开始字符流。</p>
<h4 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h4><p>操作文本文件对象</p>
<p>构造函数中加入true表示续写。</p>
<p>//需求：将一些文字存储到硬盘一个文件中。</p>
<p>记住：如果要操作文字数据，建议优先考虑字符流。</p>
<p>而且要将数据从内存写到硬盘上，要使用字符流中的输出流：Writer</p>
<p>硬盘的数据基本体现是文件，希望可以找到一个可以操作文件的Writer</p>
<p>找到了FileWriter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">			<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LINE_SEPARATOR = System.getProperty(<span class="string">"line.separator"</span>);</span><br><span class="line">		<span class="comment">//创建一个可以往文件中写入字符数据的字符输出流对象</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 既然 是往一个文件中写入文件数据，那么在创建对象时，就必须明确该文件（用于存储数据的目的地）</span></span><br><span class="line"><span class="comment">		 * 如果文件不存在，则会自动创建。</span></span><br><span class="line"><span class="comment">		 * 如果文件存在，则会被覆盖。</span></span><br><span class="line"><span class="comment">		 * 如果构造函数中加入true，可以实现对文件进行续写</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"demo.txt"</span>,<span class="keyword">true</span>);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 调用Writer对象中的write(string)方法，写入数据。	</span></span><br><span class="line"><span class="comment">		 * 其实数据写入到临时存储缓冲区。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//调用系统本地的换行</span></span><br><span class="line">		fw.write(<span class="string">"abcde"</span>+LINE_SEPARATOR+<span class="string">"hahaa"</span>);</span><br><span class="line">		fw.write(<span class="string">"xixi"</span>);</span><br><span class="line">		 <span class="comment">//进行刷新，将数据直接写入到目的地中。可以用多次flush</span></span><br><span class="line"><span class="comment">//		fw.flush();</span></span><br><span class="line">		<span class="comment">//关闭流，关闭资源。在关闭前会先调用flush刷新缓冲区中的数据到目的地。</span></span><br><span class="line">		<span class="comment">//关闭后不能够再写入</span></span><br><span class="line">		fw.close(); 	</span><br><span class="line">	<span class="comment">//fw.write("ah");//会报错</span></span><br></pre></td></tr></table></figure>

<h4 id="IO异常处理"><a href="#IO异常处理" class="headerlink" title="IO异常处理"></a>IO异常处理</h4><p>因为流对象一般会抛出异常，因此一般在try外面创建对象，在try里面创建具体的引用。</p>
<p>因为关闭一定要执行，因此close放在finally中，其中close也需要进行处理。为了不出现空指针异常，需要去判断fw，只有在不为空的时候，才进行流关闭操作。</p>
<p>  即变量定外面，new在里面，finally close在里面，不要忘记判断null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileWriter fw = <span class="keyword">null</span>;<span class="comment">// 流对象在try外面进行创建</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	fw = <span class="keyword">new</span> FileWriter(<span class="string">"k:\\demo.txt"</span>);<span class="comment">// 在try里面进行创建引用</span></span><br><span class="line">	fw.write(<span class="string">"abcde"</span> + LINE_SEPARATOR + <span class="string">"hahaa"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	System.out.println(e.toString());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (fw != <span class="keyword">null</span>)<span class="comment">//一定要加入判断，不然会出现空指针异常 </span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			fw.close();<span class="comment">// 需要单独进行处理</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"关闭失败"</span>);</span><br><span class="line">		&#125; <span class="comment">// 没有声明，因此在外面进行声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h4><p><strong>读取方式1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需求：读取一个文本文件，将读取到的字符打印到控制台。</span></span><br><span class="line">		<span class="comment">//1、创建读取字符数据的流对象</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 在创建读取流对象时，必须要明确被读取的文件，一定要确定该文件是存在的。</span></span><br><span class="line"><span class="comment">		 * 用一个读取流关联一个已存在文件</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"demo.txt"</span>);</span><br><span class="line">		<span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((ch=fr.read())!=-<span class="number">1</span>)</span><br><span class="line">			System.out.println((<span class="keyword">char</span>)ch);</span><br></pre></td></tr></table></figure>

{% asset_img 第20天2.png This is an example image %}

<p>读取时候如果读到了末尾，会使用-1标识符，如果继续读则还是-1。</p>
<p><strong>读取方式2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"demo.txt"</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用read(char[])读取文件文本数据</span></span><br><span class="line"><span class="comment"> * 先创建字符数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];<span class="comment">//长度最好是1024的整数倍</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len=fr.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">	System.out.println(<span class="keyword">new</span> String(buf,<span class="number">0</span>,len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

{% asset_img 第20天3.png This is an example image %}

<p>这种读取方式，由于后两次读的数量不一样，因此会对第一次读取的数组进行覆盖。</p>
<h4 id="复制文件一"><a href="#复制文件一" class="headerlink" title="复制文件一"></a>复制文件一</h4><p>读取一个便写一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 需求：将C盘的一个文本文件复制到d盘。</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> * 1，需要读取源</span></span><br><span class="line"><span class="comment"> * 2，将读到的源数据写入目的地</span></span><br><span class="line"><span class="comment"> * 3，既然是操作文本数据，使用字符流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyTextTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//1，读取一个已有的文本文件，使用字符读取流，和文本相关联。</span></span><br><span class="line">		FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"IO流_2.txt"</span>);</span><br><span class="line">		<span class="comment">//2，创建一个目的，用于存储读到的数据。</span></span><br><span class="line">		FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"copytext_1.txt"</span>);</span><br><span class="line">		<span class="comment">//3，频繁的读写操作。</span></span><br><span class="line">		<span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((ch=fr.read())!=-<span class="number">1</span>)&#123;<span class="comment">//只要是读，就使用循环，然后while两层括号，判断是否等于-1</span></span><br><span class="line">			fw.write(ch);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4，关闭流资源。</span></span><br><span class="line">		fw.close();</span><br><span class="line">		fr.close();		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="复制文件二"><a href="#复制文件二" class="headerlink" title="复制文件二"></a>复制文件二</h4><p>使用缓冲来读取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyTextTest_2</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">		FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			fr = <span class="keyword">new</span> FileReader(<span class="string">"IO流_2.txt"</span>);</span><br><span class="line">			fw = <span class="keyword">new</span> FileWriter(<span class="string">"copytest_2.txt"</span>);</span><br><span class="line">			<span class="comment">//创建一个临时容器，用于缓存读取到的字符</span></span><br><span class="line">			<span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[BUFFER_SIZE];</span><br><span class="line">			<span class="comment">//定义一个变量定义读取到的字符数（其实就是往数组里装的字符个数）</span></span><br><span class="line">			<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>((len=fr.read(buf))!=-<span class="number">1</span>)&#123;<span class="comment">//while里面两个括号，判断长度是否为-1即可</span></span><br><span class="line">				fw.write(buf, <span class="number">0</span>, len);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;<span class="comment">//关流前需要判断</span></span><br><span class="line">			<span class="keyword">if</span>(fw!=<span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					fw.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"读写失败"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">if</span>(fr!=<span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					fr.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"读写失败"</span>);</span><br><span class="line">				&#125;		</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="复制文件图解"><a href="#复制文件图解" class="headerlink" title="复制文件图解"></a>复制文件图解</h4>{% asset_img 第21天1.png This is an example image %}

<p>待读取的文件为源，使用流来读取，对应代码为FileReader fr = new FileReader(“demo.txt”)，要写入文件，使用流来写入，对应代码为FileWriter fw = new FileWriter (“test.txt”)。而两个流之间没有直接关系，需要使用缓冲区来作为中转，为了将读入流与缓冲区关联，使用fr.read(buf)；为了将写出流与缓冲区关联，使用fw.write(buf,0,len)。为了将流中的文件写出到输出源中，要使用fw.flush或者fw.close，flush可以多次刷新，而close只能使用一次。</p>
<h4 id="字符流缓冲区"><a href="#字符流缓冲区" class="headerlink" title="字符流缓冲区"></a>字符流缓冲区</h4><p>对应类：</p>
<p>BufferedWriter</p>
<p>BufferedReader</p>
<p>缓冲区的出现提高了对数据的读写效率。缓冲区要结合流才可以使用。在流的基础上对流的功能进行了增强。</p>
<p>进缓冲区写入后一定要刷新！！！</p>
<p>字符流缓冲区</p>
<p>BufferedWriter</p>
<p>特有方法：newLine()换行写入</p>
<p>​    写完记得要刷新flush()</p>
<p>BufferedReader</p>
<p>特有方法：readLine()按行读入</p>
<p>​      判断标志不为-1，而是null。使用String类型接收read。</p>
<p><strong>写入</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LINE_SEPARATOR = System.getProperty(<span class="string">"line.separator"</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"demo.txt"</span>);</span><br><span class="line">		<span class="comment">//为了提高写入的效率。使用了字符流的缓冲区。</span></span><br><span class="line">		<span class="comment">//创建了一个字符写入流的缓冲区对象，并和指定要被缓冲的流对象相关联。</span></span><br><span class="line">		BufferedWriter bufw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line">		<span class="comment">//写入缓冲区的写入方法将数据先写入到缓冲区中</span></span><br><span class="line"><span class="comment">//		bufw.write("abcde"+LINE_SEPARATOR+"dsd");</span></span><br><span class="line"><span class="comment">//		bufw.write("xxixiix");</span></span><br><span class="line"><span class="comment">//		bufw.newLine();</span></span><br><span class="line"><span class="comment">//		bufw.write("heheh");</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=<span class="number">4</span>;x++)&#123;</span><br><span class="line">			bufw.write(<span class="string">"abcde"</span>+x);</span><br><span class="line">			bufw.newLine();<span class="comment">//换行</span></span><br><span class="line">			bufw.flush();<span class="comment">//写一次就刷新一次</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//使用缓冲区的刷新方法将数据刷目的地中</span></span><br><span class="line"><span class="comment">//		bufw.flush();</span></span><br><span class="line">		<span class="comment">//关闭缓冲区。其实关闭的就是被缓冲的流对象</span></span><br><span class="line">		bufw.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>读取</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"buf.txt"</span>);	</span><br><span class="line">		BufferedReader bufr = <span class="keyword">new</span> BufferedReader(fr);<span class="comment">//缓冲区关联流</span></span><br><span class="line">		String line = <span class="keyword">null</span>;<span class="comment">//判断变量</span></span><br><span class="line">		<span class="comment">//按行读取</span></span><br><span class="line">		<span class="keyword">while</span>((line=bufr.readLine())!=<span class="keyword">null</span>)&#123;<span class="comment">//如果读取的不为空，则输出</span></span><br><span class="line">			System.out.println(line);</span><br><span class="line">		&#125;</span><br><span class="line">		bufr.close();</span><br></pre></td></tr></table></figure>

<p>读取中缓冲区的read方法对父类方法进行了覆写</p>
{% asset_img 第21天2.png This is an example image %}

<p>readLine原理：缓冲区从磁盘中使用父类read(buf)方法拿出数据到内存中，从内存中取出字符比较快，使用的是覆盖过的read方法，将取出的数据放在临时容器中，根据文本的行特点，判断是否为换行符，临时容器中存储的是一行的数据，不包含换行符，然后转换成字符串进行输出。</p>
<p>readLine方法使用了读取缓冲区的read方法，将读取到的字符进行缓冲并判断换行标记，将标记前的缓存数据变成字符串返回。</p>
<p>​    <strong>临时容器</strong>可以使用<strong>StringBuilder</strong>。因为最终返回的是字符串。</p>
<p><strong>按行读取</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>((line=bufr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">	bufw.write(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用：可以按行来读取，因为返回的为String类型的变量，就可以使用String中的方法，如判断该行是否包含某一字符串。</p>
<h4 id="复制文件三"><a href="#复制文件三" class="headerlink" title="复制文件三"></a>复制文件三</h4><p>使用缓冲区来实现文件的读写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"buf.txt"</span>);</span><br><span class="line">BufferedReader bufr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"buf_copt.txt"</span>);</span><br><span class="line">BufferedWriter bufw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line"><span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((ch=bufr.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">	bufw.write(ch);</span><br><span class="line">&#125;</span><br><span class="line">bufw.close();</span><br><span class="line">bufr.close();</span><br></pre></td></tr></table></figure>

<h4 id="复制文件四"><a href="#复制文件四" class="headerlink" title="复制文件四"></a>复制文件四</h4><p>使用缓冲区按行读取，为了换行使用newLine，一定要<strong>flush</strong>!!!</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"buf.txt"</span>);</span><br><span class="line">BufferedReader bufr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"buf_copt.txt"</span>);</span><br><span class="line">BufferedWriter bufw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>((line=bufr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">	bufw.write(line);</span><br><span class="line">	bufw.newLine();</span><br><span class="line">	bufw.flush();</span><br><span class="line">&#125;</span><br><span class="line">bufw.close();</span><br><span class="line">bufr.close();</span><br></pre></td></tr></table></figure>

<h4 id="装饰设计模式"><a href="#装饰设计模式" class="headerlink" title="装饰设计模式"></a>装饰设计模式</h4><p>装饰设置模式：</p>
<p>  对一组对象的功能进行增强时，就可以使用该模式进行问题的解决。</p>
<p>装饰和继承都能实现一样的特点，进行功能的拓展增强。</p>
<p>区别：</p>
<p>首先有一个继承体系</p>
<p>Writer</p>
<pre><code>|--TextWriter:用于操作文本

|--MediaWriter:用于操作媒体</code></pre><p>想到对操作的动作进行效率的提高。按照面向对象，可以通过继承对具体的进行功能的拓展。</p>
<p>效率的提高需要加入缓冲技术</p>
<p>Writer</p>
<pre><code>|--TextWriter:用于操作文本</code></pre><p>​            |–BufferTextWriter:加入了缓冲技术的操作文本的对象</p>
<pre><code>|--MediaWriter:用于操作媒体

      |--BufferMediaWriter:加入了缓冲技术的操作媒体的对象</code></pre><p>到这里就可以了，但这样做存在问题。</p>
<p>如果这个体系进行功能拓展，又多了流对象。那么这个流要提高效率是否也要产生子类？</p>
<p>是，会发现只为提高功能进行的继承，导致继承体系越来越臃肿。不够灵活。</p>
<p>重新思考问题</p>
<p>既然加入的都是同一种技术–缓冲。</p>
<p>前一种是让缓冲和具体的对象相结合。可以将缓冲进行单独的封装，哪个对象需要缓冲， 就将哪个对象和缓冲关联。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  Buffer(TextWriter w)</span><br><span class="line"></span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  Buffer(MediaWriter w)</span><br><span class="line"></span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>太麻烦，直接操作父类，利用多态.但是要使用Writer方法，继承即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferWriter</span> <span class="keyword">extends</span> <span class="title">Writer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  Buffer(Writer w)</span><br><span class="line"></span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Writer</p>
<pre><code>|--TextWriter:用于操作文本

|--MediaWriter:用于操作媒体

|--BufferWriter:用于提高效率</code></pre><p>装饰比继承<strong>灵活</strong>。</p>
<p>特点：<strong>装饰类和被装饰类都必须所属同一个接口或者父类</strong>。</p>
<h4 id="LineNumber"><a href="#LineNumber" class="headerlink" title="LineNumber"></a>LineNumber</h4><p>获取行号</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"IO流_2.txt"</span>);</span><br><span class="line">		LineNumberReader lnr = <span class="keyword">new</span> LineNumberReader(fr);</span><br><span class="line">		String line = <span class="keyword">null</span>;</span><br><span class="line">		lnr.setLineNumber(<span class="number">20</span>);</span><br><span class="line">		<span class="keyword">while</span>((line=lnr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			System.out.println(lnr.getLineNumber()+<span class="string">":"</span>+line);</span><br><span class="line">		&#125;</span><br><span class="line">		lnr.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><p>基本操作与字符流相同。但是它不仅可以操作字符，还可以操作其他媒体文件。</p>
<p>字节流一般不用flush，除非用到了缓冲区。</p>
<p>​    不要用字符流操作媒体文件，无法被解析。因为查表查不到。</p>
<p><strong>输出流OutputStream</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo_write</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//1、创建字节输出流对象，用于操作文件</span></span><br><span class="line">		FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"bytedemo.txt"</span>);</span><br><span class="line">		<span class="comment">//2、写数据。直接写入到目的地中。</span></span><br><span class="line">		fos.write(<span class="string">"abcdefg"</span>.getBytes());</span><br><span class="line">		fos.close();<span class="comment">//关闭资源动作要完成。</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输入流InputStream</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo_read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//1、创建一个读取流对象和指定的文件关联</span></span><br><span class="line">		FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"bytedemo.txt"</span>);</span><br><span class="line">		<span class="comment">//创建一个大小刚刚好的缓冲区</span></span><br><span class="line">		<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[fis.available()];<span class="comment">//慎用！！！</span></span><br><span class="line">		fis.read(buf);</span><br><span class="line">		System.out.println(<span class="keyword">new</span> String(buf));</span><br><span class="line">		<span class="comment">//利用缓冲区读取</span></span><br><span class="line">		<span class="comment">//建议使用这种读取数据的方式。</span></span><br><span class="line"><span class="comment">//		byte[] buf = new byte[1024];</span></span><br><span class="line"><span class="comment">//		int len = 0;</span></span><br><span class="line"><span class="comment">//		while((len=fis.read(buf))!=-1)&#123;</span></span><br><span class="line"><span class="comment">//			System.out.println(new String(buf,0,len));</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		<span class="comment">//一次读取一个字节。	</span></span><br><span class="line"><span class="comment">//		int ch = 0;</span></span><br><span class="line"><span class="comment">//		while((ch=fis.read())!=-1)&#123;</span></span><br><span class="line"><span class="comment">//			System.out.println((char)ch);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		fis.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="键盘录入"><a href="#键盘录入" class="headerlink" title="键盘录入"></a>键盘录入</h4><p>Windows中回车是两个字符，’\r’对应数字13，’\n’对应数字10。因此如果读取回车符号会得到13与10。</p>
<p>默认的输入与输出设备均<strong>不用关流</strong>，如果关了则不能再次获取，除非重启设备。</p>
<p>​    将系统输入与字节流进行关流，然后调用字节流的方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream in = System.in;</span><br><span class="line"><span class="keyword">int</span> ch = in.read();<span class="comment">//检测到流末尾或者异常的时候，一直阻塞。一直等待读取到数据。阻塞式方法。</span></span><br><span class="line">System.out.println(<span class="string">"ch:"</span>+ch);</span><br></pre></td></tr></table></figure>

<p>集合的清空为clear，StringBuilder的为delete</p>
<p><strong>获取键盘数据</strong></p>
<p>获取键盘录入数据，转为大写，利用over结束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readKey2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//一直读入键盘输入的值</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 获取用户键盘录入的数据，并将数据变成大写显示在控制台上。</span></span><br><span class="line"><span class="comment">		 * 如果用户输入的是over，结束键盘录入。</span></span><br><span class="line"><span class="comment">		 * 思路：</span></span><br><span class="line"><span class="comment">		 * 1，因为键盘录入只读取一个字节，要判断是否是over，需要将读取到的字节拼成字符串</span></span><br><span class="line"><span class="comment">		 * 2，那就需要一个容器。StrignBuilder。</span></span><br><span class="line"><span class="comment">		 * 3，在用户回车之前，将录入的数据变成字符串判断即可。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//1，创建容器</span></span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//2，获取键盘读取流</span></span><br><span class="line">		InputStream in = System.in;</span><br><span class="line">		<span class="comment">//3，定义变量记录读取到的字节，并循环获取</span></span><br><span class="line">		<span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((ch=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="comment">//在存储之前需要判断是否是换行标记，因为换行标记不存</span></span><br><span class="line">			<span class="keyword">if</span>(ch==<span class="string">'\r'</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(ch==<span class="string">'\n'</span>)&#123;</span><br><span class="line">				<span class="comment">//如果换行，需要判断</span></span><br><span class="line">				String temp = sb.toString();<span class="comment">//将缓冲的字符变成字符串	</span></span><br><span class="line">				<span class="keyword">if</span>(<span class="string">"over"</span>.equals(temp))</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">//不是over就输出</span></span><br><span class="line">				System.out.println(temp.toUpperCase());</span><br><span class="line">				<span class="comment">//输出完以后，将缓冲区清空，不然会将之前的也存进去</span></span><br><span class="line">				<span class="comment">//集合的清空为clear，StringBuilder的为delete。</span></span><br><span class="line">				sb.delete(<span class="number">0</span>, sb.length());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果不加else，那么回车后仍然会添加元素，则将'\n'添加进去了。因为不是回车符才进行添加。一定要加else</span></span><br><span class="line">			<span class="keyword">else</span>	</span><br><span class="line">			<span class="comment">//将读取到的字节存储到StringBuilder中。</span></span><br><span class="line">			sb.append((<span class="keyword">char</span>)ch);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>​    会发现使用到的判断跟BufferedReader中的readLine方法很接近。因此想利用readLine来做。</p>
<h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><p>InputStreamReader ：字节到字符的桥梁。解码。</p>
<p>OutputStreamWriter：字符到字节的桥梁。编码。</p>
<p>​    BufferedReader中有readline方法，如果要使用到BufferedRead方法，需要传入的是字符流对象，但是如果想让字节流也是用其方法，需要将字节流转变为字符流。</p>
<p>​    可以使用<strong>InputSreamReader</strong>。需要考虑编码的问题。在字符流对象中。将字<strong>节流变成字符流</strong></p>
<p>从名字判断。<strong>后缀为父类，前缀为功能</strong>。</p>
<p>因此可以将上面的代码改写，直接获取一行字符串即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字节流</span></span><br><span class="line">		InputStream in = System.in;</span><br><span class="line">		<span class="comment">//将字节转成字符的桥梁，转换流。</span></span><br><span class="line">		InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line">		<span class="comment">//字符流，为字符装饰流。</span></span><br><span class="line">		BufferedReader bufr = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">		String line = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span>((line=bufr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="string">"over"</span>.equals(line))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			System.out.println(line.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符与字节的区别</p>
<p>读取汉字的时候，一个汉字字符为2个字节，如果用字节读就会读2次，然后将2个字节对应成数字单独输出；如果是字符流，那么会一下子读2个，只读1次，然后查表找对应的字符。</p>
<blockquote>
<p>字节-&gt;字符，解码。因为从看不懂的变成看得懂的。使用IuputStreamReader</p>
<p>字符-&gt;字节，编码。因为从看的懂的变成看不懂的。使用OutputStreamWriter</p>
</blockquote>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC22%E5%A4%A91.png" class title="This is an example image">

<p>示意图：从键盘输入到控制台输出</p>
<p>字节流从键盘拿数据，变成字符流使用字符流装饰类来提高效率，因此数据就读取到了缓冲区中，然后从缓冲区中写数据到字符输出流，数据到了字符输出流，目的地是out.控制台，需要将字符流转换成字节流，然后进行输出字节数据。</p>
<h4 id="键盘录入到控制台输出"><a href="#键盘录入到控制台输出" class="headerlink" title="键盘录入到控制台输出"></a>键盘录入到控制台输出</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">键盘录入到控制台输出</span><br><span class="line">		<span class="comment">//键盘录入</span></span><br><span class="line">		<span class="comment">//将键盘字节流转换为字符流装饰类提高效率，背下来！！！</span></span><br><span class="line">		BufferedReader bufr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		<span class="comment">//控制台输出</span></span><br><span class="line">		BufferedWriter bufw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">		String line = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span>((line=bufr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="string">"over"</span>.equals(line))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			bufw.write(line);<span class="comment">//逐行写入</span></span><br><span class="line">			bufw.newLine();<span class="comment">//换行</span></span><br><span class="line">			bufw.flush();<span class="comment">//使用缓冲区记得要刷新</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重点代码"><a href="#重点代码" class="headerlink" title="重点代码"></a>重点代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//键盘录入</span></span><br><span class="line">BufferedReader bufr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">BufferedWriter bufw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br></pre></td></tr></table></figure>

<h4 id="流操作规律"><a href="#流操作规律" class="headerlink" title="流操作规律"></a>流操作规律</h4><p>之所以要弄清楚这个规律，是因为流对象太多，开发时不知道用哪个对象合适。</p>
<p>想要知道开发时用到哪些对象，只要通过四个明确即可。</p>
<p>1， 明确源和目的（汇）</p>
<p>​    源：  InputStream     Reader</p>
<p>​    目的：OutputStream  Writer</p>
<p>2， 明确数据是否是纯文本数据</p>
<p>​    源：是纯文本：Reader</p>
<p>​                       否：InputStream</p>
<p>​    目的：是纯文本：Writer</p>
<p>​                       否：OutputStream</p>
<p>到这里就可以明确需求中具体要用哪个体系。</p>
<p>3， 明确具体的设备。</p>
<p>​    源设备：</p>
<p>​            硬盘：File</p>
<p>​            键盘：System.in</p>
<p>​            内存：数组</p>
<p>​            网络：Socket流</p>
<p>​    目的设备：</p>
<pre><code>硬盘：File</code></pre><p>​            控制台：System.out</p>
<p>​            内存：数组</p>
<p>​            网络：Socket流</p>
<p>4， 是否需要其他额外功能。</p>
<p>​    1， 是否需要高效（缓冲区）？</p>
<p>​        是，就加上buffer。</p>
<p>​    2， 是否需要转换</p>
<p>​        是</p>
<pre><code>源：InputStreamReader 字节流-&gt;字符流

目的：OutputStreamWriter 字符流-&gt;字节流</code></pre><hr>
<p>需求1：复制一个文本文件。</p>
<p>  1，明确源和目的。</p>
<p>​        源：InputStream  Reader</p>
<p>​        目的：OutputStream Writer  </p>
<p>  2，是否是纯文本？</p>
<p>​        是！</p>
<pre><code>源：Reader</code></pre><p>​        目的：Writer</p>
<p>  3，明确具体设备</p>
<p>​        源：</p>
<p>​              硬盘：File</p>
<p>​        目的：</p>
<p>​              硬盘：File</p>
<p>​        FileReader fr = new FileReader(“a.txt”);</p>
<pre><code>FileWriter fw = new FileWriter(&quot;b.txt&quot;);</code></pre><p>  4，需要额外功能吗？</p>
<p>​        需要，需要高效。</p>
<p>​    BufferedReader bufr = new BufferedReader(new FileReader(“a.txt”));</p>
<p>​    BufferedWriter bufw = new BufferedWriter(new FileWriter(“b.txt”));</p>
<hr>
<p>需求2：读取键盘读入信息，并写入到一个文件中。</p>
<p>  1，明确源和目的。</p>
<p>​        源：InputStream  Reader</p>
<p>​        目的：OutputStream Writer </p>
<p>  2，是否是纯文本呢？</p>
<pre><code>是</code></pre><p>​              源：Reader</p>
<p>​          目的 ：Writer</p>
<p>  3，明确设备</p>
<pre><code>源：</code></pre><p>​              键盘：System.in</p>
<p>​        目的</p>
<p>​              硬盘：File</p>
<p>​    InputStream in = System.in;</p>
<p>​    FileWriter fw = new FileWriter(“b.txt”);</p>
<p>​    这样做可以完成，但是麻烦。将读取的字节数据转成字符串，再由字符流操作。</p>
<p>  4，需要额外功能吗？</p>
<p>​    需要，转换。将字节流转换成字符流。因为明确的源是Reader，这样操作文本数据最便捷。</p>
<p>​    所以要将已有的字节流转成字符流。使用字节–&gt;字符。InputStreamReader</p>
<p>​    InputStreamReader isr = new InputStreamReader(System.in);</p>
<p>​    FileWriter fw = new FileWriter(“b.txt”);</p>
<p>​    还需要功能吗？</p>
<p>​    需要：想高效</p>
<p>​    BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));</p>
<p>​    BufferedWriter bufw = new BufferedWriter(new FileWriter(“b.txt”));</p>
<hr>
<p>需求3：将一个文本文件数据显示在控制台上</p>
<p>  1，明确源和目的。</p>
<p>​        源：InputStream  Reader</p>
<p>​        目的：OutputStream Writer </p>
<p>  2，是否是纯文本呢？</p>
<p>​        是</p>
<p>​              源：Reader</p>
<p>​              目的 ：Writer</p>
<p>  3，明确具体设备</p>
<pre><code>源：</code></pre><p>​              硬盘：File</p>
<p>​        目的：</p>
<p>​              控制台：System.out</p>
<p>​    FileReader fr = new FileReader(“a.txt”);</p>
<p>​    OutputStream out = System.out;//对象类型是PrintStream</p>
<p>  4，需要额外功能吗？</p>
<p>​    需要，转换。</p>
<p>​    FileReader fr = new FileReader(“a.txt”);</p>
<p>​    OutputStreamWriter osw = new OutputStreamWriter(System.out);</p>
<p>​    需要，高效。</p>
<p>​    BufferedReader bufr = new BufferedReader(new FileReader(“a.txt”));</p>
<p>​    BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));</p>
<hr>
<p>需求4：读取键盘录入数据，显示在控制台上</p>
<p>  1，明确源和目的。</p>
<p>​        源：InputStream  Reader</p>
<pre><code>目的：OutputStream Writer </code></pre><p>  2，是否是纯文本呢？</p>
<p>​        是</p>
<p>​              源：Reader</p>
<p>​              目的 ：Writer</p>
<p>  3，明确设备</p>
<pre><code>源：</code></pre><p>​              键盘：System.in</p>
<pre><code>目的：</code></pre><p>​              控制台：System.out   </p>
<p>​    InputStream in = System.in;</p>
<p>​    OutputStream out = System.out;</p>
<p>  4，明确额外功能？</p>
<p>​    需要转换，因为都是字节流，但是操作的却是文本数据。</p>
<p>​    所以使用字符流操作起来更方便。</p>
<p>​    InputStreamReader isr = new InputStreamReader(System.in);</p>
<p>​    OutputStreamWriter osw = new OutputStreamWriter(System.out);</p>
<p>​    为了将其高效操作。</p>
<p>​    BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));</p>
<p>   BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));</p>
<h4 id="转换流的编码解码"><a href="#转换流的编码解码" class="headerlink" title="转换流的编码解码"></a>转换流的编码解码</h4><p>GBK中一个中文对应2个字节，在UTF-8编码中，一个中文对应3个字节。</p>
<p>需求5：将一个中文字符串数据按照指定的编码表写入到一个文本文件中</p>
<p>  1，目的。OutputStream Writer</p>
<p>  2，是纯文本，Writer</p>
<p>  3，设备：硬盘File</p>
<p>  FileWriter fw = new FileWriter(“a.txt”);</p>
<p>  fw.write(“你好”);</p>
<p>  注意：既然需求中已经<strong>明确了指定编码表的动作</strong>。</p>
<p>  那就<strong>不可以使用FileWriter</strong>，因为FileWriter内部是使用<strong>默认的本地码表</strong>。</p>
<p>  只能使用其父类，OutputStreamWriter。</p>
<p>  OutputStreamWriter接收一个<strong>字节输出流</strong>对象，既然是操作文件，那么对象应该是FileOutputStream</p>
<p>  OutputStreamWriter = osw = new OutputStreamWriter(new FileOutputStream(“a.txt”),<strong>charsetNam</strong>e);</p>
<p>  需要高效不？</p>
<p>  BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(“a.txt”),charsetName));</p>
<p>什么时候使用转换流呢？</p>
<p>  1，源或者目的对应的<strong>设备是字节流</strong>，但是<strong>操作的却是文本数据</strong>，可以使用转换流作为<strong>桥梁</strong>，提高对文本操作的便捷。</p>
<p>2，一旦操作文本涉及到具体的<strong>指定编码表</strong>，必须使用转换流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字节流加码表变成字符流。</span></span><br><span class="line">		OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"gbk_3.txt"</span>),<span class="string">"GBK"</span>);<span class="comment">//字符转字节，传入字节流</span></span><br><span class="line">		FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"gbk_1.txt"</span>);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 这两句代码的功能是等同的。</span></span><br><span class="line"><span class="comment">		 * FileWriter：其实就是转换流指定了本机默认码表的体现，而且这个转换流的子类对象，可以方便操作文本文件。</span></span><br><span class="line"><span class="comment">		 * 	简单说：操作文件的字节流+本机默认的编码表。</span></span><br><span class="line"><span class="comment">		 * 	这是按照默认码表来操作文件的便捷类。</span></span><br><span class="line"><span class="comment">		 * 如果操作文本文件需要明确具体的编码，FileWriter就不行了。必须用转换流。</span></span><br><span class="line"><span class="comment">		 */</span></span><br></pre></td></tr></table></figure>

<h4 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h4><p>当想把<strong>数据保持原样</strong>，使用打印流最方便。按照需求使用，如果要保证文件的大小，使用之前的输出流，如果要保持数据原样，使用打印流。打印流只负责<strong>目的</strong>。</p>
<p>PrintWriter与PrintStream</p>
<p><strong>PrintStream</strong></p>
<p>System.out类型就为PrintStream类型。PrintStream为其他输出流添加了功能，使他们能够方便的打印各种数据值表现形式。<strong>不抛出IO异常</strong>。在需要写入<strong>字符</strong>而不是写入字节的情况下，应该使用PrintWriter。</p>
<p>1，提供了打印的放法，可以对多种数据类型值打印。并保持数据的表示形式。</p>
<p>2，它不抛IO异常。</p>
<p>构造函数，接收三种类型的值</p>
<p>1， 字符串路径</p>
<p>2， File对象</p>
<p>3， 字节输出流</p>
<p><strong>write</strong>只写<strong>最低8位</strong>，print将值变为字符串再打印，保持<strong>原样</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入int为32位，只保留后8位，将前24位截取，这样在记事本中表现为a</span></span><br><span class="line">		out.write(<span class="number">97</span>);<span class="comment">//记事本中打开为a</span></span><br><span class="line">		<span class="comment">//print原理为将要打印的值变为字符串，保持原样将数据打印到目的地</span></span><br><span class="line">		out.print(<span class="number">97</span>);</span><br></pre></td></tr></table></figure>

<p><strong>PrintWriter</strong></p>
<p>之后用的很多，服务端所用的就为PrintWriter。</p>
<p>构造函数参数：</p>
<p>1， 字符串路径</p>
<p>2， File对象</p>
<p>3， 字节输出流</p>
<p>4， 字符输出流</p>
<p>直接用println方法写入数据</p>
<p><strong>public</strong> PrintWriter(OutputStream out,<strong>boolean</strong> autoFlush)</p>
<p><strong>public</strong> PrintWriter(Writer out, <strong>boolean</strong> autoFlush)</p>
<p>如果传入true，println,printf,format方法将刷新缓冲区。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		<span class="comment">//读键盘</span></span><br><span class="line">		BufferedReader bufr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		<span class="comment">//输出到控制台</span></span><br><span class="line"><span class="comment">//		PrintWriter out = new PrintWriter(System.out,true);</span></span><br><span class="line">		<span class="comment">//如果想要写入到文件中，如果直接使用字符串路径则不能自动刷新，这样使用流对象封装即可。</span></span><br><span class="line">		PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">"out.txt"</span>),<span class="keyword">true</span>);</span><br><span class="line">		String line = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span>((line=bufr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="comment">//如果不定义结束标记，则无法结束。</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="string">"over"</span>.equals(line))</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//自定义结束标记</span></span><br><span class="line">			out.println(line.toUpperCase());</span><br><span class="line">			<span class="comment">//缓冲区记得刷新。</span></span><br><span class="line"><span class="comment">//			out.flush();</span></span><br><span class="line">		&#125;</span><br><span class="line">		out.close();</span><br><span class="line">		bufr.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="序列流"><a href="#序列流" class="headerlink" title="序列流"></a>序列流</h4><p>SequenceInputStream</p>
<p>序列流只负责源。</p>
<p>​    将多个输入流合并为一个流。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC22%E5%A4%A96.png" class title="This is an example image">

<p>将最后一个流的-1作为整个流的-1。</p>
<p>SequenceInputStream(Enumeration&lt;? <strong>extends</strong> InputStream&gt; e) </p>
<p>  初始化新创建 SequenceInputStream通过记住参数，它必须是一个 Enumeration产生对象，它们的运行时类型是 InputStream 。   </p>
<p>  构造器有两种，一种是传入参数为两个字节输入流，一个是字节输入流的枚举。而Vector中有枚举，直接使用Vecor效率太低于是使用ArrayList。但是只能获取迭代器，这样便想到去new一个迭代器，需要去实现其方法，因为与迭代器只有名称不一样，因此可以利用获取的迭代器方法来实现枚举。如果用匿名内部类来实现，而内部类使用临时变量，此临时变量需要被final修饰。但是这样比较麻烦，于是想到去Collections集合工具类中找方法，此方法返回枚举，接收集合对象，可以使用集合对象的方法，于是可以使用</p>
<p>​    Enumeration<FileInputStream> en = Collections.<em>enumeration</em>(集合);</FileInputStream></p>
<p>这样可以有一种思路，即相同功能对象可以利用另一个的方法来实现自身，而不用自己去实现。</p>
<h4 id="文件切割"><a href="#文件切割" class="headerlink" title="文件切割"></a>文件切割</h4><p>​    要切几个文件用几个输出流。</p>
<p>​    如果要将文件存入指定路径，可以将路径与文件后缀名封装成文件对象，因为文件对象的构造器中可以加入文件对象。</p>
<h4 id="文件合并"><a href="#文件合并" class="headerlink" title="文件合并"></a>文件合并</h4><p>​    如果要将多个文件写入同一个文件或者将文件碎片合并到一个文件，要用到序列流。序列流需要用到枚举，而枚举可以通过集合获取到。先将字节输入流存入ArrayList集合，然后用Collections工具类获取集合的枚举。这样从序列流中将数据写入到指定的路径下。如果要指定路径+文件后缀名，可以new File(dir,”1.mp3”);</p>
<h4 id="操作对象（装饰类）"><a href="#操作对象（装饰类）" class="headerlink" title="操作对象（装饰类）"></a>操作对象（装饰类）</h4><p>ObjectInputStream与ObjectOutputStream，操作对象的流。</p>
<p>​    把对象生命周期延迟，存储在硬盘上实现持久化。把对象从堆内存存储在了硬盘上。</p>
<p><strong>ObjectOutputStream</strong></p>
<p>为了实现额外功能，相当于装饰类，将字节流对象关联。要存储的对象必须实现Serializable接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeObj</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//基础的输出流没办法存储对象，因此需要装饰类。将输出流传入对象输出流即可。</span></span><br><span class="line">		<span class="comment">//后缀名使用object</span></span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"obj.object"</span>));</span><br><span class="line">		<span class="comment">//对象序列化。被序列化的对象必须实现Serializable接口</span></span><br><span class="line">		oos.writeObject(<span class="keyword">new</span> Person(<span class="number">30</span>, <span class="string">"小强"</span>));</span><br><span class="line">		<span class="comment">//关流</span></span><br><span class="line">		oos.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ObjectInputStream</strong></p>
<p>​    ObjectInputStream对以前使用ObjectOutputStream写入的基本数据和对象进行<strong>反序列化</strong>。只能读ObjectOutputStream写入的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对象读取流，因为是增强功能因此要传入字节输入流。</span></span><br><span class="line">		ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"obj.object"</span>));</span><br><span class="line">		<span class="comment">//需要有读出对象的class文件才能获得对象。</span></span><br><span class="line">		<span class="comment">//对象的反序列化。</span></span><br><span class="line">		Person p = (Person)ois.readObject();</span><br><span class="line">		System.out.println(p.getName()+<span class="string">":"</span>+p.getAge());</span><br><span class="line">		ois.close();<span class="comment">//关流</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>因为一次只能读一个对象，因此如果想多读几个对象，可使用以下方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">				Person p = (Person) ois.readObject();</span><br><span class="line">				System.out.println(p.getName() + <span class="string">":"</span> + p.getAge());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (EOFException e) &#123;</span><br><span class="line">			</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			ois.close();<span class="comment">// 关流</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h4><p>如果用原来的class文件，用更改后的类来接收，会报错。InvalidClassException。类实现Serializable接口，Serializable为标记接口，序列化运行时使用称为serialVersionUID的版本号与每个可序列化类相关联。该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。如果接收者加载类的ID号与发送者的类的版本号不同，反序列化会导致InvalidClassException。</p>
<p>因此Serializable用于给被序列化的类加入ID号。用于判断类和对象是否是同一个版本。如果可序列化类未显示声明serialVersionUID，则序列化运行时将基于该类的各个方面计算该类的默认serialVersionUID。强烈建议所有可序列化都显示声明serialVersionUID值，因为计算默认ID对类的详细信息有较高的敏感性，根据编译期的不同可能千差万别。</p>
<p>一个可序列化的类可以通过声明一个名为”serialVersionUID”的字段来显式地声明它自己的serialVersionUID，该字段必须是static，final和long类型</p>
<p>  <strong>private</strong> <strong>static</strong> <strong>final</strong> <strong>long</strong> serialVersionUID = 9527L;</p>
<p>  只要ID号一样，就算类文件变化了，那就依然可以读出，在服务器上可能会用到。</p>
<h4 id="无法被写入的属性-static-transient"><a href="#无法被写入的属性-static-transient" class="headerlink" title="无法被写入的属性(static transient)"></a>无法被写入的属性(static transient)</h4><p><strong>静态修饰</strong></p>
<p>如果类中某一属性被静态修饰，则堆内存中没有此属性，因此无法被写入到对象中。对象输出流只能写入非静态的属性和非瞬态的。</p>
<p><strong>transient关键字</strong></p>
<p>​    短暂的，暂时的。如果某一属性不是公用的，不能被static修饰，但是又不想写到对象中，可以使用transien关键字。</p>
<p>非静态数据不想被序列化可以使用这个关键字修饰。</p>
<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p>​    IO流只能操作文件中的数据。</p>
<p>而File类用来将文件或者文件夹封装成对象，方便对文件与文件夹的属性信息进行操作。</p>
<p>File对象可以作为参数传递给流的构造函数。</p>
<h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以将一个已存在的，或者不存在的文件或目录封装成File对象。</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">File file2 = <span class="keyword">new</span> File(<span class="string">"d:\\"</span>,<span class="string">"a.txt"</span>);<span class="comment">//从父路径名字符串和子路径名字符串创建新的 File实例</span></span><br><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"d:\\"</span>);<span class="comment">//加两个反斜杠才能正常读出</span></span><br><span class="line">File f3 = <span class="keyword">new</span> File(f,<span class="string">"a.txt"</span>);<span class="comment">//从父抽象路径名和子路径名字符串创建新的 File实例</span></span><br></pre></td></tr></table></figure>

<p>不同的操作系统分隔符不一样。之前在系统类中使用字段file.separator获取分隔符。现在使用File.separator来获取分隔符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为了系统兼容，使用System.getProperty("file.separator")</span></span><br><span class="line">		String sep = System.getProperty(<span class="string">"file.separator"</span>);<span class="comment">//之前写法</span></span><br><span class="line">		String newsep = File.separator;</span><br><span class="line">		File f4 = <span class="keyword">new</span> File(<span class="string">"d:\\"</span>+newsep+<span class="string">"a.txt"</span>);</span><br><span class="line">		System.out.println(f4);</span><br></pre></td></tr></table></figure>

<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p><strong>获取修改时间</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作用：判断修改时间，加载修改后的新文件</span></span><br><span class="line">		<span class="keyword">long</span> time = file.lastModified();<span class="comment">//最后修改时间</span></span><br><span class="line">		<span class="comment">//将毫秒值转变为Date对象</span></span><br><span class="line">		Date date = <span class="keyword">new</span> Date(time);</span><br><span class="line">		<span class="comment">//日期格式化对象</span></span><br><span class="line">		DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG,DateFormat.LONG);</span><br><span class="line">		<span class="comment">//将日期对象转成String，用format方法。</span></span><br><span class="line">		String str_time = dateFormat.format(date);</span><br></pre></td></tr></table></figure>

<p>File对象的常用方法</p>
<p>1，<strong>获取</strong></p>
<p>  1.1获取文件名称 </p>
<p>​    String getName();</p>
<p>  1.2获取文件路径 </p>
<p>​    String getPath();</p>
<p>String getAbsolutePath();</p>
<p>  1.3获取文件大小 </p>
<p>​     long length();</p>
<p>  1.4获取文件修改时间 </p>
<p>​     long lastModified()得到毫秒值</p>
<p>2，<strong>创建与删除</strong></p>
<p>  如果文件或目录存在就不会创建。</p>
<p>  delete慎用，删除成功无法从回收站中找回。</p>
<p>  delete无法删除原因：</p>
<p>​    文件夹中有目录；正在被流使用</p>
<p>   2.1 文件创建 </p>
<p>​     boolean createNewFile();</p>
<p>​    和输出流不一样，如果文件不存在，则创建；如果文件存在，则不创建。</p>
<p>   2.2 文件删除</p>
<p>​     boolean delete();</p>
<p>   2.3 文件夹创建</p>
<p>​     boolean mkdir();//make directory</p>
<p>​     boolean mkdirs();//创建多级目录文件夹</p>
<p>   2.4 文件夹删除</p>
<p>​     boolean delete();//如果文件夹中有目录无法删除</p>
<p>​    如果是多级目录下的文件，则只删掉最子集的目录，前面的父目录无法删掉。</p>
<p>3，<strong>判断</strong>(很实用)</p>
<p>  在判断是否为文件或者是否是目录之前，要判断其是否存在。</p>
<p>​     boolean exists();//是否存在</p>
<p>​     boolean isFile();//是否是文件</p>
<p>​     boolean isDirectory();//是否是目录</p>
<p>4，<strong>重命名</strong></p>
<p>   需要有2个File，第二个File为命名后的文件位置</p>
<p>​     Boolean renameTo(File file);</p>
<p>   相当于剪切操作，可以从一个盘符移动到另一个。先关联两个文件，然后用文件去调用方法</p>
<p>​     File f1 = new File(“d:\1.jpg”);</p>
<p>​     File f3 = new File(“d:\1\2.jpg”);</p>
<p>​     boolean b2 = f1.renameTo(f3);</p>
<p>​     System.out.println(“文件剪切是否成功”+b2);</p>
<p>5，<strong>系统根目录和容量获取</strong></p>
<p>​     static Files[] listRoots();//获取系统中所有盘符，静态方法</p>
<p>​     long getFreeSpace();//获取可用容量</p>
<p>​     long getTotalSpace();//获取总容量</p>
<p>​     long getUsableSpace();//获取虚拟机可用容量</p>
<p>6，<strong>获取目录内容及文件名过滤器</strong></p>
<p>实现<strong>FilenameFilter</strong>接口。使用<strong>list</strong>方法。</p>
<p>使用list只能获取当前目录下的<strong>名称</strong>。</p>
<p>​     String[] list();</p>
<p>String[] list(FilenameFilter filter) </p>
<blockquote>
<p>获取当前目录下的文件以及文件夹的名称，包含隐藏文件</p>
<p>调用list方法的File对象中封装的必须是目录。否则会发生空指针异常</p>
<p>如果访问的是系统级目录，也会发生空指针异常</p>
<p> 如果目录存在，但是没有内容，会返回一个数组，但是长度为0</p>
</blockquote>
<p>文件名过滤器：过滤文件名</p>
<p>调用list(FilenameFilter)，调用list方法时候需要传入指定的过滤器对象，过滤器需要实现accept方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"d:\\"</span>);</span><br><span class="line">		String[] names = file.list(<span class="keyword">new</span> FilterByName());</span><br><span class="line">过滤器</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterByName</span> <span class="keyword">implements</span> <span class="title">FilenameFilter</span> </span>&#123;</span><br><span class="line">	<span class="comment">//实现FilenameFilter接口</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">		System.out.println(dir+<span class="string">":"</span>+name);</span><br><span class="line">		<span class="keyword">return</span> name.endsWith(<span class="string">".zip"</span>);<span class="comment">//判断以什么结尾。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC22%E5%A4%A92.png" class title="This is an example image">

<p>过滤器原理，先调用list方法获取指定路径下的全部目录，将 其存进数组，遍历数组，只要符合FilenameFilter.accept(dir,name)条件的，就进行存储，如accept方法可使用name.endsWith(指定文件格式)。</p>
<p>​    如果需要对过滤器传入参数，需要对过滤器添加构造函数，过滤器持有一个私有的字符串变量，通过构造函数来获取字符串变量，然后accept方法进行判断。</p>
<p>7，<strong>获取目录下文件对象及过滤</strong></p>
<p>实现FileFilter接口。使用listFiles方法</p>
<p>File[] listFiles() </p>
<p>返回一个抽象路径名数组，表示由该抽象路径名表示的目录中的文件。 </p>
<p>File[] listFiles(FileFilter filter) </p>
<p>返回一个抽象路径名数组，表示由此抽象路径名表示的满足指定过滤器的目录中的文件和目录。 </p>
<p>File[] listFiles(FilenameFilter filter) </p>
<p>返回一个抽象路径名数组，表示由此抽象路径名表示的满足指定过滤器的目录中的文件和目录。</p>
<p>文件类型过滤器</p>
<p>  如可以过滤非隐藏文件</p>
<h4 id="深度遍历文件夹"><a href="#深度遍历文件夹" class="headerlink" title="深度遍历文件夹"></a>深度遍历文件夹</h4><p>思路：</p>
<p>1、 将待深度遍历的目录关联File对象</p>
<p>2、 使用自定义方法来获取其所有子目录及文件</p>
<p>3、 方法怎么弄呢？首先要获取该目录下所有文件数组，遍历此数组，如果是目录则使用自定义功能继续遍历，如果不是目录则将文件名输出。这样便实现了遍历输出。</p>
<p>4、 但是这样不美观，因此需要记录下每个目录的层级信息。不能直接在方法中定义一个数，因为每次调用方法都会将这个数重置，那么需要在递归时传递给下一次递归。则进入下一次递归后将层级++,便实现了层级信息的记录。</p>
<p>5、 那么要如何美观输出呢？每多一个层级，就多一点空格，因为不知有多少字符串，所以使用StringBuilder来实现可变字符串，依靠层级数信息来添加空格信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//1，将File与待深度遍历目录关联</span></span><br><span class="line">		File dir = <span class="keyword">new</span> File(<span class="string">"d:\\test"</span>);</span><br><span class="line">		<span class="comment">//调用自定义方法，获取所有子目录及文件	</span></span><br><span class="line">		listAll(dir,<span class="number">0</span>);<span class="comment">//需要在递归时传入当前层级数。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listAll</span><span class="params">(File dir,<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//输入当前目录的名字，为了层级结构增加level以美观输出。</span></span><br><span class="line">		System.out.println(getSpace(level)+dir.getName());</span><br><span class="line">		level++;<span class="comment">//每次进一次目录，层级加一</span></span><br><span class="line">		<span class="comment">//获取指定目录下当前所有的文件夹或者对象</span></span><br><span class="line">		<span class="comment">//因为需要对数组中文件操作，所以使用listFiles()方法。</span></span><br><span class="line">		File[] files = dir.listFiles();</span><br><span class="line">		<span class="comment">//遍历文件数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;files.length;x++)&#123;</span><br><span class="line">			<span class="comment">//是目录就继续遍历，递归。</span></span><br><span class="line">			<span class="keyword">if</span>(files[x].isDirectory())&#123;</span><br><span class="line">				listAll(files[x],level);<span class="comment">//传入待遍历目录及层数</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果不是目录就进行打印</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="comment">//同样为了美观层级输出使用自定义功能</span></span><br><span class="line">				System.out.println(getSpace(level)+files[x].getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//清晰显示每层的层级结构，因为字符串数组可变，使用StringBuilder。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSpace</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//只有在目录或文件前使用|--</span></span><br><span class="line">		sb.append(<span class="string">"|--"</span>);</span><br><span class="line">		<span class="comment">//每多一层目录加一个|  。</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;level;x++)&#123;</span><br><span class="line">			sb.insert(<span class="number">0</span>,<span class="string">"|  "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归：函数自身直接或间接调用自身。</p>
<p>一个功能在被重复使用并每次使用时参与运算的结果和上一次调用有关。这时可以用递归来解决问题。</p>
<p>注意：</p>
<p>  1，递归一定要明确条件，否则容易栈溢出。即最小收敛情况。</p>
<p>  2，注意一下递归的次数。太多次容易栈溢出。超过栈内存就会报错。</p>
<p>递归中单独定义变量，每次调用方法，各个方法都会持有该变量的引用，如果想让此变量被下一次递归使用，则要作为参数传递给下一次。</p>
<h4 id="二进制转换"><a href="#二进制转换" class="headerlink" title="二进制转换"></a><strong>二进制转换</strong></h4><p>调用时候最先出栈的先输出，因此先输出1%2，然后3%2，最后6%2，因此结果是110.如果toBin()在输出下面，那就是011,因为先输出6%2，3%2，1%2。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toBin</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			toBin(num/<span class="number">2</span>);</span><br><span class="line">			System.out.println(num%<span class="number">2</span>);	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="求和"><a href="#求和" class="headerlink" title="求和"></a><strong>求和</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(num==<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> num+getSum(num-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC22%E5%A4%A93.png" class title="This is an example image">

<p>递归图解：运行sum(5),sum(4),sum(3),sum(2),sum(1)，然后sum(1)出栈，返回1，sum(2)出栈，返回2+1，sum(3)出栈，返回3+3，sum(4)出栈，返回4+6，sum(5)出栈，返回5+10。</p>
<h3 id="Properties集合"><a href="#Properties集合" class="headerlink" title="Properties集合"></a>Properties集合</h3><p>Map</p>
<pre><code>|--Hashtable</code></pre><p>​            |–Properties:</p>
<p>Properties集合：</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>1，该集合中的键和值都是字符串类型。</p>
<p>2，集合中的数据可以保存在流中(store)，或者从流中获取(load)。</p>
<p>通常该集合用于操作以键值对形式存在的配置文件。</p>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><p>1，存储</p>
<p>单个存储</p>
<p>  Object setProperty(String key, String value); </p>
<p>  也可以用来覆盖，键相等，值覆盖 </p>
<p>  使用的是Hashtable的put方法</p>
<p>2，获取</p>
<p>  单个获取</p>
<p>  String getProperty(String key); </p>
<p>  全部获取（转为Set集合）</p>
<p>  Set<String> stringPropertyNames() </String></p>
<p>  返回此属性列表中的一组键，其中键及其对应的值为字符串，包括默认属性列表中的不同键，如果尚未从主属性列表中找到相同名称的键。 </p>
<p>3，与流对象关联</p>
<p>  public void list(PrintStream out);将此属性列表打印到指定的输出流。 此方法对调试非常有用。 </p>
<p>4，持久化存储</p>
<p>  可以关联字节流或字符流，comment为相关注释，不要写中文。</p>
<p>  void store(OutputStream out, String comments);</p>
<p>  void store(Writer writer, String comments)   </p>
<p>5，获取输入流</p>
<p>  <strong>void</strong> load(InputStream inStream) </p>
<p>​    从输入字节流读取属性列表（键和元素对）。</p>
<p>  <strong>void</strong> load(Reader reader) </p>
<p>​    以简单的线性格式从输入字符流读取属性列表（关键字和元素对）。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Properties集合的存和取</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">propertiesDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//创建一个Properties集合</span></span><br><span class="line">		Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">		<span class="comment">//存储元素</span></span><br><span class="line">		prop.setProperty(<span class="string">"zhangsan"</span>, <span class="string">"30"</span>);</span><br><span class="line">		prop.setProperty(<span class="string">"lisi"</span>, <span class="string">"31"</span>);</span><br><span class="line">		prop.setProperty(<span class="string">"zhaoliu"</span>, <span class="string">"28"</span>);</span><br><span class="line">		<span class="comment">//修改元素，键相等，值覆盖</span></span><br><span class="line">		prop.setProperty(<span class="string">"zhangsan"</span>, <span class="string">"26"</span>);</span><br><span class="line">		<span class="comment">//取出所有元素</span></span><br><span class="line">		Set&lt;String&gt; names = prop.stringPropertyNames();<span class="comment">//获取键值集合</span></span><br><span class="line">		<span class="keyword">for</span>(String name:names)&#123;</span><br><span class="line">			String value = prop.getProperty(name);</span><br><span class="line">			System.out.println(name+<span class="string">":"</span>+value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="获取系统信息"><a href="#获取系统信息" class="headerlink" title="获取系统信息"></a>获取系统信息</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取系统的键值信息</span></span><br><span class="line">		Properties prop = System.getProperties();</span><br><span class="line">		<span class="comment">//只能打印，不能获取</span></span><br><span class="line">		prop.list(System.out);</span><br></pre></td></tr></table></figure>

<h5 id="模拟load方法"><a href="#模拟load方法" class="headerlink" title="模拟load方法"></a>模拟load方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 模拟load方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myLoad</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">	Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">	<span class="comment">//字符流装饰类，用以提高效率</span></span><br><span class="line">	BufferedReader bufr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"info.txt"</span>));</span><br><span class="line">	<span class="comment">//按行读取</span></span><br><span class="line">	String line = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">while</span>((line=bufr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="comment">//因为开头包含注释信息，均以#开头，因此不存。</span></span><br><span class="line">		<span class="keyword">if</span>(line.startsWith(<span class="string">"#"</span>))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		String[] arr = line.split(<span class="string">"="</span>);</span><br><span class="line">		prop.setProperty(arr[<span class="number">0</span>], arr[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将集合打印到控制台输出。</span></span><br><span class="line">	prop.list(System.out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="从文件中获取配置信息"><a href="#从文件中获取配置信息" class="headerlink" title="从文件中获取配置信息"></a>从文件中获取配置信息</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">//集合中的数据来自于一个文件</span></span><br><span class="line"><span class="comment">//注意：必须要保证该文件中的数据是键值对</span></span><br><span class="line"><span class="comment">//需要使用到读取流</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"info.txt"</span>);</span><br><span class="line"><span class="comment">//使用load方法</span></span><br><span class="line">prop.load(fis);</span><br><span class="line">prop.list(System.out);<span class="comment">//打印到指定的输出流</span></span><br></pre></td></tr></table></figure>

<h4 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h4><p>简单配置用Properties，复杂配置使用XML。相当于标签。</p>
<p>简单配置</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC22%E5%A4%A94.png" class title="This is an example image">

<p>复杂配置</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC22%E5%A4%A95.png" class title="This is an example image">

<p>XML使用起来更为清晰。</p>
<h3 id="IO流其他类"><a href="#IO流其他类" class="headerlink" title="IO流其他类"></a>IO流其他类</h3><h4 id="RandomAccessFile（多线程写入）"><a href="#RandomAccessFile（多线程写入）" class="headerlink" title="RandomAccessFile（多线程写入）"></a>RandomAccessFile（多线程写入）</h4><p>随机访问文件。看到这个类的名字，纠结。父类为Object。不是IO体系中的子类。此类的实例支持对随机访问文件的读取和写入。随机访问文件的行为类似存储在文件系统中的一个大型byte数组。</p>
<p>​    利用seek方法修改指针位置，即可实现在指定位置的随机读写。一般要求数据有规律。</p>
<p>​    应用：利用多线程，对同一个文件分段同时写入数据。多线程写入。</p>
<p>特点：</p>
<p>1， 该对象既能读，又能写。</p>
<p>2， 该对象内部维护了一个大型byte数组，并通过指针可以操作数组中的元素。</p>
<p>3， 可以通过getFilePointer方法获取指针的位置，和通过seek方法设置指针的位置。</p>
<p>4， 其实该对象就是字节输入流和输出流进行了封装。</p>
<p>5， 该对象的源或者目的只能是文件。通过构造函数就可以看出。</p>
<p>6，如果文件不存在，则创建；如果文件存在，不创建。</p>
<p>构造方法</p>
<p>  RandomAccessFile(File file, String mode) 创建一个随机访问文件流，从File参数指定的文件读取，并可选地写入。 </p>
<p>  RandomAccessFile(String name, String mode) 创建随机访问文件流，以从中指定名称的文件读取，并可选择写入文件。</p>
<p>mode的含义</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC22%E5%A4%A97.png" class title="This is an example image">

<p>局限性：<strong>目的只能是文件</strong>，不能是其他输出流。</p>
<p>write(byte b)，如果传入String类型，需要用getBytes()方法转成字节。</p>
<p>​    按字节写入，如果传入一个比较大的int类型数，会被截断。</p>
<p><strong>读写方法</strong></p>
<p><strong>void</strong> write(<strong>byte</strong>[] b) 从指定的字节数组写入 b.length个字节到该文件，从当前文件指针开始。 </p>
<p><strong>void</strong> writeInt(<strong>int</strong> v) 将 int写入文件为四个字节，高字节为首。 </p>
<p><strong>int</strong> read(<strong>byte</strong>[] b) 从该文件读取最多 b.length个字节的数据到一个字节数组。 </p>
<p><strong>int</strong> readInt() 从该文件读取一个带符号的32位整数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用RandomAccessFile对象写入一些人员信息，比如姓名和年龄。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">		<span class="comment">//可以读也可以写</span></span><br><span class="line">		RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"ranacc.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">		raf.write(<span class="string">"张三"</span>.getBytes());</span><br><span class="line">		raf.writeInt(<span class="number">97</span>);</span><br><span class="line">		raf.write(<span class="string">"小强"</span>.getBytes());</span><br><span class="line">		raf.writeInt(<span class="number">99</span>);</span><br><span class="line">		raf.close();<span class="comment">//关流</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"ranacc.txt"</span>, <span class="string">"r"</span>);<span class="comment">//只读即可</span></span><br><span class="line">		<span class="comment">//通过seek设置指针的位置。</span></span><br><span class="line">		raf.seek(<span class="number">1</span>*<span class="number">8</span>);<span class="comment">//随机的读取，只要指定指针的位置即可</span></span><br><span class="line">		<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">		raf.read(buf);</span><br><span class="line">		<span class="comment">//将字节数组变成字符串</span></span><br><span class="line">		String name = <span class="keyword">new</span> String(buf);</span><br><span class="line">		<span class="keyword">int</span> age = raf.readInt();</span><br><span class="line">		System.out.println(<span class="string">"name:"</span>+name);</span><br><span class="line">		System.out.println(<span class="string">"age:"</span>+age);</span><br><span class="line">		System.out.println(raf.getFilePointer());</span><br><span class="line">		<span class="comment">//关流</span></span><br><span class="line">		raf.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>随机读写</strong></p>
<p>​    通过seek方法可以随时设置指针的位置，可以实现随机的读取，只要指定指针的位置即可。</p>
<p>​    因为数据都在byte数组里面存着，因此如果某位置有数据，因此如果再从0写入，会将原来的数据进行覆盖。因此可以修改数据。</p>
<p>​    再设置seek方法，将数据写在想要的位置即可。</p>
<h4 id="管道流"><a href="#管道流" class="headerlink" title="管道流"></a>管道流</h4><p>​    PipedInputStream和PipedOutputStream。</p>
<p>​    将两个流关流，只读指定流的数据。</p>
<p>​    输入输出可以直接进行连接，通过结合<strong>多线程</strong>使用。</p>
<p>管道输入流应连接到管道输出流; 管道输入流然后提供写入管道输出流的任何数据字节。通常，一个线程从PipedInputStream对象读取数据，并且其他线程将数据写入相应的PipedOutputStream 。 不建议尝试从单个线程使用这两个对象，因为它可能会使线程死锁。 管道输入流包含一个缓冲区，在读取操作中将读取操作与限制内的操作相分离。 如果向连接的管道输出流提供数据字节的线程不再存在， 则称管道为broken 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipedStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//创建管道流。</span></span><br><span class="line">		PipedInputStream input = <span class="keyword">new</span> PipedInputStream();</span><br><span class="line">		PipedOutputStream output = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">		<span class="comment">//管道流连接，使用初始化或者connect</span></span><br><span class="line">		input.connect(output);</span><br><span class="line">		<span class="comment">//不能使用单线程，因为读为阻塞任务，容易死锁。</span></span><br><span class="line">		<span class="comment">//开启线程，将线程任务传入</span></span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Input(input)).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Output(output)).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> PipedInputStream in;</span><br><span class="line">	Input(PipedInputStream in)&#123;</span><br><span class="line">		<span class="keyword">this</span>.in = in;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//异常不能往外抛</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">			<span class="keyword">int</span> len = in.read(buf);</span><br><span class="line">			String s = <span class="keyword">new</span> String(buf,<span class="number">0</span>,len);</span><br><span class="line">			System.out.println(<span class="string">"s="</span>+s);</span><br><span class="line">			in.close();<span class="comment">//关流</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Output</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> PipedOutputStream out;</span><br><span class="line">	Output(PipedOutputStream out)&#123;</span><br><span class="line">		<span class="keyword">this</span>.out = out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">			out.write(<span class="string">"hi，管道来了"</span>.getBytes());</span><br><span class="line">			out.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="操作基本数据类型（装饰类）"><a href="#操作基本数据类型（装饰类）" class="headerlink" title="操作基本数据类型（装饰类）"></a>操作基本数据类型（装饰类）</h4><p>​    DataInputStream与DataOutputStream。</p>
<p>​    用于操作<strong>基本数据类型</strong>。如果使用修改版UTF-8写入，则只有此流对应的方法才为你那个读入。</p>
<p>数据输入流允许应用程序以独立于机器的方式从基础输入流读取原始Java数据类型。 应用程序使用数据输出流来写入稍后可以被数据输入流读取的数据。</p>
<p>普通的write会将整数只保留后8位。</p>
<p>为装饰类，需要传入相应的字节输入流与字节输出流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeDate</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"data.txt"</span>));</span><br><span class="line">		<span class="comment">//UTF-8修改版，用转换流也读不了，只有这个流可以</span></span><br><span class="line">		dos.writeUTF(<span class="string">"你好"</span>);</span><br><span class="line">		dos.close();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readDate</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		DataInputStream dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"data.txt"</span>));</span><br><span class="line">		String str = dis.readUTF();</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="操作字节数组（源、目的为内存）"><a href="#操作字节数组（源、目的为内存）" class="headerlink" title="操作字节数组（源、目的为内存）"></a>操作字节数组（源、目的为内存）</h5><p>​    一般操作的<strong>数据不大</strong>。</p>
<p>​    ByteArrayInputStream与ByteArrayOutputStream</p>
<p>​    源和目的都是<strong>内存</strong>。没有调用底层资源、</p>
<p>ByteArrayOutputStream该类实现了将数据写入字节数组的输出流。 当数据写入缓冲区时，<strong>缓冲区会自动增</strong>长。 可以使用toByteArray()和<strong>toString()</strong>检索数据。 </p>
<p><strong>关闭</strong>ByteArrayOutputStream<strong>没有任何效果</strong>。 在关闭流之后，仍可以调用此类中的方法，而不生成IOException 。 </p>
<p>A ByteArrayInputStream包含一个内部缓冲区，其中包含可以从流中读取的字节。 内部计数器跟踪由read方法提供的下一个字节。</p>
<p>关闭一个ByteArrayInputStream没有任何效果。 该流中的方法可以在流关闭后调用，而不生成IOException 。</p>
<p>输入流<strong>源就是数组</strong>。</p>
<h5 id="操作字符数组"><a href="#操作字符数组" class="headerlink" title="操作字符数组"></a>操作字符数组</h5><p>CharArrayReader与CharArrayWriter</p>
<p>源为字符数组。</p>
<h5 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h5><p>​    StringReader与StringWriter</p>
<p>​    源为字符串。</p>
<h3 id="编码表"><a href="#编码表" class="headerlink" title="编码表"></a>编码表</h3><p>​    编码表：将各个国家的文字用数字表示，并一一对应，形成一张表。</p>
<p>常见的编码表</p>
<p><strong>ASCII</strong>：美国标准信息交换码。</p>
<p>​    用一个字节的7位可以表示</p>
<p><strong>ISO8859-1</strong>：拉丁码表。欧洲码表</p>
<p>​    用一个字节的8位表示，兼容ASCII码表。</p>
<p><strong>GB2312</strong>：中国的中文编码表。</p>
<p><strong>GBK</strong>：中国的中文编码表升级，融合了更多的中文文字符号。</p>
<p><strong>Unicode</strong>：国际标准码，融合了多种文字。</p>
<p>​    所有文字都用两个字节表示，Java语言使用的就是unicode</p>
<p><strong>UTF-8</strong>：最多用三个字节来表示一个字符。Unicode to其他，如果可以用一个字节装下（ASCII码）用一个，两个装的下用两个，三个装的下用三个。</p>
<h4 id="编码解码"><a href="#编码解码" class="headerlink" title="编码解码"></a>编码解码</h4><h5 id="简单编码解码"><a href="#简单编码解码" class="headerlink" title="简单编码解码"></a>简单编码解码</h5><p>利用getBytes(编码名)和new String(byte[] b,编码名)来分别实现编码和解码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 字符串--&gt;字节数组：编码。</span></span><br><span class="line"><span class="comment">		 * 字节数组--&gt;字符串：解码。</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 你好：GBK：-60 -29 -70 -61</span></span><br><span class="line"><span class="comment">		 * 	负数因为一个中文2个字节，而这个字节是很大，以1打头，因此是负数。</span></span><br><span class="line"><span class="comment">		 * 你好：utf-8：-28 -67 -96 -27 -91 -67 </span></span><br><span class="line"><span class="comment">		 * 	六个字节，一个汉字用3个字节表示</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//如果是char类型，使用unicode码完成</span></span><br><span class="line">		<span class="comment">//字符串编码按照本地的编码来</span></span><br><span class="line">		String str = <span class="string">"你好"</span>;</span><br><span class="line">		<span class="comment">//编码</span></span><br><span class="line">		<span class="keyword">byte</span>[] buf = str.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">		<span class="comment">//解码</span></span><br><span class="line">		String s1 = <span class="keyword">new</span> String(buf,<span class="string">"UTF-8"</span>);</span><br><span class="line">		System.out.println(s1);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="编码解码问题"><a href="#编码解码问题" class="headerlink" title="编码解码问题"></a>编码解码问题</h5><p>​    如果编码编错了，解不出来。如果编对了，解错了，有可能有救。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC24%E5%A4%A91.png" class title="This is an example image">

<p>当你好用GBK编码，获得4个数，用iso8859-1解码，获取4个未知字符，再利用iso8859-1对四个未知字符进行编码，获取4位数字，然后利用GBK进行解码，获得你好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串编码按照本地的编码来</span></span><br><span class="line">		String str = <span class="string">"你好"</span>;</span><br><span class="line">		<span class="comment">//编码</span></span><br><span class="line">		<span class="keyword">byte</span>[] buf = str.getBytes(<span class="string">"gbk"</span>);</span><br><span class="line">		<span class="comment">//解码</span></span><br><span class="line">		String s1 = <span class="keyword">new</span> String(buf,<span class="string">"iso8859-1"</span>);</span><br><span class="line">		System.out.println(s1);</span><br><span class="line">		<span class="comment">//获取源字节</span></span><br><span class="line">		<span class="keyword">byte</span>[] buf2 = s1.getBytes(<span class="string">"iso8859-1"</span>);</span><br><span class="line">		String s2 = <span class="keyword">new</span> String(buf2,<span class="string">"GBK"</span>);</span><br><span class="line">		System.out.println(s2);</span><br></pre></td></tr></table></figure>

<p>一种应用</p>
<p>  当数据从本地提交到服务器，在服务器先解码然后以流的形式传回，但是不是中文编码，因此先用服务器自己的编码表再编码一次，然后用GBK解码，就可以得到想要的信息。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC24%E5%A4%A92.png" class title="This is an example image">

<p>如果使用utf-8先解码再编码，很有可能会解码失败，因为使用GBK获取的数字在utf-8中找不到对应的码，因此会变成未知字符，此时码已经发生了变化，因此就无法被还原。而使用iso8859-1可以还原是因为里面没有用到中文而且都是单字节编码。</p>
<h5 id="UTF-8编码"><a href="#UTF-8编码" class="headerlink" title="UTF-8编码"></a>UTF-8编码</h5><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC24%E5%A4%A93.png" class title="This is an example image">

<p>一个字节时，打头位固定为1,2个字节时，前几位也为固定位。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC24%E5%A4%A94.png" class title="This is an example image">

<p>当字节流读数据，读到第一个字节开头为110，然后读第二个字节开头为10，马上去查表。然后读到0，读一个字节就去查表。然后毒药1110，再读10，再读10，然后去查表。</p>
<p>​    一个字节，打头为0；两个字节，打头为2个1，三个字节，打头为3个1。</p>
<h5 id="联通问题"><a href="#联通问题" class="headerlink" title="联通问题"></a>联通问题</h5><p>​    联通在记事本中打开为乱码。解码出了问题。因为联通写入记事本，默认的是使用UTF-8存入，解码的时候也使用UTF-8。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	String str = <span class="string">"联通"</span>;</span><br><span class="line">	<span class="comment">//联通的GBK编码与UTF-8的编码规则相冲突。</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 11000001</span></span><br><span class="line"><span class="comment">	 * 10101010</span></span><br><span class="line"><span class="comment">	 * 11001101</span></span><br><span class="line"><span class="comment">	 * 10101000</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">byte</span>[] buf = str.getBytes();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">byte</span> b:buf)</span><br><span class="line">		System.out.println(Integer.toBinaryString(b&amp;<span class="number">255</span>));<span class="comment">//取单字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="网络模型概述"><a href="#网络模型概述" class="headerlink" title="网络模型概述"></a>网络模型概述</h4><p>OSI（Open System Interconnection开放系统互联）参考模型</p>
<p>TCP/IP模型</p>
<p>七层模型</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC26%E5%A4%A91.png" class title="This is an example image">

<p><strong>1层物理层</strong>：主要定义物理设备标准，如<strong>网线</strong>的接口类型、光纤的接口类型、各种<strong>传输介质</strong>的传输速率等。它的主要作用是<strong>传输比特流</strong>（就是1、0转化为电流强弱来进行传输，到大目的后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做<strong>比特</strong>。</p>
<p><strong>2层数据链路层</strong>：主要将从物理层接收的数据进行<strong>MAC地址</strong>（网卡的地址，每个网卡<strong>唯一</strong>）的封装与解封装。常把这一层的数据叫做<strong>帧</strong>。这一层工作的设备是<strong>交换机</strong>（实现互联），数据通过交换机来传输。</p>
<p><strong>3层网络层</strong>：主要将从下层接收到的数据进行<strong>IP地址</strong>（例192.168.0.1）的封装与解封装。看数据到底发向哪一台主机。在这一层工作的设备是<strong>路由器</strong>（数据包方向的定义），常把这一层的数据叫做<strong>数据包</strong>。</p>
<p><strong>4层传输层</strong>：定义了一些传输数据的<strong>协议</strong>和<strong>端口号</strong>（WWW端口80等），如：<strong>TCP</strong>（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），<strong>UDP</strong>（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做<strong>段</strong>。</p>
<p><strong>5会话层</strong>：通过传输层（端口号：传输端口与接收端口）<strong>建立数据传输的通路</strong>。主要在你的系统之间发起会话或者接收会话请求（设备之间需要互相认识，可以使IP也可以是MAC或者是主机名）</p>
<p><strong>6表示层</strong>：主要是进行对接收的数据进行<strong>解释</strong>、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转成人能识别的东西（如图片、声音等））。</p>
<p><strong>7应用层</strong>：主要是一些<strong>终端的应用</strong>（应用软件），比如FTP（各种文件下载），WEB（IE浏览），QQ之类的（可以把它理解成我们在电脑屏幕上可以看到的东西，就是终端应用）。</p>
<p>对数据加上每一层的标识，便于解析。逐层包装标识（<strong>封包</strong>），逐层解析（<strong>拆包</strong>）。</p>
<p>七层模型过于繁琐，因此有了TCP/IP参考模型。</p>
<p>1主机至网络层：物理层+数据链路层。（交换机为一部分）</p>
<p>2<strong>网际层</strong>：网络层</p>
<p>3<strong>传输层</strong>：原传输层（<strong>重要</strong>）</p>
<p>5   应用层：会话层+表示层+应用层。（Java Web开发）</p>
<h4 id="网络通讯要素"><a href="#网络通讯要素" class="headerlink" title="网络通讯要素"></a>网络通讯要素</h4><p>​    IP地址</p>
<p>​    端口号</p>
<p>​    传输协议</p>
<h5 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h5><p>​    IPV4：有4段，一段的最大值为一个Byte，即2^8，0-255。最大值为255。</p>
<p>​    IPV6：融入了字母。因为地址够用，因此很多设备都可以拥有独立的IP地址，物联网的时代。</p>
<p>IP地址：<strong>InetAddress</strong></p>
<p>​    网络中设备的表示</p>
<p>​    不易记忆，可用主机名</p>
<p>​    本地回环地址：127.0.0.1 主机名：localhost 用于在没有互联网时<strong>本机访问本机</strong>。如果ping本机地址有问题，网卡可能出问题了。<strong>测试网卡</strong>。</p>
<h5 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a><strong>InetAddress</strong></h5><p>​    存在于网际层。</p>
<p>​    可以通过主机名称或者主机地址字符串获得ip对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取本地主机IP地址对象</span></span><br><span class="line">		InetAddress ip = InetAddress.getLocalHost();</span><br><span class="line">		<span class="comment">//获取其他主机的IP地址对象</span></span><br><span class="line">		ip = InetAddress.getByName(<span class="string">"172.21.21.196"</span>);</span><br><span class="line">		ip = InetAddress.getByName(<span class="string">"DESKTOP-L0U8999"</span>);</span><br><span class="line">		ip = InetAddress.getByName(<span class="string">"www.baidu.com"</span>);</span><br><span class="line">		<span class="comment">//获取IP地址更多</span></span><br><span class="line">		System.out.println(ip.getHostAddress());</span><br><span class="line">		System.out.println(ip.getHostName());</span><br></pre></td></tr></table></figure>

<p>IP地址太多记不住，给主机命名，记住名字即可。</p>
<p>com一般属于商业化组织，营利性；org属于非营利性。</p>
<p>cn标识所属国家类别。</p>
<p>IP地址与名字有对应关系，互联网上公共的服务器中存放着IP地址和名称的对应关系。叫做<strong>域名解析DNS</strong>，机器叫域名解析服务器（记住了IP地址）。不指定DNS解析地址，宽带服务商解析，信息发给他，他再发给DNS服务器。</p>
<p>  现在一个IP地址可能分配给多台主机使用。</p>
<p>  如果想提高解析速度，可以在本机中创建域名解析列表。即<strong>host</strong>文件，本地域名解析列表。域名解析最先走的为本地解析列表，如果解析失败再走互联网的解析。自己可以创建对应名称来访问本机，其他人使用此host文件中的域名或地址无法访问到本主机，因为其机器上没有此列表。如果想在局域网中所有人都可以使用此解析列表，可以在某台主机上使用DNS解析软件，然后其他主机的DNS解析地址指向此主机即可。</p>
<p>  如果想屏蔽某些网站，可以将其域名与本地ip地址127.0.0.1关联，这样可以屏蔽公共解析，指向本地解析。</p>
<p>IP地址：192.168.1.1</p>
<p>子网掩码：255.255.255.0</p>
<p>子网掩码前3个均为255，代码IP地址前三位均为网络位，最后一位为IP地址位。从0-255,0代表网络位，不可用，因此1-254可用，255不属于IP地址而是广播地址。如果发到192.168.1.255，代表把消息发到192.168.1.0网络上所有存活的机器上。</p>
<h5 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h5><p>逻辑端口，给应用程序分配数字标识。</p>
<p>​    用于标识进程的逻辑地址，不同进程的标识。</p>
<p>​    有效端口：0<del>65535（2^16），其中0</del>1024系统使用或保留端口。</p>
<p>禁用端口：可以防止某些应用程序禁用互联网。</p>
<h5 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h5><p>​    通讯规则</p>
<p>​    常见协议：TCP，UDP</p>
<p>UDP</p>
<p>数据报文协议</p>
<p>​    将数据及源和目的封装成数据包中，<strong>不需要建立连接</strong></p>
<p>​    每个数据报的大小限制在<strong>64k</strong>内</p>
<p>​    因无连接，是<strong>不可靠</strong>协议</p>
<p>​    不需要建立连接，<strong>速度快</strong></p>
<p>如QQ聊天，视频通讯。</p>
<p>TCP</p>
<p>传输控制协议。</p>
<p>​    建立连接，形成传输数据的通道</p>
<p>​    在连接中进行<strong>大数据量</strong>传输</p>
<p>​    通过<strong>三次握手</strong>完成连接，是可靠协议</p>
<p>​    必须建立连接，<strong>效率会稍低</strong></p>
<p>下载数据</p>
<h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p>插座，套接字</p>
<p>socket就是为网络服务提供的一种机制</p>
<p>通信的两端都有Socket</p>
<p>网络通信其实就是Socket间的通信</p>
<p>数据在两个Socket间通过IO传输。</p>
<h4 id="UDP传输"><a href="#UDP传输" class="headerlink" title="UDP传输"></a>UDP传输</h4><ul>
<li><p>DatagramSocket与DatagramPacket</p>
</li>
<li><p>建立发送端，接收端</p>
</li>
<li><p>建立数据包</p>
</li>
<li><p>调用Socket的发送接收方法</p>
</li>
<li><p>关闭Socket</p>
</li>
</ul>
<p>发送端与接收端是两个独立的运行程序</p>
<p>DtagramSocket：表示用于<strong>发送</strong>和<strong>接收</strong>数据报包的套接字。</p>
<p>​    可以直接new对象，有发送和接收数据包的方法。</p>
<p>DatagramPacket：表示数据报包数据报包实现无连接包投递服务。不对包投递做出保障。</p>
<p>​    构造时有的是发送的，有的是接收的。发送的数据包有目的地址，接收不需要。带有IP对象的均为用来发送的。发送多接收少。</p>
<p>UDP发送端与接收端哪个先连接都可以。</p>
<p>发送端指定的端口为接收端的端口，而接收端获取的端口为发送端的端口。</p>
<p>发送端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 创建UDP传输的发送端</span></span><br><span class="line"><span class="comment">		 * 思路：</span></span><br><span class="line"><span class="comment">		 * 1，建立UDP的Socket服务。</span></span><br><span class="line"><span class="comment">		 * 2，将要发送的数据封装到数据包中。</span></span><br><span class="line"><span class="comment">		 * 3，通过UDP的Socket服务将数据包发送出去</span></span><br><span class="line"><span class="comment">		 * 4，关闭Socket服务。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//1，UDP的Socket服务。使用DatagramSocket对象。</span></span><br><span class="line">		DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">8888</span>);<span class="comment">//明确发送端的端口号</span></span><br><span class="line">		<span class="comment">//2，将要发送的数据封装到数据包中。</span></span><br><span class="line">		String str = <span class="string">"中午吃什么？"</span>;</span><br><span class="line">			<span class="comment">//使用DatagramPacket将数据封装到该对象包中</span></span><br><span class="line">		<span class="keyword">byte</span>[] buf = str.getBytes();</span><br><span class="line">		<span class="comment">//将地址改为接收端的IP地址即可</span></span><br><span class="line">		DatagramPacket dp =</span><br><span class="line">				<span class="keyword">new</span> DatagramPacket(buf, buf.length, InetAddress.getLocalHost(), <span class="number">10000</span>);</span><br><span class="line">		<span class="comment">//3，通过UDP的Socket服务将数据包发送出去，使用send方法。</span></span><br><span class="line">		ds.send(dp);</span><br><span class="line">		<span class="comment">//4，关闭资源</span></span><br><span class="line">		ds.close();</span><br></pre></td></tr></table></figure>

<p>接收端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 建立UDP接收端的思路。</span></span><br><span class="line"><span class="comment">		 * 1，建立UDP的Socket服务，因为是要接收数据，必须要明确一个端口号。</span></span><br><span class="line"><span class="comment">		 * 2，创建数据包，用于存储接收到的数据。方便用数据包对象的方法解析这些数据。</span></span><br><span class="line"><span class="comment">		 * 3，使用Socket服务的receive方法将接收到的数据存储到数据包中。</span></span><br><span class="line"><span class="comment">		 * 4，通过数据包的方法解析数据包中的数据。</span></span><br><span class="line"><span class="comment">		 * 5，关闭资源。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//1，建立UDP的Socket服务</span></span><br><span class="line">		DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">10000</span>);<span class="comment">//明确接收的端口号</span></span><br><span class="line">		<span class="comment">//2，创建数据包</span></span><br><span class="line">		<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line">		<span class="comment">//3，使用接收方法将数据存储到数据包中</span></span><br><span class="line">		ds.receive(dp);<span class="comment">//阻塞式的。</span></span><br><span class="line">		<span class="comment">//4，通过数据包对象的方法，解析其中的数据，比如，地址，端口，数据内容。</span></span><br><span class="line">		String ip = dp.getAddress().getHostAddress();<span class="comment">//IP地址对象的字符串表示</span></span><br><span class="line">		<span class="keyword">int</span> port = dp.getPort();<span class="comment">//获得端口，发送端的端口</span></span><br><span class="line">		String text = <span class="keyword">new</span> String(dp.getData(),<span class="number">0</span>,dp.getLength());<span class="comment">//只取有效数据</span></span><br><span class="line">		System.out.println(ip+<span class="string">":"</span>+port+<span class="string">":"</span>+text);</span><br><span class="line">		<span class="comment">//5，关闭资源</span></span><br><span class="line">		ds.close();</span><br></pre></td></tr></table></figure>

<h4 id="TCP传输"><a href="#TCP传输" class="headerlink" title="TCP传输"></a>TCP传输</h4><ul>
<li><p>Socket和ServerSocket</p>
</li>
<li><p>建立客户端和服务器端</p>
</li>
<li><p>建立连接后，通过Socket中的IO流进行数据的传输</p>
</li>
<li><p>关闭Socket</p>
</li>
</ul>
<p>同样，客户端与服务器端是两个独立的应用程序。</p>
<p>Socket类实现客户端套接字。ServerSocket类实现服务器套接字。</p>
<p>客户端向服务端发送信息建立通道，通道建立后服务器端向客户端发送信息。</p>
<p>客户端一般初始化时要指定对方的IP地址和端口，IP地址可以是IP对象，也可以是IP对象字符串表现形式。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC26%E5%A4%A92.png" class title="This is an example image">

<p>建立通道后，信息传输通过Socket流，为底层建立好的，又有输入和输出，想要获取输入或输出流对象，找Socket来获取。为字节流。getInputStream()和getOutputStream()方法来获取输入流和输出流。</p>
<p>  服务端获取到客户端Socket对象，通过其对象与Cilent进行通讯。</p>
<p>  客户端的输出对应服务端的输入，服务端的输出对应客户端的输入。</p>
<p>  TCP必须<strong>先开服务端</strong>。</p>
<p>  如果名称为out,in的视为Socket流，如果不是就是一般流。</p>
<p>  tcp使用的时候可能会出现两端都在等待的情况，原因可能是数据没有发送出去。最大原因在于有阻塞式方法。</p>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端发数据到服务端</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * TCP传输，客户端建立的过程</span></span><br><span class="line"><span class="comment">		 * 1，创建TCP客户端Socket服务，使用的是Socket对象。</span></span><br><span class="line"><span class="comment">		 * 		建议该对象一创建就明确目的地。要连接的主机。</span></span><br><span class="line"><span class="comment">		 * 2，如果连接建立成功，说明数据传输通道已建立。</span></span><br><span class="line"><span class="comment">		 * 		该通道就是Socket流，是底层建立好的。既然是流，说明这里既有输入，又有输出。</span></span><br><span class="line"><span class="comment">		 * 		想要输入或者输出流对象，可以找Socket来获取。</span></span><br><span class="line"><span class="comment">		 * 		可以通过getInputStream()和getOutputStream()方法来获取两个字节流。</span></span><br><span class="line"><span class="comment">		 * 3，使用输出流，将数据写出。</span></span><br><span class="line"><span class="comment">		 * 4，关闭资源。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//创建客户端Socket服务</span></span><br><span class="line">		Socket socket = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(), <span class="number">10002</span>);</span><br><span class="line">		<span class="comment">//获取Socket流中的输出流</span></span><br><span class="line">		OutputStream out = socket.getOutputStream();</span><br><span class="line">		<span class="comment">//使用输出流，将指定的输出写出去</span></span><br><span class="line">		out.write(<span class="string">"TCP演示，哥们又来了！"</span>.getBytes());</span><br><span class="line">		<span class="comment">//关闭资源</span></span><br><span class="line">		socket.close();</span><br></pre></td></tr></table></figure>

<p><strong>服务端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务端接收客户端发送过来的数据，并打印在控制台上。</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 建立TCP服务端的思路</span></span><br><span class="line"><span class="comment">		 * 1，创建服务端Socket服务，通过ServerSocket对象。</span></span><br><span class="line"><span class="comment">		 * 2，服务端必须对外提供一个端口，否则客户端无法连接。</span></span><br><span class="line"><span class="comment">		 * 3，获取连接过来的客户端对象。</span></span><br><span class="line"><span class="comment">		 * 4，通过客户端对象获取Socket流，读取客户端发来的数据。</span></span><br><span class="line"><span class="comment">		 * 5，关闭资源。关客户端，关服务端。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//1，创建服务端对象</span></span><br><span class="line">		ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">10002</span>);</span><br><span class="line">		<span class="comment">//2，获取连接过来的客户端对象</span></span><br><span class="line">		Socket s = ss.accept();<span class="comment">//阻塞式</span></span><br><span class="line">		String ip = s.getInetAddress().getHostAddress();<span class="comment">//获取IP地址</span></span><br><span class="line">		<span class="comment">//3，通过Socket对象获取输入流，要读取客户端发来的数据</span></span><br><span class="line">		InputStream in = s.getInputStream();</span><br><span class="line">		<span class="comment">//读取数据，自定义缓冲区</span></span><br><span class="line">		<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len = in.read(buf);</span><br><span class="line">		String text = <span class="keyword">new</span> String(buf, <span class="number">0</span>, len);</span><br><span class="line">		System.out.println(ip+<span class="string">":"</span>+text);</span><br><span class="line">		<span class="comment">//关闭客户端</span></span><br><span class="line">		s.close();</span><br><span class="line">		ss.close();<span class="comment">//一般服务器端不关闭</span></span><br></pre></td></tr></table></figure>

<p><strong>服务端与客户端交互</strong></p>
<p>服务器接收到数据后，利用客户端的Socket对象的输出流写入数据，客户端利用Socket流的输入流进行数据接收。</p>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取服务端返回的数据，使用Socket读取流。</span></span><br><span class="line">		InputStream in = socket.getInputStream();</span><br><span class="line">		<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len = in.read(buf);</span><br><span class="line">		String text = <span class="keyword">new</span> String(buf, <span class="number">0</span>, len);</span><br><span class="line">		System.out.println(<span class="string">"客户端收到反馈:"</span>+text);</span><br></pre></td></tr></table></figure>

<p><strong>服务端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用客户端Socket对象的输出流给客户端返回数据</span></span><br><span class="line">		OutputStream out = s.getOutputStream();</span><br><span class="line">		out.write(<span class="string">"收到"</span>.getBytes());</span><br></pre></td></tr></table></figure>

<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC27%E5%A4%A91.png" class title="This is an example image">

<p>服务器端原理，<strong>并发访问</strong>，只有一个端口对外提供，当进来一个客户端Socket，阻塞，新建线程去执行，线程任务就是读写操作。然后再进来一个客户端，再利用新线程去执行，为了避免线程过多，一个线程结束后就结束线程。把连接进来的客户端封装在线程中。</p>
<h4 id="常见客户端与服务端"><a href="#常见客户端与服务端" class="headerlink" title="常见客户端与服务端"></a>常见客户端与服务端</h4><p>最常见客户端：</p>
<p>​    浏览器：IE。</p>
<p>最常见的服务器：</p>
<p>​    服务器：Tomcat。</p>
<p>http：应用层协议，超文本传输控制协议。文字带颜色，大小，图片带声音。使用语言为html。</p>
<p>定义了web浏览器与服务器的通信规则。浏览器中有解析http协议的解析引擎。</p>
<p>FTP：文件传输协议</p>
<p>Web服务器默认端口：80</p>
<p>Tomcat服务器对外提供接口。interface <strong>Servlet</strong>。必须直接或间接实现。Tomcat对外提供Web资源访问。</p>
<p>访问服务器：http://主机名:8080/myweb</p>
<p>​    会自动去webapps下去寻找。</p>
<p>​    服务器必须对外提供可访问资源，即Web应用程序。webapps下存放的为web资源。</p>
<h4 id="客户端和服务端原理"><a href="#客户端和服务端原理" class="headerlink" title="客户端和服务端原理"></a>客户端和服务端原理</h4><p>了解原理：</p>
<p>1， 自定义服务端，使用已有的客户端IE，了解一下客户端给服务器端发了什么请求。</p>
<p>发送的请求是</p>
<p>GET / HTTP/1.1 <strong>请求行</strong> <strong>请求方式 /myweb/1,html 请求的资源路径 http协议版本(1.0或者1.1,1.1更常用)请求方式包括GET,POST</strong></p>
<p><strong>请求消息头</strong> <strong>属性名：属性值（键值对）</strong></p>
<p>Accept: </p>
<p><strong>服务器可以支持的app</strong></p>
<p>text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8</p>
<p><strong>支持的语言</strong></p>
<p>Accept-Language: zh-Hans-CN,zh-Hans;q=0.8,en-US;q=0.5,en;q=0.3</p>
<p>Upgrade-Insecure-Requests: 1</p>
<p><strong>用户信息，系统版本</strong></p>
<p>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36 Edge/18.17763</p>
<p><strong>支持的压缩方式，服务器发送信息时将信息压缩，客户端解压缩</strong></p>
<p>Accept-Encoding: gzip, deflate</p>
<p><strong>访问的主机</strong></p>
<p>Host: 127.0.0.1:9090</p>
<p>Connection: Keep-Alive</p>
<p>请求头和请求体之间有<strong>空行</strong></p>
<p>请求体：可能会有注册信息等。</p>
<p>2， 自定义浏览器</p>
<p>服务端发回应答消息</p>
<p>HTTP/1.1 403 Forbidden <strong>应答行</strong>，http的协议版本 <strong>应答状态码</strong> 应答状态<strong>描述信息</strong></p>
<p><strong>200</strong>代表成功，描述信息OK  <strong>404</strong> not found 找不到页面 </p>
<p><strong>应答消息属性信息</strong>。属性名：属性值</p>
<p>Server: bfe</p>
<p>Date: Tue, 05 Mar 2019 15:26:23 GMT</p>
<p><strong>最后修改时间</strong>，带着信息访问，如果修改日期一致本地缓存界面与服务器端一样，发新的状态码。</p>
<p>Last-Modified:一堆日期</p>
<p><strong>发送字节数</strong></p>
<p>Content-Length: 0</p>
<p><strong>收到数据类型</strong></p>
<p>Content-Type: text/plain; charset=utf-8</p>
<p>Connection: close</p>
<p>//有一行空行</p>
<p><strong>应答体</strong></p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC27%E5%A4%A92.png" class title="This is an example image">

<p>处理请求并给予应答。</p>
<p>可以网页输入http://主机名:指定端口号，即可以访问自定义的服务端。</p>
<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>协议解析对象</p>
<p>​    浏览器向服务器发送<strong>http请求信息</strong>，然后浏览器发送<strong>应答消息头</strong>和应答体。浏览器中只显示应答体，而应答消息头被浏览器解析引擎解析。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC27%E5%A4%A93.png" class title="This is an example image">

<p>可以使用URL对象对应答消息头进行解析。URL底层挂的是URLConnection</p>
<p>​    类URL代表一个<strong>统一资源定位符</strong>，是指向互联网“资源”的<strong>指针</strong>。资源可以是简单的文件或目录，也可以是对更为复杂的对象的引用，例如对数据库或搜索引擎的查询。</p>
<p>​    URI<strong>统一资源标识符引用</strong>。</p>
<p>​    每个URL都是URI，但不一定每个URI都是URL。URI还包括个子类URN，统一资源名称。mailto、news和isbnURI都是URN的示例。</p>
<p>​    URL对象可以直接解析URL地址。getProtocol()，获取协议。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取信息</span></span><br><span class="line">		System.out.println(url.getProtocol());<span class="comment">//协议</span></span><br><span class="line">		System.out.println(url.getHost());<span class="comment">//主机</span></span><br><span class="line">		System.out.println(url.getPort());<span class="comment">//端口</span></span><br><span class="line">		System.out.println(url.getFile());<span class="comment">//文件名，会带有name参数</span></span><br><span class="line">		System.out.println(url.getPath());<span class="comment">//路径，只负责到文件</span></span><br><span class="line">		System.out.println(url.getQuery());<span class="comment">//参数信息，？后的部分</span></span><br></pre></td></tr></table></figure>

<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC27%E5%A4%A94.png" class title="This is an example image">

<p>InputStream openStream()<strong>打开此URL的连接</strong>并返回一个用于从该连接<strong>读入的InputStream</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只输出应答体，不输出应答消息头</span></span><br><span class="line">		InputStream in = url.openStream();</span><br><span class="line">		<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len = in.read(buf);</span><br><span class="line">		String text = <span class="keyword">new</span> String(buf, <span class="number">0</span>, len);</span><br><span class="line">		System.out.println(text);</span><br><span class="line">		in.close();</span><br><span class="line">		<span class="comment">//URL不用关闭</span></span><br></pre></td></tr></table></figure>

<p>其中openStream()底层使用的是openConnection().getInputStream()</p>
<h4 id="URLConnection"><a href="#URLConnection" class="headerlink" title="URLConnection"></a>URLConnection</h4><p>URL连接器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取url对象的URL连接器，将连接封装成了对象：java中内置的可以解析的具体协议的对象+socket</span></span><br><span class="line">		URLConnection conn = url.openConnection();</span><br></pre></td></tr></table></figure>

<p>conn打印结果如下</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC27%E5%A4%A95.png" class title="This is an example image">

<p>​    前面http地址为http底层实现。</p>
<p>String <strong>getHeaderField</strong>(String ) 获取相关属性，</p>
<p>如使用String value = conn. getHeaderField(“Content-Type”)，获取内容类型，然后用相关的解析器去解析。</p>
<p>可以获取输入和输出流，因此相当于使用了Socket，但是加入了协议。</p>
<p>URL中openStream原理为先获取连接，然后获取流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取url对象的URL连接器，将连接封装成了对象</span></span><br><span class="line">		URLConnection conn = url.openConnection();</span><br><span class="line">		InputStream in = conn.getInputStream();</span><br></pre></td></tr></table></figure>

<p>因此以后浏览器就不用使用Socket，而是使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str_url = <span class="keyword">new</span> String(<span class="string">"http://192.168.1.100:8080/myweb/1.html?name=lisi"</span>);</span><br><span class="line">		URL url = <span class="keyword">new</span> URL(str_url);<span class="comment">//抛出无法解析URL</span></span><br><span class="line">		<span class="comment">//只输出应答体，不输出应答消息头</span></span><br><span class="line">		InputStream in = url.openStream();</span><br></pre></td></tr></table></figure>

<h4 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h4><p>1，C/S      Client/Server</p>
<p>​    特点：</p>
<p>该结构的软件，客户端和服务端都需要编写。</p>
<p>​        开发成本较高，维护较为麻烦。</p>
<p>​        可能会出现版本差异</p>
<p>​    好处：</p>
<p>​       客户端在本地可以分担一部分运算。</p>
<p>网络游戏就是客户端，因为很多数据存储在本地，位置坐标实时与主机交换。</p>
<p>2，B/S      Browser/Server</p>
<p>​    特点：</p>
<p>​        该结构的软件，只开发服务器端，不开发客户端，因为客户端直接由浏览器取代。</p>
<p>​        开发成本相对低，维护更为简单。</p>
<p>​    缺点：</p>
<p>​       所有运算都在服务器端完成。</p>
<hr>
<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><h4 id="概述与应用场景"><a href="#概述与应用场景" class="headerlink" title="概述与应用场景"></a>概述与应用场景</h4><p>反射中涉及到的对象均在java.lang.reflect包中。Constructoe,Filed,Method。</p>
<p>​    AccessibleObject类是Field、Method、和Constructor对象的基类。它提供了将反射的对象标记为在使用时取消Java语言访问控制检查的能力。</p>
<p>java反射机制是在运行状态中，对于任意一个类(class文件)，都能够知道这个类的所有属性和方法；</p>
<p>对于任意一个对象，都能够调用它的任意一个方法和属性。</p>
<p>这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p><strong>动态获取类中信息</strong>，就是java的反射机制。</p>
<p>可以理解为对类的解剖。</p>
<p>软件的功能扩展利用对外提供接口实现。</p>
<p>​    一个类实现了软件对外暴露的接口，会在程序的配置文件中写入，程序读取此配置文件，会去寻找接口实现类的class文件。如果找到则加载此文件，并获取该文件里所有内容。拿到字节码文件就可以新建对象，因为其中有构造函数。</p>
<p>​    如果想要对指定名称的字节码文件加载并获取其中的内容并调用。</p>
<p>实现方法：这时使用到了<strong>反射</strong>技术。</p>
<p>优点：极大的提高了程序的扩展性。</p>
<p>Tomcat提供的接口为Servlet，服务器端脚本程序片段。将实现接口的类名称写入配置文件，软件便可以动态加载此类中的内容。利用的是反射技术。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC28%E5%A4%A91.png" class title="This is an example image">

<p>​    需要<strong>接口</strong>+<strong>配置文件</strong>。</p>
<p>​    学习框架：框架作用，配置文件怎么用，常用对象的用法。</p>
<p>​    反射技术提高了扩展技术，用起来简单（用户只面对配置文件）。</p>
<h4 id="细节和Class对象"><a href="#细节和Class对象" class="headerlink" title="细节和Class对象"></a>细节和Class对象</h4><p>​    传参通过配合文件完成。</p>
<p>​    拿到类以后，获取指定类中的信息。</p>
<p>​    反射的过程：由Class类来完成</p>
<p>Class类用来表述二进制字节码文件。可以new对象，提供获取到字节码文件中的内容，如名称、字段、构造函数、一般函数。该类就可以获得字节码文件中的<strong>所有内容</strong>。反射就是依靠该类来完成的。</p>
<p>​    想要对一个类文件进行解剖，只要获取到该类的<strong>字节码文件对象</strong>即可。</p>
<h4 id="获取Class对象的三种方式"><a href="#获取Class对象的三种方式" class="headerlink" title="获取Class对象的三种方式"></a>获取Class对象的三种方式</h4><p>要想对字节码文件进行解剖，必须要有字节码文件对象。如何获取其对象？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 获取字节码对象的方式：</span></span><br><span class="line"><span class="comment">	 * 方式一，Object中的getClass()方法</span></span><br><span class="line"><span class="comment">	 * 想要用这种方式必须要明确具体的类并创建对象。</span></span><br><span class="line"><span class="comment">	 * 麻烦！！！</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">		Person p = <span class="keyword">new</span> Person();</span><br><span class="line">		Class clazz = p.getClass();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 方式二：</span></span><br><span class="line"><span class="comment">	 * 	任何数据类型都具备一个静态的属性.class来获取其对应的Class对象</span></span><br><span class="line"><span class="comment">	 * 相对简单，但是还是要明确用到类中的静态成员</span></span><br><span class="line"><span class="comment">	 * 还是不够扩展</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">		Class clazz = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 方式三：</span></span><br><span class="line"><span class="comment">	 * 只要通过给定的类的字符串名称就可以获取该类，更为扩展</span></span><br><span class="line"><span class="comment">	 * 可以用Class类中的方法完成</span></span><br><span class="line"><span class="comment">	 * 该方法就是forName()</span></span><br><span class="line"><span class="comment">	 * 这种方式只要有名称即可，更为方便，扩展性更强</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">		<span class="comment">//需要带着包名</span></span><br><span class="line">		String className = <span class="string">"cn.zc.bean.Person"</span>;</span><br><span class="line">		Class clazz = Class.forName(className);</span><br></pre></td></tr></table></figure>

<h4 id="获取Class中的构造函数"><a href="#获取Class中的构造函数" class="headerlink" title="获取Class中的构造函数"></a>获取Class中的构造函数</h4><p>获得空参的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//早期：new的时候，先根据被new的类的名称找寻该类的字节码文件，并加载进内存，</span></span><br><span class="line">		<span class="comment">//	  并创建该字节码文件对象，并接着创建该字节文件的对应的Person对象 </span></span><br><span class="line"><span class="comment">//		cn.zc.bean.Person p = new cn.zc.bean.Person();</span></span><br><span class="line">		<span class="comment">//现在：</span></span><br><span class="line">		String name = <span class="string">"cn.zc.bean.Person"</span>;</span><br><span class="line">		<span class="comment">//找寻该名称类文件，并加载进内存，并产生Class对象</span></span><br><span class="line">		Class clazz = Class.forName(name);</span><br><span class="line">		<span class="comment">//如何产生该类的对象呢？</span></span><br><span class="line">		<span class="comment">//如果没有public公共构造函数，会出错。</span></span><br><span class="line">		<span class="comment">//如果是private构造函数，则不能访问，报错。</span></span><br><span class="line">		Object obj = clazz.newInstance();</span><br></pre></td></tr></table></figure>

<p>如果想要获得要输入参数的对象，则要获取构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//		cn.zc.bean.Person p = new cn.zc.bean.Person("小强", 39);</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 当获取指定名称对应的类中所体现的对象时，</span></span><br><span class="line"><span class="comment">		 * 而该对象初始化不使用空参数构造函数该怎么办？</span></span><br><span class="line"><span class="comment">		 * 既然是通过指定的构造函数进行对象的初始化，</span></span><br><span class="line"><span class="comment">		 * 所以应该先获取到该构造函数。通过字节码文件对象即可完成。</span></span><br><span class="line"><span class="comment">		 * 该方法是getConstructor(...parameterTypes)</span></span><br><span class="line"><span class="comment">		 * 获取到所有的公有构造函数</span></span><br><span class="line"><span class="comment">		 * getDeclaredConstructors获取所有权限的构造函数</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		String name = <span class="string">"cn.zc.bean.Person"</span>;</span><br><span class="line">		<span class="comment">//找寻该名称类文件，并加载进内存，并产生Class对象</span></span><br><span class="line">		Class clazz = Class.forName(name);</span><br><span class="line">		<span class="comment">//传进参数类型对应的class</span></span><br><span class="line">		Constructor constructor = clazz.getConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">		<span class="comment">//通过该构造器对象的newInstance方法进行对象的初始化</span></span><br><span class="line">		Object obj = constructor.newInstance(<span class="string">"小明"</span>,<span class="number">38</span>);</span><br></pre></td></tr></table></figure>

<h4 id="获取Class中的字段"><a href="#获取Class中的字段" class="headerlink" title="获取Class中的字段"></a>获取Class中的字段</h4><p>如果字段是私有的，则不能直接访问，需要先取消权限检查，称为暴力访问，不建议使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取字节码文件中的字段</span></span><br><span class="line"><span class="comment"> * 直接get加对应的，获得的均为公共的</span></span><br><span class="line"><span class="comment"> * 如果是所有的则是Declared。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getFieldDemo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Class clazz = Class.forName(<span class="string">"cn.zc.bean.Person"</span>);</span><br><span class="line">	Field field = <span class="keyword">null</span>;<span class="comment">//clazz.getField("age");//只能获取公有的，包含父类</span></span><br><span class="line">	field = clazz.getDeclaredField(<span class="string">"age"</span>);<span class="comment">//只获取本类，但包含私有</span></span><br><span class="line">	<span class="comment">//对私有字段的访问取消权限检查。暴力访问。</span></span><br><span class="line">	field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">	Object obj = clazz.newInstance();</span><br><span class="line">	field.set(obj, <span class="number">89</span>);<span class="comment">//设置字段的值</span></span><br><span class="line">	Object o = field.get(obj);<span class="comment">//属性要被对象调用//如果不改权限，无效访问异常，因为是私有的</span></span><br><span class="line">	System.out.println(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取Class中的方法"><a href="#获取Class中的方法" class="headerlink" title="获取Class中的方法"></a>获取Class中的方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 获取指定Class中的所有公共函数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMethodDemo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class clazz = Class.forName(<span class="string">"cn.zc.bean.Person"</span>);</span><br><span class="line">		Method[] methods = clazz.getMethods();<span class="comment">//获取的都是公有的方法，包含父类</span></span><br><span class="line">		methods = clazz.getDeclaredMethods();<span class="comment">//只获取本类中所有方法，包含私有</span></span><br><span class="line">		<span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">			System.out.println(method);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//获取指定的不带参数方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMethodDemo_2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class clazz = Class.forName(<span class="string">"cn.zc.bean.Person"</span>);</span><br><span class="line">		<span class="comment">//必须指定方法名和列表	</span></span><br><span class="line">		Method method = clazz.getMethod(<span class="string">"show"</span>, <span class="keyword">null</span>);<span class="comment">//获取空参数一般方法</span></span><br><span class="line"><span class="comment">//		Object obj = clazz.newInstance();//获取空参数对象</span></span><br><span class="line">		<span class="comment">//获取有参数的对象</span></span><br><span class="line">		Constructor constructor = clazz.getConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">		Object obj = constructor.newInstance(<span class="string">"小明"</span>,<span class="number">37</span>);</span><br><span class="line">		method.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">		Field field = clazz.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line">		field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">		System.out.println(field.get(obj));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取指定的带参数方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMethodDemo_3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class clazz = Class.forName(<span class="string">"cn.zc.bean.Person"</span>);</span><br><span class="line">		<span class="comment">//必须指定方法名和列表	</span></span><br><span class="line">		Method method = clazz.getMethod(<span class="string">"paraMethod"</span>, String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;<span class="comment">//获取空参数一般方法</span></span><br><span class="line">		Object obj = clazz.newInstance();</span><br><span class="line">		method.invoke(obj, <span class="string">"小强"</span>,<span class="number">89</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="反射演示"><a href="#反射演示" class="headerlink" title="反射演示"></a>反射演示</h4><p>  想要不修改主函数，只通过修改配置文件来让不同的设备运行。程序要对外暴露一个接口PCI，要实现开和关的方法，设备要实现此接口。</p>
<p>  关键：对外暴露接口，加载配置文件，新功能实现此接口，获取到Class对应的对象，将此接口对象传入相应的方法，其他的就很简单了。</p>
<p>思路：</p>
<p>1、 将配置文件关联到文件对象，新建Properties对象，新建流将文件中数据load进Properties中。</p>
<p>2、 遍历键值对，逐个获取到类名。根据类名获取到Class文件</p>
<p>3、 因为所有的设备对象都实现了PCI接口，因此可以利用Class获取到的空参对象强转为PCI类型</p>
<p>4、 将此PCI设备传进主板的使用PCI方法，即可。将流关闭</p>
<p>主函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Mainboard mb = <span class="keyword">new</span> Mainboard();</span><br><span class="line">		mb.run();</span><br><span class="line">		<span class="comment">//每次添加一个设备都需要修改代码传递一个新创建的对象</span></span><br><span class="line"><span class="comment">//		mb.usePCI(new SoundCard());</span></span><br><span class="line">		<span class="comment">//能不能不修改代码就可以完成这个动作</span></span><br><span class="line">		<span class="comment">//不用new来完成，而是直接获取其Class文件，在内部实现创建对象的动作</span></span><br><span class="line">		File configFile = <span class="keyword">new</span> File(<span class="string">"pci.properties"</span>);</span><br><span class="line">		Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">		FileInputStream fis = <span class="keyword">new</span> FileInputStream(configFile);</span><br><span class="line">		prop.load(fis);<span class="comment">//把流中的数据加载到键值对中</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;prop.size();x++)&#123;</span><br><span class="line">			String pciName = prop.getProperty(<span class="string">"pci"</span>+(x+<span class="number">1</span>));</span><br><span class="line">			Class clazz = Class.forName(pciName);<span class="comment">//用Class去加载这个pci子类</span></span><br><span class="line">			PCI p = (PCI)clazz.newInstance();<span class="comment">//要有空参构造参数</span></span><br><span class="line">			mb.usePCI(p);</span><br><span class="line">		&#125;</span><br><span class="line">		fis.close();		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置文件</strong></p>
<p>pci1=cn.zc.reflect.test.SoundCard</p>
<p>pci2=cn.zc.reflect.test.NetCard</p>
<p><strong>接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PCI</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>主板</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mainboard</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"main borad run..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">usePCI</span><span class="params">(PCI p)</span> </span>&#123;<span class="comment">//PCI p = new SoundCard();</span></span><br><span class="line">		<span class="keyword">if</span> (p ! = <span class="keyword">null</span>) &#123;</span><br><span class="line">			p.open();</span><br><span class="line">			p.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>正确表达的字符串。</p>
<p>正则表达式用于操作字符串数据。</p>
<p>通过一些特定的符号来体现的。</p>
<p>  所以为了掌握正则表达式，必须要学习一些符号。</p>
<p>  虽然简化了，但是阅读性差。</p>
<h4 id="常见的规则"><a href="#常见的规则" class="headerlink" title="常见的规则"></a>常见的规则</h4><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC28%E5%A4%A92.png" class title="This is an example image">

<p><strong>字符类</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[abc] 字符串某一位必须是a或b或c，只能是三者中一个</span><br><span class="line">[^abc] 任何字符，除了abc</span><br><span class="line">[a-zA-Z]所有大小写字母</span><br><span class="line">[a-d[m-p]] a到b或m到p: [a-dm-p]并集</span><br><span class="line">[a-z&amp;&amp;[def]]d,e或f，交集</span><br><span class="line">[a-z&amp;&amp;[^bc]]a到z，除了b和c:[ad-z]（减去）</span><br><span class="line">[a-z&amp;&amp;[^m-p]]a到z，而非m到p:[a-lq-z]（减去）</span><br></pre></td></tr></table></figure>

<p><strong>预定义字符类</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.  任何字符（与行结束可能匹配也可能不匹配）</span><br><span class="line">\d 数字：[0-9]</span><br><span class="line">\D 非数字：[^0-9]</span><br><span class="line">\s 空白字符：[ \t\n\x0B\f\r]</span><br><span class="line">\S 非空白字符：[^\s]</span><br><span class="line">\w 单词字符：[a-zA-Z_0-9]大小写字母，数字，下划线</span><br><span class="line">\W 非单词字符：[^\w]</span><br></pre></td></tr></table></figure>

<p><strong>边界匹配器</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^  行的开头</span><br><span class="line">$  行的结尾</span><br><span class="line">\b 单词边界，即两个单词中间的位置</span><br><span class="line">\B 非单词边界</span><br><span class="line">\A 输入的开头</span><br><span class="line">\G 上一个匹配的结尾</span><br><span class="line">\Z 输入的结尾，仅用于最后的结束符（如果有的话）</span><br><span class="line">\z 输入的结尾</span><br></pre></td></tr></table></figure>

<p><strong>Greedy数量词</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X? X,一次或一次也没有，至多一次</span><br><span class="line">X* X，零次或多次，有没有都可</span><br><span class="line">X+ X，一次或多次，不能为0次</span><br><span class="line">X&#123;n&#125;  X,恰好n次</span><br><span class="line">X&#123;n,&#125; X，至少n次</span><br><span class="line">X&#123;n,m&#125; X，至少n次，但不会超过m次</span><br></pre></td></tr></table></figure>

<h4 id="常见的功能"><a href="#常见的功能" class="headerlink" title="常见的功能"></a>常见的功能</h4><p>​    Pattern类指定为字符串的正则表达式必须首先被编译为此类的实例（将正则表达式封装成对象）。然后可将得到的模式（正则规则）用于创建Matcher对象（匹配器），依照正则表达式，该对象可以与任意字符序列匹配。执行匹配所涉及的所有状态都驻留在匹配器中，所以多个匹配器可以共享同一模式。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC28%E5%A4%A93.png" class title="This is an example image">

<p>String类中这些关于正则的方法底层调用的是正则对象的方法，不过String类直接使用比较简单点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 正则表达式对字符串的常见操作：</span></span><br><span class="line"><span class="comment">		 * 1，匹配</span></span><br><span class="line"><span class="comment">		 * 		其实使用的是String类中的matches()方法</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 2，切割</span></span><br><span class="line"><span class="comment">		 * 		其实使用的就是String类中的split()方法</span></span><br><span class="line"><span class="comment">		 * 3，替换</span></span><br><span class="line"><span class="comment">		 * 		其实使用的是String类中的replaceAll()方法</span></span><br><span class="line"><span class="comment">		 * 4，获取</span></span><br><span class="line"><span class="comment">		 * 		只能使用正则对象、匹配器对象来完成</span></span><br><span class="line"><span class="comment">		 * 		包名为java.util.regex</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 匹配</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">functionDemo_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//匹配手机号码是否正确</span></span><br><span class="line">		String tel = <span class="string">"158000o1111"</span>;</span><br><span class="line">		<span class="comment">//首个为1，第二位为固定，其他是0-9</span></span><br><span class="line">		String regex = <span class="string">"1[3589]\\d&#123;9&#125;"</span>;</span><br><span class="line">		<span class="keyword">boolean</span> b = tel.matches(regex);</span><br><span class="line">		System.out.println(tel+<span class="string">":"</span>+b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 切割</span></span><br><span class="line"><span class="comment">	 * 组：((A)(B(C)))，按照左括号数组。组1A(B(c))，组2A，组3B(C),组4C</span></span><br><span class="line"><span class="comment">	 * 组零代表整个表达式</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">functionDemo_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//		String str = "zhangsan         xiaoqiang              zhaoliu";</span></span><br><span class="line"><span class="comment">//		String[] names = str.split(" +");//至少出现一次</span></span><br><span class="line"><span class="comment">//		String str = "zhangsan.xiaoqiang.zhaoliu";</span></span><br><span class="line"><span class="comment">//		String[] names = str.split("\\.");//.是特殊符号，需要加上\\.，将其转义	</span></span><br><span class="line">		String str = <span class="string">"zhangsanttttxiaoqiangmmmmmmmmmmzhaoliu"</span>;</span><br><span class="line">		<span class="comment">//使用叠词来切割，因为叠词的第一个为任意，第二个与第一个一样而且不止一个</span></span><br><span class="line">		<span class="comment">//因此将第一个任意的封装为组，第二个使用此组，使用1，转义变成\\1不止一个用+</span></span><br><span class="line">		String[] names = str.split(<span class="string">"(.)\\1+"</span>);<span class="comment">//正则中用小括号封装，组，从1开始，用编号代表组</span></span><br><span class="line">		<span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">			System.out.println(name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 替换</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">functionDemo_3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String str = <span class="string">"zhangsanttttxiaoqiangmmmmmmmmmmzhaoliu"</span>;</span><br><span class="line">		<span class="comment">//第二个中要使用第一个正则表达式中的内容，使用$加组号</span></span><br><span class="line">		str = str.replaceAll(<span class="string">"(.)\\1+"</span>, <span class="string">"$1"</span>);</span><br><span class="line">		System.out.println(str);</span><br><span class="line">		String tel = <span class="string">"15800001111"</span>;<span class="comment">//158****1111</span></span><br><span class="line">		<span class="comment">//将前三位和后四位进行分组，然后这两个组不变，中间的4位变成****</span></span><br><span class="line">		tel = tel.replaceAll(<span class="string">"(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)"</span>, <span class="string">"$1****$2"</span>);<span class="comment">//将不匹配的替换掉</span></span><br><span class="line">		System.out.println(tel);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 获取</span></span><br><span class="line"><span class="comment">	 * 1，将正则规则进行对象的封装</span></span><br><span class="line"><span class="comment">	 * Pattern p = Pattern.compile("a*b");//规则，a没有或多次+b</span></span><br><span class="line"><span class="comment">	 * 2，通过正则对象的matcher方法与字符串关联。获取要对字符串操作的匹配器对象Matcher。</span></span><br><span class="line"><span class="comment">	 * Matcher m = p.matcher("aaaaab");</span></span><br><span class="line"><span class="comment">	 * 3，通过Matcher匹配器对象的方法对字符串进行操作。</span></span><br><span class="line"><span class="comment">	 * boolean b = m.matches();</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">functionDemo_4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String str = <span class="string">"daa jia hao,ming tian bu fang jia!"</span>;</span><br><span class="line">		String regex = <span class="string">"\\b[a-z]&#123;3&#125;\\b"</span>;<span class="comment">//单词前后需要要有单词边界</span></span><br><span class="line">		<span class="comment">//1，将正则封装成对象</span></span><br><span class="line">		Pattern p = Pattern.compile(regex);</span><br><span class="line">		<span class="comment">//2，通过正则对象获取匹配器对象</span></span><br><span class="line">		Matcher m = p.matcher(str);<span class="comment">//将字符串关联</span></span><br><span class="line">		<span class="comment">//3，使用Matcher对象的方法对字符串进行操作</span></span><br><span class="line">		<span class="comment">//既然要获取三个字母组成的单词</span></span><br><span class="line">		<span class="comment">//查找。find()</span></span><br><span class="line">		System.out.println(str);</span><br><span class="line">		<span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">			<span class="comment">//先找再获取</span></span><br><span class="line">			System.out.println(m.group());<span class="comment">//获取匹配的子序列</span></span><br><span class="line">			System.out.println(m.start()+<span class="string">":"</span>+m.end());<span class="comment">//可以拿到indexOf，即位置</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相关题目整理"><a href="#相关题目整理" class="headerlink" title="相关题目整理"></a>相关题目整理</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="a-与-a区别"><a href="#a-与-a区别" class="headerlink" title="a++与++a区别"></a>a++与++a区别</h3><p>a=3 b = a++ 和b = ++a</p>
<p>若是单个语句，则没有太大区别，若是在运算当中，则</p>
<p>a++，先将a的值用temp存储，然后进行a = a+1，然后存下原来的temp，及若b = a++,</p>
<p>b = 3，a =4；若b = ++a，则b = 4,a = 4</p>
<p>若为i = 3,i = i++，则i= 3，因为存储的是temp的值，+=，-=，*=，/=.为左=左加右，左=左减右，以此类推</p>
<h3 id="short-s-4-，s-4与s-s-4的区别"><a href="#short-s-4-，s-4与s-s-4的区别" class="headerlink" title="short s = 4 ，s += 4与s = s + 4的区别"></a>short s = 4 ，s += 4与s = s + 4的区别</h3><p>s += 4为赋值运算，在底层做了自动的强制转换，编译成功，s = s + 4没有自动转换，精度损失，编译不会通过</p>
<h3 id="两个数互换位置，不使用第三个数"><a href="#两个数互换位置，不使用第三个数" class="headerlink" title="两个数互换位置，不使用第三个数"></a>两个数互换位置，不使用第三个数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = a ^ b  </span><br><span class="line">b = a ^ b  </span><br><span class="line">a = a ^ b</span><br></pre></td></tr></table></figure>

<h3 id="用三元运算符取两个整数中大的"><a href="#用三元运算符取两个整数中大的" class="headerlink" title="用三元运算符取两个整数中大的"></a>用三元运算符取两个整数中大的</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x,y</span><br><span class="line"><span class="keyword">int</span> max = x&gt;y?x:y;</span><br></pre></td></tr></table></figure>

<h3 id="if-与-switch的比较"><a href="#if-与-switch的比较" class="headerlink" title="if 与 switch的比较"></a>if 与 switch的比较</h3><p>if :</p>
<ol>
<li><p>对具体的值进行判断。</p>
</li>
<li><p>对区间判断。</p>
</li>
<li><p>对运算结果是boolean类型的表达式进行判断。</p>
</li>
</ol>
<p>switch</p>
<ol>
<li><p>对具体的值进行判断</p>
</li>
<li><p>值的个数是固定的。</p>
</li>
</ol>
<p>对于几个固定的值判断，建议使用switch进行判断，因为switch语句将具体的答案加载进内存，<strong>效率相对较高</strong></p>
<h3 id="while和for循环区别"><a href="#while和for循环区别" class="headerlink" title="while和for循环区别"></a>while和for循环区别</h3><p>for循环结束后，控制循环变量被释放，无法被再次利用，而while中的变量可以。如果不使用此变量，用for较好，节省内存空间；若要用到变量，则用while较好。</p>
<h3 id="直接打印数组名"><a href="#直接打印数组名" class="headerlink" title="直接打印数组名"></a>直接打印数组名</h3><p>直接打印数组名出来的符号什么意思，如[I@c17164</p>
<p>@分隔符，右边c17164是在当前操作系统下计算出的数组地址，如windows下用哈希算法计算出来的地址位置，左边[表示数组，I表示Int类型</p>
<h3 id="数组异常"><a href="#数组异常" class="headerlink" title="数组异常"></a>数组异常</h3><p>使用数组带来的问题</p>
<p>1、 当访问到数组中不存在的角标，会出现ArrayIndexOutOfBoundsException</p>
<p>2、 当引用型变量没有任何实体指向时，还在用其操作，会出现NullPointerException</p>
<hr>
<h3 id="面对对象-1"><a href="#面对对象-1" class="headerlink" title="面对对象"></a>面对对象</h3><p>如何理解面对对象</p>
<p>（1）   符合现在人们思维的习惯（2）使复杂的事情变得简单化（3）让我们从程序的执行者变成指挥者。面向对象的三个特征：封装，继承，多态</p>
<h3 id="类与对象之间的关系"><a href="#类与对象之间的关系" class="headerlink" title="类与对象之间的关系"></a>类与对象之间的关系</h3><p>类：事物的描述</p>
<p>对象：该类事物的实例，在java中通过new来创建</p>
<h3 id="构造函数与一般函数区别"><a href="#构造函数与一般函数区别" class="headerlink" title="构造函数与一般函数区别"></a>构造函数与一般函数区别</h3><p>构造函数对象创建时就会调用与之对应的构造函数对对象进行初始化，而一般函数对象创建后需要该函数功能时才调用；构造函数对象创建时，会调用只调用一次；一般函数对象创建后可以被调用多次。</p>
<h3 id="什么时候定义构造函数"><a href="#什么时候定义构造函数" class="headerlink" title="什么时候定义构造函数"></a>什么时候定义构造函数</h3><p>在描述事物时，该事物一存在就已具备的一些内容，这些内容定义在构造函数中。可以以重载形式进行运行，定义不同的构造函数</p>
<h3 id="若有静态代码块、构造代码块、构造函数，三个执行顺序"><a href="#若有静态代码块、构造代码块、构造函数，三个执行顺序" class="headerlink" title="若有静态代码块、构造代码块、构造函数，三个执行顺序"></a>若有静态代码块、构造代码块、构造函数，三个执行顺序</h3><p>静态代码块随着类的加载而执行，最先执行。如果有对象，构造代码块执行，然后构造函数执行。如果有继承，先运行父类构造函数。</p>
<h3 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h3><ol>
<li>抽象类中有构造函数吗？</li>
</ol>
<p>有，用于给子类对象进行初始化</p>
<ol start="2">
<li>抽象类可以不定义抽象方法吗？</li>
</ol>
<p>可以，但是很少见，目的是不让该类创建对象。AWT的适配器对象就是这种类</p>
<p>通常这个类中的方法有方法体，但是却没有内容</p>
<ol start="3">
<li>抽象关键字不可以和哪些关键字共存？</li>
</ol>
<p>private不行，抽象类需要被子类覆盖 ; static不行，抽象类本身不需创建对象</p>
<p>final 不行，抽象类需要被子类覆盖</p>
<ol start="4">
<li>抽象类和一般类的异同点</li>
</ol>
<p>相同点：抽象类和一般类都是用来描述事物的，都在内部定义了成员。</p>
<p>不同点：</p>
<ul>
<li><p>一般类有足够的信息描述事物。抽象类描述事物的信息有可能不足。</p>
</li>
<li><p>一般类中不能定义抽象方法，只能定义非抽象方法。抽象类中可以定义抽象方法，同时也可以定义非抽象方法。</p>
</li>
<li><p>一般类可以被实例化。抽象类不可以被实例化。</p>
</li>
</ul>
<ol start="5">
<li><p>抽象类一定是父类吗？</p>
<p>是的，需要子类覆盖方法后才可以对子类实例化。</p>
</li>
</ol>
<h3 id="this关键字含义，final特点"><a href="#this关键字含义，final特点" class="headerlink" title="this关键字含义，final特点"></a>this关键字含义，final特点</h3><p>this关键字：调用本类属性，调用本类方法，使用本类构造器，本类对象的引用</p>
<p>final：final是一个修饰符，可以修饰类，方法，变量；final修饰的类不可以被继承；final修饰的方法不可以被覆盖；final修饰的变量是一个常量，只能赋值一次变量命名与函数一样，常量所有字母都大写</p>
<h3 id="main输出1"><a href="#main输出1" class="headerlink" title="main输出1"></a>main输出1</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%801.png" class title="This is an example image">

<p>如果用单|，要判断左边跟右边，这时候j=0+4，但是如果是||，左边满足，那么右边直接被屏蔽，那么j仍然等于4。输出4.</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String比较"><a href="#String比较" class="headerlink" title="String比较"></a>String比较</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stringDemo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		String s = <span class="string">"abc"</span>;</span><br><span class="line">		<span class="comment">//s = "nba";</span></span><br><span class="line">		String s1 = <span class="string">"abc"</span>;</span><br><span class="line">		System.out.println(s==s1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stringDemo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String s = <span class="string">"abc"</span>;</span><br><span class="line">		String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">		System.out.println(s==s1);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>​    第一个为真，第二个为假。第一种创建String方式为在常量池中创建对象，可以共享，而new在堆内存中进行创建。</p>
<p>​    如果要比较对象的内容，用equals()，而String类将Object中的比较方法进行覆写，普通的equals()比较地址，而字符串比较内容。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/String1.png" class title="This is an example image">

<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/String2.png" class title="This is an example image">

<p>结果一个为5，一个为41，原因下面将4变成了4字符串。第三种方式也可以实现输出41，更简洁。</p>
<h3 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h3><p>{“nba”,abc”,”cba”,”zz”,”qq”,”haha”}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">思路：</span><br><span class="line"><span class="number">1</span>、对数组排序。可以用选择，冒泡都行。</span><br><span class="line"><span class="number">2</span>、<span class="keyword">for</span>嵌套和比较，以及换位</span><br><span class="line"><span class="number">3</span>、问题：以前排的是整数，比较用的是比较运算符，现在是字符串对象</span><br><span class="line">	  字符串对象比较，对象中提供了用于字符串对象比较的功能。</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest_1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String[] arr = &#123; <span class="string">"nba"</span>, <span class="string">"abc"</span>, <span class="string">"cba"</span>, <span class="string">"zz"</span>, <span class="string">"qq"</span>, <span class="string">"haha"</span> &#125;;</span><br><span class="line">		print(arr);</span><br><span class="line">		System.out.println();</span><br><span class="line">		sortString(arr);</span><br><span class="line">		print(arr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			System.out.print(arr[i] + <span class="string">"\t"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String[] sortString(String[] arr) &#123;</span><br><span class="line">		String s;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (arr[i].compareTo(arr[j]) &gt; <span class="number">0</span>) &#123;<span class="comment">//字符串比较用compareTo()方法</span></span><br><span class="line">					swap(arr,i,j);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(String[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		String temp = arr[j];</span><br><span class="line">		arr[j] = arr[i];</span><br><span class="line">		arr[i] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一个子串在整串中出现的次数"><a href="#一个子串在整串中出现的次数" class="headerlink" title="一个子串在整串中出现的次数"></a>一个子串在整串中出现的次数</h3><p>“nbaernbatynbauinbaopnba”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">思路：</span><br><span class="line"><span class="number">1</span>、要找的子串是否存在，如果存在，获取其出现的位置，可以使用indexOf()完成</span><br><span class="line"><span class="number">2</span>、如果找到了，那么记录出现的位置并在剩余的字符串中继续查找该子串，剩余字符串的</span><br><span class="line">起始位是出现位置+子串长度</span><br><span class="line"><span class="number">3</span>、以此类推，通过循环完成查找，如果找不到就是-<span class="number">1</span>，并对每次找到用计数器记录</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest_2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String str = <span class="string">"nbaernbatnbaynbauinbaopnba"</span>;</span><br><span class="line">		String key = <span class="string">"nba"</span>;</span><br><span class="line">		<span class="keyword">int</span> count = getKeyStringCount_2(str,key);</span><br><span class="line">		System.out.println(<span class="string">"count="</span>+count);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getKeyStringCount_2</span><span class="params">(String str, String key)</span> </span>&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 思路：</span></span><br><span class="line"><span class="comment">		 * 不新增字符串，而是改变每次查找的位置，其中起始位为上一次找到的位置加上key的长度</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((index=str.indexOf(key, index))!=-<span class="number">1</span>)&#123;</span><br><span class="line">			index += key.length();</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取子串在整串中出现的次数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getKeyStringCount</span><span class="params">(String str, String key)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//1、定义计数器</span></span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//2、定义变量，记录key出现的位置</span></span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((index = str.indexOf(key))!=-<span class="number">1</span>)&#123;</span><br><span class="line">			str = str.substring(index+key.length());</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两个字符串中最大相同的子串"><a href="#两个字符串中最大相同的子串" class="headerlink" title="两个字符串中最大相同的子串"></a>两个字符串中最大相同的子串</h3><p>“qwerabcdtyuiop”</p>
<p>“xcabcdvbn”</p>
<h2 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h2><h3 id="什么时候定义继承"><a href="#什么时候定义继承" class="headerlink" title="什么时候定义继承"></a>什么时候定义继承</h3><p>当类与类之间存在着所属关系的时候，就定义继承。xxx是yyy的一种，xxx extends yyy</p>
<p>继承就是不断向上抽离的过程，如果A和B部分功能相同，可以将相同功能进行抽离，变成父类。</p>
<h3 id="子类实例化访问父类构造函数原因"><a href="#子类实例化访问父类构造函数原因" class="headerlink" title="子类实例化访问父类构造函数原因"></a>子类实例化访问父类构造函数原因</h3><p>子类继承了父类，获取到了父类中的内容（属性），所以在使用父类内容之前要先看父类是如何对自己的内容进行初始化的，所以子类在构造对象时必须访问父类的构造函数。为了完成这个必须的动作，就在子类的构造函数函数中加入了super();语句.如果父类中没有定义空参数构造函数.那么子类的构造函数必须用super明确要调用父类中哪个构造函数同时子类构造函数中如果使用this()调用了本类构造函数时，super就没有了，因为this和super都只能定义在第一行，所以只能有一个。但是可以保证的是，子类中肯定会有其他的构造函数访问父类的构造函数。</p>
<h3 id="main输出题目1"><a href="#main输出题目1" class="headerlink" title="main输出题目1"></a>main输出题目1</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%A7%E6%89%BF1.png" class title="This is an example image">

<p>A 可以，因为覆盖了 </p>
<p>B不可以，权限不够 </p>
<p>C可以，子类特有方法</p>
<p>D 不可以，调用的不确定项 </p>
<p>E不可以，静态只能覆盖静态</p>
<h2 id="多态-1"><a href="#多态-1" class="headerlink" title="多态"></a>多态</h2><h3 id="main输出题目1-1"><a href="#main输出题目1-1" class="headerlink" title="main输出题目1"></a>main输出题目1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> 讲课()&#123;</span><br><span class="line">        System.out.println(“讲课”);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">void</span> 钓鱼()&#123;</span><br><span class="line">        System.out.println(“钓鱼”);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> 讲课()&#123;</span><br><span class="line">        System.out.println(“Java”);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">void</span> 看电影()&#123;</span><br><span class="line">        System.out.println(“看电影”);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line">main函数中</span><br><span class="line">	Fu a = <span class="keyword">new</span> Zi();</span><br><span class="line">a.讲课()；<span class="comment">//所输出为Java，因为在子类中对父类进行了覆盖</span></span><br><span class="line">a.钓鱼(); <span class="comment">//所输出为钓鱼，因为在子类中对父类进行了继承</span></span><br><span class="line">a.看电影():<span class="comment">//不能调用，需要进行向下转型</span></span><br><span class="line">Zi b = (Zi)a；</span><br><span class="line">b.看电影();<span class="comment">//所输出为看电影</span></span><br></pre></td></tr></table></figure>

<h3 id="main输出题目2"><a href="#main输出题目2" class="headerlink" title="main输出题目2"></a>main输出题目2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">	print(“Fu”);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        print(Fu method)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">4</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">	print(“Zi”);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        print(Zi method)&#125;</span><br><span class="line">&#125;</span><br><span class="line">main函数中</span><br><span class="line">	Fu f = <span class="keyword">new</span> Zi();	</span><br><span class="line">	输出f.num</span><br><span class="line">	f.show()</span><br><span class="line">	f.method()</span><br><span class="line">	结果为<span class="number">3</span>，Zi，Fu method</span><br></pre></td></tr></table></figure>

<h3 id="main输出题目3"><a href="#main输出题目3" class="headerlink" title="main输出题目3"></a>main输出题目3</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%80%813.png" class title="This is an example image">

<p>结果为A B</p>
<p>​    因为f.show()调用父类方法，被子类覆盖，输出A，然后进行for循环判断，输出B，返回false，因为为双与，因此直接短路，循环结束。所以总输出结果为A B。</p>
<h3 id="main输出题目4"><a href="#main输出题目4" class="headerlink" title="main输出题目4"></a>main输出题目4</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%80%814.png" class title="This is an example image">

<p>输出B C 7。使用多态，在子类的构造函数中第一行为super()，因此输出B，此时i=0，然后i+2=2，然后输出C，i+5=7。因此最后结果为B C 7。</p>
<h3 id="main输出题目5"><a href="#main输出题目5" class="headerlink" title="main输出题目5"></a>main输出题目5</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%80%815.png" class title="This is an example image">

<p>输出：4 5 showZi showZi</p>
<h3 id="main输出题目6"><a href="#main输出题目6" class="headerlink" title="main输出题目6"></a>main输出题目6</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%80%816.png" class title="This is an example image">

<p>执行子类构造函数，默认第一行为super()，因为父类中没有空参的构造函数，只有有参的构造函数，因此super()不能被执行，编译失败。</p>
<h3 id="main输出题目7"><a href="#main输出题目7" class="headerlink" title="main输出题目7"></a>main输出题目7</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%80%817.png" class title="This is an example image">

<p>因为父类中方法与此类不一样，覆盖失败，编译报错。调用的不确定性。</p>
<h3 id="多态时成员的特点-1"><a href="#多态时成员的特点-1" class="headerlink" title="多态时成员的特点"></a>多态时成员的特点</h3><p>1.成员变量</p>
<p>编译时：参考引用型变量所属的类中是否有调用的成员变量，有，编译通过；没有，编译失败。</p>
<p>运行时：参考引用型变量所属的类中是否有调用的成员变量，并运行所属类中的成员变量</p>
<p>简单说：<strong>编译和运行都参考等号的左边</strong></p>
<p>2.成员函数（<strong>非静态</strong>，<strong>重点</strong>）</p>
<p>编译时：参考引用型变量所属的类中是否有调用的函数，有，编译通过；没有，编译失败。</p>
<p>运行时：参考的是对象所属的类中是否有调用的函数</p>
<p>简单说：<strong>编译看左边，运行看右边</strong></p>
<p>3.静态函数</p>
<p>编译时：参考引用型变量所属的类中是否有调用的静态方法</p>
<p>运行时：参考引用型变量所属的类中是否有调用的静态方法</p>
<p>简单说：<strong>编译和运行都参考等号的左边</strong></p>
<p>​    其实静态方法是不需要对象的，直接类名调用即可</p>
<h2 id="内部类-1"><a href="#内部类-1" class="headerlink" title="内部类"></a>内部类</h2><h3 id="内部类可以直接访问外部类中成员的原因"><a href="#内部类可以直接访问外部类中成员的原因" class="headerlink" title="内部类可以直接访问外部类中成员的原因"></a>内部类可以直接访问外部类中成员的原因</h3><p>内部类持有外部类的引用，外部类名.this</p>
<p>​    从内部类在局部位置上只能访问局部中被final修饰的局部变量</p>
<h3 id="main输出1-1"><a href="#main输出1-1" class="headerlink" title="main输出1"></a>main输出1</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%85%E9%83%A8%E7%B1%BB1.png" class title="This is an example image">

<p>在主函数中，若直接new Inner()对象会失败，因为<strong>静态方法中不允许有非静态成员</strong>，相当于this.new Inner()，而static中不允许出现this，此时需要将class Inner修改成 static class Inner</p>
<h3 id="main输出2"><a href="#main输出2" class="headerlink" title="main输出2"></a>main输出2</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%85%E9%83%A8%E7%B1%BB2.png" class title="This is an example image">

<p>new Object(){}相当于创立了子类对象，而Object obj=子类对象，匿名内部类这个子类对象被向上转型（多态）为Object类型，隐藏了子类特有属性，这样就不能使用子类特有的方法。编译看左边，Object类中无show方法，因此会编译失败</p>
<h3 id="main输出3"><a href="#main输出3" class="headerlink" title="main输出3"></a>main输出3</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%85%E9%83%A8%E7%B1%BB3.png" class title="This is an example image">

<p>编译失败，因为内部类中如果定义了静态成员，该内部类必须被静态修饰，或者该成员变量被final修饰。因为内部类相当于外部类的成员，必须在外部类的对象创建以后进行，java虚拟机要求所有的静态变量要在对象创建之前完成，因为如果非静态内部类中有静态变量，就要先加载非静态方法，再加载静态成员，与JVM矛盾。</p>
<p>​    但是可以在非静态内部类中定义静态常量（静态常量一定要有一个编译期常量），如果变量被static final修饰，字面常量会在编译阶段确定，称为编译期常量，不需要加载类的字节码文件，即编译期常量不会导致类加载，因此静态常量在非静态内部类中是合法的。（编译期常量折叠：编译期在编译阶段通过语法分析计算出常量表达式的具体值）。但是如果将y改成Math.randm()，会报错，因为这个需要运行确定。</p>
<p>​    总结：<strong>非静态内部类中不能拥有静态成员变量/方法，但是可以有静态的编译期常量，不能使用非编译期常量</strong>。</p>
<h3 id="main输出4"><a href="#main输出4" class="headerlink" title="main输出4"></a>main输出4</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%85%E9%83%A8%E7%B1%BB4.png" class title="This is an example image">

<p>A正确，在外部类访问内部类，必须要建立内部类的对象。</p>
<p>B 错误，因为主函数是静态方法，只能调用静态成员，所以内部类必须是静态的。</p>
<p>C错误，格式错误，应该是new Demo().new Inner();</p>
<p>D 格式正确，但是要求内部类是静态的。</p>
<h3 id="main输出5"><a href="#main输出5" class="headerlink" title="main输出5"></a>main输出5</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%85%E9%83%A8%E7%B1%BB5.png" class title="This is an example image">

<p>调用show()方法，不能直接show()，因为是非静态的，需要对象调用,new Demo().show();</p>
<p>然后传一个匿名对象进去，实现func()方法。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%85%E9%83%A8%E7%B1%BB5-2.png" class title="This is an example image">

<h2 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h2><h3 id="main输出1-2"><a href="#main输出1-2" class="headerlink" title="main输出1"></a>main输出1</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A31.png" class title="This is an example image">

<p>编译失败，因为编译看左边，运行看右边，而因为接口A中没有func方法，所以编译会报错。a所属的A接口中没有func()方法。</p>
<h3 id="main输出2-1"><a href="#main输出2-1" class="headerlink" title="main输出2"></a>main输出2</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A32.png" class title="This is an example image">

<p>编译失败，A a = get()；相当于A a = new B()；相当于把B对象封装，因为A中没有test()方法，因此编译报错。</p>
<h2 id="异常-1"><a href="#异常-1" class="headerlink" title="异常"></a>异常</h2><h3 id="main输出1-3"><a href="#main输出1-3" class="headerlink" title="main输出1"></a>main输出1</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BC%82%E5%B8%B81.png" class title="This is an example image">

<p>找main函数入口，执行show()方法,此方法进栈，抛出异常被catch，因此进入catch，输出B，finally一定会被执行，输出C，问题被解决了，输出D。因此结果为B C D。</p>
<h3 id="main输出2-2"><a href="#main输出2-2" class="headerlink" title="main输出2"></a>main输出2</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BC%82%E5%B8%B82.png" class title="This is an example image">

<p>throw异常下面的语句无法被执行，因为抛出异常就进入catch捕获异常。因此输出A是句废话，编译失败。与main输出1不一样，main输出1<strong>将异常封装</strong>，方法下面的语句还有可能被执行到。</p>
<p>throw 语句下面不要加其他语句，必然要跳转！！！</p>
<h3 id="main输出3-1"><a href="#main输出3-1" class="headerlink" title="main输出3"></a>main输出3</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BC%82%E5%B8%B83.png" class title="This is an example image">

<p>多catch时，父类的catch放在最下面，因此编译会失败。</p>
<h3 id="main输出4-1"><a href="#main输出4-1" class="headerlink" title="main输出4"></a>main输出4</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BC%82%E5%B8%B84.png" class title="This is an example image">

<p>134</p>
<p>13423</p>
<p>​    原因：foo(0)，不等于1，Output=1，然后执行finally，output=13，正常结束，output=134，然后输出134；执行foo(1)，一次是满足条件，丢出异常，output=1342（因为Output为静态变量，一直存在，因此始终操作的是同一变量），然后执行return，但是因为finally一定被执行（除非退出jvm），因此output=13423</p>
<h2 id="多线程-1"><a href="#多线程-1" class="headerlink" title="多线程"></a>多线程</h2><h3 id="实现死锁"><a href="#实现死锁" class="headerlink" title="实现死锁"></a>实现死锁</h3><p>死锁的代码：利用同步的嵌套</p>
<p>run方法中封装线程任务，设置两个同步的嵌套，一个为同步锁a,b；另一个为同步锁b,a；然后设定同步锁对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> flag;</span><br><span class="line">	<span class="comment">//设置构造函数，可以直接初始化参数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.flag = flag;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//设置同步的嵌套</span></span><br><span class="line">		<span class="keyword">if</span>(flag)&#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">				<span class="keyword">synchronized</span>(MyLock.obja)&#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName()+<span class="string">"if的obja"</span>);</span><br><span class="line">						<span class="keyword">synchronized</span>(MyLock.objb)&#123;</span><br><span class="line">							System.out.println(Thread.currentThread().getName()+<span class="string">"if的objb"</span>);</span><br><span class="line">					&#125;	</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">				<span class="keyword">synchronized</span>(MyLock.objb)&#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName()+<span class="string">"else的objb"</span>);</span><br><span class="line">						<span class="keyword">synchronized</span>(MyLock.obja)&#123;</span><br><span class="line">							System.out.println(Thread.currentThread().getName()+<span class="string">"else的obja"</span>);</span><br><span class="line">					&#125;	</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设立同步锁对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object obja = <span class="keyword">new</span> Object();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object objb = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Test a = <span class="keyword">new</span> Test(<span class="keyword">true</span>);</span><br><span class="line">		Test b = <span class="keyword">new</span> Test(<span class="keyword">false</span>);</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(a);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(b);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试题1"><a href="#面试题1" class="headerlink" title="面试题1"></a>面试题1</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B1.png" class title="This is an example image">

<p>错误在第一行，此run()方法为子类特有方法，Test实现了Runnable接口，但是没有覆盖Run()方法，应该被abstract修饰</p>
<h3 id="面试题2"><a href="#面试题2" class="headerlink" title="面试题2"></a>面试题2</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B2.png" class title="This is an example image">

<p>​    判断Thread自身run()和runnable的run方法优先级，应该输出subThread run。</p>
<p>​    Thread实现了自己的run方法，因此直接执行下边的run()方法，只有在下边的run()未实现时，才会寻找到上边的Runnable的run方法，并执行，这就是优先级顺序。</p>
<p>​    因为应该以<strong>子类的任务</strong>为主(new Thread中的run方法)，如果子类没有覆写run方法，那么则以<strong>任务对象</strong>为主，如果没有任务对象，则以<strong>Thread</strong>原有run方法为主</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux使用</title>
    <url>/2020/01/14/Linux%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Linux视频学习笔记"><a href="#Linux视频学习笔记" class="headerlink" title="Linux视频学习笔记"></a>Linux视频学习笔记</h2><blockquote>
<p><a href="https://www.bilibili.com/video/av21303002?p=1" target="_blank" rel="noopener">尚硅谷韩顺平老师视频讲解</a>笔记</p>
<p><a href="https://github.com/Sunxz007/Linux-note-follow-Hanshunping" target="_blank" rel="noopener">Sunxz007Github</a>笔记</p>
</blockquote>
<p>课程内容如下图所示</p>
<img src="/2020/01/14/Linux%E4%BD%BF%E7%94%A8/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9.png" class title="This is an example image">

<a id="more"></a>



<h2 id="Linux下安装jdk8"><a href="#Linux下安装jdk8" class="headerlink" title="Linux下安装jdk8"></a>Linux下安装jdk8</h2><h3 id="卸载Linux自带OpenJDK"><a href="#卸载Linux自带OpenJDK" class="headerlink" title="卸载Linux自带OpenJDK"></a>卸载Linux自带OpenJDK</h3><p>切换到root权限</p>
<blockquote>
<p>su root</p>
</blockquote>
<p> 使用java -version看OpenJDK信息，然后查询系统自带java相关文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep java</span><br></pre></td></tr></table></figure>

<p>命令说明：</p>
<p>rpm 　管理套件</p>
<p>-qa 　使用询问模式，查询所有套件</p>
<p>grep　　查找文件里符合条件的字符串</p>
<p>java 　查找包含java字符串的文件</p>
<p> 除noarch外，删除其他java文件</p>
<blockquote>
<p>rpm -e –nodeps java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64</p>
</blockquote>
<p>命令介绍</p>
<p>rpm 　　　管理套件</p>
<p>-e　　　　　删除指定的套件</p>
<p>–nodeps　　不验证套件档的相互关联性</p>
<p> 当输入java -version，没有找到命令，代表删除成功。</p>
<hr>
<h3 id="下载JDK"><a href="#下载JDK" class="headerlink" title="下载JDK"></a>下载JDK</h3><p>历史版本下载地址：　　<a href="http://www.oracle.com/technetwork/java/javase/archive-139210.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/archive-139210.html</a></p>
<p> 通过浏览器下载会默认下载到当前登陆用户的下载目录，下载位置为“当前用户/下载/jdk-8u211-linux-x64.tar.gz”。</p>
<p> cd 下载，然后使用</p>
<blockquote>
<p>ls -al 展示本目录下所有文件</p>
</blockquote>
<p> 为了查看当前目录路径，可以使用</p>
<blockquote>
<p>pwd 查看当前目录路径</p>
</blockquote>
<hr>
<h3 id="复制JDK"><a href="#复制JDK" class="headerlink" title="复制JDK"></a>复制JDK</h3><h4 id="备份JDK"><a href="#备份JDK" class="headerlink" title="备份JDK"></a>备份JDK</h4><p> 将压缩包复制一份到/usr/local/src/作备份，输入命令</p>
<blockquote>
<p>cp jdk-8u211-linux-x64.tar.gz /usr/local/src</p>
</blockquote>
<p>命令说明：</p>
<p>cp　　　　　　　　　　　　　　 复制文件或目录</p>
<p>jdk-8u211-linux-x64.tar.gz　　　　文件名</p>
<p>/user/local/src　　　　　　　　　 要复制的目标目录</p>
<h4 id="创建java文件夹"><a href="#创建java文件夹" class="headerlink" title="创建java文件夹"></a>创建java文件夹</h4><p> 在usr目录下创建一个文件夹，名为java</p>
<blockquote>
<p>mkdir java</p>
</blockquote>
<p> 然后将文件拷贝至/usr/java</p>
<blockquote>
<p>cp jdk-8u211-linux-x64.tar.gz /usr/java</p>
</blockquote>
<hr>
<h3 id="解压缩JDK"><a href="#解压缩JDK" class="headerlink" title="解压缩JDK"></a>解压缩JDK</h3><h4 id="在java目录下解压JDK压缩文件"><a href="#在java目录下解压JDK压缩文件" class="headerlink" title="在java目录下解压JDK压缩文件"></a>在java目录下解压JDK压缩文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-8u144-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>

<p>命令介绍：</p>
<p>tar　　　　　　备份文件</p>
<p>-zxvf　　　　　</p>
<p>-z　　　　　　 　　　　　　　 通过gzip指令处理备份文件</p>
<p>-x　　　　　　　　　　　　　　 从备份文件中还原文件</p>
<p>-v　　　　　　　　　　　　　　 显示指令执行过程</p>
<p>-f　　　　　　 　　　　　　　　 指定备份文件</p>
<p>jdk-8u211-linux-x64.tar.gz　　　　文件名</p>
<h4 id="删除JDK压缩包"><a href="#删除JDK压缩包" class="headerlink" title="删除JDK压缩包"></a>删除JDK压缩包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -f jdk-8u211-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>

<p>命令解释：</p>
<p>rm　　　　删除文件或目录</p>
<p>-f　　　　 强制删除文件或目录</p>
<hr>
<h3 id="配置JDK环境变量"><a href="#配置JDK环境变量" class="headerlink" title="配置JDK环境变量"></a>配置JDK环境变量</h3><h4 id="编辑全局变量"><a href="#编辑全局变量" class="headerlink" title="编辑全局变量"></a>编辑全局变量</h4><p>命令行键入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<p>命令说明：</p>
<p>vim　　　　　　文本编辑</p>
<p>/etc/profile　　　全局变量文件</p>
<p>进入文本编辑状态下，光标走到文件最后一行，键盘按下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i</span><br></pre></td></tr></table></figure>

<p> 进入插入状态：</p>
<p>在文本的最后一行粘贴如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i</span><br></pre></td></tr></table></figure>

<p>注意JAVA_HOME=/usr/java/jdk1.8.0_211 为你自己的目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#java environment</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_211</span><br><span class="line">export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;jre&#x2F;lib&#x2F;rt.jar:$&#123;JAVA_HOME&#125;&#x2F;lib&#x2F;dt.jar:$&#123;JAVA_HOME&#125;&#x2F;lib&#x2F;tools.jar</span><br><span class="line">export PATH&#x3D;$PATH:$&#123;JAVA_HOME&#125;&#x2F;bin</span><br></pre></td></tr></table></figure>

<p>【注】：CentOS6上面的是JAVAHOME，CentOS7是{JAVA_HOME}</p>
<p> 复制完成后，在键盘敲下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ESC</span><br><span class="line">shift+q</span><br></pre></td></tr></table></figure>

<p> 进入EX模式，敲下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x</span><br></pre></td></tr></table></figure>

<p> 保存并退出。</p>
<hr>
<h3 id="检验环境变量是否生效"><a href="#检验环境变量是否生效" class="headerlink" title="检验环境变量是否生效"></a>检验环境变量是否生效</h3><h4 id="让刚刚设置的环境变量生效"><a href="#让刚刚设置的环境变量生效" class="headerlink" title="让刚刚设置的环境变量生效"></a>让刚刚设置的环境变量生效</h4><p>键入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<p>source /etc/profile或 . /etc/profile</p>
<h4 id="检查是否配置成功"><a href="#检查是否配置成功" class="headerlink" title="检查是否配置成功"></a>检查是否配置成功</h4><p>键入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>pwd 查看当前目录路径</li>
<li>ls -al 展示本目录下所有文件</li>
</ul>
<h3 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h3><ul>
<li>mkdir dir 创建文件夹</li>
</ul>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul>
<li>cp 复制文件</li>
</ul>
<p>cp　　　　　　　　　　　　　　 复制文件或目录</p>
<p>jdk-8u211-linux-x64.tar.gz　　　　完整文件名</p>
<p>/user/local/src　　　　　　　　　 要复制的目标目录</p>
<ul>
<li>rm 删除文件</li>
</ul>
<p>rm　　　　删除文件或目录</p>
<p>-f　　　　 强制删除文件或目录</p>
<ul>
<li>tar 备份，解压缩文件</li>
</ul>
<p>tar　　　　　　备份文件</p>
<p>-zxvf　　　　　</p>
<p>-z　　　　　　 　　　　　　　 通过gzip指令处理备份文件</p>
<p>-x　　　　　　　　　　　　　　 从备份文件中还原文件</p>
<p>-v　　　　　　　　　　　　　　 显示指令执行过程</p>
<p>-f　　　　　　 　　　　　　　　 指定备份文件</p>
<p>jdk-8u211-linux-x64.tar.gz　　　　文件名</p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><h4 id="编辑全局变量-1"><a href="#编辑全局变量-1" class="headerlink" title="编辑全局变量"></a>编辑全局变量</h4><p>vim /etc/profile</p>
<p>i 插入</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Java爬虫</title>
    <url>/2020/01/07/Java%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h2 id="实现场景"><a href="#实现场景" class="headerlink" title="实现场景"></a>实现场景</h2><p>​    通过 selenium 实现模拟人为操作自动化依据，工作经验，学历要求，公司规模，行业领域抓取拉钩薪资范围。只针对网页，不受防爬的影响。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li><p><a href="http://npm.taobao.org/mirrors/chromedriver" target="_blank" rel="noopener">Chrome WebDriver</a></p>
</li>
<li><p>Selenium</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.seleniumhq.selenium<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>selenium-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.141.59<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<a id="more"></a>

<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h3><p>选择Maven，在pom文件中写<dependencies>/<dependency>，主要逻辑是通过java代码操作selenium的jar包，然后操作Webdiver，然后操作浏览器。</dependency></dependencies></p>
<p>将WebDriver拷贝到src/main/resources下。在src/main/java下新建类LagouSearcher。</p>
<ul>
<li>让系统知道WebDriver的位置</li>
<li>创建WebDriver</li>
<li>通过WebDriver访问浏览器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      <span class="comment">//告诉系统webdriver的位置</span></span><br><span class="line">      <span class="comment">//通过反射机制，拿到类中的resources下面的文件路径 </span></span><br><span class="line">System.setProperty("webdriver.chrome.driver",LagouSearcher.class.getClassLoader().getResource("chromedriver.exe").getPath());</span><br><span class="line">      WebDriver webDriver = <span class="keyword">new</span> ChromeDriver();</span><br><span class="line">      <span class="comment">//通过webdriver访问指定页面</span></span><br><span class="line">      webDriver.get(<span class="string">"https://www.lagou.com/zhaopin/Java/?labelWords=label"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="选择搜索条件"><a href="#选择搜索条件" class="headerlink" title="选择搜索条件"></a>选择搜索条件</h3><p>WebDriver通过操纵元素来选择其具体位置。</p>
<p>​    许多都为li标签，只能通过li为multi-chosen，span下class不同名称来判断</p>
<img src="/2020/01/07/Java%E7%88%AC%E8%99%AB/li.jpg" class title="This is an example image">

<p>​    用到<a href="https://www.w3school.com.cn/xpath/xpath_syntax.asp" target="_blank" rel="noopener">XPath</a>语法</p>
<table>
<thead>
<tr>
<th align="left">表达式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">nodename</td>
<td align="left">选取此节点的所有子节点。</td>
</tr>
<tr>
<td align="left">/</td>
<td align="left">从根节点选取。</td>
</tr>
<tr>
<td align="left">//</td>
<td align="left">从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">选取当前节点。</td>
</tr>
<tr>
<td align="left">..</td>
<td align="left">选取当前节点的父节点。</td>
</tr>
<tr>
<td align="left">@</td>
<td align="left">选取属性。</td>
</tr>
</tbody></table>
<p>具体实例为</p>
<table>
<thead>
<tr>
<th align="left">路径表达式</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bookstore</td>
<td align="left">选取 bookstore 元素的所有子节点。</td>
</tr>
<tr>
<td align="left">/bookstore</td>
<td align="left">选取根元素 bookstore。 注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！</td>
</tr>
<tr>
<td align="left">bookstore/book</td>
<td align="left">选取属于 bookstore 的子元素的所有 book 元素。</td>
</tr>
<tr>
<td align="left">//book</td>
<td align="left">选取所有 book 子元素，而不管它们在文档中的位置。</td>
</tr>
<tr>
<td align="left">bookstore//book</td>
<td align="left">选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。</td>
</tr>
<tr>
<td align="left">//@lang</td>
<td align="left">选取名为 lang 的所有属性。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 学习</title>
    <url>/2019/12/29/SpringBoot-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="SpringBoot学习"><a href="#SpringBoot学习" class="headerlink" title="SpringBoot学习"></a>SpringBoot学习</h1><h2 id="涉及的一些知识点"><a href="#涉及的一些知识点" class="headerlink" title="涉及的一些知识点"></a>涉及的一些知识点</h2><ul>
<li>SpringBoot</li>
<li>Spring MVC</li>
<li>MyBatis</li>
<li>MySQL、H2</li>
<li>Flyway</li>
<li>Heroku</li>
<li>Git/Github</li>
<li>Maven</li>
<li>Restful<a id="more"></a>
<h2 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h2></li>
</ul>
<p>​    选择Spring，进行创建</p>
<h3 id="初始创建文件夹"><a href="#初始创建文件夹" class="headerlink" title="初始创建文件夹"></a>初始创建文件夹</h3><p>​    src.main文件中包括java文件夹（存放<strong>Java</strong>文件）和resources（存放<strong>静态</strong>文件，<strong>Web</strong>or<strong>模板</strong>文件和<strong>配置</strong>文件）。</p>
<p>​    java文件夹下的application作用是可以作为SpringBoot项目启动的窗口。</p>
<h3 id="网址构成"><a href="#网址构成" class="headerlink" title="网址构成"></a>网址构成</h3><p><a href="https://www.bilibili.com/video" target="_blank" rel="noopener">https://www.bilibili.com/video</a></p>
<p>​    对应的是https或者http+域名+路径</p>
<ul>
<li><p>绑定本机的地址是localhost/120.0.0.1  (可以通过此地址访问本机项目承载地址)</p>
</li>
<li><p>路径是一个path，因此网络地址对应到本机可以是localhost/120.0.0.1/video</p>
</li>
<li><p>最终对应的是<a href="http://localhost:8887/hello" target="_blank" rel="noopener">http://localhost:8887/hello</a>  (Tomcat默认的端口号是<strong>8080</strong>)</p>
</li>
</ul>
<h3 id="正式编程"><a href="#正式编程" class="headerlink" title="正式编程"></a>正式编程</h3><h4 id="实现输入网址返回可视化界面"><a href="#实现输入网址返回可视化界面" class="headerlink" title="实现输入网址返回可视化界面"></a>实现输入网址返回可视化界面</h4><h5 id="文档说明"><a href="#文档说明" class="headerlink" title="文档说明"></a>文档说明</h5><ol>
<li><p>使用<a href="https://spring.io/guides" target="_blank" rel="noopener">Spring官方文档</a>下的<a href="https://spring.io/guides/gs/serving-web-content/" target="_blank" rel="noopener">Serving Web Content with Spring MVC</a>，找到其依赖的dependency</p>
<p>，复制进项目，导入相应的包。</p>
</li>
<li><p>创建Web资源，写Controller，写Controller注解，写Mapping，通过路由的方法，可以接受各种资料。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingController</span> </span>&#123;</span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/greeting"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">greeting</span><span class="params">(@RequestParam(name=<span class="string">"name"</span>, required=<span class="keyword">false</span>, defaultValue=<span class="string">"World"</span>)</span> String name, Model model) </span>&#123;</span><br><span class="line">		model.addAttribute(<span class="string">"name"</span>, name);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"greeting"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@Controller，将当前类作为路由API的一个承载者</p>
</blockquote>
<p>作用是以网址形式向服务端传送key-value信息。</p>
<ul>
<li>name=hughzc</li>
</ul>
<p>也可以进行接收，如name=“name”，前面定义变量，后面用来接收值。<strong>GetMapping</strong>方法可以获得从浏览器接收的参数。然后使用<strong>model</strong>来显示信息，类似map，将信息向前端传递。key是”“name”，value是前端传过来的name，接收到并set到model中。返回greeting。</p>
<blockquote>
<p>体现的编程思路：仔细阅读文档。</p>
</blockquote>
<p>​    因为返回greeting，因此定义的文件名为greeting，具体为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">src&#x2F;main&#x2F;resources&#x2F;templates&#x2F;greeting.html</span><br></pre></td></tr></table></figure>

<p>里面的内容为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Getting Started: Serving Web Content<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"'Hello, ' + $&#123;name&#125; + '!'"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>head跟body就是比较基础的html语言，不一样的是加入了标签，告知spring使用模板引擎去解析。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>要做的是</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"'Hello, ' + $&#123;name&#125; + '!'"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>spring动态语言，将 model中的key为name的信息替换掉，p标签中的内容是Hello，+输入内容。</p>
</li>
<li><p>让当前的程序可执行</p>
<p>目前可以直接调用main函数，后续会导成jar包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar build&#x2F;libs&#x2F;gs-serving-web-content-0.1.0.jar</span><br></pre></td></tr></table></figure>

<p>利用maven打成jar包，放到服务器，在服务器上直接运行上述命令即可。</p>
</li>
</ol>
<h5 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h5><p>​    SpringBoot特点是所有带有注解的文件，只要在当前application的同一级或下一级目录，就会自动加载进来。</p>
<ol>
<li><p>并列application的同一级创建一个package为<strong>controller</strong></p>
<ul>
<li><p>新建类，写注解@Controller，识别此类作为spring的bean管理，同时为一个controller（允许此类接收前端的请求）。新建一个返回值为String的hello方法，加上注解@GetMapping(“/hello”)。hello方法接收参数为@RequestParam，请求的是name，定义name跟model。</p>
<p>将浏览器中传入的值放入model中，</p>
<p>输出hello，此时会自动去resources.templates下去找模板。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(name = <span class="string">"name"</span>)</span> String name, Model model)</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"name"</span>,name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在templates下新建<strong>html</strong>文件<strong>hello</strong>(与contrller中返回类型同名)，代码为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Getting Started: Serving Web Content<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"'Hello, ' + $&#123;name&#125; + '!'"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动SpringBoot，输入<a href="http://localhost:8080/hello?name=hughzc，返回结果。hello名为html文件名。8080为默认端口。" target="_blank" rel="noopener">http://localhost:8080/hello?name=hughzc，返回结果。hello名为html文件名。8080为默认端口。</a></p>
<blockquote>
<p>Hello, hughzc!</p>
</blockquote>
</li>
<li><p>修改端口号，在<strong>配置</strong>文件(resources.application.properties)中进行修改，点击重新启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.port&#x3D;8887</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ol>
<h2 id="将代码放至Github托管"><a href="#将代码放至Github托管" class="headerlink" title="将代码放至Github托管"></a>将代码放至Github托管</h2><h3 id="简单流程"><a href="#简单流程" class="headerlink" title="简单流程"></a>简单流程</h3><ol>
<li><p>添加SSH keys，设置当前仓库的权限</p>
</li>
<li><p>在Github新建仓库</p>
</li>
<li><p>git init新建仓库</p>
</li>
<li><p>git add, commit 代码</p>
</li>
<li><p>修改git文件，加入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">	name = </span><br><span class="line">	email = @<span class="number">163</span>.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果这时候有新的commit，可以使用代码，进行commit的追加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit --amend  --no-edit</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用git push，将本地文件更新至仓库</p>
</li>
</ol>
<h2 id="明确需求"><a href="#明确需求" class="headerlink" title="明确需求"></a>明确需求</h2><h3 id="目标效果"><a href="#目标效果" class="headerlink" title="目标效果"></a>目标效果</h3><p><a href="https://elasticsearch.cn/" target="_blank" rel="noopener">elastic社区</a></p>
<ul>
<li>最上面为导航，功能分类，搜索功能， 登录</li>
<li>下面为一系列Tag</li>
<li>再下面为主要板块，topic列表，包括评论数，时间，人等元素</li>
<li>右边为热门元素</li>
</ul>
<h2 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h2><h3 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h3><p>​    <a href="https://v3.bootcss.com/getting-started/#download" target="_blank" rel="noopener">官方网站</a>，Bootstrap为前端UI框架，可以快速搭建出一个前端页面，在<strong>组件</strong>中可以浏览所需要的功能，前端组件轮子集合，可以极大减小开发量。</p>
<p>​    可以做到响应式布局，使用到了<a href="https://v3.bootcss.com/css/#grid" target="_blank" rel="noopener">栅格系统</a>，通过media设置尺寸，在不同屏幕尺寸下做不同的CSS样式。将整个浏览器分为12份，通过前缀后的数字组合实现快速布局。</p>
<h3 id="Bootstrap编写导航栏样式"><a href="#Bootstrap编写导航栏样式" class="headerlink" title="Bootstrap编写导航栏样式"></a>Bootstrap编写导航栏样式</h3><ul>
<li><p>下载Bootstrap</p>
</li>
<li><p>复制进src/main/resources/static(放资源文件)</p>
</li>
<li><p>更改resources/templates/hello.html为index.html</p>
<ul>
<li>修改社区名称<titile></titile></li>
<li>删除body中内容</li>
</ul>
</li>
<li><p>引入bootstrap，样式和js文件</p>
<p>可直接将所需要的文件拖入，自动加入其路径</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/bootstrap.min.css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/bootstrap-theme.min.css"</span> /&gt;</span></span><br><span class="line">&lt;script src="../static/js/bootstrap.min.js" type="application/javascript" &lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>拷贝需要的组件代码至body中</p>
<ul>
<li><p>导航条</p>
<p>修改名字，删去不需要的内容</p>
<p>初始样式效果</p>
<img src="/2019/12/29/SpringBoot-%E5%AD%A6%E4%B9%A0/%E5%AF%BC%E8%88%AA%E8%8C%83%E4%BE%8B.png" class title="初始结果">

<p>理想修改效果</p>
<img src="/2019/12/29/SpringBoot-%E5%AD%A6%E4%B9%A0/%E7%90%86%E6%83%B3%E7%A4%BE%E5%8C%BA%E5%AF%BC%E8%88%AA.png" class title="理想结果">
</li>
</ul>
</li>
<li><p>创建indexController</p>
<ul>
<li>给注解Contrller</li>
<li>匹配路径为根目录，即(“/”)，什么都不输入默认访问此路径</li>
<li>返回index模板</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">indexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">"index"</span>;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际修改效果</p>
<img src="/2019/12/29/SpringBoot-%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E9%99%85%E6%95%88%E6%9E%9C.png" class title="实际结果">

</li>
</ul>
<h2 id="利用Github-App实现登录"><a href="#利用Github-App实现登录" class="headerlink" title="利用Github App实现登录"></a>利用Github App实现登录</h2><p>​    实现登录功能，接入Github。查看API文档，找到<a href="https://developer.github.com/apps/" target="_blank" rel="noopener">OAuth Apps</a>，依据提示进行操作。</p>
<h3 id="创建APP"><a href="#创建APP" class="headerlink" title="创建APP"></a>创建APP</h3><p>​    <a href="https://developer.github.com/apps/building-oauth-apps/creating-an-oauth-app/" target="_blank" rel="noopener">依据网站提示</a>，在Github设置中进行创建</p>
<ol>
<li><p>填写APP名称</p>
</li>
<li><p>主页URL</p>
</li>
<li><p><a href="https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/" target="_blank" rel="noopener">callback URL</a></p>
<ul>
<li>用户被重定向以请求他们的GitHub身份</li>
<li>用户通过GitHub被重定向回您的站点</li>
<li>您的应用程序使用用户的访问令牌访问API</li>
</ul>
<p>需要拿到一些用户数据，正常来说直接在主页URL后加入callback，但是为了本地调试方便，地址为</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">http://localhost:8887/callback</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Github登录流程"><a href="#Github登录流程" class="headerlink" title="Github登录流程"></a>Github登录流程</h3><p>​    使用<a href="https://www.visual-paradigm.com" target="_blank" rel="noopener">Visual Paradig</a>利用时序图梳理登录流程。</p>
<ol>
<li><p>创建项目</p>
</li>
<li><p>创建diagram，选择Sequence diagram，表示对象和对象通过时间传递传递消息的路线。</p>
<p>用户向个人社区发出访问，社区进行登录。</p>
<ul>
<li>给Github发出认证，Github认证后回调 redirect_uri并携带code</li>
<li>用户持access_token 携带code，若匹配，Github返回access_token </li>
<li>站点发送user 携带access_token给Github，Github返回user信息</li>
<li>站点将user信息存入数据库，更新给用户登录状态</li>
<li>用户显示登录成功</li>
</ul>
</li>
</ol>
<img src="/2019/12/29/SpringBoot-%E5%AD%A6%E4%B9%A0/github%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B.png" class title="登录流程">

<h4 id="调用authorize"><a href="#调用authorize" class="headerlink" title="调用authorize"></a>调用authorize</h4><p>​    将登录按钮绑定地址，点击登录时可以跳转到指定地址并携带写入参数。将地址href写成<a href="https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/" target="_blank" rel="noopener">参考文档</a>中所给。</p>
<blockquote>
<p>URL中有多个参数时，第一个参数用<strong>?</strong>区分，之后的参数用<strong>&amp;</strong>区分</p>
</blockquote>
<p>​    在index.html中找到登录，传入必要参数(clien_id，redirect_uri，scope，state)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://github.com/login/oauth/authorize?client_id=github上给的&amp;redirect_uri=http://localhost:8887/callback&amp;scope=user&amp;state=1"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    这时候点击登录并授权后，网站会返回code信息，后面将code信息提取出来</p>
<h4 id="获取code"><a href="#获取code" class="headerlink" title="获取code"></a>获取code</h4><ol>
<li><p>写新的Controller</p>
<p>返回String类型的callback()，返回index主页，在calback中寻找，写GetMapping注解，需要传入参数，为用户写入的String类型的code和state。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">authorizeController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指向返回文件</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/callback"</span>)</span><br><span class="line">    <span class="comment">//使用name接收code，为String类型</span></span><br><span class="line">    <span class="comment">//使用name接收state，为String类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">callback</span><span class="params">(@RequestParam(name = <span class="string">"code"</span>)</span> String code,</span></span><br><span class="line"><span class="function">                           @<span class="title">RequestParam</span><span class="params">(name = <span class="string">"state"</span>)</span> String state)</span>&#123;</span><br><span class="line">        <span class="comment">//登录成功后返回index页面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模拟post请求</p>
<p>使用<a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType JSON</span><br><span class="line">    = MediaType.get(<span class="string">"application/json; charset=utf-8"</span>);</span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"><span class="function">String <span class="title">post</span><span class="params">(String url, String json)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  RequestBody body = RequestBody.create(json, JSON);</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .post(body)</span><br><span class="line">      .build();</span><br><span class="line">  <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">return</span> response.body().string();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>​    新建一个包provider，提供对第三方信息的支持能力，新建类GithubProvider</p>
<blockquote>
<p>体现思想：不同业务间进行隔离</p>
</blockquote>
<p>​    写注解@Component</p>
<blockquote>
<p>@Component 仅仅把当前类初始化Spring容器的上下文，这样调用时不用实例化对象，IOC，便于去调用对象</p>
</blockquote>
<p>​    查看文档，在使用Post请求时，有5个参数，当编程参数超过2个，不要使用形参传入，而是封装成对象。</p>
<p>​    新建一个包dto，即数据传输模型，新建类AccessTokenDTO，里面有需要传输的5个参数，快捷键alt+insert快速创建其getter和setter方法。</p>
<p>​    类GithubProvider中编写方法getAccessToken，接收AccessTokenDTO类型的数据。在此方法中拷贝OkHttp中的方法，引入jar包。</p>
<p>​    在Maven中添加依赖，找到pom.xml，将依赖代码复制进依赖中。</p>
<blockquote>
<p><a href="https://mvnrepository.com/" target="_blank" rel="noopener">Maven包查询</a></p>
</blockquote>
<p>将不必要的修饰删除，如public static final修饰。</p>
<ul>
<li>json就是自定义接收变量的access_token类变量，为了将access_token转化为json，需要jar包，使用<a href="https://mvnrepository.com/artifact/com.alibaba/fastjson" target="_blank" rel="noopener">fastjson</a>，将其依赖复制进pom.xml。方法中需要json，使用JSON.toJSONString(accessTokenDTO)，自动将accessToken转化成String类型的JSON。</li>
<li>url更改成<a href="https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/" target="_blank" rel="noopener">参考文档</a>中给出的POST地址</li>
<li>处理IO异常</li>
<li>最后返回null，如果取到了返回body。因为怀疑此body不是我们所需要的，因此可以先将其打印</li>
</ul>
<blockquote>
<p>遇到不知道是否正确的变量，可以打印进行调试</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAccessToken</span><span class="params">(AccessTokenDTO accessTokenDTO)</span></span>&#123;</span><br><span class="line">    MediaType mediaType = MediaType.get(<span class="string">"application/json; charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line">    RequestBody body = RequestBody.create(JSON.toJSONString(accessTokenDTO), mediaType);</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">            .url(<span class="string">"https://github.com/login/oauth/access_token"</span>)</span><br><span class="line">            .post(body)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">        String string = response.body().string();</span><br><span class="line">        System.out.println(string);</span><br><span class="line">        <span class="keyword">return</span> string;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    GithubProvider的getAccessToken已经封装好，在controller/AuthorizeController中进行调用。通过@Component注解 ，已经将GithubProvider放到了Spring的容器中，利用@Autowired注解将Spring容器中的写好的实例化的实例加载到当前使用的上下文。通过注解加定义实例将实例化好的放入，使用方便。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> GithubProvider githubProvider;</span><br></pre></td></tr></table></figure>

<p>​    在AuthorizeController的calback方法中，将需要的5个参数封装进AccessToken，调用githubProvider的getAccessToken方法实现post请求。</p>
<p>​    这时候启动项目，在localhost:8887页面点击登录，没有报错，而且在控制台打印了所需要的access_token。</p>
<blockquote>
<p>疑问，在AccessController中的mapping “callback”没有自己写，是Spring封装好的吗？</p>
<p>之前url有一个是callback的，应该是之前的那个</p>
</blockquote>
<p>​    即返回如下所示的字符串。这样通过access_token的api获取到了access_token。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">access_token=e72e16c7e42f292c6912e7710c838347ae178b4a&amp;token_type=bearer</span><br></pre></td></tr></table></figure>

<p>​    要获取到access_token，先用&amp;拆分，然后用=拆分。对应的更改代码为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String string = response.body().string();</span><br><span class="line">String token = string.split(<span class="string">"&amp;"</span>)[<span class="number">0</span>].split(<span class="string">"="</span>)[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> token;</span><br></pre></td></tr></table></figure>

<h4 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h4><p>官方文档第三步</p>
<blockquote>
<p>The access token allows you to make requests to the API on a behalf of a user.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Authorization: token OAUTH-TOKEN</span><br><span class="line">GET https:&#x2F;&#x2F;api.github.com&#x2F;user</span><br></pre></td></tr></table></figure>

<p>For example, in curl you can set the Authorization header like this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Authorization: token OAUTH-TOKEN&quot; https:&#x2F;&#x2F;api.github.com&#x2F;user</span><br></pre></td></tr></table></figure>
</blockquote>
<p>​    在<a href="https://github.com/settings/tokens/new" target="_blank" rel="noopener">github界面</a>创建新的personal access token，拿到user信息，用来测试。复制token用于验证是否是调用API就可以拿回数据。</p>
<p>​    验证方法，使用文档中给定的GET网址，加上github创建的access_token，ctrl+shift+n，在无痕网址界面进行验证，确实可以得到用户个人信息。测试完毕，删除此access_token。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">https://api.github.com/user?access_token=自己的access_token</span><br></pre></td></tr></table></figure>

<p>​    在GithubProvider中再写方法，通过access_token获取到用户信息。需要的参数是id，name，bio。</p>
<p>​    在dto中创建对象GithubUser。有三个属性，String的name和bio,long类型的id以避免越界。GithubUser是GithubProvider的一个返回值。使用<a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">okhttp</a>的get方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">run</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">    <span class="keyword">return</span> response.body().string();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    url为测试所用的url，但accesstoken不同。</p>
<p>​    浏览器返回的是json的格式，拿到获取的response的string，使用<strong>JSON.parseObject(string)</strong>，将<strong>string</strong>自动转化为java类对象。这样将String的json对象去自动解析转换成java的类对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> GithubUser <span class="title">getUser</span><span class="params">(String accessToken)</span></span>&#123;</span><br><span class="line">    OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">            .url(<span class="string">"https://api.github.com/user?access_token="</span>+accessToken)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Response response = client.newCall(request).execute();</span><br><span class="line">        String string = response.body().string();</span><br><span class="line">        GithubUser githubUser = JSON.parseObject(string,GithubUser<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> githubUser;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在AuthorizeController中调用GithubProvider.getUser(accessToken)，将user进行打印，看是否是所需要的。通过github的user的api携带access_token获取到了用户信息。</p>
<blockquote>
<p>出现错误，在点击登录的时候并灭有出现理想的user姓名，而是空，先检查了access_token，发现是正确的，则说明是getUser()方法出现了问题，进行检查后发现是url里面少写了一个“=”。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizeController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Autowired与Component，调用GithubProdiver</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GithubProvider githubProvider;</span><br><span class="line">    <span class="comment">//指向返回文件</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/callback"</span>)</span><br><span class="line">    <span class="comment">//使用name接收code，为String类型</span></span><br><span class="line">    <span class="comment">//使用name接收state，为String类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">callback</span><span class="params">(@RequestParam(name = <span class="string">"code"</span>)</span> String code,</span></span><br><span class="line"><span class="function">                           @<span class="title">RequestParam</span><span class="params">(name = <span class="string">"state"</span>)</span> String state)</span>&#123;</span><br><span class="line">        AccessTokenDTO accessTokenDTO = <span class="keyword">new</span> AccessTokenDTO();</span><br><span class="line">        accessTokenDTO.setClient_id(<span class="string">"网站给定"</span>);</span><br><span class="line">        accessTokenDTO.setClient_secret(<span class="string">"网站给定"</span>);</span><br><span class="line">        accessTokenDTO.setCode(code);</span><br><span class="line">        accessTokenDTO.setState(state);</span><br><span class="line">        accessTokenDTO.setRedirect_uri(<span class="string">"http://localhost:8887/callback"</span>);</span><br><span class="line">        String accessToken = githubProvider.getAccessToken(accessTokenDTO);</span><br><span class="line">        GithubUser user = githubProvider.getUser(accessToken);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">        <span class="comment">//登录成功后返回index页面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置文件的分离application-proerties"><a href="#配置文件的分离application-proerties" class="headerlink" title="配置文件的分离application.proerties"></a>配置文件的分离application.proerties</h2><blockquote>
<p>体现的思路：要用到的时候在进行设计，不要过度设计</p>
</blockquote>
<p>​    之前将各种信息都写在了代码中，在线上部署的时候，地址这些需要手动修改，比较麻烦，要做到不同的环境去读取配置文件，将需要的信息写上不同的内容。写在application.proerties中。需要的有Client_id，Client_secret和Redirect_uri。</p>
<blockquote>
<p>server.port = 8887，含义是server下面的port值是8887</p>
</blockquote>
<p>​    修改配置文件为</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">github.client.id</span> = <span class="string">给定的</span></span><br><span class="line"><span class="meta">github.client.secret</span> = <span class="string">给定的</span></span><br><span class="line"><span class="meta">github.redirect.uri</span> = <span class="string">http://localhost:8887/callback</span></span><br></pre></td></tr></table></figure>

<p>​    通过value注解来使用</p>
<blockquote>
<p>@Value(“${string}”)，在配置文件中读取key为string的value</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;github.client.id&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String clientId;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;github.client.secret&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String clientSecret;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;github.redirect.uri&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String redirectUri;</span><br></pre></td></tr></table></figure>

<p>​    然后可以通过变量名直接使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">accessTokenDTO.setClient_id(clientId);</span><br><span class="line">accessTokenDTO.setClient_secret(clientSecret);</span><br><span class="line">   accessTokenDTO.setRedirect_uri(redirectUri);</span><br></pre></td></tr></table></figure>

<h2 id="Session和Cookies原理和实现"><a href="#Session和Cookies原理和实现" class="headerlink" title="Session和Cookies原理和实现"></a>Session和Cookies原理和实现</h2><p>​    Session的简单理解是在银行开户，银行中存有你的账户信息。Cookies是银行卡，去银行取钱需要银行卡。在网页的application下可以看到cookie</p>
<img src="/2019/12/29/SpringBoot-%E5%AD%A6%E4%B9%A0/cookies.png" class title="This is an example image">

<p>​    看到有多张银行卡</p>
<ul>
<li>domain代表银行，cookie不能跨域，每条记录都有个域名，路径和过期时间，如15天可用这种。</li>
<li>name相当于卡号</li>
<li>value相当于卡号对应的唯一标识</li>
</ul>
<p>​      可在network中看向服务端请求的信息。Request中有cookie信息，服务端通过cookie找到session，返回，渲染到页面。</p>
<p>​      要做到的效果是，没有登录的时候，有登录和我，登录成功后，我变成登陆者的名字，去掉登录。 </p>
<p>​     在AuthorizeController下有callback，在user不为空的时候，可以证明登录成功。</p>
<p>​    session在httprequest中拿到，将user对象放入session，此时框架集成了功能，使得前端有了指定的cookie。重新返回到index主页。使用redirect会将地址那些去掉，重定向到指定界面。这时候就写到了cookie，还需要在页面展示。</p>
<p>​    在前端界面进行修改，如果有session，则展示我。</p>
<blockquote>
<p>不知道如何实现，则直接baidu，用关键词搜索，不要用自己的上下文语义</p>
</blockquote>
<p>​    在callback()方法中增加参数 <strong>HttpServletRequest request</strong>，在接收到user后写上判断语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(user != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//登录成功，写cookie和session</span></span><br><span class="line">            <span class="comment">//将user对象放入session，框架集成，前端有了银行卡</span></span><br><span class="line">            request.getSession().setAttribute(<span class="string">"user"</span>,user);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"redirect:index"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//登录失败，重新登陆</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"redirect:index"</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>​    在前端页面修改逻辑，如果session.user不为空，显示我；如果为空，显示登录</p>
<blockquote>
<p>在改动大的时候，注意看控制台，会有提示信息</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"dropdown"</span> <span class="attr">th:if</span>=<span class="string">"$&#123;session.user != null&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"dropdown-toggle"</span> <span class="attr">data-toggle</span>=<span class="string">"dropdown"</span> <span class="attr">role</span>=<span class="string">"button"</span> <span class="attr">aria-haspopup</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">aria-expanded</span>=<span class="string">"false"</span>&gt;</span>我 <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"caret"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"dropdown-menu"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>消息中心<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>个人资料<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>退出登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">th:unless</span>=<span class="string">"$&#123;session.user == null&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://github.com/login/oauth/authorize?client_id=eb92e00b211c84362136&amp;redirect_uri=http://localhost:8887/callback&amp;scope=user&amp;state=1"</span>&gt;</span></span><br><span class="line">    登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    但是没有登录也没有我，修改语法。将unless语法修改为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">th:unless</span>=<span class="string">"not $&#123;session.user != null&#125;"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://github.com/login/oauth/authorize?client_id=eb92e00b211c84362136&amp;redirect_uri=http://localhost:8887/callback&amp;scope=user&amp;state=1"</span>&gt;</span></span><br><span class="line">     登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    还是不行，进行调试，因为还没有点击登录，因此session为空。在页面中打印user,在GithubUser类中，重写其toString()方法。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">"$&#123;session.user&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    在网页的检查，element中找到代码对应相应位置，可以看到没有值。</p>
<p>​    重新修改语法，两个都使用if。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">th:if</span>=<span class="string">"$&#123;session.user == null&#125;"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://github.com/login/oauth/authorize?client_id=eb92e00b211c84362136&amp;redirect_uri=http://localhost:8887/callback&amp;scope=user&amp;state=1"</span>&gt;</span></span><br><span class="line">     登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    然后可以进行提交，但没有重定向到主页，说明重定向语法写错，修改为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">"redirect:/"</span>;</span><br></pre></td></tr></table></figure>

<p>​    这时候登录后变成我，而且刷新也不变化，说明已经将登录态记住了。这时候查看Application，出现了cookies。默认写了一个key，发送请求时，将name和value拼到cookie请求头中，发到服务端，通过cookie的key去找requst的session</p>
<img src="/2019/12/29/SpringBoot-%E5%AD%A6%E4%B9%A0/%E9%BB%98%E8%AE%A4cookie.png" class title="This is an example image">

<p>​    然后将显示的我修改成个人名称，在index中将我去掉，添加<strong>th:text=”${session.user.getName()}</strong>变成如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"dropdown-toggle"</span> <span class="attr">data-toggle</span>=<span class="string">"dropdown"</span> <span class="attr">role</span>=<span class="string">"button"</span> <span class="attr">aria-haspopup</span>=<span class="string">"true"</span> <span class="attr">aria-expanded</span>=<span class="string">"false"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;session.user.getName()&#125;"</span> &gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"caret"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    但是每次重启服务器，用户都需要重新登录，如何解决？将登录信息持久化到数据库。</p>
<h2 id="MySQL基本概念及语法"><a href="#MySQL基本概念及语法" class="headerlink" title="MySQL基本概念及语法"></a>MySQL基本概念及语法</h2><p>​    MySQL是一个DataBase(数据库)，在数据库下有Table(表)，用表来承载数据，表下面是记录Record，之间为组合关系。没有一者，另一者也不存在。</p>
<img src="/2019/12/29/SpringBoot-%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%B8%89%E5%B1%82%E6%A8%A1%E5%9E%8B.png" class title="This is an example image">

<p>​    <a href="https://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener">MySQL菜鸟教程资料</a>。</p>
<ul>
<li><p>创建数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> 数据库名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (column_name column_type);</span><br></pre></td></tr></table></figure>

<p>在 RUNOOB 数据库中创建数据表runoob_tbl：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`runoob_tbl`</span>(</span><br><span class="line">   <span class="string">`runoob_id`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> AUTO_INCREMENT,</span><br><span class="line">   <span class="string">`runoob_title`</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   <span class="string">`runoob_author`</span> <span class="built_in">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">   <span class="string">`submission_date`</span> <span class="built_in">DATE</span>,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span> ( <span class="string">`runoob_id`</span> )</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<p> 具体含义为：如果存在就删除，不存在就创建表，具体有int类型的id（逐渐自动增长），String类型的title，author，工具栏日Date类型的date。PRIMARY KEY表示每个表有自己的主键。</p>
</li>
<li><p>插入数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name ( field1, field2,...fieldN )</span><br><span class="line">                       <span class="keyword">VALUES</span></span><br><span class="line">                       ( value1, value2,...valueN );</span><br></pre></td></tr></table></figure>

<p>具体例子为</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; INSERT INTO runoob_tbl </span><br><span class="line">    -&gt; (runoob_title, runoob_author, submission_date)</span><br><span class="line">    -&gt; VALUES</span><br><span class="line">    -&gt; ("学习 PHP", "菜鸟教程", NOW());</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name,column_name</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line">[<span class="keyword">WHERE</span> Clause]</span><br><span class="line">[<span class="keyword">LIMIT</span> N][ <span class="keyword">OFFSET</span> M]</span><br></pre></td></tr></table></figure>

<p>含义为查询…，从….中，在…条件下，限制N个，从M开始。通过分页从数据库中拿出数据。</p>
<p>具体例子为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> runoob_tbl;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Update更新</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> field1=<span class="keyword">new</span>-value1, field2=<span class="keyword">new</span>-value2</span><br><span class="line">[<span class="keyword">WHERE</span> Clause]</span><br></pre></td></tr></table></figure>

<p>具体例子为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> runoob_tbl <span class="keyword">SET</span> runoob_title=<span class="string">'学习 C++'</span> <span class="keyword">WHERE</span> runoob_id=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>delete删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name [<span class="keyword">WHERE</span> Clause]</span><br></pre></td></tr></table></figure>

<p>具体例子为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ELETE FROM runoob_tbl WHERE runoob_id=3;</span><br></pre></td></tr></table></figure>

<p>删除id=3时的数据。</p>
</li>
</ul>
<h2 id="H2数据库"><a href="#H2数据库" class="headerlink" title="H2数据库"></a>H2数据库</h2><p> <a href="http://h2database.com/html/main.html" target="_blank" rel="noopener">H2数据库</a>是一个快速的内置数据库，通过浏览器或控制台直接仿问，在pom中添加其依赖，在IDEA中的Database添加H2数据库，使用embedded连接方式，路径选择为：在根目录下，以项目命名。</p>
<blockquote>
<p>在WIN10下，选择Data Source From Path，更好用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdbc:h2:C:&#x2F;Code&#x2F;mycommunity</span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个table user，增加一个column，name为id，自动增长，主键</li>
<li>增加一个account_id，类型为VARCHAR(100)，即长度为100个字符的字符串</li>
<li>增加name，类型为VARCHAR(50)</li>
<li>自己设置value，登录成功后，手动设置到Cookie中，当传递过来时，拿值在数据库中查找，命名为token，类型为char(36)</li>
<li>数据库的信息有两个时间，创建时间和修改时间，用于去排查问题，gmt为格林尼标准时间<ul>
<li>增加gmt_create，类型为BIGINT，相当于Long</li>
<li>增加gmt_modified，类型为BIGINT</li>
</ul>
</li>
</ul>
<img src="/2019/12/29/SpringBoot-%E5%AD%A6%E4%B9%A0/H2%E5%88%9B%E5%BB%BA.png" class title="This is an example image">

<p>对应到具体的代码为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span> auto_increment,</span><br><span class="line">	account_id <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">	<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">	token <span class="built_in">char</span>(<span class="number">36</span>),</span><br><span class="line">	gmt_create <span class="built_in">BIGINT</span>,</span><br><span class="line">    gmt_modified <span class="built_in">BIGINT</span>,</span><br><span class="line">	<span class="keyword">constraint</span> user_pk</span><br><span class="line">		primary <span class="keyword">key</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="集成MyBatis并实现插入操作"><a href="#集成MyBatis并实现插入操作" class="headerlink" title="集成MyBatis并实现插入操作"></a>集成MyBatis并实现插入操作</h2><blockquote>
<p>快速实现的思想：baidu搜索关键词然后在官网上看一手资料</p>
</blockquote>
<p> MyBatis 是支持普通 SQL查询，存储过程和高级映射的优秀持久层框架。找到<a href="http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/" target="_blank" rel="noopener">MyBatis官方资料</a>，按照步骤操作，查阅<a href="https://docs.spring.io/spring-boot/docs/2.0.0.RC1/reference/htmlsingle/#boot-features-embedded-database-support" target="_blank" rel="noopener">Spring文档</a>。</p>
<ul>
<li><p>添加依赖</p>
</li>
<li><p>需要DataSource，在Spring中定义连接池，在application.properties中添加配置文件</p>
<ul>
<li><p>添加spring-boot-starter-jdbc依赖</p>
</li>
<li><p>在配置文件中添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.datasource.url=jdbc:h2:C:/Code/mycommunity</span><br><span class="line">spring.datasource.username=sa</span><br><span class="line">spring.datasource.password=123</span><br><span class="line">spring.datasource.driver-class-name=org.h2.Driver</span><br></pre></td></tr></table></figure>

<p>org.h2.Driver报错，查询后将h2的Maven依赖的test标签去掉即可。</p>
</li>
</ul>
</li>
<li><p>提供Mapper</p>
<p>新建包mapper，新建类UserMapper。</p>
<ul>
<li><p>写Mapper注解，添加insert接口，传入User类型的数据，alt+回车导入自己写的数据库model的User类</p>
</li>
<li><p>新建类model，用于数据库传数据，新建类User，含有设置数据库的6种变量</p>
</li>
<li><p>写insert注解，添加“”写SQL的查询语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name ( field1, field2,...fieldN )</span><br><span class="line">                       <span class="keyword">VALUES</span></span><br><span class="line">                       ( value1, value2,...valueN );</span><br></pre></td></tr></table></figure>

<p>第一个参数括号中写要传入的参数，values后的括号要加#{}</p>
<p>这样MyBatis可以将Object user中的名为#{}的值自动替换为object中对应值。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into user (name,accout_id,token,gmt_create,gmt_modified) values (#&#123;name&#125;,#&#123;accountId&#125;,#&#123;token&#125;,#&#123;gmtCreate&#125;,#&#123;gmtModified&#125;)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在AuthorizeController中，当user不为空时，将其添加进数据库</p>
<ul>
<li><p>通过注解@Autowired将UserMapper注解进来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserMapper userMapper;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用其userMapper的insert方法，新建User对象，用ctrl+alt+v快捷键</p>
</li>
<li><p>设置user的属性</p>
<ul>
<li>token采用UUID来做</li>
<li>name为githubUser的name</li>
<li>id将githubUser的ID转为String类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">            <span class="comment">//set user values</span></span><br><span class="line">            user.setToken(UUID.randomUUID().toString());</span><br><span class="line">            user.setName(githubUser.getName());</span><br><span class="line">            user.setAccountId(String.valueOf(githubUser.getId()));</span><br><span class="line">            user.setGmtCreate(System.currentTimeMillis());</span><br><span class="line">            user.setGmtModified(user.getGmtCreate());</span><br><span class="line">            userMapper.insert(user);</span><br></pre></td></tr></table></figure>

<p> 点击登录后，在数据库中存下了信息。</p>
<p> 当想测试，可以打断点，然后点击debug按钮。</p>
<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><ol>
<li><p>无法找到数据库</p>
<p>删除user table，重新添加</p>
</li>
<li><p>找不到ACCOUT_ID Column</p>
<p>在INSERT注解中语法写错，将account_id错写为accout_id，因此在H2数据库中找不到指定的column</p>
</li>
</ol>
<h2 id="获取登录状态"><a href="#获取登录状态" class="headerlink" title="获取登录状态"></a>获取登录状态</h2><p> 以token为依据，绑定前端和后端的登录状态，将token抽取成变量，手动写key和value，手动将session和user进行识别。在数据库中查询是否在数据库中，存在则登录成功，不存在则登陆失败。此时不需要写入session，因为插入数据库的过程相当于写入session，在形参中注入<strong>HttpServletResponse</strong>，通过response写入cookie。</p>
<p> 不知道应该传输什么参数，使用ctrl+P。新建cookie，name为‘“token”，value为之前定义的token。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.addCookie(<span class="keyword">new</span> Cookie(<span class="string">"token"</span>,token));</span><br></pre></td></tr></table></figure>

<p> 此时因为没有写入session，session为空，因此网页上还是显示的是登录。检查网工业源码，在application中找到了自己写入的token。</p>
<p> 需要访问网页时将key为token的cookie信息拿到，因此在indexController中，先注入userMapper(只有在userMapper中才可以访问user)，希望userMapper中有findByToken方法，传入token，然后返回model包中的user对象。在index函数中增加参数<strong>HttpServletRequest</strong>，利用其获得到Cookie，使用ctrl+alt+v，快速生成变量，将得到cookies进行for循环，快捷写法：cookies.for，然后自动变成for循环。如果cookies中含有token，获得其value，为所需要的token。然后userMapper中创建相应方法(alt+回车，快速修复)，获得到user对象。</p>
<blockquote>
<p>设置cookie，使用response；获得cookie，使用request</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"token"</span>.equals(cookie.getName()))&#123;</span><br><span class="line">        String token = cookie.getValue();</span><br><span class="line">        User user = userMapper.findByToken(token);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在UserMapper类中新建方法，注解为Select。查询数据库中是否包含token。</p>
<p> MyBatis编译时，将形参中的值放入#{}对应的进行替换，如果是类可以直接进行替换，如果不是类，需要加入注解。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">Select</span>(<span class="string">"select * from user where token = #&#123;token&#125;"</span>)</span><br><span class="line"><span class="keyword">User</span> findByToken(@Param(<span class="string">"token"</span>) <span class="keyword">String</span> token);</span><br></pre></td></tr></table></figure>

<p> user相当于数据库和java类交互的模型，用user类插入数据，从数据库中查询数据返回User类。拿到user类后，需要与前端交互。</p>
<p> 如果user不为空，就将session写入user中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认要求依赖对象必须存在</span></span><br><span class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"token"</span>.equals(cookie.getName()))&#123;</span><br><span class="line">                String token = cookie.getValue();</span><br><span class="line">                User user = userMapper.findByToken(token);</span><br><span class="line">                <span class="keyword">if</span> (user != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    request.getSession().setAttribute(<span class="string">"user"</span>,user);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p> 如果服务器重启或者链接突然断开，再次连接需要重新登录，比较麻烦，因此将cookie持久化至数据库中，虽然cookie可以存储很多信息，但不应该将私密信息存储在cookie中，cookie中只存储令牌信息或token，从而前后端交互使用。</p>
<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p> 当用户量很大，请求信息很多时，会比较慢。可以用redis等去改进。</p>
<h2 id="集成Flyway-Migration"><a href="#集成Flyway-Migration" class="headerlink" title="集成Flyway Migration"></a>集成Flyway Migration</h2><p> 在获取到用户信息时，GithubUser中的bio没有用到，因此在数据库中添加项，右键user点击modified。但是这样一个人改动，其他人数据库都要重新添加数据库脚本，比较麻烦。</p>
<p> 使用数据库的迁移原因是：自动将不同人的数据库版本进行整合，自动管理数据库版本。</p>
<p> 进入<a href="https://flywaydb.org/getstarted/" target="_blank" rel="noopener">Flyway官网</a>，查看其Maven方式，将其plugin代码拷贝进pom.xml同级标签下，将其url地址更改为application.propertites中字段，user，password也做相应更改。保持数据库版本一致。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>jdbc:h2:C:/Code/mycommunity<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span>sa<span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">password</span>&gt;</span>123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 创建src/main/resources/db/migration，文件命名方式仿照如下</p>
<blockquote>
<p>src/main/resources/db/migration/V1__Create_person_table.sql</p>
</blockquote>
<p> 新建文件V1__Create_user_table.sql，将之前的sql语句粘贴。</p>
<p> 先删除原数据库，然后运行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn flyway:migrate</span><br></pre></td></tr></table></figure>

<p> 这样自动生成了新的数据库，而且生成flyway_shema_history文件，记录数据库执行过程，当有多个人执行数据库时，以文件中的记录为准；</p>
<p> 当数据库表格变更时，如要新增一个VARCHAR(256)类型的bio，<strong>不直接在数据库中添加</strong>，而是写好语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">USER</span> <span class="keyword">add</span> bio <span class="built_in">VARCHAR</span>(<span class="number">256</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以先在IDEA的数据库中做对应操作，然后复制对应语句，这样不用自己去写语句，但是最后不能点执行，不然flyway操作会失败</p>
</blockquote>
<p> 然后复制要变更的语句，复制在migration文件夹下生成新的文件V2__Add_bio_col_to_user_table.sql，重新运行flyway命令。这样子user数据库便新增了一个col为bio。</p>
<blockquote>
<p>相当于对数据库的每条操作都分批次写在sql文件中，然后运行flyway对对应生成相应的数据库。</p>
</blockquote>
<p> 无论表有多么细小的改动，都要重新创建一个对应的sql文件，不然会抛出异常，因为表对应的状态码改变了。降低数据库维护难度。</p>
<h2 id="Bootstrap编写问题发布界面"><a href="#Bootstrap编写问题发布界面" class="headerlink" title="Bootstrap编写问题发布界面"></a>Bootstrap编写问题发布界面</h2><p> 仿照网站模板去做</p>
<img src="/2019/12/29/SpringBoot-%E5%AD%A6%E4%B9%A0/%E5%8F%91%E8%B5%B7%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF.jpg" class title="This is an example image">

<p> 需要有标题输入框，内容框，标签，确认发起和发起指南。拷贝一份index页面叫做publish。title改为发布-未名社区，上面一栏其他不用改变，在下面去添加内容。</p>
<p> 目测为3:1的左右分割布局，使用<a href="https://v3.bootcss.com/css/#grid" target="_blank" rel="noopener">SpringBoot栅格系统</a>中的流式布局</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container-fluid"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 3:1在栅格系统（12份）下，为9:3，使用大屏幕尺寸，类前缀为.col-lg-，先敲下div.col-lg-9，然后按下<strong>Tab键</strong>，自动生成一个div。</p>
<p> 当屏幕变小的时候，从col-lg-9部分均占据全部页面，即其他尺寸比例变化，不同尺寸比例用<strong>空格</strong>隔开。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-9 col-md-12 col-sm-12 col-xs-12"</span> <span class="attr">style</span>=<span class="string">"background-color: red;height: 300px"</span>;&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-3 col-md-12 col-sm-12 col-xs-12"</span> <span class="attr">style</span>=<span class="string">"background-color: green;height: 300px"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 其中背景色，高度均为style下的属性，不同属性间用分号隔开。</p>
<p> 进入publish网页，需要写PublishController。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PublishController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/publish"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">publish</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"publish"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 进入publish界面，可以看到在正常窗口下是9:3比例，当界面缩小后，变成了红色在上，绿色在下，均铺满整个窗口。</p>
<img src="/2019/12/29/SpringBoot-%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8.jpg" class title="This is an example image">

<img src="/2019/12/29/SpringBoot-%E5%AD%A6%E4%B9%A0/%E5%85%B6%E4%BB%96%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8.jpg" class title="This is an example image">

<p>页面中需要一个输入框，使用组件，有一个发起，找到好看的icon。在div中加入标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-search"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 将class中名称替换为所需要的，然后加入h2，文本为发起。span为h2块置元素，将其放在h2中。</p>
<p> 增加基本输入框，被form包裹，action为点击时所提交地址。placeholder为当没有输入时，默认显示文字。修改type为text，id和for为title，增加name为title。</p>
<p> 下面为问题补充，为文本输入框，因此在label下增加textarea标签，加入class。</p>
<p> 标签页需要输入框，再增加绿色的提交按钮。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn btn-success"</span>&gt;</span>（成功）Success<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 最后上面一部分代码为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"title"</span>&gt;</span>问题标题（简单扼要）：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">id</span>=<span class="string">"title"</span> <span class="attr">name</span>=<span class="string">"title"</span> <span class="attr">placeholder</span>=<span class="string">"问题标题..."</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"title"</span>&gt;</span>问题补充（必填：请参照右边提示）：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">id</span>=<span class="string">"description"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">cols</span>=<span class="string">"30"</span> <span class="attr">rows</span>=<span class="string">"10"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"title"</span>&gt;</span>添加标签：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">id</span>=<span class="string">"tag"</span> <span class="attr">name</span>=<span class="string">"tag"</span> <span class="attr">placeholder</span>=<span class="string">"输入标签，以，号分隔"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">class</span>=<span class="string">"btn btn-success"</span>&gt;</span>发布<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 然后为增加问题发布导航界面。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-3 col-md-12 col-sm-12 col-xs-12"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h3</span>&gt;</span>问题发起指南<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    ● 问题标题：请用精简的语言描述您发布的问题，不超过25字</span><br><span class="line">    ● 问题补充：详细描述您的问题内容，并确保问题描述清晰直观，并提供一些相关的资料</span><br><span class="line">    ● 选择标签：选择一个或者多个合适的标签，用逗号隔开，每个标签不超过10个字</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 得到效果为</p>
<img src="/2019/12/29/SpringBoot-%E5%AD%A6%E4%B9%A0/%E9%97%AE%E9%A2%98%E5%8F%91%E5%B8%83%E7%95%8C%E9%9D%A2.png" class title="This is an example image">

<p>进一步修复样式，通过<strong>检查</strong>来做。在浏览器中编辑，实时预览，然后拷贝代码。</p>
<p> 发现这一部分的代码应该放在nav外层，使用ctrl+w同时选中上下层。将其放在nav下面。</p>
<p> 在static/css下面增加community.css文件</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 将其拷贝至publish页面中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/community.css"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p> 在提问部分的div class中加上main</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container-fluid main"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 这样将导航和问题发布界面隔开。</p>
<img src="/2019/12/29/SpringBoot-%E5%AD%A6%E4%B9%A0/margin30.jpg" class title="This is an example image">

<p>为了有突出效果，将最外层的body颜色改为灰色，将内容发布界面颜色改为白色。让发布按钮飘在右边。加入float</p>
<img src="/2019/12/29/SpringBoot-%E5%AD%A6%E4%B9%A0/%E5%8F%91%E5%B8%83%E6%8C%89%E9%92%AE.jpg" class title="This is an example image">

<p> 修改css代码，增加body，修改颜色为灰色，修改main部分颜色为白色。增加btn-publish按钮。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#efefef</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: white;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn-publish</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在button的class后面进行追加</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">class</span>=<span class="string">"btn btn-success btn-publish"</span>&gt;</span>发布<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 这样样式基本达成效果。</p>
<p> 网页添加部分完整代码为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container-fluid main"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-9 col-md-12 col-sm-12 col-xs-12"</span> ;&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-plus"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>发起<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"title"</span>&gt;</span>问题标题（简单扼要）：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">id</span>=<span class="string">"title"</span> <span class="attr">name</span>=<span class="string">"title"</span> <span class="attr">placeholder</span>=<span class="string">"问题标题..."</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"title"</span>&gt;</span>问题补充（必填：请参照右边提示）：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">id</span>=<span class="string">"description"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">cols</span>=<span class="string">"30"</span> <span class="attr">rows</span>=<span class="string">"10"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"title"</span>&gt;</span>添加标签：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">id</span>=<span class="string">"tag"</span> <span class="attr">name</span>=<span class="string">"tag"</span> <span class="attr">placeholder</span>=<span class="string">"输入标签，以，号分隔"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">class</span>=<span class="string">"btn btn-success btn-publish"</span>&gt;</span>发布<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-3 col-md-12 col-sm-12 col-xs-12"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h3</span>&gt;</span>问题发起指南<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            ● 问题标题：请用精简的语言描述您发布的问题，不超过25字</span><br><span class="line">            ● 问题补充：详细描述您的问题内容，并确保问题描述清晰直观，并提供一些相关的资料</span><br><span class="line">            ● 选择标签：选择一个或者多个合适的标签，用逗号隔开，每个标签不超过10个字</span><br><span class="line">            <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><h3 id="创建Table，存储发布者数据"><a href="#创建Table，存储发布者数据" class="headerlink" title="创建Table，存储发布者数据"></a>创建Table，存储发布者数据</h3><p>数据库数据包括：id(primary key), title, descrption, gmt_create, gmt_modified, creator, comment_count, view_count, like_count, tag。基本思路为先利用IDEA添加所需要的信息，然后复制生成的表格代码如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> question</span><br><span class="line">(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span> auto_increment,</span><br><span class="line">	title <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">	description <span class="built_in">TEXT</span>,</span><br><span class="line">	gmt_create <span class="built_in">BIGINT</span>,</span><br><span class="line">	gmt_modified <span class="built_in">BIGINT</span>,</span><br><span class="line">	creator <span class="built_in">int</span>,</span><br><span class="line">	comment_count <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">	view_count <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">	like_count <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">	tag <span class="built_in">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">	<span class="keyword">constraint</span> question_pk</span><br><span class="line">		primary <span class="keyword">key</span> (<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>​    在Flyway中创建新脚本，命名为V3__Create_question_table.sql。将sql代码粘贴进此文件，运行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn flyway:migrate</span><br></pre></td></tr></table></figure>

<h3 id="写Mapper文件"><a href="#写Mapper文件" class="headerlink" title="写Mapper文件"></a>写Mapper文件</h3><p>在mapper包下新建类QuestionMapper，增加Mapper注解，将类更改为interface，写create函数，需要传入question类，然后增加Insert注解，写入相关sql语句，即 insert into (写表中需要插入名称) values (#{question类中相关变量名称})</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QuestionMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into (title,description,gmt_create,gmt_modified,creator,tag) values (#&#123;title&#125;,#&#123;description&#125;,#&#123;gmtCreate&#125;,#&#123;gmtModified&#125;,#&#123;creator&#125;,#&#123;tag&#125;)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(Question question)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在model包中添加类Question，包含以下变量，并alt+insert创建getter和setter方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String title;</span><br><span class="line"><span class="keyword">private</span> String description;</span><br><span class="line"><span class="keyword">private</span> String tag;</span><br><span class="line"><span class="keyword">private</span> Long gmtCreate;</span><br><span class="line"><span class="keyword">private</span> Long gmtModified;</span><br><span class="line"><span class="keyword">private</span> Integer creator;</span><br><span class="line"><span class="keyword">private</span> Integer viewCount;</span><br><span class="line"><span class="keyword">private</span> Integer commentCount;</span><br><span class="line"><span class="keyword">private</span> Integer likeCount;</span><br></pre></td></tr></table></figure>

<p>​    修改publish.html中回答问题部分，添加form后面内容，action路由到publish界面，提交post请求</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/publish"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    get为渲染页面，post为执行请求。在PublishController中增加方法</p>
<p>​    仍然返回publish界面，前后端未分离带来。增加PostMapping注解，接收参数title,description,tag。利用Autowired持有questionmapper，并调用其create方法。ctrl+P查看其需要参数，需要question，新建一个question，ctrl+alt+v，将变量抽取出来。给question设置变量。shift+回车，换行。</p>
<p>​    为了获取到user，可以利用index中的利用cookie来获取。request利用HttpServletRequest注入，usermapper利用@Autowired自动注入。为了在服务端API接口级别传递到页面中，将要传递的写入Model。</p>
<p>如果获取到的user为空，则需要给model传入错误信息，并且回到publish界面。如果有错误提示，alt+回车。将信息填入后，回到首页。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> QuestionMapper questionMapper;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@PostMapping</span>(<span class="string">"/publish"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">doPublish</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           @RequestParam(<span class="string">"title"</span>)</span> String title,</span></span><br><span class="line"><span class="function">           @<span class="title">RequestParam</span><span class="params">(<span class="string">"description"</span>)</span> String description,</span></span><br><span class="line"><span class="function">           @<span class="title">RequestParam</span><span class="params">(<span class="string">"tag"</span>)</span> String tag,</span></span><br><span class="line"><span class="function">           HttpServletRequest request,</span></span><br><span class="line"><span class="function">           Model model)</span>&#123;</span><br><span class="line">       User user = <span class="keyword">null</span>;</span><br><span class="line">       Cookie[] cookies = request.getCookies();</span><br><span class="line">       <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="string">"token"</span>.equals(cookie.getName()))&#123;</span><br><span class="line">               String token = cookie.getValue();</span><br><span class="line">               user = userMapper.findByToken(token);</span><br><span class="line">               <span class="keyword">if</span> (user != <span class="keyword">null</span>)&#123;</span><br><span class="line">                   request.getSession().setAttribute(<span class="string">"user"</span>,user);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (user == <span class="keyword">null</span>)&#123;</span><br><span class="line">           model.addAttribute(<span class="string">"error"</span>,<span class="string">"用户未登陆"</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"publish"</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       Question question = <span class="keyword">new</span> Question();</span><br><span class="line">       question.setTitle(title);</span><br><span class="line">       question.setDescription(description);</span><br><span class="line">       question.setTag(tag);</span><br><span class="line">       question.setCreator(user.getId());</span><br><span class="line">       question.setGmtCreate(System.currentTimeMillis());</span><br><span class="line">       question.setGmtModified(question.getGmtModified());</span><br><span class="line"></span><br><span class="line">       questionMapper.create(question);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"redirect:/"</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​    为了提示错误信息，在publish.html界面，在提交问题的上方，增加一个span，修改class为bootstrap中的警告框，文本为错误信息。</p>
<p>​    继续包裹一个流式布局，希望其充满整个屏幕，将错误提示报告和提交按钮放至流式布局下。警告框最大化屏幕为9，当页面缩写后为12。button给其对应的class。</p>
<p>​    但是效果不是太好，警告框比提交框更宽。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container-fluid main "</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"alert alert-danger col-lg-9 col-md-12 col-sm-12 col-xs-12"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;error&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">class</span>=<span class="string">"btn btn-success btn-publish col-lg-3 col-md-12 col-sm-12 col-xs-12"</span>&gt;</span></span><br><span class="line">    发布</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/2019/12/29/SpringBoot-%E5%AD%A6%E4%B9%A0/%E8%AD%A6%E5%91%8A%E6%A1%861.png" class title="This is an example image">

<p>​    将button的流式布局重新放在一个div中，然后将button放置在此div下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-3 col-md-12 col-sm-12 col-xs-12"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">class</span>=<span class="string">"btn btn-success btn-publish"</span>&gt;</span></span><br><span class="line">    发布</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="Spring知识总结"><a href="#Spring知识总结" class="headerlink" title="Spring知识总结"></a>Spring知识总结</h1><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><ol>
<li><p>Controller</p>
<blockquote>
<p>@Controller，将当前类作为路由API的一个承载者</p>
</blockquote>
</li>
<li><p>Component</p>
<blockquote>
<p>@Component 仅仅把当前类初始化Spring容器的上下文，这样调用时不用实例化对象，IOC，便于去调用对象</p>
</blockquote>
</li>
<li><p>Autowired</p>
<blockquote>
<p>@Autowired注解将Spring容器中的写好的实例化的实例加载到当前使用的上下文</p>
</blockquote>
</li>
<li><p>Value</p>
<blockquote>
<p>@Value(“${string}”)，在配置文件中读取key为string的value</p>
</blockquote>
</li>
</ol>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul>
<li>在类和类之间传输用DTO，在数据库中使用model</li>
</ul>
<h1 id="快捷键技巧"><a href="#快捷键技巧" class="headerlink" title="快捷键技巧"></a>快捷键技巧</h1><h3 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="IDEA快捷键"></a>IDEA快捷键</h3><ul>
<li>ctrl + P：提示输入参数类型</li>
<li>ctrl + shift+n 快速<strong>查找</strong>文件</li>
<li>shift + F6 更改名称</li>
<li>ctrl + shift + F12 切换最大屏</li>
<li>alt + 鼠标左键按住拖动，实现对多行的批量修改</li>
<li>alt + insert 提示创建get和set</li>
<li>选中指定部分，alt + 回车，引入jar包</li>
<li>ctrl + alt + v 选中new Class，快速创建其变量</li>
<li>按住shift + 回车 自动换到当前光标的下一行</li>
<li>ctrl + e 切回最近的一个访问窗口</li>
<li>右键Git/history，可以看到历史提交信息时当前目录的情况</li>
<li>shift+F6 将所有同名变量更名</li>
<li>变量.for 完成对某变量的for循环</li>
<li>alt+回车 修复</li>
<li>右键Git revert，将某个文件还原至Git提交状态</li>
<li>ctrl+w同时选中上下层</li>
<li>ctrl+alt+l 简单格式化</li>
</ul>
<h3 id="其他快捷键"><a href="#其他快捷键" class="headerlink" title="其他快捷键"></a>其他快捷键</h3><ul>
<li>ctrl+shift+n 打开新的匿名窗口</li>
</ul>
<p>学到知识</p>
<ol>
<li>Maven是管理包和包的依赖的工具，pom.xml中包括所有运行Spring项目需要的包，主要为依赖parent</li>
<li>gitignore用于只提交部分的代码，避免一些文件冲突</li>
<li>学习一个新东西先进官网去学习，先拷贝进自己项目跑起来</li>
<li>当编程参数超过2个，不要使用形参传入，而是封装成对象</li>
</ol>
<h1 id="资源支持"><a href="#资源支持" class="headerlink" title="资源支持"></a>资源支持</h1><ul>
<li><a href="https://spring.io/guides" target="_blank" rel="noopener">Spring官方文档</a></li>
<li><a href="https://spring.io/guides/gs/serving-web-content/" target="_blank" rel="noopener">Serving Web Content with Spring MVC</a></li>
<li><a href="https://elasticsearch.cn/" target="_blank" rel="noopener">elastic社区</a></li>
<li><a href="https://v3.bootcss.com/getting-started/#download" target="_blank" rel="noopener">BootStrap</a></li>
<li><a href="https://developer.github.com/apps/" target="_blank" rel="noopener">OAuth Apps文档</a></li>
<li><a href="https://www.visual-paradigm.com" target="_blank" rel="noopener">Visual Paradig</a></li>
<li><a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp</a></li>
<li><a href="https://mvnrepository.com/" target="_blank" rel="noopener">Maven包查询</a></li>
<li><a href="http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/" target="_blank" rel="noopener">MyBatis官方资料</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.0.0.RC1/reference/htmlsingle/#boot-features-embedded-database-support" target="_blank" rel="noopener">Spring文档</a></li>
<li><a href="https://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener">MySQL菜鸟教程资料</a></li>
<li><a href="https://flywaydb.org/getstarted/" target="_blank" rel="noopener">Flyway官网</a></li>
</ul>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown使用</title>
    <url>/2019/12/29/markdown%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="markdown在hexo中使用"><a href="#markdown在hexo中使用" class="headerlink" title="markdown在hexo中使用"></a>markdown在hexo中使用</h1><h2 id="markdown工具"><a href="#markdown工具" class="headerlink" title="markdown工具"></a>markdown工具</h2><h3 id="个人使用工具：Typora"><a href="#个人使用工具：Typora" class="headerlink" title="个人使用工具：Typora"></a>个人使用工具：<strong>Typora</strong></h3><ol>
<li>基于Windows下载</li>
<li>偏好设置 </li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><p>​    博客部署至远端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hexo deploy -g</span><br></pre></td></tr></table></figure>

<p>​    将hexo文件夹源代码（写作所在文件夹）push至github仓库</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m “message”</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h2><p>引用自博客</p>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_30734435/article/details/98497054" target="_blank" rel="noopener">https://blog.csdn.net/weixin_30734435/article/details/98497054</a></p>
</blockquote>
<h4 id="更改配置文件"><a href="#更改配置文件" class="headerlink" title="更改配置文件"></a>更改配置文件</h4><p>​    在根目录下配置文件<code>_config.yml</code> 中有 <code>post_asset_folder:false改为true</code>。这样在建立文件时，<code>Hexo</code>会自动建立一个与文章同名的文件夹，这样就可以把与该文章相关的所有资源（图片）都放到那个文件夹里方便后面引用。</p>
<h4 id="安装git插件"><a href="#安装git插件" class="headerlink" title="安装git插件"></a>安装git插件</h4><blockquote>
<p>npm install <a href="https://github.com/7ym0n/hexo-asset-image" target="_blank" rel="noopener">https://github.com/7ym0n/hexo-asset-image</a> –save</p>
</blockquote>
<h4 id="在插入图片处增加代码"><a href="#在插入图片处增加代码" class="headerlink" title="在插入图片处增加代码"></a>在插入图片处增加代码</h4><p><a href="https://hexo.io/zh-cn/docs/asset-folders" target="_blank" rel="noopener">官方文档</a>给出了解决方式，使用代码为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure>

<p>​    将example.jpg修改为所需要的文件名称和后缀即可，其中<strong>This is an example image</strong>是图片描述。</p>
<h4 id="显示效果"><a href="#显示效果" class="headerlink" title="显示效果"></a>显示效果</h4><img src="/2019/12/29/markdown%E4%BD%BF%E7%94%A8/%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%B9%E6%B3%95.png" class title="This is an example image">

<h3 id="标题前不加数字"><a href="#标题前不加数字" class="headerlink" title="标题前不加数字"></a>标题前不加数字</h3><p>​    在标题前面加数字，hexo使用Next模板后，会自动根据多级标题加上相应数字生成目录，如果人为在多级标题前面加入数字，体验感并不好。</p>
<h1 id="markdown语法记录"><a href="#markdown语法记录" class="headerlink" title="markdown语法记录"></a>markdown语法记录</h1><p>引用自知乎，将一些常用命令进行记录</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/90561228" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/90561228</a></p>
</blockquote>
<h2 id="字体编辑"><a href="#字体编辑" class="headerlink" title="字体编辑"></a>字体编辑</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>​    有6级标题可选，分别为按下Ctrl+1~6。</p>
<h3 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">快捷键：Ctrl+数字  或 Ctrl+加减号  或  ### （几个#表示几级标题，同上）</span><br></pre></td></tr></table></figure>

<h3 id="字体加粗"><a href="#字体加粗" class="headerlink" title="字体加粗"></a>字体加粗</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">快捷键：Ctrl+b</span><br><span class="line">示 例：**加粗内容**</span><br></pre></td></tr></table></figure>

<p>​    加粗前：字体；加粗后<strong>字体</strong></p>
<h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">快捷键：ctrl+i</span><br><span class="line">示 例：*斜体*</span><br></pre></td></tr></table></figure>

<p>​    斜体前：斜体；斜体后<em>斜体</em></p>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">快捷键：alt+shift+5</span><br><span class="line">示 例：~~删除的内容~~</span><br></pre></td></tr></table></figure>

<p>​    删除前：删除；删除后：<del>删除</del></p>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">快捷键：Ctrl+u</span><br><span class="line">示 例：&lt;u&gt;下划线内容&lt;&#x2F;u&gt;</span><br></pre></td></tr></table></figure>

<p>​    下划前：下划；下划后：<u>下划</u></p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：这块有个脚注[^脚注]</span><br><span class="line">     [^脚注]:填写脚注的内容</span><br><span class="line">示例：有一个github网址[^1]</span><br><span class="line">     [^1]:https:&#x2F;&#x2F;github.com&#x2F;</span><br></pre></td></tr></table></figure>

<p>​    无脚注；有脚注<a href="https://github.com/" target="_blank" rel="noopener">^1</a></p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：数字+英文小数点(.)+空格</span><br><span class="line">示例：1. list1</span><br><span class="line">     2. list2</span><br></pre></td></tr></table></figure>

<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：- +空格 或 * + 空格</span><br><span class="line">示例： - list1</span><br><span class="line">      - list2</span><br></pre></td></tr></table></figure>

<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h3 id="插入代码块"><a href="#插入代码块" class="headerlink" title="插入代码块"></a>插入代码块</h3><p>快捷键：shift+3个~</p>
<h3 id="插入数学公式"><a href="#插入数学公式" class="headerlink" title="插入数学公式"></a>插入数学公式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：$$ + enter</span><br><span class="line">示例：$$ + enter后输入11+12，结果如下所示</span><br></pre></td></tr></table></figure>

<p>$$<br>11+12<br>$$</p>
<h3 id="插入引用"><a href="#插入引用" class="headerlink" title="插入引用"></a>插入引用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：&gt; + 空格</span><br><span class="line">示例：&gt; + 空格后，输入 引用的内容，结果如下所示</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是一个引用</p>
</blockquote>
<h3 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操 作:Ctrl+k弹出后，输入 [输入标题名](输入链接地址) 即可</span><br><span class="line">示 例1：[百度一下，你就知道](https:&#x2F;&#x2F;www.baidu.com&#x2F;)</span><br><span class="line">示 例2：这是 [百度一下，你就知道](https:&#x2F;&#x2F;www.baidu.com&#x2F; &quot;百度&quot;) 的链接.  </span><br><span class="line">示 例3：这是 [github][1] 的链接.  </span><br><span class="line">       [1]: https:&#x2F;&#x2F;github.com&#x2F; &quot;github&quot;</span><br><span class="line">ps：按住ctrl点击链接可直接打开</span><br></pre></td></tr></table></figure>

<p><a href="https://www.baidu.com/" target="_blank" rel="noopener">百度一下，你就知道</a></p>
<p>这是<a href="https://www.baidu.com/" target="_blank" rel="noopener" title="百度">百度一下，你就知道</a> 的链接</p>
<h3 id="插入注释"><a href="#插入注释" class="headerlink" title="插入注释"></a>插入注释</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：[^文字]：文字</span><br><span class="line">示例：[^1]：文献1</span><br></pre></td></tr></table></figure>

<p>​    <a href="hughzc.github.io">^2</a> : 个人博客地址</p>
<h3 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">快捷键：ctrl+t</span><br><span class="line">示 例：按完快捷键后，弹出下图，选择对应的行和列，点击确定即可。</span><br></pre></td></tr></table></figure>
<p>弹出下图的选项</p>
<img src="/2019/12/29/markdown%E4%BD%BF%E7%94%A8/%E8%A1%A8%E6%A0%BC.png" class title="This is an example image">



<table>
<thead>
<tr>
<th>1</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="普通markdown插入图片"><a href="#普通markdown插入图片" class="headerlink" title="普通markdown插入图片"></a>普通markdown插入图片</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：直接拖动  或 ctrl+shift+i(相对路径地址)</span><br><span class="line">示例：![](C:\1.jpg)</span><br></pre></td></tr></table></figure>

<p>​    如果是在hexo中插入图片，需要使用代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入分隔符"><a href="#插入分隔符" class="headerlink" title="插入分隔符"></a>插入分隔符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：--- + enter  或者 *** + enter</span><br></pre></td></tr></table></figure>

<p>这是条分割线</p>
<hr>
<h3 id="插入目录"><a href="#插入目录" class="headerlink" title="插入目录"></a>插入目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：[toc]+enter</span><br></pre></td></tr></table></figure>







]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
