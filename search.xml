<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>设计模式</title>
    <url>/2020/03/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>为了学习设计模式，需要了解为什么要有设计模式，设计模式有哪些及设计模式在哪里得到了使用。下面将分别从以下方面进行介绍。</p>
<h2 id="设计模式解决痛点"><a href="#设计模式解决痛点" class="headerlink" title="设计模式解决痛点"></a>设计模式解决痛点</h2><p>在编写软件的时候，人们会遇到多项挑战，如重用性、可读性、可靠性、耦合性、内聚性等，而设计模式就是人们将经常遇到的问题，总结而得到的比较通用的解决方式，可以让程序具有更好的以下特性：</p>
<ul>
<li>代码重用性：相同功能代码，不用多次编写</li>
<li>可读性：编程更规范，便于其他人的阅读和理解（祖传奥利给山）</li>
<li>可扩展性：需要增加新功能时，非常方便，可维护性好</li>
<li>可靠性：增加新功能后，对原有功能没有影响</li>
</ul>
<p>这样程序具有高内聚、低耦合的特性。</p>
<h2 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h2><p>那设计出了一种原则，如何知道这种设计原则是否真的规范呢？那么设计模式需要遵守一些原则，即设计设计模式的原则。以下列出了七大原则</p>
<ul>
<li>单一职责原则</li>
<li>接口隔离原则</li>
<li>依赖倒转原则</li>
<li>里氏替换原则</li>
<li>开闭原则</li>
<li>迪米特法则</li>
<li>合成复用原则</li>
</ul>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>对类来说，一个类应该只负责一项职责（并不是只有一种方法），若A负责两个不同职责，如职责1与职责2，当职责1需求而改变A时，可能造成职责2的运行错误，因此需要将类A更细粒度分为类1与类2。</p>
<h4 id="单一职责原则注意事项与细节"><a href="#单一职责原则注意事项与细节" class="headerlink" title="单一职责原则注意事项与细节"></a>单一职责原则注意事项与细节</h4><ol>
<li>降低类的复杂度，一个类只复杂一项职责</li>
<li>提高类的可读性，可 维护性</li>
<li>降低变更引起的风险</li>
<li>通常，应遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则：只有类中方法足够少，才可以在方法级别保持单一职责原则</li>
</ol>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应建立在最小的接口上。</p>
<p>如果，接口C中有2个方法，类B实现了接口C，类A依赖类B中的第1个方法(A中传入接口C类型对象，调用其中1个方法，依靠多态实现)，即C中的后一个方法A是不需要的。这样就违背了接口隔离原则。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">(C c)</span></span>&#123;</span><br><span class="line">        c.method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">psvm&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    a.methodA(<span class="keyword">new</span> B());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若要按照接口隔离原则处理，应该将接口C进行拆解，其中只要包含类A需要的方法即可。</p>
<h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><ol>
<li>高层模块不应该依赖底层模块，二者都应该依赖其抽象</li>
<li>抽象不应该依赖细节，细节应该依赖抽象</li>
<li>依赖倒转的中心思想是面向接口编程</li>
<li>设计理念：相对于细节的多变性，抽象的东西更稳定。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在Java中，抽象指接口或抽象类，细节就是具体的实现类</li>
<li>使用接口或抽象类目的是指定好规范，不涉及具体的操作，把展现细节的任务交给实现类去实现。</li>
</ol>
<h4 id="依赖关系传递的三种方式"><a href="#依赖关系传递的三种方式" class="headerlink" title="依赖关系传递的三种方式"></a>依赖关系传递的三种方式</h4><p>如果类A要实现1个功能，定义一个抽象类具有此功能，类B实现此抽象类，然后类A中调用抽象类的方法，在传参的时候将B类传入即可。但是这种依赖关系的传递有三种方法：</p>
<ol>
<li>接口传递</li>
<li>构造方法传递</li>
<li>setter方法传递</li>
</ol>
<p>假设有一个接口如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于接口传递，即为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">(Interface i)</span></span>&#123;</span><br><span class="line">        i.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用时</span></span><br><span class="line">psvm&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    a.methodA(<span class="keyword">new</span> B());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于构造方法传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Interface i;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(Interface i)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.i = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用时</span></span><br><span class="line">psvm&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A(<span class="keyword">new</span> B());</span><br><span class="line">    a.methodA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于setter方法传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Interface i;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setter</span><span class="params">(Interface i)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.i = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用时</span></span><br><span class="line">psvm&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    a.setter(<span class="keyword">new</span> B());</span><br><span class="line">    a.methodA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：如果要依赖一个接口，需要持有其对象，可以选择在方法调用时接收，也可以选择在此类中持有个私有的接口引用，然后通过构造函数或者setter方法去获取其实例化对象。</p>
<h4 id="依赖倒转原则的注意事项和细节"><a href="#依赖倒转原则的注意事项和细节" class="headerlink" title="依赖倒转原则的注意事项和细节"></a>依赖倒转原则的注意事项和细节</h4><ol>
<li>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好</li>
<li>变量的声明类型尽量是抽象类或接口，这样变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化</li>
<li>继承时遵循里氏替换原则</li>
</ol>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>继承性的思考和说明</p>
<ol>
<li>继承包含的含义：父类中已经实现好的方法，实际上在设定规范和契约，虽然它不强制要求所有的子类必须要遵守这些契约，但如果子类对这些已经实现的方法任意修改，会对整个继承体系造成破坏</li>
<li>继承在给程序设计带来便利的同时，也带来了弊端。如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性。若一个类被其他类所继承，则当这个类要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障</li>
<li>因此在编程中为了正确的使用继承，应该考虑里氏替换原则</li>
</ol>
<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li>里氏替换原则在1988年由姓里的女士提出</li>
<li>所有引用积累的地方必须能透明地使用其子类的对象</li>
<li>在使用继承时，遵循里氏替换原则，<strong>在子类中尽量不要重写父类的方法</strong></li>
<li>里氏替换原则告诉我们，继承实际上增强了两个类的耦合性，在适当的情况下，可以通过聚合、组合、依赖来降低耦合</li>
</ol>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>若子类修改了父类的方法，让原来的父类和子类都继承一个更通俗的积累，原有的继承关系去掉，采用依赖、聚合、组合等关系替代。</p>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li>开闭原则是编程中最基础、最重要的设计原则</li>
<li>一个软件实体如类，模块和函数应该对<strong>扩展开放</strong>（对提供方），对<strong>修改关闭</strong>（对使用方），<strong>用抽象构建框架</strong>，<strong>用实现扩展细节</strong></li>
<li>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化</li>
<li>编程中遵守其他 原则，以及使用设计模式的目的就是遵循开闭原则</li>
</ol>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li>一个对象应该对其他对象保持最少的了解</li>
<li>类与类关系越密切，耦合度越大</li>
<li>迪米特法则又叫<strong>最少知道原则</strong>，即一个类对自己依赖的类知道的越少越好，也就是对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄漏任何信息</li>
<li>迪米特法则更简单定义：只与直接的朋友通信</li>
<li>朋友关系：只要两个对象之间有耦合关系，这两个对象就是朋友关系。直接朋友：出现成员变量，方法参数，方法返回值中的类；非直接朋友：出现在局部变量中的类。陌生的类最好不要以局部变量的形式出现在类的内部</li>
</ol>
<h4 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h4><ol>
<li>迪米特法则的核心是降低类之间的耦合</li>
<li>但是由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间（对象间）耦合关系，并不是要求完全没有依赖关系</li>
</ol>
<h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>原则是尽量使用合成/聚合的方式，而不是使用继承</p>
<h3 id="设计原则核心思想"><a href="#设计原则核心思想" class="headerlink" title="设计原则核心思想"></a>设计原则核心思想</h3><ol>
<li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起</li>
<li>针对接口编程，而不是针对实现编程</li>
<li>为了交互对象之间的松耦合设计而努力</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>七大原则</tag>
      </tags>
  </entry>
  <entry>
    <title>哈夫曼树</title>
    <url>/2020/03/06/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
    <content><![CDATA[<p>写这篇博客源自于之前做了一道哈夫曼编码的题，但是当时哈夫曼树的知识已经遗忘了，因此没有做出来。后来在学习左神的算法的时候，复习到了切金条的问题，其中用到了哈夫曼树，因此趁此机会在网上学习了哈夫曼树的相关知识并自己动手用Java实现了相关操作，记录在博客中，方便日后查阅。</p>
<blockquote>
<p>参考博客：<code>https://www.cnblogs.com/kubixuesheng/p/4397798.html</code></p>
</blockquote>
<a id="more"></a>

<h1 id="什么是哈夫曼树"><a href="#什么是哈夫曼树" class="headerlink" title="什么是哈夫曼树"></a>什么是哈夫曼树</h1><p>要学习哈夫曼树，首先要知道哈夫曼树是什么，为什么要用哈夫曼树。</p>
<h2 id="问题场景：判断结构"><a href="#问题场景：判断结构" class="headerlink" title="问题场景：判断结构"></a>问题场景：判断结构</h2><p>如果要使用条件判断将百分制成绩转换为等级输出，可以写多个if else语句，将其判断逻辑用一个树来表示，其中越接近树顶层的结果越容易获取到，假如有如下的分数段分布情况</p>
<table>
<thead>
<tr>
<th>分数</th>
<th>0-59</th>
<th>60-69</th>
<th>70-79</th>
<th>80-89</th>
<th>90-100</th>
</tr>
</thead>
<tbody><tr>
<td>比例</td>
<td>0.05</td>
<td>0.15</td>
<td>0.40</td>
<td>0.30</td>
<td>0.10</td>
</tr>
</tbody></table>
<p>为了写出判断每个学生分数区间的代码，可以有如下两种构造方式</p>
<p>构造方式1</p>
<img src="/2020/03/06/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/%E6%9E%84%E9%80%A01.png" class title="This is an example image">

<p>构造方式2</p>
<img src="/2020/03/06/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/%E6%9E%84%E9%80%A02.png" class title="This is an example image">

<p>这样第一种方式的判断次数要多余第二种方式，原因是假设头节点高度为0，越往下高度越高，节点所在的高度越高，则找到此节点所需要的工作量越大。这时候为了找到一种效率最高的判别树，便找到了哈夫曼树。</p>
<h2 id="哈夫曼树有关概念"><a href="#哈夫曼树有关概念" class="headerlink" title="哈夫曼树有关概念"></a>哈夫曼树有关概念</h2><p>路径：在一棵树中，从一个结点到另一个结点的通路。</p>
<p>路径长度：路径上的结点个数-1。</p>
<p>结点的权：路径上的值，可以理解为节点的距离，通常指字符对应的二进制编码出现的概率。</p>
<p>树的路径长度：从树根节点到每一个叶结点的路径长度之和。</p>
<p>结点的带权路径长度：该结点到树根的路径长度与该结点上权的乘积</p>
<p>树的带权路径长度：所有的结点带权路径长度之和。</p>
<p>哈夫曼树就是树的带权路径长度最短的二叉树。</p>
<h1 id="如何得到一棵哈夫曼树"><a href="#如何得到一棵哈夫曼树" class="headerlink" title="如何得到一棵哈夫曼树"></a>如何得到一棵哈夫曼树</h1><h2 id="哈夫曼树构造算法"><a href="#哈夫曼树构造算法" class="headerlink" title="哈夫曼树构造算法"></a>哈夫曼树构造算法</h2><ol>
<li>根据给定的带权值的结点构成二叉树集合，每个二叉树只有一个带权值的结点，左右子树为空</li>
<li>在集合中选取权值最小的两个二叉树重新构造一个二叉树，新的二叉树的权值为两个二叉树权值之和</li>
<li>在集合中删除取出的两个二叉树，将新的二叉树放入</li>
<li>重复步骤2,3直到只有一棵二叉树</li>
</ol>
<p>这样便得到了一棵哈夫曼树。</p>
<p>要注意的是，具有相同带权结点的哈夫曼树不唯一。</p>
<h1 id="哈夫曼树的应用"><a href="#哈夫曼树的应用" class="headerlink" title="哈夫曼树的应用"></a>哈夫曼树的应用</h1><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p>哈夫曼编码为哈夫曼树在通讯领域的应用，可以有效压缩数据，在编码时候需要考虑两个问题：数据的最小冗余编码（频率大的字符编码短），译码唯一性（一个译码对应唯一编码），利用哈夫曼树可以很好解决以上问题。</p>
<p>在之前介绍的哈夫曼树构造基础之上，在两个子树合并为一个新的二叉树时，选择权值较小的二叉树为左子树，然后从树的根结点出发，其左子树的分支标‘0’，右子树的分支标’1’，这样便可以得到每个字符的编码，如下图所示</p>
<img src="/2020/03/06/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81.png" class title="This is an example image">

<p>这样得到的编码即为二进制前缀编码。</p>
<p>总算将其基本概念大致介绍了一遍，那么开始从最初的起点（做错的题）开始，自己设计一个用于26个英文字符编码的哈夫曼树吧！</p>
<h1 id="”我的”哈夫曼树"><a href="#”我的”哈夫曼树" class="headerlink" title="”我的”哈夫曼树"></a>”我的”哈夫曼树</h1><h2 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h2><p>假设某段通信电文仅由 6 个字母 ABCDEF 组成，字母在电文中出现的频率分别为2，3，7，15，4，6。根据这些频率作为权值构造哈夫曼编码，最终构造出的哈夫曼树带权路径长度与字母 B 的哈夫曼编码分别为<strong>__</strong>。(这里假定左节点的值小于右节点的值)</p>
<p>因此接下来的内容为致力于构造自己的哈夫曼树，来解决此类问题。</p>
<h2 id="需求介绍"><a href="#需求介绍" class="headerlink" title="需求介绍"></a>需求介绍</h2><p>在明确了问题后，需要进一步分析需求。</p>
<p>输入：目前看到关于哈夫曼树的题目有两种输入方式，一种是直接输入一串字符串，另一种是逐个输入字符，频率。</p>
<p>输出：希望最后输出有哈夫曼树的路径长度，带权路径长度与每个字母对应的哈夫曼编码。</p>
<p>因此便得到了基础需求，即输入字符串或者字符+频率，得到其对应的哈夫曼树路径长度、带权路径长度与哈夫曼编码，下面将逐步实现这些需求，并在此基础之上，增加一些自定义的需求。说明：下面定义的哈夫曼树基于大写英文字母进行统计，只进行A-Z的字符统计。</p>
<h2 id="树结点的结构"><a href="#树结点的结构" class="headerlink" title="树结点的结构"></a>树结点的结构</h2><p>树由结点构成，基本的树结点中有值，左结点，右结点，而为了实现需求，需要在此之上加入每个节点的字符，结点的值为每个字符的频率，而当集合中有多个子树权值相等时，为了让树显得更加饱满（高度更低），选择优先让子结点数更少的二叉树进行合并，因此需要加上当前结点下所有结点的个数（包括自己），因此树结点的定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HaffNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Character c;<span class="comment">//字符</span></span><br><span class="line">    <span class="keyword">public</span> Integer fre;<span class="comment">//频数</span></span><br><span class="line">    <span class="keyword">public</span> Integer count;<span class="comment">//子结点个数</span></span><br><span class="line">    <span class="comment">//两个结点</span></span><br><span class="line">    <span class="keyword">public</span> HaffNode left;</span><br><span class="line">    <span class="keyword">public</span> HaffNode right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HaffNode</span><span class="params">(Character c, Integer fre, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">        <span class="keyword">this</span>.fre = fre;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈夫曼树的结构"><a href="#哈夫曼树的结构" class="headerlink" title="哈夫曼树的结构"></a>哈夫曼树的结构</h2><p>在前面所介绍的哈夫曼树的生成算法中，每次需要弹出两个权值最小的两个子树，最后直到只有一个子树，因此可以利用小根堆来实现，在Java中的实现为优先级队列PriorityQueue，为了保证让子结点树更小的二叉树优先被弹出，定义相应的比较器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HaffmanCompare</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">HaffNode</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//让树更均衡</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(HaffNode o1, HaffNode o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.fre != o2.fre ? o1.fre - o2.fre : o1.count - o2.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心思想为如果两个二叉树权值不同，则优先比较权值；若权值相同，则优先弹出子树个数更少的二叉树。</p>
<p>然后将此比较器传入哈夫曼树中维护的优先级队列中，因为在需求中介绍了有两种输入方式，一种为直接传入字符串，一种为逐个传入字符和频数，因此相应的定义了两种构造函数，一种有参数的对应传入字符串，一种无参数的对应逐个传入字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHaffman</span> </span>&#123;</span><br><span class="line">    <span class="comment">//持有小根堆，用来统计每个字符的个数</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;HaffNode&gt; numHeap = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String str = <span class="keyword">null</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHaffman</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        numHeap = <span class="keyword">new</span> PriorityQueue&lt;HaffNode&gt;(<span class="keyword">new</span> HaffmanCompare());</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHaffman</span><span class="params">()</span></span>&#123;</span><br><span class="line">        numHeap = <span class="keyword">new</span> PriorityQueue&lt;HaffNode&gt;(<span class="keyword">new</span> HaffmanCompare());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在完成了树的初始化后，需要将每个字符与其频率封装成为结点对象，传入维护的优先级队列中。因此首先需要统计每个字符与其频率</p>
<h2 id="统计每个字符与其频率"><a href="#统计每个字符与其频率" class="headerlink" title="统计每个字符与其频率"></a>统计每个字符与其频率</h2><h3 id="传入字符串"><a href="#传入字符串" class="headerlink" title="传入字符串"></a>传入字符串</h3><p>首先介绍传入参数为一个字符串的形式，假设传入字符串为“ABACCDA”，为了统计每个字符串个数，可以利用桶排序，即维护一个长度为26的数组作为桶，若为A在0号桶，为B在1号桶，以此类推。这样便可以将每个桶位置处的字符个数统计出来。然后遍历桶的26个位置，如果当前桶中有数，就将此位置对应的字符与其频率封装成结点对象，并放入堆中。</p>
<p>其中封装的时候，传入当前字符，频率，所有结点个数（1）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入字符串，统计频率，并加到大根堆中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFre</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//桶排序，将每个字符放入桶中</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];<span class="comment">//统计频率</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        arr[str.charAt(i)-<span class="string">'A'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从桶中取出来数，统计每个字母的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] != <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)(<span class="string">'A'</span>+i)+<span class="string">" "</span>+arr[i]+<span class="string">" "</span>);</span><br><span class="line">            numHeap.add(<span class="keyword">new</span> HaffNode((<span class="keyword">char</span>)(<span class="string">'A'</span>+i),arr[i],<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="传入数组"><a href="#传入数组" class="headerlink" title="传入数组"></a>传入数组</h3><p>而如果是以A 3，换行，B 4,…，这样的形式输入，则在输入的函数处维护一个数组，数组的index为0的地方表示A，值为3，表示A的频率为3，以此类推，便得到了一个字符的频率数组，完成此过程的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入字符和频数来构造数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCharAndFre</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">char</span> c, <span class="keyword">int</span> fre)</span></span>&#123;</span><br><span class="line">    <span class="comment">//新建桶，放入桶中</span></span><br><span class="line">    <span class="keyword">if</span> (c &lt; <span class="string">'A'</span> || c &gt; <span class="string">'Z'</span> || fre &lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"输入的字符不为A-Z之间或者频数不为正数"</span>);</span><br><span class="line">    arr[c-<span class="string">'A'</span>] = fre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将所有的输入都存到了上述数组中后，便可以遍历桶，将不为0处对应的字符与频率封装为结点对象并放入堆中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFre</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="comment">//从桶中取出来数，统计每个字母的个数</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (arr[i] != <span class="number">0</span>)&#123;</span><br><span class="line">               System.out.print((<span class="keyword">char</span>)(<span class="string">'A'</span>+i)+<span class="string">" "</span>+arr[i]+<span class="string">" "</span>);</span><br><span class="line">               numHeap.add(<span class="keyword">new</span> HaffNode((<span class="keyword">char</span>)(<span class="string">'A'</span>+i),arr[i],<span class="number">1</span>));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>接下来便可以开始构造哈夫曼树</p>
<h2 id="树的构造"><a href="#树的构造" class="headerlink" title="树的构造"></a>树的构造</h2><p>这方法需要返回树的根结点，其思路为</p>
<ol>
<li>如果堆为空，返回空</li>
<li>如果堆中元素比1大，则弹出2个结点</li>
<li>新建一个结点，字符为A-Z之外的（此处选#），权值为两个子树之和，左子树为权值较小的，总结点树为两子树结点树之和+1</li>
<li>将此结点重新放入堆中，继续步骤2,3，直到只有1个结点</li>
<li>返回此结点，即为哈夫曼树的头结点</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构建哈夫曼树</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> HaffNode <span class="title">getHaffTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果堆为空，返回空</span></span><br><span class="line">    <span class="keyword">if</span> (numHeap.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//从numHeap中弹出两个，构建新的节点，再丢进去</span></span><br><span class="line">    <span class="keyword">while</span> (numHeap.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        HaffNode cf1 = numHeap.poll();</span><br><span class="line">        HaffNode cf2 = numHeap.poll();</span><br><span class="line">        <span class="comment">//字符用单引号</span></span><br><span class="line">        HaffNode res = <span class="keyword">new</span> HaffNode(<span class="string">'#'</span>,cf1.fre+cf2.fre,cf1.count+cf2.count+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//构建左右子树</span></span><br><span class="line">        res.left = cf1.fre &lt;= cf2.fre ? cf1 : cf2;</span><br><span class="line">        res.right = cf1.fre &lt;= cf2.fre ? cf2 : cf1;</span><br><span class="line">        numHeap.offer(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只剩一个的时候弹出</span></span><br><span class="line">    <span class="keyword">return</span> numHeap.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树的打印"><a href="#树的打印" class="headerlink" title="树的打印"></a>树的打印</h2><p>为了直观显示树的结构和方便验证程序的正确性，此处<strong>直接使用左神的打印树的函数</strong>，其核心思路为递归方式的中序遍历，每一层树占据的长度为len，因此需要计算得到每个结点所在树的高度，如果为右子树，用<code>V</code>标识；如果为左子树，用<code>^</code>标识。递归的中序遍历为递归左子树，打印当前结点，递归右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(HaffNode head)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Binary Tree:"</span>);</span><br><span class="line">        printInOrder(head, <span class="number">0</span>, <span class="string">"H"</span>, <span class="number">17</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printInOrder</span><span class="params">(HaffNode head, <span class="keyword">int</span> height, String to, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        printInOrder(head.right, height + <span class="number">1</span>, <span class="string">"v"</span>, len);</span><br><span class="line">        String val = to + head.c + head.fre + to;</span><br><span class="line">        <span class="keyword">int</span> lenM = val.length();</span><br><span class="line">        <span class="keyword">int</span> lenL = (len - lenM) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> lenR = len - lenM - lenL;</span><br><span class="line">        val = getSpace(lenL) + val + getSpace(lenR);</span><br><span class="line">        System.out.println(getSpace(height * len) + val);</span><br><span class="line">        printInOrder(head.left, height + <span class="number">1</span>, <span class="string">"^"</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSpace</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String space = <span class="string">" "</span>;</span><br><span class="line">        StringBuffer buf = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            buf.append(space);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buf.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="树的编码"><a href="#树的编码" class="headerlink" title="树的编码"></a>树的编码</h2><p>在构建好树以后，需要得到每个叶子结点的编码。思路为递归实现，需要传入的参数是统计结果的Map，用来表示当前路径长度的String，用来表示总的带权路径长度的StringBuilder，以及当前树的高度和当前结点。</p>
<p>采用先序遍历，base case为结点为空，当结点不为空的时候：</p>
<ol>
<li>如果当前结点为叶子结点，将其字符编码加入，将其带权路径加入到结果中（如果StringBuilder长度为0，直接将当前高度*频率加入；若已经有数，将之前的数取出，累加上当前结点的带权路径长度，替换到StirngBuilder中原来的值）</li>
<li>如果当前结点不为叶子结点，递归遍历其左子树，其中string加上0，高度加一</li>
<li>递归遍历其右子树，string加上1，高度加一</li>
</ol>
<p>在此过程中遇到的坑有，之前为了获得结点的字符使用的是StringBuilder类型，但是因为StringBuilder的值在堆中而不是在当前递归栈中，在返回到上一级时需要将当前步骤的影响消除，使用此方法效果有问题。后在leetcode上找到了相似的题目，使用String类型来保存当前栈的状态，这样不用自己去手动消除这一步状态 ，更为简单。而计算带权路径又需要一个堆内存中的变量，此处使用比较笨的方法，利用StringBuilder，每次取出之前的值，加上当前值再进行替换。其中使用的replace函数来替换，起始位置为0，终止位置要是其长度。</p>
<p>得到的启示：要是遇到要获取每个结点的路径的题目，可以使用String类型来保存其路径，这样可以自动随栈变化，使用比较方便。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编码，使用StringBuilder有问题，现在改成String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encodingHaff</span><span class="params">(Map&lt;Character,String&gt; map, String sb, StringBuilder num, <span class="keyword">int</span> height, HaffNode cf)</span></span>&#123;</span><br><span class="line">    <span class="comment">//basecase</span></span><br><span class="line">    <span class="keyword">if</span> (cf != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//当前节点为叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (cf.left == <span class="keyword">null</span> &amp;&amp; cf.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//将答案加入</span></span><br><span class="line">            map.put(cf.c,sb);</span><br><span class="line">            <span class="keyword">if</span> (num.length() == <span class="number">0</span>)&#123;</span><br><span class="line">                num.append(height*cf.fre);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = Integer.valueOf(num.toString())+height*cf.fre;</span><br><span class="line">                num.replace(<span class="number">0</span>,num.length(),String.valueOf(temp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果不为叶子节点，遍历左右两边</span></span><br><span class="line">            encodingHaff(map,sb+<span class="number">0</span>, num, height+<span class="number">1</span>, cf.left);</span><br><span class="line">            encodingHaff(map,sb+<span class="number">1</span>,num, height+<span class="number">1</span>, cf.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时需要实现给一个字符串，输出其编码后的二进制码，思路为字符串每一位在Map中进行寻找，最后输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入字符串，给编码后的二进制码结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">codeHaff</span><span class="params">(String str, Map&lt;Character,String&gt; map)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        res.append(map.get(str.charAt(i)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树编码结果的输出"><a href="#树编码结果的输出" class="headerlink" title="树编码结果的输出"></a>树编码结果的输出</h2><p>在上一步中，树所有的编码结果放在了一个Map中，因此需要获取Map中的所有数，比较old school的方式是先获取Map的EntrySet类型的Set，再获取Set的EntrySet类型迭代器，利用迭代器来遍历Map，获取其每一个Key与Value，为了让程序更有拓展性，此处使用了泛型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历map</span></span><br><span class="line">   <span class="keyword">public</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">itraMap</span><span class="params">(Map&lt;K,V&gt; map)</span></span>&#123;</span><br><span class="line">       <span class="comment">//得到entey</span></span><br><span class="line">       Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">       <span class="comment">//遍历enterset</span></span><br><span class="line">       Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it = entrySet.iterator();</span><br><span class="line">       <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">           Map.Entry&lt;K,V&gt; me = it.next();</span><br><span class="line">           K key = me.getKey();</span><br><span class="line">           V value = me.getValue();</span><br><span class="line">           System.out.println(key+<span class="string">":"</span>+value+<span class="string">" "</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用更加简洁的写法，用 foreach语句遍历map的keySet，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历map的较方便写法</span></span><br><span class="line"><span class="keyword">public</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">itraMap2</span><span class="params">(Map&lt;K,V&gt; map)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (K key : map.keySet())&#123;</span><br><span class="line">        V value = map.get(key);</span><br><span class="line">        System.out.println(key+<span class="string">":"</span>+value+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候基本需求便实现了，但是获取了编码，如果给出了一串编码后的结果，该如何得到其解码呢？</p>
<p>因为哈夫曼树为二进制前缀编码，当编码规则确定后，解码结果应该唯一。因此，如果给定了一个字符串输入，从第一个字符开始看，在根结点开始遍历，如果是0，去左子树；如果是1，去右子树；如果都不是，抛出异常。当遍历结点走到了叶子节点时，将当前字符添加至结果，并从树的根结点开始遍历，直到将输入的字符串遍历完。</p>
<p>其中，遇到的坑是判断的逻辑，应该是先往左或右去走，再判断是不是叶子结点，而不是先判断再走。原因是在此处，默认至少树中是有2个以上的结点的，因为如果只有头结点一个叶子结点，是无法编码的，也就无法解码。因此头结点是不用判断的，当到了头结点，至少要<strong>先走出一步再进行判断</strong>，不然会少判断一个字符，造成解码错误。基本原理是<code>1</code>或者<code>0</code>的状态，是在在路径上的结点才有的，也就是要先走一步才有1或者0的状态，因此要先走一步，再进行判断。</p>
<p>第二个坑是char字符的判断，字符用单引号，字符串用双引号，因为刚开始的时候比较的为(0or1)，比较的不是0与1字符，因此一直判断不对 。总的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//译码</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">decodeHaff</span><span class="params">(String str, HaffNode head)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;                                                                               </span><br><span class="line">       <span class="comment">//返回结果</span></span><br><span class="line">       StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       HaffNode cur = head;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">           <span class="comment">//如果当前为0，往左走，如果为1，往右走</span></span><br><span class="line">           Character nowChar = str.charAt(i);</span><br><span class="line">           <span class="comment">//字符使用单引号，字符串使用双引号</span></span><br><span class="line">           <span class="comment">//是0往左走，是1往右走</span></span><br><span class="line">           <span class="keyword">if</span> (nowChar.equals(<span class="string">'0'</span>)) &#123;</span><br><span class="line">               cur = cur.left;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nowChar.equals(<span class="string">'1'</span>)) &#123;</span><br><span class="line">               cur = cur.right;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"译码错误"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果当前节点为叶节点，添加至结果，再从头开始找</span></span><br><span class="line">           <span class="keyword">if</span> (cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">               res.append(cur.c);</span><br><span class="line">               cur = head;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造总方法"><a href="#构造总方法" class="headerlink" title="构造总方法"></a>构造总方法</h2><p>因此总的方法为：如果传入的是字符串，使用无参的得到频率方法；若传入的是数组，使用有参的得到频率方法，然后后面的均为构造树，返回类型为得到的字符与二进制编码的Map，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//主方法，对应输入string的构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;Character,String&gt; <span class="title">mainHaff</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"所有字母及频数如下"</span>);</span><br><span class="line">      <span class="comment">//1、得到每个字符的频率并放入堆中</span></span><br><span class="line">      getFre();</span><br><span class="line">      <span class="keyword">return</span> getTree();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//主方法，对应输入字母，频数的输入方式</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;Character,String&gt; <span class="title">mainHaff</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">      <span class="comment">//从桶中取出来数，统计每个字母的个数</span></span><br><span class="line">      getFre(arr);</span><br><span class="line">      <span class="keyword">return</span> getTree();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//已经得到了堆，用堆得到哈夫曼树</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;Character,String&gt; <span class="title">getTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//1、构建哈夫曼树</span></span><br><span class="line">      HaffNode head = getHaffTree();</span><br><span class="line">      <span class="comment">//2、看哈夫曼树的遍历</span></span><br><span class="line">      printTree(head);</span><br><span class="line">      <span class="comment">//3、得到 每个字符的编码map</span></span><br><span class="line">      Map&lt;Character,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      String sb = <span class="keyword">new</span> String();</span><br><span class="line">      StringBuilder sum = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      encodingHaff(map,sb,sum, <span class="number">0</span>, head);</span><br><span class="line">      <span class="comment">//4、遍历map看结果</span></span><br><span class="line">      itraMap2(map);</span><br><span class="line">      <span class="comment">//5、输出路径长度与带权值路径长度</span></span><br><span class="line">      System.out.println(<span class="string">"哈夫曼带权路径长度为："</span>+sum);</span><br><span class="line">      System.out.println(<span class="string">"哈夫曼总路径长度为："</span>+head.fre);</span><br><span class="line">      <span class="keyword">return</span> map;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造输入"><a href="#构造输入" class="headerlink" title="构造输入"></a>构造输入</h2><p>输入的逻辑为：如果输入1，输入一串字符串，然后构建哈夫曼树；如果输入2，循环输入字符与频率，如果输出end表示结束，将获得的频率数组传入用于构建哈夫曼树。这样便得到了编码信息。这时候用户可以选择是否继续，如果输入1便继续，输入当前规则下得到的编码字符串，则输出为译码后的字符信息。输入代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">    <span class="comment">//提示以字符串输入还是每个字母频率</span></span><br><span class="line">    System.out.println(<span class="string">"请输入数字1或者2"</span>);</span><br><span class="line">    System.out.println(<span class="string">"输入1：将整个字符串输入"</span>);</span><br><span class="line">    System.out.println(<span class="string">"输入2：将字符对应的频数输入"</span>);</span><br><span class="line">    <span class="keyword">int</span> n = Integer.valueOf(bf.readLine());</span><br><span class="line">    MyHaffman mf = <span class="keyword">null</span>;</span><br><span class="line">    Map&lt;Character,String&gt; map = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//处理输入</span></span><br><span class="line">    <span class="keyword">switch</span> (n)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">"请输入完整字符串"</span>);</span><br><span class="line">            String str = bf.readLine().toUpperCase();</span><br><span class="line">            mf = <span class="keyword">new</span> MyHaffman(str);</span><br><span class="line">            map = mf.mainHaff();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">"请输入字母和频数，中间用空格隔开"</span>);</span><br><span class="line">            System.out.println(<span class="string">"以end作为结束"</span>);</span><br><span class="line">            String s;</span><br><span class="line">            mf = <span class="keyword">new</span> MyHaffman();</span><br><span class="line">            <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">while</span> (!(s=bf.readLine()).equals(<span class="string">"end"</span>))&#123;</span><br><span class="line">                String[] strArr = s.split(<span class="string">" "</span>);</span><br><span class="line">                <span class="keyword">char</span> c = strArr[<span class="number">0</span>].toUpperCase().charAt(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">int</span> fre = Integer.valueOf(strArr[<span class="number">1</span>]);</span><br><span class="line">                mf.addCharAndFre(arr,c,fre);</span><br><span class="line">            &#125;</span><br><span class="line">            map = mf.mainHaff(arr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"是否要继续：如果要编码，输入1；如果要译码，输入2，否则输入3"</span>);</span><br><span class="line">    <span class="keyword">int</span> opt;</span><br><span class="line">    <span class="keyword">while</span> ((opt = Integer.valueOf(bf.readLine())) != <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"输入要编码的字符串，如ABSFSDF"</span>);</span><br><span class="line">            String str = bf.readLine().toUpperCase();</span><br><span class="line">            System.out.println(<span class="string">"编码后的二进制码为："</span>+mf.codeHaff(str,map));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"输入要译码的二进制码，由0或者1组成"</span>);</span><br><span class="line">            String str = bf.readLine();</span><br><span class="line">            System.out.println(str);</span><br><span class="line">            System.out.println(<span class="string">"解码后的字符串为："</span>+mf.decodeHaff(str,mf.getHaffTree()));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"是否要继续：如果要编码，输入1；如果要译码，输入2，否则输入3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><h3 id="输入字符串"><a href="#输入字符串" class="headerlink" title="输入字符串"></a>输入字符串</h3><p>输入字符串ABCACCDAEAE，交互过程如下</p>
<img src="/2020/03/06/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/%E5%AD%97%E7%AC%A6%E4%B8%B21.png" class title="This is an example image">

<p>得到的所有字母及频数如下</p>
<img src="/2020/03/06/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/%E5%AD%97%E7%AC%A6%E4%B8%B22.png" class title="This is an example image">

<p>得到的每个字符的编码规则及带权路径等如下</p>
<img src="/2020/03/06/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/%E5%AD%97%E7%AC%A6%E4%B8%B23.png" class title="This is an example image">

<p>接着编码、解码及退出如下</p>
<p>可以看到正常的完成了需要的功能。</p>
<h3 id="输入字符及频数"><a href="#输入字符及频数" class="headerlink" title="输入字符及频数"></a>输入字符及频数</h3><p>不忘初心，牢记使命。</p>
<p>这个博客开始的地方就是这道错题，请这位选手回到讲台。</p>
<img src="/2020/03/06/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/%E7%89%9B%E5%AE%A2%E9%A2%98%E7%9B%AE.png" class title="This is an example image">

<p>我们开始用程序来做这一道题</p>
<p>交互方式如下</p>
<img src="/2020/03/06/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/%E5%AD%97%E7%AC%A6%E9%A2%91%E6%95%B01.png" class title="This is an example image">

<p>那么结果应该为！</p>
<img src="/2020/03/06/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/%E5%AD%97%E7%AC%A6%E9%A2%91%E6%95%B02.png" class title="This is an example image">

<p>所以答案选A！</p>
<img src="/2020/03/06/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/%E5%AD%97%E7%AC%A6%E9%A2%91%E6%95%B03.png" class title="This is an example image">

<h3 id="小彩蛋"><a href="#小彩蛋" class="headerlink" title="小彩蛋"></a>小彩蛋</h3><p>输入字符及频数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a <span class="number">1</span></span><br><span class="line">b <span class="number">1</span></span><br><span class="line">h <span class="number">1</span></span><br><span class="line">e <span class="number">1</span></span><br><span class="line">i <span class="number">2</span></span><br><span class="line">j <span class="number">1</span></span><br><span class="line">o <span class="number">1</span></span><br><span class="line">u <span class="number">2</span></span><br><span class="line">y <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>二进制码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">01110101011111101001100000011110101</span></span><br></pre></td></tr></table></figure>

<p>答案在文章最后</p>
<p>输入字符及频数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a <span class="number">1</span></span><br><span class="line">e <span class="number">2</span></span><br><span class="line">f <span class="number">3</span></span><br><span class="line">h <span class="number">2</span></span><br><span class="line">i <span class="number">1</span></span><br><span class="line">j <span class="number">1</span></span><br><span class="line">n <span class="number">2</span></span><br><span class="line">p <span class="number">2</span></span><br><span class="line">s <span class="number">1</span></span><br><span class="line">v <span class="number">1</span></span><br><span class="line">y <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>二进制码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">111111111011101010010010100111011100001000111000000001101</span></span><br></pre></td></tr></table></figure>

<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>从不太了解哈夫曼树，到查阅博客，自己编写哈夫曼树的类，遇到问题，在leetcode和左神算法笔记中寻找方法，不断调试，踩坑，添加功能，到最后马马虎虎完成了自己要求的功能，也许其中还有很多考虑的不够周到的地方，但因为自己的好奇心去实现一个功能，确实是一件很有意思的事情。</p>
<h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>彩蛋1：</p>
<p>字符编码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A:<span class="number">000</span> </span><br><span class="line">B:<span class="number">010</span> </span><br><span class="line">U:<span class="number">101</span> </span><br><span class="line">E:<span class="number">1111</span> </span><br><span class="line">H:<span class="number">011</span> </span><br><span class="line">Y:<span class="number">001</span> </span><br><span class="line">I:<span class="number">110</span> </span><br><span class="line">J:<span class="number">100</span> </span><br><span class="line">O:<span class="number">1110</span></span><br></pre></td></tr></table></figure>

<p>二进制码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">01110101011111101001100000011110101</span></span><br></pre></td></tr></table></figure>

<p>答案：</p>
<p>HUBEIJIAYOU</p>
<p>彩蛋2：</p>
<p>字符编码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">P:<span class="number">000</span> </span><br><span class="line">A:<span class="number">1100</span> </span><br><span class="line">S:<span class="number">1001</span> </span><br><span class="line">E:<span class="number">010</span> </span><br><span class="line">V:<span class="number">1010</span> </span><br><span class="line">F:<span class="number">111</span> </span><br><span class="line">H:<span class="number">001</span> </span><br><span class="line">I:<span class="number">1000</span> </span><br><span class="line">Y:<span class="number">1101</span> </span><br><span class="line">J:<span class="number">1011</span> </span><br><span class="line">N:<span class="number">011</span></span><br></pre></td></tr></table></figure>

<p>对应的二进制码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">111111111011101010010010100111011100001000111000000001101</span></span><br></pre></td></tr></table></figure>

<p>答案：</p>
<p>FFFNVSHENJIEHAPPY</p>
]]></content>
      <categories>
        <category>哈夫曼树</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>哈夫曼树</tag>
        <tag>哈夫曼编码</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE知识整理</title>
    <url>/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><p>根据网上博客和黑马的一些资料，整理了下面的JavaSE的知识点</p>
<blockquote>
<p><a href="https://blog.csdn.net/ThinkWon/article/details/104390612" target="_blank" rel="noopener">https://blog.csdn.net/ThinkWon/article/details/104390612</a></p>
<p>《黑马程序员Java学习》</p>
</blockquote>
<a id="more"></a>

<h2 id="Java基本语法、特性"><a href="#Java基本语法、特性" class="headerlink" title="Java基本语法、特性"></a>Java基本语法、特性</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="Java有哪些数据类型"><a href="#Java有哪些数据类型" class="headerlink" title="Java有哪些数据类型"></a>Java有哪些数据类型</h4><p>Java中数据类型分为基础数据类型与引用数据类型</p>
<ul>
<li>基础数据类型<ul>
<li>数值型<ul>
<li>整数类型，<strong>默认int</strong><ul>
<li>byte：1字节</li>
<li>short：2字节</li>
<li>int：4字节</li>
<li>long：8字节</li>
</ul>
</li>
<li>浮点数类型，<strong>默认double</strong><ul>
<li>float：4字节</li>
<li>double：8字节</li>
</ul>
</li>
</ul>
</li>
<li>字符型<ul>
<li>char：2字节，用单引号括</li>
</ul>
</li>
<li>布尔型<ul>
<li>boolean：1字节，只有2个值</li>
</ul>
</li>
</ul>
</li>
<li>引用数据类型<ul>
<li>类(class)</li>
<li>接口(interface)</li>
<li>数组([])</li>
</ul>
</li>
</ul>
<h4 id="float与double"><a href="#float与double" class="headerlink" title="float与double"></a>float与double</h4><p>float f = 1.1;会报错吗？</p>
<p>会，1.1默认为double，这里相当于向下转型，造成精度损失，需要更改为float f = 1.1f或者float f = (float)1.1</p>
<h4 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗"></a>short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗</h4><p>s1 = s1+1有错，因为1为int类型，不能将int隐式的转换为低精度的short，所以需要类型转换。</p>
<p>s1 += 1，这里相当于强制类型转换，s1 = (short)(s1 + 1)，使用 ++ 或者 += 相当于执行了类型转换</p>
<h4 id="Math-round-11-5-等于多少？Math-round-11-5-等于多少"><a href="#Math-round-11-5-等于多少？Math-round-11-5-等于多少" class="headerlink" title="Math.round(11.5) 等于多少？Math.round(-11.5)等于多少"></a>Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</h4><p>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加 0.5 然后进行下取整。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="最有效率的方式计算2乘以8"><a href="#最有效率的方式计算2乘以8" class="headerlink" title="最有效率的方式计算2乘以8"></a>最有效率的方式计算2乘以8</h4><p>2 &lt;&lt; 3，左移几位相当于2乘以几次方，位运算效率最高。</p>
<p>而<code>&gt;&gt;</code>表示右移，右移几位就是除以2的几次幂，高位保持原来的数字，而对于<code>&gt;&gt;&gt;</code>，无论高位是什么，用<code>0</code>来补齐，因此是无符号位右移。</p>
<h4 id="计算-6"><a href="#计算-6" class="headerlink" title="计算~6"></a>计算~6</h4><p><code>~6</code>相当于对6逐位取反，6全部取反+1得到-6，<code>~6=-7</code></p>
<h4 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h4><p>&amp;运算符的作用是</p>
<ol>
<li>按位与 ，num1&amp;num2相当于将每个数的二进制位相与</li>
<li>逻辑与运算，boolean f1 &amp; f2，两个同时为真返回真</li>
</ol>
<p>而&amp;&amp;是短路的与运算，boolean f1 &amp; f2，如果左边的f1为假，则直接返回假，屏蔽了f2，逻辑或（|）与短路运算符（||）作用也类似。</p>
<h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="switch的作用类型"><a href="#switch的作用类型" class="headerlink" title="switch的作用类型"></a>switch的作用类型</h4><p>在JDK5之前，switch(expr)中的expr只能是基础数据类型中的byte、short、int、char，在JDK5引入了枚举类型enum，在JDK7后，可以为字符串String，但长整形long不可以。因此总的为byte、short、int、char、enum、String。</p>
<h4 id="break-continue-return-的区别及作用"><a href="#break-continue-return-的区别及作用" class="headerlink" title="break ,continue ,return 的区别及作用"></a>break ,continue ,return 的区别及作用</h4><p>break：结束当前的循环体，不再执行此循环</p>
<p>continue：跳出本次循环，继续执行下一个循环</p>
<p>return：结束当前的方法，直接返回</p>
<h4 id="在-Java-中，如何跳出当前的多重嵌套循环"><a href="#在-Java-中，如何跳出当前的多重嵌套循环" class="headerlink" title="在 Java 中，如何跳出当前的多重嵌套循环"></a>在 Java 中，如何跳出当前的多重嵌套循环</h4><p>给外面的循环定义一个名称，在需要跳出的地方使用break 循环名即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">loop1:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">break</span> loop1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h4><p>public static void main(String[] args)</p>
<p>main方法是Java程序的入口，public表示任何类和对象可以访问，static表示方法随类而加载，可使用类名来调用，void表明没有返回值，main为JVM识别的特殊方法名，不是关键字。字符串数组args可以用来输入参数。main为最先加载的方法（不一定最先执行），因此需要被静态调用。</p>
<p>是否有其他写法？</p>
<p>public与static可以交换顺序，也可以定义为final，也可以用synchronized来修饰main方法。</p>
<h4 id="在main方法执行前输出"><a href="#在main方法执行前输出" class="headerlink" title="在main方法执行前输出"></a>在main方法执行前输出</h4><p>可以使用静态代码块，静态代码块在类加载时被调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		Sout(<span class="string">"Hello1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	main()&#123;</span><br><span class="line">		Sout(<span class="string">"Hello2"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数的重载与覆盖"><a href="#函数的重载与覆盖" class="headerlink" title="函数的重载与覆盖"></a>函数的重载与覆盖</h4><ul>
<li>重载：重载发生于<strong>一个类</strong>中，若同名的方法有不同的输入参数列表（参数类型不同，参数个数不同或均不同）视为重载</li>
<li>覆盖：也称为覆写，重写，override，发生在<strong>子类和父类</strong>之间，要求子类重写方法与父类有相同的参数列表和返回类型，子类方法权限大于等于父类方法（父类方法不能被private修饰），子类方法声明异常不能多于父类异常（其子类或子集）。</li>
</ul>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><h4 id="四种访问修饰符及区别"><a href="#四种访问修饰符及区别" class="headerlink" title="四种访问修饰符及区别"></a>四种访问修饰符及区别</h4><p>用访问修饰符来保护对类、变量、方法和构造方法的访问，支持四种访问权限。</p>
<ul>
<li>public：对所有类可见，使用对象为类、接口、变量、方法</li>
<li>default：默认的，在一个包中可见，使用对象为类、接口、变量、方法</li>
<li>protected：对同一个包内和子类可见。使用对象为内部类，变量，方法，不能修饰外部类</li>
<li>private：在同一个类内可见。使用对象为变量，方法，不能修饰外部类</li>
</ul>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">同一类中</th>
<th align="center">同一包中</th>
<th align="center">子类中</th>
<th align="center">不同包中</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">default</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="static作用"><a href="#static作用" class="headerlink" title="static作用"></a>static作用</h4><ol>
<li>创建独立于具体对象的域变量或者方法，随类而加载，可以直接用类名调用</li>
<li>形成静态代码块优化程序性能。在类被加载时，按照static块出现顺序执行，只加载一次，可以将只需要进行一次的初始化操作放在static中</li>
</ol>
<h4 id="static特点"><a href="#static特点" class="headerlink" title="static特点"></a>static特点</h4><ol>
<li>static是一个修饰符，修饰成员（成员变量和成员函数）</li>
<li>static修饰的成员被所有对象共享</li>
<li>static优先于对象存在，随类的第一次使用而加载，且只加载一次</li>
<li>static修饰的成员多了一种调用方式，即直接被类名调用</li>
<li>static变量值在类加载时分配空间，以后创建类对象时不会重新分配，可以对其任意赋值</li>
</ol>
<h4 id="static应用场景"><a href="#static应用场景" class="headerlink" title="static应用场景"></a>static应用场景</h4><ol>
<li>修饰成员变量</li>
<li>修饰成员方法</li>
<li>静态代码块</li>
<li>修饰类（只能修饰内部类即静态内部类）</li>
<li>静态导包</li>
</ol>
<h4 id="static注意事项"><a href="#static注意事项" class="headerlink" title="static注意事项"></a>static注意事项</h4><ol>
<li>静态方法只能访问静态成员，静态方法可直接被类名调用，非静态既可以访问静态，又可以访问非静态</li>
<li>静态 方法中不能出现this与static</li>
<li>主函数是静态的，不要在主函数中创建其他函数</li>
</ol>
<h4 id="方法调用顺序"><a href="#方法调用顺序" class="headerlink" title="方法调用顺序"></a>方法调用顺序</h4><p>父类静态代码块-&gt;子类静态代码块-&gt;子类静态方法-&gt;父类非静态代码块-&gt;父类构造方法-&gt;子类非静态代码块-&gt;子类构造方法</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="final作用"><a href="#final作用" class="headerlink" title="final作用"></a>final作用</h4><p>用于修饰类、属性和方法</p>
<ul>
<li><p>被final修饰的<strong>类不可以被继承</strong></p>
<p>关键字final置于定义前</p>
</li>
<li><p>被final修饰的<strong>方法不可以被重写</strong></p>
<p>防止任何继承类修改其定义，处于设计的考虑</p>
</li>
<li><p>被final修饰的变量不可以被改变，<strong>不可变的是变量的引用</strong>，而不是引用指向的内容（针对对象）</p>
<p>一般会加静态，全局变量。固定常量一律用final修饰。<strong>不能改变的数据类型需要是基本数据类型</strong>，对常量定义时需要对其赋值。对对象的引用表明此引用不能指向另一个对象，但对象本身可以被修改。</p>
</li>
</ul>
<p>允许在参数列表中以声明的方式将参数指定为final，意味着无法在方法中更改参数引用所指向的对象。可以读参数，无法改参数，主要用来<strong>向匿名内部类传递数据</strong>。</p>
<h4 id="final-finally-finalize区别"><a href="#final-finally-finalize区别" class="headerlink" title="final finally finalize区别"></a>final finally finalize区别</h4><ul>
<li>final可以修饰类、方法、变量，修饰类表明该类不能被继承，修饰方法表明该方法不能被重写，修饰变量表明该变量为常量不能重新被赋值，但若修饰的是对象的引用，不可变的是引用。</li>
<li>finally一般作用在try-catch代码块中，处理异常时将一定要执行的方法放在finally中，表示不管是否出现异常，该代码块都一定会执行（存在try语句，在try语句中没有执行System.exist(0)），一般放关闭资源的代码。</li>
<li>finalize是Object类的方法，一般由垃圾回收器调用，当调用Syetem.gc()的时候，由垃圾回收器调用finalize()，回收垃圾，是一个对象是否可回收的最后判断。</li>
</ul>
<h3 id="this与super"><a href="#this与super" class="headerlink" title="this与super"></a>this与super</h3><h4 id="this关键字使用"><a href="#this关键字使用" class="headerlink" title="this关键字使用"></a>this关键字使用</h4><p>this的含义：代表本类对象引用，可以理解成<strong>指向对象本身的一个指针</strong>。</p>
<p>this的用法</p>
<ol>
<li><p>普通的直接引用，this相当于当前对象本身</p>
</li>
<li><p>构造函数中，形参与成员变量重名，用this区分</p>
</li>
<li><p>在构造函数中引用本类的其他构造函数</p>
<p>this(待传入参数，可为空)，只能放在构造函数的第一行，不可与super()同时出现</p>
</li>
</ol>
<h4 id="super关键字使用"><a href="#super关键字使用" class="headerlink" title="super关键字使用"></a>super关键字使用</h4><p>super为指向超（父）类对象的指针，此超类为离当前类最近的一个父类。</p>
<p>super的用法与this类似</p>
<ol>
<li><p>普通的直接引用，使用super.xxx来引用父类成员</p>
</li>
<li><p>子类中的成员变量与父类中成员变量重名时，用super()区分</p>
</li>
<li><p>引用父类构造函数</p>
<p>super(参数)，调用父类中构造函数，在子类的构造函数第一行默认为super()，如果有this()，则没有super()，因为二者均需要出现在构造函数第一行</p>
</li>
</ol>
<h4 id="this与super-1"><a href="#this与super-1" class="headerlink" title="this与super"></a>this与super</h4><ol>
<li>this指当前对象，super指父类对象</li>
<li>this在本类中调用本来方法，super在子类中调用父类方法</li>
<li>this与super均要放在构造函数的第一行</li>
<li>this与super不能出现在一个构造函数中，因为this()中调用其他构造函数，其他构造函数中有super()</li>
<li>二者均不可在static环境中使用，如static变量，static方法，static代码块</li>
</ol>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h3><h4 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h4><p>面向过程：具体化的，流程化的，为了解决问题，需要一步步分析和实现</p>
<p>面向对象：模型化的，将过程的实现抽象为多个类，直接去调用类的属性和方法，不用去一步步实现，面向对象的底层是面向过程，将面向过程抽象成类并进行封装，就是面向对象了</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>优点</th>
<th>缺点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>面向过程</td>
<td>性能更高，没有调用类的资源消耗。</td>
<td>没有面向对象易维护、复用、扩展</td>
<td>单片机，嵌入式开发，Linux/Unix</td>
</tr>
<tr>
<td>面向对象</td>
<td>易维护、易复用、易扩展，系统耦合性更低</td>
<td>性能比面向过程低</td>
<td>需求变化多，互联网应用</td>
</tr>
</tbody></table>
<h4 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h4><p>面向对象的特征主要有4个方面，抽象，封装，继承和多态</p>
<p>抽象：将一类对象的<strong>共同特征</strong>总结出来构造类的过程，包括<strong>数据抽象</strong>和<strong>行为抽象</strong>两方面，抽象只关注对象的属性和行为，并不关心其实现细节。</p>
<p>封装：将一个对象的<strong>属性私有化</strong>，同时对外提供可以<strong>访问属性的方法</strong>。在类中编写方法对实现细节进行封装，隐藏一切可隐藏的，只对外暴露最简单的编程<strong>接口</strong>。</p>
<p>继承：从父类继承属性与方法到子类，子类可以增加新的数据和功能，方便复用，继承会增加类之间的耦合性。（里氏替换原则）</p>
<p>多态：某一种事物具有多种形态，用父类类型指向子类对象，一个对象对应着不同类型。</p>
<h4 id="面向对象的基本原则"><a href="#面向对象的基本原则" class="headerlink" title="面向对象的基本原则"></a>面向对象的基本原则</h4><ol>
<li><p>单一职责原则</p>
<p>一个类只有一个职责，内部高内聚</p>
</li>
<li><p>接口隔离原则</p>
<p>一个类对另一个类的依赖建立在最小的接口上</p>
</li>
<li><p>依赖倒转原则</p>
<p>抽象不应该依赖细节，细节应该依赖抽象，<strong>面向接口编程</strong>。依赖关系的三种传递：接口传递、构造方法传递、setter方法传递</p>
</li>
<li><p>里氏替换原则</p>
<p>与继承相关，任何时候子类都能替换父类</p>
</li>
<li><p>开放封闭原则</p>
<p>模块和函数应该对<strong>扩展开放</strong>（对提供方），对<strong>修改关闭</strong>（对使用方），<strong>用抽象构建框架，用实现扩展细节</strong></p>
</li>
<li><p>迪米特法则（最少知道原则）</p>
<p>一个类对自己依赖的类知道越少越好，陌生的类最好不要以局部变量形式出现在类的内部</p>
</li>
<li><p>合成复用原则</p>
<p>尽量使用合成/聚合的方式，而不是继承</p>
</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="继承的好处"><a href="#继承的好处" class="headerlink" title="继承的好处"></a>继承的好处</h4><ol>
<li>提高了代码的复用性</li>
<li>让类与类之间有了联系，为多态提供了前提</li>
</ol>
<h4 id="继承的注意事项"><a href="#继承的注意事项" class="headerlink" title="继承的注意事项"></a>继承的注意事项</h4><ol>
<li><p>Java中支持单继承，不直接支持多继承</p>
<p>多继承会出现父类成员变量调用的不确定性，可以多实现</p>
</li>
<li><p>子类中有父类非private的属性和方法</p>
</li>
<li><p>子类可以对父类的属性和功能进行扩展</p>
</li>
<li><p>子类可以对父类方法进行覆盖</p>
</li>
</ol>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="多态的特点与实现方式"><a href="#多态的特点与实现方式" class="headerlink" title="多态的特点与实现方式"></a>多态的特点与实现方式</h4><p>程序中的引用变量所指向的具体类型和调用方法只有在程序运行时才能确定，这样可以实现引用变量绑定到不同的类上，让程序可以选择多个运行状态。</p>
<p>利用父类或接口引用变量指向子类或具体实现类的对象，提高程序的扩展性。</p>
<p>方法<strong>重载</strong>（overload）实现的是<strong>编译</strong>时的多态性（也称<strong>前绑定</strong>），根据参数列表的不同来区分不同的函数；方法<strong>覆盖</strong>（override）实现的是<strong>运行</strong>时的多态性（也称<strong>后绑定</strong>），运行时的多态是面向对象最精髓的（引用变量调用的方法只有在运行时才能确定）。</p>
<p>实现多态需要做到</p>
<ul>
<li><p>继承（子类继承父类）</p>
</li>
<li><p>方法重写（子类重写父类中的<strong>已有</strong>或抽象方法）</p>
</li>
<li><p>向上转型（父类型引用子类对象，接口类型引用实现类的对象，相同的调用会根据子类对象不同而表现不同的行为）</p>
</li>
</ul>
<h3 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h3><h4 id="抽象类和接口的对比"><a href="#抽象类和接口的对比" class="headerlink" title="抽象类和接口的对比"></a>抽象类和接口的对比</h4><p>从设计层面来说，抽象类是对<strong>类的抽象</strong>，是一种模板设计；接口是<strong>行为的抽象</strong>，是一种行为的规范</p>
<p>相同点</p>
<ul>
<li>接口和抽象类<strong>不能直接实例化</strong></li>
<li>位于继承的顶端，用于被其他类实现或继承</li>
<li>都包含抽象方法，其子类必须覆写这些抽象方法</li>
</ul>
<p>不同点</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>声明</td>
<td>abstract关键字</td>
<td>interface关键字</td>
</tr>
<tr>
<td>实现</td>
<td>子类使用extends继承</td>
<td>子类使用implements实现</td>
</tr>
<tr>
<td>构造器</td>
<td>可以有</td>
<td>没有</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>方法可以为任意访问修饰符</td>
<td>接口方法默认为public，不允许定义为private或protected</td>
</tr>
<tr>
<td>多继承</td>
<td>只能继承一个类</td>
<td>可以多实现</td>
</tr>
<tr>
<td>抽象方法</td>
<td>可以有非抽象方法</td>
<td>全为抽象方法</td>
</tr>
</tbody></table>
<p>选择抽象类或者接口，遵循如下原则</p>
<ul>
<li>行为模型总是通过接口而不是抽象类定义，通常<strong>优先使用接口</strong>，少使用抽象类</li>
<li>选择抽象类的情况：需要定义子类的行为，又要为子类提供通用的功能</li>
</ul>
<h4 id="普通类与抽象类区别"><a href="#普通类与抽象类区别" class="headerlink" title="普通类与抽象类区别"></a>普通类与抽象类区别</h4><ul>
<li>普通类中不能有抽象方法，抽象类中可以包含抽象方法</li>
<li>普通类可以直接实例化，抽象类不能直接实例化</li>
</ul>
<h4 id="抽象类能用final修饰吗"><a href="#抽象类能用final修饰吗" class="headerlink" title="抽象类能用final修饰吗"></a>抽象类能用final修饰吗</h4><p>不能，定义抽象类的目的是让其他类继承，而final关键字修饰的类不能被继承，二者相违背，因此抽象类不能被final修饰</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="创建一个对象用什么关键字？对象实例与对象引用有何不同？"><a href="#创建一个对象用什么关键字？对象实例与对象引用有何不同？" class="headerlink" title="创建一个对象用什么关键字？对象实例与对象引用有何不同？"></a>创建一个对象用什么关键字？对象实例与对象引用有何不同？</h4><p>创建类使用关键字new，对象实例存在于堆内存中，而对象引用指向对象实例，对象引用可以指向一个对象实例或者指向空，而一个对象实例可以有多个对象引用指向它。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="成员变量与局部变量区别"><a href="#成员变量与局部变量区别" class="headerlink" title="成员变量与局部变量区别"></a>成员变量与局部变量区别</h4><p>成员变量定义在方法外部，局部变量定义在类的方法或代码块中。</p>
<ul>
<li>作用域：成员变量针对整个类有效，局部变量只在方法或代码块中有效</li>
<li>存储位置：成员变量存储在堆内存中，局部变量存储在栈中</li>
<li>生命周期：成员变量周期与对象一样，局部变量周期与方法一样</li>
<li>初始值：成员变量默认有初始值，局部变量没有默认初始值，使用前需要赋值</li>
<li>使用原则：就近原则，先在局部范围找，接着在成员中找</li>
</ul>
<h4 id="静态变量和实例变量区别"><a href="#静态变量和实例变量区别" class="headerlink" title="静态变量和实例变量区别"></a>静态变量和实例变量区别</h4><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在Java中定义一个不做事且没有参数的构造方法的作用"></a>在Java中定义一个不做事且没有参数的构造方法的作用</h4><p>在执行子类的构造方法前，默认执行super()，若父类中只有有参数的构造方法，则编译会报错，因为程序在父类中找不到相应方法来执行，因此需要在父类中加上一个不做事的空参的构造方法</p>
<h4 id="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"><a href="#在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？" class="headerlink" title="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"></a>在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</h4><p>子类与父类有较强的耦合性，在初始化子类前，需要相应对父类进行初始化，此函数可以帮助子类做初始化工作</p>
<h4 id="一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？"><a href="#一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？" class="headerlink" title="一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？"></a>一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？</h4><p>构造方法的主要作用是完成对类对象的<strong>初始化</strong>工作。若没有显式声明构造方法，程序也能正确执行，因为每个类中有一个默认的空参的构造方法，但当自己定义了构造方法后，就没有该默认构造方法了。</p>
<h4 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="构造方法有哪些特性？"></a>构造方法有哪些特性？</h4><ul>
<li>名字与类相同</li>
<li>没有返回值，不能用void声明函数</li>
<li>在new对象时自动调用该方法</li>
</ul>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h3 id="常见类"><a href="#常见类" class="headerlink" title="常见类"></a>常见类</h3><h4 id="Object中的方法"><a href="#Object中的方法" class="headerlink" title="Object中的方法"></a>Object中的方法</h4><h4 id="String的equals与"><a href="#String的equals与" class="headerlink" title="String的equals与=="></a>String的equals与==</h4><h4 id="String不变性的理解"><a href="#String不变性的理解" class="headerlink" title="String不变性的理解"></a>String不变性的理解</h4><h4 id="String重写equals而不重写hashcode的问题"><a href="#String重写equals而不重写hashcode的问题" class="headerlink" title="String重写equals而不重写hashcode的问题"></a>String重写equals而不重写hashcode的问题</h4><h4 id="String、StringBuffer、StringBuilder区别"><a href="#String、StringBuffer、StringBuilder区别" class="headerlink" title="String、StringBuffer、StringBuilder区别"></a>String、StringBuffer、StringBuilder区别</h4><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="List与Set"><a href="#List与Set" class="headerlink" title="List与Set"></a>List与Set</h3><p>Collection下有List、Set和Queue，重点说明List与Set的区别。</p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/list%E4%B8%8Eset.png" class title="This is an example image">

<p>一、特点</p>
<p>按照特点来看</p>
<ul>
<li>List：元素有序（存入和取出顺序一致），可以索引（角标）操作元素，元素可以重复</li>
<li>Set：元素不能重复，无序</li>
</ul>
<p>二、种类</p>
<ul>
<li><p>List</p>
<ul>
<li>底层是数组，查询快，增删慢<ul>
<li>Vector，线程安全，效率低</li>
<li>ArrayList，线程不安全，效率高</li>
</ul>
</li>
<li>底层是链表，查询慢，增删快<ul>
<li>LinkedList，线程不安全，效率高</li>
</ul>
</li>
</ul>
</li>
<li><p>Set</p>
<ul>
<li><p>底层是哈希表</p>
<p>HashSet，保证元素唯一性，存入的类需要覆写hashcode()和equals()方法</p>
<p>先判断hashcode()，再判断equals()</p>
</li>
<li><p>底层是二叉树</p>
<p>TreeSet，保证元素排序，两种排序方式，比较器优先使用</p>
<ul>
<li>自然顺序，让对象所属的类实现Compareble接口，覆盖compareTo()方法，无参构造</li>
<li>让集合自身具备比较功能，比较器实现Comparator接口，覆盖compare()方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>其中，Vector虽安全，但不适用于高并发。HashSet底层为HashMap，在add元素时，以键的形式放入，值为PRESENT。TreeSet的核心在排序，不排序用HashSet。TreeSet有两种排序方式，方式一是被排序类实现Compareble接口（实现equals()、hashcode()、compareTo()方法），方式二为传入比较器，比较器需要实现Comparator接口（实现compare()方法）。TreeSet底层为TreeMap，两种排序方式比较器优先级较高。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap为Java中非常重要和常用的一种数据结构，下面将重点介绍HashMap的底层原理及方法实现。</p>
<p>Java8以前：数组+链表</p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/%E9%93%BE%E8%A1%A8hash.png" class title="This is an example image">

<p>操作为非同步，效率较高。<strong>数组默认16</strong>，存储链表头节点，数组位置的获得方式是hash(key.hashCode())%len，计算键的哈希值再算出%数组长度的值。实际中通过位运算来实现。其中数组的类型为Entry&lt;K,V&gt;，当发生哈希冲突时，则将数组中的Entry设置为新值的next，新值放在数组中，旧值在新值的链表上。</p>
<p>最坏的情况下，链表会集中在一个数组，这样查找的时间复杂度从O(1)变为O(n)。</p>
<p>Java8及以后：链表+数组+红黑树</p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/%E7%BA%A2%E9%BB%91%E6%A0%91hash.png" class title="This is an example image">

<p>当数组中某个位置链表长度大于TREEIFY_THRESHOLD常量时，链表转换为红黑树，最坏情况下的性能从O(n)提高到O(logn)。数组类型变为Node，当链表大小<strong>超过</strong>TREEIFY_THRESHOLD（<strong>默认是8</strong>）时，链表被改造成红黑树。当红黑树元素被删除<strong>低于</strong>UNTREEIFY_THRESHOLD（<strong>默认是6</strong>）时，红黑树被转成链表。HashMap在首次使用时才被初始化，可以扩容，当插入一个元素，若对应位置数组没有元素，则新建；如果有，则判断是树还是链表，按照相应方式插入。若链表元素超过阈值，则树化；若插入值的键重复，就更新值。</p>
<h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><p>HashMap的put方法逻辑是：</p>
<ol>
<li>若HashMap未被初始化 ，进行初始化</li>
<li>对key求hash值，计算下标</li>
<li>如果没有碰撞，直接放入桶中</li>
<li>如果碰撞了，以链表的方式链接到 后面</li>
<li>如果链表长度超过阈值（8），把链表转成红黑树</li>
<li>如果链表的长度低于6，把红黑树转成链表</li>
<li>如果key对应节点存在，替换旧值</li>
<li>如果桶满了（容量16*负载因子0.75），需要resize（扩容2倍重排）</li>
</ol>
<h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><p>先计算hash值找到对应的桶，然后在链表或者红黑树中通过equals方法找到对应的节点，找到值并返回。</p>
<h4 id="扩容resize-方法"><a href="#扩容resize-方法" class="headerlink" title="扩容resize()方法"></a>扩容resize()方法</h4><p>在构造哈希表时，若不指明初始大小，默认为16，若大小达到了容量16*负载因子0.75，用大数组去替代小数组，重新调整hashmap大小为原来2倍，比较耗时。</p>
<ul>
<li>在多线程环境下，调整大小会存在条件竞争，容易造成<strong>死锁</strong></li>
<li>rehashing是一个比较耗时的过程</li>
</ul>
<h4 id="如何减少碰撞"><a href="#如何减少碰撞" class="headerlink" title="如何减少碰撞"></a>如何减少碰撞</h4><ul>
<li><p>使用扰动函数：促使元素位置分布均匀，减少碰撞几率</p>
</li>
<li><p>使用final对象，并采用合适的equals()和hashCode()方法</p>
<p>使用String、Integer等类作为键很好，防止键值改变，放入和获取到的键不一样，就不能获取到</p>
</li>
</ul>
<p>哈希散列的过程：可以看到<strong>hashmap允许键为null</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> h;</span><br><span class="line">	<span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h=key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将hashCode右移16位，去除低位，与原数据异或，混合原始哈希码的高位和低位，加大低位随机性，散列更均匀，计算下标使用(数组长度-1)&amp;hash，数组长度总为2^n（传入值时替换为最接近2的n次方的值），等价于对长度取模，效率更高。    </p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/hash%E6%95%A3%E5%88%97.png" class title="This is an example image">

<h4 id="Dos攻击"><a href="#Dos攻击" class="headerlink" title="Dos攻击"></a>Dos攻击</h4><p>在JDK7以前，如果对方知道我方使用哈希算法，可以发送大量哈希值相同的请求来导致严重的哈希碰撞，然后不停访问这些key就可以显著影响服务器的性能（大量占用CPU），这样形成了一次拒绝服务供给（DoS）。这样将最坏性能从O（N）优化至O（logN），有较大的改善。</p>
<p>那么怎么进一步处理呢？</p>
<ol>
<li>限制POST和GET请求参数个数</li>
<li>限制POST请求的请求体大小</li>
<li>Web Application FireWall（WAF）</li>
</ol>
<p>对于JDK7，HashMap会动态的使用一个专门的TreeMap实现来替换掉它。</p>
<h4 id="多线程下的HashMap"><a href="#多线程下的HashMap" class="headerlink" title="多线程下的HashMap"></a>多线程下的HashMap</h4><p>由于HashMap不是线程安全的，在多线程下会出现问题，有</p>
<ul>
<li><p>多线程put操作后，get操作导致死循环</p>
<p>rehash时容易出现环状链表</p>
</li>
<li><p>多线程put非null元素后，get操作得到null值</p>
</li>
<li><p>多线程put操作，导致元素丢失</p>
</li>
</ul>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><blockquote>
<p>引用自博客<code>https://my.oschina.net/hosee/blog/618828</code></p>
</blockquote>
<p>要了解红黑树是什么，为什么要有红黑树。</p>
<p>红黑树是二叉查找树，不同的是在每个结点上增加一个存储位来表示颜色，Red或Black。而红黑树的特点是通过对任何一条从根到叶子的路径上各个结点的着色方式的限制，红黑树确保没有一条路径比其他路径长出两倍，树是接近平衡的。</p>
<p>二叉查找树简单理解是：</p>
<ul>
<li>若有左子树，则左子树上所有结点的值均小于根节点值 </li>
<li>若有右子树，则右子树上所有结点的值均大于根节点值</li>
<li>任意节点的左、右子树分别为二叉查找树</li>
<li>没有键值相等的节点</li>
</ul>
<p>一般普通的二叉查找树高度为log(N)，但如果二叉查找树退化为一个链表，最坏时间会变成O（N）,那么红黑树如何保证树相对平衡呢？介绍其5个性质：</p>
<ol>
<li>每个节点要么红、要么黑</li>
<li>根节点是黑</li>
<li>叶节点是黑的</li>
<li>若一个节点是红，两个儿子都是黑的（不存在两个连续的红色节点）</li>
<li>对任意节点，其到叶节点尾端指针的每条路径都包含相同数目的黑节点</li>
</ol>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%9B%BE.png" class title="This is an example image">

<p>数学证明红黑树的操作时间复杂度最差为O(logN)。</p>
<h4 id="HashMap与HashTable"><a href="#HashMap与HashTable" class="headerlink" title="HashMap与HashTable"></a>HashMap与HashTable</h4><p>因为HashMap在多线程下不安全，而线程安全的类有HashTable，其线程安全原因是使用了synchronized修饰符，锁为调用者的this，与Collections.synchronizedMap(hashMap)几乎无区别，只是锁不一样，synchronizedMap锁为Object类的mutex，hashMap方法均用synchronized(mutex)加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但HashTable在多线程下效率较低，因此又引入了ConcurrentHashMap。</p>
<h4 id="HashMap与ConcurrentHashMap"><a href="#HashMap与ConcurrentHashMap" class="headerlink" title="HashMap与ConcurrentHashMap"></a>HashMap与ConcurrentHashMap</h4><p>那么该如何优化HashTable呢？</p>
<p><strong>通过锁细粒度化，将整锁拆解成多个锁进行优化</strong>。</p>
<p>早期的ConcurrentHashMap通过<strong>分段锁Segment</strong>实现</p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/segment.png" class title="This is an example image">

<p>在HashMap的基础上，外面多了一层数组结构，有多个Segment（一种可重入锁），每个Segment中有多段数据（HashEntry），当一个线程占用一个锁时，位于此Segment上的其他数据也可以被访问到。默认分配<strong>16</strong>个Segment，理论上比HashTable效率高16倍。将HashMap的table数组逻辑上拆分为多个子数组，每个子数组配置一个Segment，线程只有在获取到某把分段锁后，才能获取到其中的子数组，其他没有该Segment的线程访问其中数据被阻塞，而访问没有被Segment锁住的数据不会被阻塞。</p>
<p>而当前的ConcurrentHashMap，使用<strong>CAS+Synchronized使锁更细化</strong></p>
<h1 id="Java高级"><a href="#Java高级" class="headerlink" title="Java高级"></a>Java高级</h1>]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>并发与锁总结</title>
    <url>/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>要学习一个知识点，可以采取的思路是了解为什么要用它，怎么用它，有什么缺点，如何去改进。</p>
<p>对于并发 ，也将从这四个方面进行介绍。</p>
<a id="more"></a>

<blockquote>
<p>引用到的资料来源：</p>
<p><a href="https://blog.csdn.net/cy973071263/article/details/104546954" target="_blank" rel="noopener">https://blog.csdn.net/cy973071263/article/details/104546954</a></p>
<p><a href="https://blog.csdn.net/javazejian/article/details/72828483#理解java对象头与monitor" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/72828483#%E7%90%86%E8%A7%A3java%E5%AF%B9%E8%B1%A1%E5%A4%B4%E4%B8%8Emonitor</a></p>
<p><a href="https://blog.csdn.net/qq_37113604/article/details/81582784?depth_1-utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/qq_37113604/article/details/81582784?depth_1-utm_source=distribute.pc_relevant.none-task</a></p>
</blockquote>
<h2 id="并发应用场景"><a href="#并发应用场景" class="headerlink" title="并发应用场景"></a>并发应用场景</h2><p>利用多线程去替代单线程，主要有两个应用场景。</p>
<ol>
<li><p>获得更好的性能</p>
<p>单线程执行速度有限，为了获得更好的性能需要使用多线程</p>
</li>
<li><p>由于业务模型的需要</p>
<p>确实需要多个执行实体</p>
</li>
</ol>
<p>需要分清进程与线程的区别</p>
<h3 id="为什么要有进程与线程"><a href="#为什么要有进程与线程" class="headerlink" title="为什么要有进程与线程"></a>为什么要有进程与线程</h3><p>进程为了解决并发操作问题，保存了当前线程的状态，由于分配时间短，会有不同进程并行执行的感觉（实际为并发）。但一个进程只能一次执行一个任务，若子任务不存在顺序的区别，可以并发执行。让CPU切给子任务更细的时间片去执行。这样一个进程包括多个线程。</p>
<p><strong>进程让操作系统的并发成为可能，线程让进程的内部并发成为可能</strong>。</p>
<h3 id="进程与线程区别"><a href="#进程与线程区别" class="headerlink" title="进程与线程区别"></a>进程与线程区别</h3><ul>
<li><p>进程可以看作是独立应用，线程不可以</p>
</li>
<li><p>进程有独立的地址空间，相互不影响，线程只是进程的不同执行路径，线程没有独立的地址空间</p>
</li>
<li><p>多进程程序比多线程程序健壮</p>
</li>
<li><p>进程的切换比线程的切换开销大</p>
</li>
</ul>
<h2 id="多线程怎么用"><a href="#多线程怎么用" class="headerlink" title="多线程怎么用"></a>多线程怎么用</h2><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><ol>
<li><p>新建（New）：创建后尚未启动的线程的状态（还未调用start方法）</p>
</li>
<li><p>运行（Runnable）：包含Running和Ready（正在执行或等待CPU为其分配时间）</p>
</li>
<li><p>无限期等待（Waiting）：不会被分配CPU执行时间，需要显式被唤醒</p>
</li>
<li><p>限期等待（Timed Waiting）：在一定时间后会由系统自动唤醒（sleep方法）</p>
</li>
<li><p>阻塞（Blocked）：等待获取排它锁（Synchronized）</p>
</li>
<li><p>结束（Terminated）：已终止线程的状态，线程已经结束执行（run或main方法结束）</p>
</li>
</ol>
<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" class title="This is an example image">

<h3 id="Java使用多线程的三种方式"><a href="#Java使用多线程的三种方式" class="headerlink" title="Java使用多线程的三种方式"></a>Java使用多线程的三种方式</h3><h4 id="方式一：继承Thread类"><a href="#方式一：继承Thread类" class="headerlink" title="方式一：继承Thread类"></a>方式一：继承Thread类</h4><p>1、 定义一个类继承Thread类</p>
<p>2、 覆盖Thread类中的run()方法。Thread类用于描述线程，因此Thread类也有对任务的描述，这个任务就是通过Thread类中的run()方法来体现，因此 run()方法就是封装自定义线程运行任务的函数。run方法中定义的是线程要运行的任务代码。</p>
<p>3、 直接创建Thread的子类对象创建线程</p>
<p>4、 调用start()方法，作用为启动线程，调用run()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(MyThread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用的时候</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">MyThread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<p>原理：Thread本身实现了Runnable接口，通过start()方法启动线程，native方法start()启动新线程并执行run()方法，实现方式较为简单，但继承有局限性。</p>
<h4 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口"></a>方式二：实现Runnable接口</h4><p>1、 定义类实现Runnable接口</p>
<p>2、 覆盖接口中的run()方法，将线程的任务代码封装到run()方法中</p>
<p>3、 通过Thread类创建对象，并将Runnable接口的子类对象作为Thread类构造函数的参数进行传递</p>
<p>原因：因为线程的任务都封装在Runnable子类对象run()方法中，所以要在线程对象创建时明确要运行的任务。</p>
<p>4、 调用线程对象的start()方法启动线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RunTest r = <span class="keyword">new</span> RunTest();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<p>原理：当传入一个Runnable类型的任务参数target给Thread后，Thread的run()方法就会调用target.run()</p>
<h4 id="方式三：实现Callable接口"><a href="#方式三：实现Callable接口" class="headerlink" title="方式三：实现Callable接口"></a>方式三：实现Callable接口</h4><p>1、创建Callable接口的实现类，并实现call()方法，并创建该实现类的实例</p>
<p>2、使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值</p>
<p>3、使用FutureTask对象作为Thread对象的target创建并启动线程</p>
<p>4、调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String value = <span class="string">"test"</span>;</span><br><span class="line">        System.out.println(<span class="string">"Ready to work"</span>);</span><br><span class="line">        Thread.currentThread().sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">"task done"</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> MyCallable());</span><br><span class="line">    <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">    <span class="keyword">if</span> (!task.isDone())&#123;</span><br><span class="line">        System.out.println(<span class="string">"task has not finished, please wait"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"task return : "</span> + task.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get方法会被阻塞直到子线程结束。</p>
<h4 id="三种方法的比较"><a href="#三种方法的比较" class="headerlink" title="三种方法的比较"></a>三种方法的比较</h4><p>实现Runnable和实现Callable接口的方式大致相同，基本思路均为将任务进行分装再传递给Thread对象，但后者执行call()方法有返回值且get()方法可以获取异常，且Callable接口可以搭配线程池使用，进行统一管理。二者和Thread的比较为：</p>
<p>1、Thread是一个类，Runnable是一个接口；</p>
<p>2、继承Thread类后不能继承其他类，而实现Runnable接口后仍可继承其他类，更为灵活，避免了单继承的局限性；</p>
<p>3、Thread类中的资源不能共享（多个任务对象），而实现Runnable接口可以实现资源共享（只有一个任务对象）；</p>
<p>4、Runnable将任务记性封装，更体现了面向对象的编程思想。</p>
<p>因此相比于继承Thread，更推荐使用Runnable接口来实现多线程。</p>
<h4 id="Thread中run-方法执行顺序"><a href="#Thread中run-方法执行顺序" class="headerlink" title="Thread中run()方法执行顺序"></a>Thread中run()方法执行顺序</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println("R run");</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">)&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        System.out.println("T run");</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure>

<p>输出为T run，看Thread中run()方法的源码</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/* What will be run. */</span></span><br><span class="line">    private Runnable target;</span><br><span class="line">    </span><br><span class="line">@Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (target != null) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    其会对target进行判断，当target不为空的时候，执行Runnable的run方法，但由于多态，当子类方法覆写了父类方法时，会优先执行子类方法。因此执行顺序为Thread子类&gt;Runnable方法&gt;Thread类</p>
<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>上文中介绍了为什么要用多线程及如何使用，但当多个线程操作一个资源时，会带来安全问题。如两个线程都在卖票，剩最后一张票的时候，会出现票数量&lt;0的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+num--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当开启多个线程卖票的时候，会出现如下的结果</p>
<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/%E5%8D%96%E7%A5%A8.png" class title="This is an example image">

<p>已经限制了票数要&gt;0，为什么会出现票数=-1的情况呢？</p>
<h3 id="线程安全产生原因"><a href="#线程安全产生原因" class="headerlink" title="线程安全产生原因"></a>线程安全产生原因</h3><ol>
<li><p>多个线程在操作共享的数据。</p>
</li>
<li><p>操作共享数据的线程代码有多条。（操作共享数据代码在2行以上容易出事）</p>
</li>
</ol>
<p>当一个线程在执行操作共享数据的多条代码中，其他线程参与了运算，就会导致线程安全问题的产生。</p>
<p>那么该如何解决呢？</p>
<p>解决思路：将多条操作共享数据的线程代码封装起来；当有线程在执行这些代码的时候，其他线程是不可以参与运算的。必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算，类似于上锁，当一群人要去上厕所，谁进去了将门锁住，其他人（线程）也就进不来了。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><p>为了解决线程安全问题，有的锁比较悲观，认为其他线程一定会修改数据，因此在拿数据的时候会上锁，若其他线程访问会被阻塞，Java中关键字synchronized的实现为悲观锁；而乐观锁，在拿数据时，认为别人不会修改，不会上锁，但在更新时会判断其他线程有没有更新数据。乐观锁适用于多读的场景，可以提高吞吐量。CAS就是比较常见的乐观锁的实现方式。</p>
<p>下面将主要将介绍比较常见的synchronized，RenentrantLock与JMM的内存可见性（volatile）与CAS。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronized为互斥锁，具有的特性为</p>
<ol>
<li><p>互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程的协调机制，这样在同一时间只有一个线程对需要同步的代码块（复合操作）进行访问。互斥性也称为操作的<strong>原子性</strong>。</p>
</li>
<li><p>可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（<strong>即在获得锁时应获得最新共享变量的值</strong>），否则另一个线程可能是在本地缓存的某个副本上继续操作，从而引起不一致。</p>
</li>
</ol>
<p>synchronized锁的不是代码，锁的都是对象。</p>
<h4 id="synchronized使用"><a href="#synchronized使用" class="headerlink" title="synchronized使用"></a>synchronized使用</h4><p>可以分为对象锁和类锁，均加在同步代码块上或同步方法上。同步代码块的使用如下</p>
<p>对象锁：</p>
<p>1、 同步代码块（synchronized(this)）, synchronized(类实例对象))，锁是小括号()中的实例对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">synchrnozed(<span class="keyword">this</span>或类实例对象)&#123;</span><br><span class="line">	<span class="comment">//要同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、 同步非静态方法（synchronized method），锁是当前对象的实例对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> 返回值 method()&#123;</span><br><span class="line">	<span class="comment">//要同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类锁：</p>
<p>1、 同步代码块（synchronized(类.class)），锁时小括号()中的类的对象（Class对象）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">synchrnozed(类<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//要同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、 同步静态方法（synchronized static method），锁是当前对象的类对象（Class对象）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> 返回值 method()&#123;</span><br><span class="line">	<span class="comment">//要同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>当出现锁的嵌套时，容易出现死锁。即线程1先获取锁A，再获取锁B；而线程2先获取锁B，再获取锁A。这时候两个线程均不能请求 到另一个锁，就会出现死锁，进程卡死。</p>
<p>要注意的是，这里的两个锁对象一定要用static修饰，因为要保证这两个对象随类加载保证唯一性，如果不加static，就会每次new DeadLockSyn的时候，产生各自的两个o1，o2，则不能出现死锁现象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadLockSyn</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//要加static是因为随类的创建而产生</span></span><br><span class="line">    <span class="comment">//如果不加static，那么产生的是各自的object对象，不是同一个锁了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeadLockSyn</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"完成任务"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DeadLockSyn d1 = <span class="keyword">new</span> DeadLockSyn(<span class="keyword">true</span>);</span><br><span class="line">DeadLockSyn d2 = <span class="keyword">new</span> DeadLockSyn(<span class="keyword">false</span>);</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(d1);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(d2);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<p>简单实现死锁程序的关键</p>
<ul>
<li>两个锁对象保证唯一性：static修饰</li>
<li>两个锁的嵌套调用</li>
</ul>
<h4 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h4><p>当每个线程可以独立安全的完成自己的任务了，但如果A线程的任务涉及到了B线程，如A线程是生产烤鸭的，B线程是吃烤鸭的，只有生产出来的烤鸭被吃掉了A才会继续生产，那要如何实现呢？</p>
<p>这时候需要用到线程间的通信，即A线程刚来做烤鸭，发现B线程还没吃，就跟B线程交流下，让他快点吃，自己先睡个觉，等烤鸭被吃了再起来吃。主要用到的方法是wait、notify()与notifyAll()。</p>
<p><strong>生产者与消费者</strong></p>
<p>基本的实现思路是：封装一个烤鸭资源对象，实现Runnable接口，有一个标识变量，代表烤鸭有没有被吃。生产烤鸭的方法需要加锁，首先判断烤鸭有没有被吃，如果没被吃，生产任务停止，唤醒吃烤鸭任务。如果烤鸭被吃了，进行生产。吃烤鸭的方法与生产类似。</p>
<p>需要持有一个资源，其属性有资源名称name，当前资源数量和标志变量（用来判断消费还是生产）。对同步的生产方法，当还没有消费的时候，让当前线程wait，释放锁；当已经消费了，进行生产，反转标志变量，数量自增，唤醒其他线程。对同步的消费方法，当还没有生产的时候，让当前线程wait，释放锁；当已经生产了，进行消费，反转标志变量，唤醒其他线程。生产者和消费者类持有资源类对象，实现Runnable接口，并分别在run()方法中调用其生产和消费方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//生产的物品名称</span></span><br><span class="line">    <span class="comment">//同步的生产方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当还没有消费，生产线程等待</span></span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始生产</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        count++;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"生产"</span>+name+count);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同步的消费方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//当还没有生产，消费线程等待</span></span><br><span class="line">        <span class="keyword">while</span> (!flag)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始生产</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"消费"</span>+<span class="keyword">this</span>.name+count);</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Resource r;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Resource r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            r.set(<span class="string">"烤鸭"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Resource r;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Resource r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            r.out();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Resource r = <span class="keyword">new</span> Resource();</span><br><span class="line">        Producer p = <span class="keyword">new</span> Producer(r);</span><br><span class="line">        Consumer c = <span class="keyword">new</span> Consumer(r);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(p);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(p);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(c);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(c);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，在同步方法中判断标记要使用while而不能使用if，因为if只进行一次判断，不安全。唤醒线程的时候要使用notifyAll()而不能使用notify()，不然容易造成死锁。notify是唤醒线程池中的一个线程，而notifyAll是唤醒线程池中的所有线程。</p>
<p>可见在synchronized中，线程间通信主要依靠wait()、notify()和notifyAll()方法，这三个方法均在Object类中，那么既然wait()和sleep()都能让线程休眠，二者有什么区别呢？</p>
<p><strong>wait和sleep</strong>差别</p>
<p><strong>基本差别</strong></p>
<ol>
<li><p>sleep是<strong>Thread</strong>类的方法，wait是<strong>Object</strong>类中定义的方法</p>
</li>
<li><p>sleep()方法可以在任何地方使用， wait()方法只能在synchronized方法或synchronized块中使用</p>
</li>
<li><p>sleep在设置时间结束后自动唤醒，而wait需要使用notify或者notifyAll方法唤醒</p>
</li>
</ol>
<p><strong>本质差别</strong></p>
<p>​    Thread.sleep只会让出CPU，不会导致锁行为的改变；Object.wait不仅会让出CPU，还是释放已经占有的同步资源锁</p>
<p>二者相比，sleep类似于线程在厕所中睡着了，wait类似于从厕所中让出来睡着了。</p>
<p>介绍了synchronized后，需要了解为什么每个对象都可以作为锁，即需要了解synchronized的底层原理</p>
<h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><h4 id="实现基础"><a href="#实现基础" class="headerlink" title="实现基础"></a>实现基础</h4><p>实现synchronized的基础是以下两点</p>
<ul>
<li>Java对象头</li>
<li>Monitor</li>
</ul>
<h4 id="对象头结构"><a href="#对象头结构" class="headerlink" title="对象头结构"></a>对象头结构</h4><p>​    在JVM中，对象在内存中的布局有对象头、实例数据（存放类的属性数据信息）和对齐填充（虚拟机要求对象起始地址必须是8字节的整数倍）。一般synchronized使用的<strong>锁对象</strong>是存储在<strong>Java对象头</strong>里的，头结构由<strong>Mark Word</strong> 和<strong>CLass Metadata Address</strong>组成，其中CLass Metadata Address用于<strong>确定该对象是哪个类的实例</strong>；而<strong>Mark Word</strong>用于存储对象自身的运行时数据，是实现轻量级锁和偏向锁的<strong>关键</strong>，默认存储着对象的hashCode，分代年龄，锁类型，锁标志位等信息。</p>
<h4 id="Markword"><a href="#Markword" class="headerlink" title="Markword"></a>Markword</h4><img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/markword.png" class title="This is an example image">

<p>MarkWord被设计为一个<strong>非固定</strong>的数据结构，以便存储更多有效数据，会根据对象本身的状态，复用存储空间，轻量级锁和偏向锁是JDK6后新增。</p>
<h4 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h4><p>对于重量级锁，锁标志位是10，指针指向的是monitor对象的起始地址，<strong>每个对象都有Monitor与之关联</strong>，monitor被线程持有后就处于锁定状态。在Java虚拟机中，monitor是由ObjectMonitor实现。monitor底层由C++实现，里面有两个队列，WaitSet（等待池）和EntryList（锁池），而owner指向持有ObjectMonitor对象的线程。</p>
<p>具体过程为：当有多个线程同步访问同步代码时，进入锁池集合，当线程获取到锁对象的monitor以后，进入_Owner 区域并将owner变量设置为当前线程，Monitor中的计数器count+1，如果当前线程调用了wait()方法，会释放当前的Monitor，将owner变量设置为null，count减一，该线程进入等待池来等待被唤醒。若当前变量执行完毕，也会释放Monitor锁，并将对应的变量值复位。</p>
<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/monitor.png" class title="This is an example image">

<p>monitor对象存在于每个Java对象的对象头中，synchronized锁通过这种方式获取锁，这也是为什么所有Java对象均可以作为锁的原因，也是wait,notify,notifyAll等方法存在于对象Object中的原因。而wait,notify,notifyAll方法需要在synchronized中使用是因为调用这几个方法前必须拿到当前对象的监视器monitor对象，而synchronized关键字可以获取 monitor，因此若不在synchronized中使用会报IllegalMonitorStateException异常。</p>
<p>接下来反编译synchronized应用于同步代码块和同步方法中的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synBlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"synchronized in code block"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"synchronized in method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体操作为先javac生成对应class文件，然后执行javap -v Sync，首先看应用于同步代码块中的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>: monitorenter</span><br><span class="line">  4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">  7: ldc           #3                  // String synchronized in code block</span><br><span class="line">  9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line"> <span class="number">12</span>: aload_1</span><br><span class="line"> <span class="number">13</span>: monitorexit</span><br><span class="line"> <span class="number">14</span>: goto          <span class="number">22</span></span><br><span class="line"> <span class="number">17</span>: astore_2</span><br><span class="line"> <span class="number">18</span>: aload_1</span><br><span class="line"> <span class="number">19</span>: monitorexit</span><br></pre></td></tr></table></figure>

<p>截取了最重要的输出，可看到同步代码块实现的方式为monitorenter和monitorexit，分别是同步 开始和结束的位置。当执行monitorenter，当前线程会尝试获取对象锁，当计数器为0时，可以成功获取monitor并将计数器置为1，表示持有锁，当已经拥有此锁的时候，可以重入（再次遇到有相同对象锁时，可以获取）；若其他线程持有了锁，便会在monitorenter处阻塞，直到其他线程释放锁并将计数器置为0。为了保证monitorenter和monitorexit可以正常配对执行，编译期产生处理器声明可以处理任何异常，目的是为了处理monitorexit指令，正常释放锁，因此多了一个monitorexist。</p>
<p>而对于同步方法，并没有显式的monitorenter等，而是用ACC_SYNCHRONIZED访问标志来区分此方法是否是同步方法，当方法调用时，检查方法此标识是否被设置，如果设置则持有monitor，无论方法是否正常完成，释放monitor。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synMethod</span><span class="params">()</span></span>;</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">        0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        3: ldc           #5                  // String synchronized in method</span><br><span class="line">        5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">8</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>在早期，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间（时间成本相对较高）。而从JDK6以后，其性能有了较大提升</p>
<h3 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h3><h4 id="锁的膨胀"><a href="#锁的膨胀" class="headerlink" title="锁的膨胀"></a><strong>锁的膨胀</strong></h4><p>锁并不会一开始就进入到重量级锁，在JDK6对锁优化后，锁的状态有四种，并且会根据实际情况膨胀升级，膨胀方向为无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁。</p>
<p><strong>偏向锁</strong></p>
<p>在很多情况下，锁不存在多线程竞争，总是由一个线程多次获得。其核心的思想是：当一个线程获得了锁，锁就进入偏向模式，Markword的结构调整为偏向锁模式，当该线程再次请求锁的时候，获取锁的过程只要检查Markword的<strong>锁标记位</strong>是偏向锁且当前线程id与Markword中<strong>ThreadID</strong>相等即可，这样便可以省去很多锁申请的操作。</p>
<p>​    适用条件：无锁竞争的场合，但不适用于比较激烈的多线程场合。偏向锁失败后会先升级为轻量级锁。</p>
<p><strong>轻量级锁</strong></p>
<p>​    轻量级锁适用于线程交替执行同步代码，其依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，只允许顺序拿锁，但如果有竞争操作，轻量级锁会先尝试自旋，尝试失败后会膨胀为重量级锁。</p>
<p>轻量级锁的加锁过程</p>
<ol>
<li>在代码进入到同步代码块的时候，如果同步对象锁是无锁状态（锁标志位是‘01’），虚拟机首先在当前 线程的栈帧中建立叫锁空间（Lock Record）的空间用于存储锁对象目前的Mark Word拷贝，官方称为Displaced Mark Word，此时线程堆栈和对象头状态如下</li>
</ol>
<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/%E8%BD%BB%E9%87%8F%E7%BA%A71.png" class title="This is an example image">

<ol start="2">
<li>拷贝对象头中的Mark Word复制到锁记录中</li>
<li>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record中owner指针指向object mark word。如果更新成功，执行步骤4，否则执行步骤5</li>
<li>如果更新成功，当前线程就拥有了该对象的锁，并且对象mark word锁标志设置成‘00’，表示此对象处于轻量级锁状态，此时线程堆栈与对象头的状态如下</li>
</ol>
<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/%E8%BD%BB%E9%87%8F%E7%BA%A72.png" class title="This is an example image">

<ol start="5">
<li>如果更新失败了，虚拟机首先将检查对象的mark word是否指向当前线程的栈帧，是说明当前线程已经拥有了锁，可以直接进入同步块继续执行。否则说明有多个线程竞争锁，先进行一段时间的自旋，如果自旋期间成功获得锁，则执行同步代码。若自旋结束后也没有获得锁，则将膨胀为重量级锁，将锁标志位变成‘10’，此时mark word中存储的就是指向重量级锁的指针，后面等待锁的线程进入阻塞状态。</li>
</ol>
<p>执行完毕解锁</p>
<ol>
<li>通过CAS操作尝试把线程栈帧中复制的Displaced Mark Word对象替换当前的Mark Word</li>
<li>若替换成功，整个同步过程就完成了</li>
<li>若替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），则要在释放锁的同时，唤醒被挂起的线程</li>
</ol>
<p><strong>自旋锁</strong></p>
<p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。依赖的思想是也许几个CPU周期后就可以获得锁，虚拟机会让当前等待锁的线程做几个空循环（称为自旋的原因），经过固定的若干次循环后，如果得到锁，就进入临界区。反之，就会将线程真实地在操作系统层面挂起。</p>
<p>自旋锁的缺点是：若锁被其他线程长时间占用，会带来许多性能上的开销</p>
<p>因此自旋<strong>需要有一定的限度</strong>，如果超出限度还没有获取到锁，就要用传统的方法去挂起线程。</p>
<p>对自旋锁有优化，为<strong>自适应自旋锁</strong>，自旋的次数不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，这样JVM依据之前自旋成功率在增加或减少自旋次数，<strong>更加精确</strong>。</p>
<p>比较三种锁如下</p>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距</td>
<td>若线程存在锁竞争，会带来额外的锁撤销的消耗</td>
<td>只有<strong>一个线程</strong>访问同步块或同步方法</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>若线程长时间抢不到锁，自旋会消耗CPU性能</td>
<td><strong>线程交替执行</strong>同步方法块或同步方法的场景</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU</td>
<td>线程<strong>阻塞</strong>，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗</td>
<td>追求吞吐量，同步块或者同步方法<strong>执行时间较长的场景</strong></td>
</tr>
</tbody></table>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>上面介绍了第一种优化方式是使用锁膨胀来代替单纯的重量级锁，而第二种方式为使用锁消除。</p>
<p>在JIT（Just-In-Time Compiler）编译时，对运行上下文进行扫描，去除不可能存在竞争的锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">        System.out.println(<span class="string">"method1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    System.out.println(<span class="string">"method2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中，method1中方法虽然被同步修饰，但锁变量为方法内的私有变量，不会被其他线程获取到，因此在编译阶段会被优化掉，反编译得到结果如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PUBLIC</span><br><span class="line">   Code:</span><br></pre></td></tr></table></figure>

<p>可以看到并没有ACC_SYNCHRONIZED标志。</p>
<p>在动态编译同步块的时候，JIT编译器借助逃逸分析（Escape Analysis）技术来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。</p>
<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>锁粗化是虚拟机对另一种极端情况的优化处理，通过扩大锁的范围，避免反复加锁和释放锁。</p>
<p>一般设置同步时尽量限制在小的范围，只在共享数据的实际作用域中，减少等待时间。但如果有一连串操作对一个对象<strong>反复加锁解锁</strong>，甚至加锁操作出现在<strong>循环体</strong>中，即使没有线程竞争，频繁进行互斥同步锁操作，会降低性能。当JIT此时会将加锁同步的范围扩散（粗化）到整个<strong>操作序列的外部</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面操作中，在循环体中进行了加锁，如果没有锁粗化，那么方法一应该会比方法二慢很多，但测试了两端代码运行时间后，结果为下图</p>
<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/%E9%94%81%E7%B2%97%E5%8C%96.png" class title="This is an example image">

<p>说明方法一种锁范围被扩大至循环体外，验证了锁粗化的效果。</p>
<p>上文中介绍了Java中使用synchrnonized上锁的方式，那么按照面向对象的思想，能否将锁及线程间的通信业对象化 呢？下面将介绍将介绍其增强版-重入锁。</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentranlLock位于java.util.concurrent.locks包，基于AQS（AbstractQueuedSynchronizer队列同步器）实现，AQS是Java并发构建锁或其他同步组件的基础，是JUC包的核心，一般使用AQS的方式为继承，而利用AQS实现同步结构，必须要实现同步结构，至少要实现acquire（实现资源的独占权）和release（释放对资源的独占）。</p>
<h4 id="ReentranlLock特点"><a href="#ReentranlLock特点" class="headerlink" title="ReentranlLock特点"></a>ReentranlLock特点</h4><p>ReentrantLock的特点有：</p>
<ul>
<li><p>重入锁有着显式的操作过程，必须手动指定何时加锁、释放锁，在逻辑控制的灵活性上好于synchronized。</p>
</li>
<li><p>在退出临界区时必须释放锁。</p>
</li>
<li><p>可以实现比synchronized更细粒度的控制，如控制锁的公平性</p>
<p>在公平时，倾向于将锁赋予等待时间最长的线程</p>
</li>
<li><p>性能不一定比synchronized高，也是可重入（已持有锁的线程可以再次访问需要同一个锁的代码）的</p>
<p>在低竞争场合，synchronized性能可能会优于ReentrantLock</p>
</li>
</ul>
<h4 id="ReentrantLock使用"><a href="#ReentrantLock使用" class="headerlink" title="ReentrantLock使用"></a>ReentrantLock使用</h4><p>使用可重入锁的流程分为三步：</p>
<ol>
<li>上锁</li>
<li>try中写同步执行代码</li>
<li>finally中解锁</li>
</ol>
<h4 id="处理死锁"><a href="#处理死锁" class="headerlink" title="处理死锁"></a>处理死锁</h4><p>之前演示过了synchronized的死锁情况，使用ReentrantLock也可以达到相同的效果，那么有没有方法可以处理死锁呢？</p>
<p><strong>中断响应</strong></p>
<p>对于synchronized，线程等待锁，结果是要么获取锁执行，要么继续等待，而RenentranlLock提供了线程可以被中断的情况，在等待锁的过程中，程序可以根据需要取消对锁的请求，对处理死锁有一定的帮助。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> lockStatus;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntLock</span><span class="params">(<span class="keyword">int</span> lockStatus)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockStatus = lockStatus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lockStatus == <span class="number">1</span>)&#123;</span><br><span class="line">                lock1.lockInterruptibly();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;&#125;</span><br><span class="line">                lock2.lockInterruptibly();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lock2.lockInterruptibly();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;&#125;</span><br><span class="line">                lock1.lockInterruptibly();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"线程完成任务"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock1.isHeldByCurrentThread())</span><br><span class="line">                lock1.unlock();</span><br><span class="line">            <span class="keyword">if</span> (lock2.isHeldByCurrentThread())</span><br><span class="line">                lock2.unlock();</span><br><span class="line">            System.out.println(Thread.currentThread().getId()+<span class="string">"线程退出"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">		<span class="comment">//main函数中</span></span><br><span class="line">        IntLock lock1 = <span class="keyword">new</span> IntLock(<span class="number">1</span>);</span><br><span class="line">        IntLock lock2 = <span class="keyword">new</span> IntLock(<span class="number">2</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(lock1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(lock2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t2.interrupt();</span><br></pre></td></tr></table></figure>

<p>lock1与lock2容易形成死锁，lockInterruptibly方法可以对中断进行相应的锁申请动作，在等待锁的过程中可以响应中断。当t2被中断的时候，t2会放弃对锁lock1的申请，同时释放已经获得的lock2，这样t1线程就可以顺序获取lock2而执行下去。</p>
<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/%E5%93%8D%E5%BA%94%E4%B8%AD%E6%96%AD.png" class title="This is an example image">

<p><strong>锁申请等待限时</strong></p>
<p>除了等待外部通知将线程中断外，避免死锁还可以使用限时等待。给定等待时间，让线程自动放弃，    使用tryLock()方法进行限时的等待，tryLock()方法接收两个参数，等待时长和计时单位。在请求等待时间之内，如果请求成功，返回true，否则返回false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TryLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">                Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"完成任务"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"任务失败"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock.isHeldByCurrentThread())</span><br><span class="line">                lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当创建两个线程去执行此任务时，会发现线程2执行失败，线程1执行成功。因为先持有锁的线程会持有锁6秒，而另一个线程等待锁只有5秒钟（5,TimeUnit.SECONDS），因此后请求锁的线程请求失败。</p>
<p>此方法也可以空参数运行，表示当前线程尝试获取锁，如果锁未被其他线程占用，申请锁成功，并立刻返回true；若锁被其他线程占用，当前线程不会等待，立刻返回false。这种模式不会引起线程等待，也不会引起死锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TryLockDeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">int</span> lock;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TryLockDeadLock</span><span class="params">(<span class="keyword">int</span> lock)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lock == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//上锁1</span></span><br><span class="line">                <span class="keyword">if</span> (lock1.tryLock())&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">                        <span class="comment">//上锁2</span></span><br><span class="line">                        <span class="keyword">if</span> (lock2.tryLock())&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                System.out.println(Thread.currentThread().getName()+<span class="string">"job done"</span>);</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                                lock2.unlock();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                        lock1.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//上锁2</span></span><br><span class="line">                <span class="keyword">if</span> (lock2.tryLock())&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">                        <span class="comment">//上锁1</span></span><br><span class="line">                        <span class="keyword">if</span> (lock1.tryLock())&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                System.out.println(Thread.currentThread().getName()+<span class="string">"job done"</span>);</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                                lock1.unlock();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                        lock2.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>死锁代码：利用条件判断，第一个线程先用锁1，再用锁2；第二个线程先用锁2，再用锁1。使用tryLock()后，线程不会一直处于阻塞状态，会不停尝试，只要执行足够长的时间，线程会得到需要的资源（同时获得两个所），从而正常执行。但结果不总是会正常完成，有时还是会出现死锁。</p>
<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>在大多数情况下，锁的申请都是非公平的，即不会根据等待时间来挑选执行线程。而公平锁的特点是：不会产生饥饿现象，不会出现一线程长时间等待获取不到CPU分配时间的情况。</p>
<p>synchronized是非公平锁，而ReentrantLock可以设置为公平锁，将fair设置为true即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(Boolean fair)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FairLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock fair = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//1、上锁</span></span><br><span class="line">            fair.lock();</span><br><span class="line">            <span class="comment">//2、try中运行代码</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"工作"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3、finally中释放锁</span></span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                fair.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，当开启两个线程时，两个线程轮流输出，几乎不会发生同一个线程多次获得锁的可能，而如果使用非公平锁会出现一个线程多次获得锁进行输出。实现公平锁要维护一个有序队列，实现成本比较高，性能比较低下，默认可重入锁是非公平的，若无特殊需求不使用公平锁。</p>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>在synchrnozied中，有wait、notify和notifyAll搭配使用进行线程间的通信，而ReentrantLock中也有，那就是Condition，Condition与重入锁相关联，通过newCondition()方法可获取Condition对象，一个锁可以获得多个Condition，类似的，Condition中提供了await()、signal()、signalAll()方法。</p>
<p>下面将基于重入锁和Condition来实现多生产多消费者模式。核心是一个锁，两个监视器，在要同步的方法中，先上锁，然后在try中写同步代码，最后在finally中解锁。其中利用标志变量来判断当前线程是否休眠。生产者和消费者类实现Runnable接口，在run()方法中调用资源类的方法即可。要注意的是，生产完后，要唤醒消费线程；消费完后，要唤醒生产线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockResource</span></span>&#123;</span><br><span class="line">    <span class="comment">//一个锁，两个监视器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition proCondition = lock.newCondition();</span><br><span class="line">    Condition conCondition = lock.newCondition();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LockResource</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同步set方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//2、在try中写同步代码</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    proCondition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进行生产</span></span><br><span class="line">            count++;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"生产"</span>+name+count);</span><br><span class="line">            <span class="comment">//唤醒消费线程</span></span><br><span class="line">            conCondition.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、在finally中解锁</span></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同步消费方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//2、在try中写同步代码</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!flag)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conCondition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进行消费</span></span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"消费"</span>+name+count);</span><br><span class="line">            <span class="comment">//唤醒生产线程</span></span><br><span class="line">            proCondition.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、在finally中解锁</span></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerRe</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LockResource r;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProducerRe</span><span class="params">(LockResource r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            r.set();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerRe</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LockResource r;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsumerRe</span><span class="params">(LockResource r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            r.out();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="synchronized和ReentrantLock区别"><a href="#synchronized和ReentrantLock区别" class="headerlink" title="synchronized和ReentrantLock区别"></a>synchronized和ReentrantLock区别</h4><ol>
<li>synchronized是关键字，ReentrantLock是类</li>
<li>ReentrantLock可以设置为公平锁，synchronized不行</li>
<li>ReentrantLock可以设置锁的等待时间，避免死锁</li>
<li>底层机制：sync操作对象头中Mark Word，lock调用Unsafe类中方法</li>
</ol>
<h3 id="JMM内存可见性"><a href="#JMM内存可见性" class="headerlink" title="JMM内存可见性"></a>JMM内存可见性</h3><p>Java内存模型（Java Memory Model，简称JMM）是抽象概念，描述一组规范，围绕原子性、有序性和可见性展开。通过此规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。</p>
<p><strong>原子性</strong></p>
<p>原子性指一个操作不可中断，即使是多个线程一起执行的时候，一个操作一旦开始就不会被其他线程干扰。</p>
<p><strong>可见性</strong></p>
<p>可见性指当一个线程修改了某个共享变量的值，其他线程能够立刻知道这个修改。以下情况会导致可见性问题</p>
<ul>
<li><p>缓存优化</p>
<p>CPU改动后的值被缓存在cache或寄存器中，另一个CPU读到值没有更新</p>
</li>
<li><p>硬件优化</p>
<p>一些内存读写不会立即触发，而会先进入一个硬件队列等待</p>
</li>
<li><p>指令重排及编辑器优化</p>
</li>
</ul>
<p><strong>有序性</strong></p>
<p>在并发时，程序的执行可能会出现乱序，原因是程序在执行时可能会进行指令重排，重排后的指令与原指令未必一致。</p>
<p>线程将变量从主内存中拷贝至线程自己的本地内存进行操作，操作完成后再放回主内存。主内存和工作内存的关系是，工作内存是主内存的备份，工作内存是线程的私有区域。因此线程间的传值必须依靠主内存来完成。</p>
<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/%E4%B8%BB%E5%86%85%E5%AD%98.png" class title="This is an example image">

<h4 id="JMM中主内存和工作内存"><a href="#JMM中主内存和工作内存" class="headerlink" title="JMM中主内存和工作内存"></a>JMM中主内存和工作内存</h4><p>JMM中的主内存</p>
<ul>
<li>存储Java实例对象</li>
<li>包括成员变量、类信息、常量、静态变量等</li>
<li>属于数据共享的区域，多线程并发操作会引发线程安全问题</li>
</ul>
<p>JMM中的工作内存</p>
<ul>
<li>存储当前方法的所有本地变量信息，本地变量对其他线程不可见</li>
<li>字节码行号指示器，Native方法信息</li>
<li>属于线程私有区域，不存在线程安全问题</li>
</ul>
<p>主内存与工作内存的数据类型及操作方式</p>
<ul>
<li>方法里的基本数据类型本地变量将直接存储在工作内存的栈帧结构中</li>
<li>引用类型的本地变量：引用存储在工作内存中，实例存储在主内存中</li>
<li>成员变量、static信息、类信息均存储在主内存中</li>
<li>主内存共享的方式是线程各拷贝一份数据到工作内存，操作完成后刷新回主内存</li>
</ul>
<p>前面提到指令重排会影响可见性和有序性，但指令重排对提高CPU性能非常重要，那什么时候不能够指令重排呢？答案是无法通过happens-before原则推导出来的，才能进行指令重排。在JVM内部的实现，通常依赖于<strong>内存屏障</strong>，通过禁止某些重排序的方式，提供内存可见性保证，即实现了各种happens-before的规则。下面将简单介绍下happens-before原则。</p>
<h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><ol>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；（先来后到）</li>
<li>锁定规则：一个unlock操作先行于后面对同一个锁的lock操作；（解锁后才能上锁）</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；（写好才给看）</li>
<li>传递规则：A先于B，B先于C，则A先于C；（排队）</li>
<li>线程启动规则：线程的start()方法先于它的每一个动作；（不开始不许动）</li>
<li>线程中断规则：线程的中断（interrupt()）先于被中断的代码检测到中断的发生；</li>
<li>线程终结规则：线程的操作先于线程的终结（Thread.join()）；</li>
<li>对象终结规则：对象的初始化先于finalized。</li>
</ol>
<p>值得注意的是，第1条的次序规则只在单线程下有效，多线程中不一定保证。第3条volatitle保证了线程的可见性，写一定先于读。第6条线程A若对线程B设置中断，线程B马上可以知道。第8个要保证对象的字段要在初始化后可见。</p>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>为了在适当的场合保证线程间的原子性、有序性和可见性，volatile关键字是JVM提供的轻量级同步机制，对于保证操作的原子性有很大的帮助，但其<strong>不能替代锁</strong>，也无法保证一些复合操作的原子性。</p>
<ul>
<li>保证被volatile修饰的共享变量对所有线程总是<strong>可见</strong>的</li>
<li>禁止指令重排序优化</li>
</ul>
<p>如果操作volatile修饰的变量是复合的（多条操作），如value++这种（先读，后自增），即使value被volatile修饰也会引发线程安全问题。synchronized会创建内存屏障，保证所有CPU结果刷到主内存中，可以保证操作的内存可见性，因此在synchronized代码块或方法中操作的变量可以省略volatile修饰。而如果对一个变量的操作是原子性的，如操作布尔类型的变量，加上volatile就可以实现可见性，实现线程安全的目的，此时可以省略synchronized。</p>
<h5 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h5><p>当写一个volatile变量时，JMM把该线程对应的工作内存中的共享变量刷新到主内存中；当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效，只能从主线程中重新读取。</p>
<h5 id="如何禁止重排序"><a href="#如何禁止重排序" class="headerlink" title="如何禁止重排序"></a>如何禁止重排序</h5><p>内存屏障（Memory Barrier）</p>
<ol>
<li>保证特性操作的执行顺序</li>
<li>保证某些变量的内存可见性</li>
</ol>
<p>通过插入内存屏障禁止指令在内存屏障前后的指令执行重排序优化；强制刷出各种CPU的缓存数据，因此任何CPU上的线程能够读取到这些数据的最新版本。</p>
<h5 id="单例双重检测"><a href="#单例双重检测" class="headerlink" title="单例双重检测"></a>单例双重检测</h5><p>广为人知的单例模式懒汉式在多线程下是不安全的，因此有如下的双重检测</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中要点是，此类中持有的instance是私有静态的，因为不能被其他类直接获取而且不能通过对象获得。构造函数要私有。获取实例的对象要公共静态，为了直接通过类名调用。锁对象为单例类的class对象而双重检测，同步是为了线程安全，外层判断是为了提高效率。但是这样依然会存在风险。</p>
<p>原因 ：instance = new Singleton();可以分为三步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memory = allocate();<span class="comment">//1、分配对象内存空间</span></span><br><span class="line">instance(memory); <span class="comment">//2、初始化对象</span></span><br><span class="line">instance = memory <span class="comment">//3、设置instance指向刚分配的内存地址，此时instance=null</span></span><br></pre></td></tr></table></figure>

<p>而因为步骤2和步骤3之间没有happens-before关系，因此是可以被重排序的，这样排序后的顺序为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memory = allocate();<span class="comment">//1、分配对象内存空间</span></span><br><span class="line">instance = memory <span class="comment">//3、设置instance指向刚分配的内存地址，此时instance！=null</span></span><br><span class="line">instance(memory); <span class="comment">//2、初始化对象</span></span><br></pre></td></tr></table></figure>

<p>这时候，会出现instance指向了分配的空间已经不为null，但还没有初始化对象，如果此时线程被切走，再次进来的线程判断instance不为空，直接将instance返回，出现问题。</p>
<p>因此解决办法是不让这部分指令重排，即<strong>让instance被volatile修饰</strong>。因此完整的线程安全的单例双重检测如下，其中volatile与static顺序没有要求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Singleton&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="volatile与synchronized"><a href="#volatile与synchronized" class="headerlink" title="volatile与synchronized"></a>volatile与synchronized</h4><ol>
<li>二者本质不同。volatile为告诉JVM当前变量在寄存器（工作内存）中的值是不确定的，需要<strong>从主存中读取</strong>；synchronized则是<strong>锁定当前变量</strong>，只有当前线程可以访问该变量，其他线程被阻塞住直到该线程完成变量操作为止。</li>
<li><strong>使用级别</strong>不同。volatile仅能使用在变量级别，而synchronized可以使用在变量、方法和类级别<ul>
<li>synchronized(A.class) //修饰类</li>
<li>synchronized void get() //修饰方法</li>
<li>synchronized(o) //修饰变量</li>
</ul>
</li>
<li>volatile仅能实现变量的修改可见性，<strong>不确保原子性</strong>；而synchronized可以保证变量修改的可见性和原子性</li>
<li>volatile不会造成线程阻塞，而synchronized会</li>
<li>volatile标记的变量不会被编译期优化，synchronized标记的变量可以被编译期优化</li>
</ol>
<h3 id="CAS-Compare-and-Swap"><a href="#CAS-Compare-and-Swap" class="headerlink" title="CAS(Compare and Swap)"></a>CAS(Compare and Swap)</h3><p>​    乐观锁最常见的实现方式，默认没有数据冲突，如果有就回滚数据并重新提交。</p>
<p>CAS是一种高效实现数据安全性的方法</p>
<ul>
<li>支持原子更新操作，适用于计数器，序列发生器（给变量自增的工具）等场景</li>
<li>属于乐观锁机制，号称lock-free（底层仍有加锁行为）</li>
<li>CAS操作失败时由开发者决定是否继续尝试，还是执行其他操作</li>
</ul>
<h4 id="CAS思想"><a href="#CAS思想" class="headerlink" title="CAS思想"></a>CAS思想</h4><p>包含有三个操作数——内存位置（V），预期原值（A）和新值（B）</p>
<p>将内存位置（主内存）的值与预期原值比较，如果匹配则自动将该位置值更新为新值，并返回true；否则不做任何操作，并返回false。</p>
<p>对于volatile修饰的变量，虽然保证了内存可见性，但不能保证操作原子性，反编译如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译结果部分展示如下</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">2: getfield      #2                  // Field value:I</span><br><span class="line">     <span class="number">5</span>: iconst_1</span><br><span class="line">     <span class="number">6</span>: iadd</span><br><span class="line">     7: putfield      #2                  // Field value:I</span><br></pre></td></tr></table></figure>

<p>可以看到自增这个操作是分为先取值，再自增，再将值放回去的，因此这种非原子性的操作容易引发线程安全问题。而之前介绍的将add方法加上synchronized关键字实现悲观锁可以解决，但是效率相对较低，此时也可以使用CAS这种乐观锁来实现。Java中的AtomicInteger类便可以在不使用悲观锁的情况下保证线程安全，引用其实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">            <span class="keyword">int</span> current = get();  </span><br><span class="line">            <span class="keyword">int</span> next = current + <span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))  </span><br><span class="line">                <span class="keyword">return</span> current;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//存在自旋</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> var5;</span><br><span class="line">    	<span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    	&#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"> </span><br><span class="line">    	<span class="keyword">return</span> var5;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中getAndIncrement相当于自增操作，那么来看CAS操作是如何实现操作的安全性的。首先value被volatile修饰，这样保证了内存的可见性，因此当前数current为从主内存中刷出来的数据(CAS中的A)，next为其操作后变成的数据(CAS中的B)，然后调用了unsafe类的compareAndSwapInt方法，其中unsafe类为底层实现，其中为native方法，其实现逻辑类似于如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == expect) &#123;</span><br><span class="line">	<span class="keyword">this</span> = update</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即如果期望值A与主内存处为同一地址，那么就将主内存中的地址修改为更新后的值位置；否则不做修改。因此CAS的关键在于将期望值与主内存中值进行比较，确保值没有变动才进行修改。</p>
<p>在J.U.C包中的atomic包中提供了常用的原子性数据以及引用、数组等相关原子类型和更新操作工具，是很多线程安全服务的首选。那么CAS这么好用，有没有什么缺点呢？</p>
<h4 id="CAS缺点及解决方式"><a href="#CAS缺点及解决方式" class="headerlink" title="CAS缺点及解决方式"></a>CAS缺点及解决方式</h4><ul>
<li>CAS中存在自旋等待，若循环时间长，开销很大，浪费CPU资源</li>
<li>由于CAS比较的为this对象，因此只能保证一个共享变量的原子操作</li>
<li>ABA问题</li>
</ul>
<p>下面将详细介绍ABA问题。ABA问题描述为如果内存地址V初次读取到为A，在赋值检查时仍为A，不能保证此值没有被其他线程修改过，如果曾经被改为B再改回来，CAS操作会误认为此值没有被改变过，此漏洞就是CAS的ABA问题。</p>
<p>那么该如何解决呢？</p>
<p>1、ABA问题</p>
<p>对于解决ABA问题，JDK1.5后后atomic包中提供了类AtomicStampedReference类，增加了<strong>版本号的比较</strong>，在比较值的同时，再进行版本号的比较。若存在ABA问题的应用场景，使用传统的互斥同步会更高效点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                             V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> newStamp)</span></span></span><br></pre></td></tr></table></figure>

<p>版本号的使用如下(使用lambda表达式，()-&gt;{方法代码})</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//新建类，初始化值</span></span><br><span class="line">        AtomicStampedReference&lt;Integer&gt; at = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//新建两个任务，执行方法</span></span><br><span class="line">        <span class="comment">//任务1，执行ABA操作</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = at.getStamp();</span><br><span class="line">            System.out.println(<span class="string">"线程1第一次拿到的版本号"</span>+stamp);</span><br><span class="line">            <span class="comment">//暂停一段时间，让线程2拿到相同的版本号</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">            <span class="comment">//进行A-&gt;B操作</span></span><br><span class="line">            at.compareAndSet(<span class="number">2</span>,<span class="number">5</span>,at.getStamp(),at.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"线程1第一次操作后的版本号"</span>+at.getStamp());</span><br><span class="line">            <span class="comment">//进行B-&gt;A操作</span></span><br><span class="line">            at.compareAndSet(<span class="number">5</span>,<span class="number">2</span>,at.getStamp(),at.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"线程1第二次操作后的版本号"</span>+at.getStamp());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = at.getStamp();</span><br><span class="line">            System.out.println(<span class="string">"线程2第一次拿到的版本号"</span>+stamp);</span><br><span class="line">            <span class="comment">//暂停，让线程一完成ABA操作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进行A-&gt;C操作，看能否操作成功</span></span><br><span class="line">            <span class="keyword">boolean</span> b = at.compareAndSet(<span class="number">2</span>,<span class="number">10</span>,stamp,stamp+<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"当前内存中最新值为"</span>+at.getReference());</span><br><span class="line">            System.out.println(<span class="string">"线程2处理完ABA问题后的结果为："</span>+b);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这样当线程1执行完ABA操作后，虽然期待值与主内存中值相等，但是版本号变化了，因此当线程2用旧的版本号进行操作的时候，无法成功执行CAS操作，执行结果为</p>
<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/CAS%E7%BB%93%E6%9E%9C.png" class title="This is an example image">

<p>2、循环时间长</p>
<blockquote>
<p>以下解释引用自<a href="https://blog.csdn.net/qq_37113604/article/details/81582784?depth_1-utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">博客</a></p>
<p>若JVM可以支持处理器提供的pause指令效率会有一定提升。pause指令的作用是：1、延迟流水线执行指令，使CPU不消耗过多的执行资源；2、避免在退出循环时因内存顺序冲突而引起CPU流水线被清空，提高CPU执行效率。</p>
</blockquote>
<p>3、只能保证一个共享变量的原子操作</p>
<p>可以将多个变量合并为一个共享变量进行操作，JDK1.5后提供了AtomicReference类，可以保证引用对象之间的原子性，因此可以将多个变量放在一个对象中进行CAS操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect, V update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CAS与synchronized"><a href="#CAS与synchronized" class="headerlink" title="CAS与synchronized"></a>CAS与synchronized</h4><p>在synchronized未被改进前，synchronized在资源竞争较少时，线程被阻塞在操作系统层面被挂起开销较大，因此CAS更适用于竞争较少的场合；而竞争较多的场合，CAS资源几率大，效率低于synchronized。</p>
<p>而synchronized在JDK1.6后被改进，有了前面介绍过的锁的膨胀机制，在竞争资源较少时也能获得与CAS类似的性能。</p>
<h4 id="concurrent包的实现"><a href="#concurrent包的实现" class="headerlink" title="concurrent包的实现"></a>concurrent包的实现</h4><p>concurrent包有通用化的实现模式</p>
<blockquote>
<ol>
<li>声明共享变量为volatile（保证内存可见性）</li>
<li>使用CAS的原子条件更新实现线程间的同步</li>
<li>配合以volatile的读/写和CAS所具有的读和写的内存语义来实现线程间的通信</li>
</ol>
</blockquote>
<p>关于锁的实现先说到这里，接下来说下多线程非常常用的线程池。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>在之前使用多线程时，依赖的是新建多个Thread对象，然后传递任务对象，再开启线程。</p>
<p>但是线程的创建与销毁开销是比较大的，为了重复利用线程，提高效率，便有了线程池。为了了解线程池，从为什么要用线程池（优势），怎么用线程池（方式与种类），重要参数来说明。</p>
<h4 id="线程池优势"><a href="#线程池优势" class="headerlink" title="线程池优势"></a>线程池优势</h4><ul>
<li><p><strong>降低资源消耗</strong></p>
<p>重复利用已创建的线程来降低线程创建和销毁造成的消耗</p>
</li>
<li><p><strong>提高线程的可管理性</strong></p>
<p>线程是稀缺资源，无限制的创建会消耗系统资源，降低稳定性，使用线程池可以统一的分配、调优和监控</p>
</li>
</ul>
<p>使用线程池后，创建线程变成从线程池中获得空闲线程，关闭线程变成向线程池归还线程。</p>
<h4 id="常见线程池种类"><a href="#常见线程池种类" class="headerlink" title="常见线程池种类"></a>常见线程池种类</h4><p>JDK提供了Executor框架来更好的控制线程池，下面先介绍5种常用的线程池工作方法。</p>
<p>1、指定工作数量的线程池</p>
<p>newFixedThreadPool(int nThreads)</p>
<p>每当一个任务去创建一个线程，如果工作线程数量达到线程池的初始最大数，将提交的任务存储池队列中；如果工作线程退出，将会有新的工作线程被创建，补足nThread的数目。</p>
<p>适用于可以<strong>预测线程数量</strong>的任务中，或者服务器<strong>负载较重</strong>，对当前线程数量进行限制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、处理大量短时间工作任务的线程池</p>
<p>newCachedThreadPool()</p>
<p>（1）试图缓存线程并重用，当无缓存线程可用时，就创建新的线程</p>
<p>（2）如果线程闲置的时间超过阈值（一般60s），则会被终止并移出缓存</p>
<p>（3）系统长时间闲置的时候，不会占用什么资源</p>
<p>适用于服务器<strong>负载较轻</strong>，执行很多短期异步任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、唯一的工作线程池</p>
<p>newSingleThreadExecutor()</p>
<p>创建唯一的工作线程来执行任务，如果线程异常结束，会有另一个线程取代它。可保证顺序的去执行各个任务，且在给定的时间内不会有多个线程是活动的。</p>
<p>适用于需要保证<strong>顺序执行</strong>各个任务，并且在任意时间点，<strong>不会有多个线程是活动的</strong>场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、定时或者周期性的工作调度</p>
<p>newSingleThreadScheduledExecutor()与newScheduledThreadPool(int corePoolSize)</p>
<p>二者区别在于单一工作线程还是多个线程，前者与newSingleThreadExecutor()一样，若线程异常结束，会有另一个线程来取代它确保顺序执行。</p>
<p>适用于需要后台线程<strong>执行周期任务</strong>的场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、拥有多个任务队列的线程池</p>
<p>newWorkStealingPool()</p>
<p>内部创建ForkJoinPool，利用work-stealing算法，并行地执行任务，不保证处理顺序，JDK8引入。</p>
<p>可以减少连接数，创建当前可用CPU数量的线程来并行执行，适用于大耗时的操作，可以并行来执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ForkJoin框架</p>
<p>将大任务切割成若干个小任务并发执行，最终汇总每个小任务的结果后得到大任务结果的框架。</p>
<p>是Executor接口的一种具体实现，更好利用多处理带来的好处，使用分治法解决问题。使用的是work-stealing算法，具体是从其他任务队列中窃取任务来执行。将任务分别放在不同的队列中，为每个队列来创建一个线程执行任务。会出现某些队列任务已经完成而其他队列任务还没有完成的情况，这时候为了提高效率，完成任务的处于空闲状态的线程会从其他处于busy状态的线程处窃取等待执行的任务。为了减少窃取和被窃取任务的竞争，使用双端队列，<strong>被窃取任务</strong>线程从双端队列<strong>头部</strong>拿任务执行，而<strong>窃取任务</strong>线程从双端队列<strong>尾部</strong>拿任务。</p>
<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/%E7%AA%83%E5%8F%96%E4%BB%BB%E5%8A%A1.png" class title="This is an example image">

<p>下面将介绍JDK中的Executor框架</p>
<h4 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h4><img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/%E6%A1%86%E6%9E%B6.png" class title="This is an example image">

<p>Executor框架将任务的提交与运行进行分离，在Java标准库中提供了Executor、ExecutorService和ScheduledExecutorService三个接口和基础实现。如Executors类扮演<strong>线程池工厂</strong>的角色，通过Executors可以获得拥有特定功能的线程池。ThreadPoolExecutor类实现Executor接口，表示一个<strong>线程池</strong>，通过此接口，任何Runnable的对象均可以被ThreadPoolExecutor线程池调度。以上成员均在J.U.C包中。</p>
<h4 id="J-U-C的三个Executor接口"><a href="#J-U-C的三个Executor接口" class="headerlink" title="J.U.C的三个Executor接口"></a>J.U.C的三个Executor接口</h4><h5 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h5><p>运行新任务的简单接口，将任务提交与任务执行细节解耦。下面只有一个execute(Runnable command)方法，线程执行有多种可能</p>
<ul>
<li>可能为创建一个新线程并立即启动</li>
<li>可能是用已有的工作线程来运行传入的任务</li>
<li>可能是根据设置线程池的容量或阻塞队列的容量来决定将线程放入阻塞队列或接收传入的线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br></pre></td></tr></table></figure>

<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/%E6%8E%A5%E5%8F%A31.png" class title="This is an example image">

<h5 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h5><p>具备管理执行器和任务声明周期的方法，提交任务机制更完善。扩展了Executor接口，如可以返回Future的submit方法，Callable弥补了Runnale没有返回值的短板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h5><p>扩展了ExecutorService，支持定期执行任务。</p>
<h4 id="线程池使用"><a href="#线程池使用" class="headerlink" title="线程池使用"></a>线程池使用</h4><p>展示固定大小的线程池的使用为例子，基本思路仍为创建任务类实现Runnable接口，实现run()方法，然后利用Executors线程工厂来获取线程池，利用线程池的submit(task)方法来执行任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis()+<span class="string">": Thread ID"</span>+Thread.currentThread().getId());</span><br><span class="line">        <span class="comment">//休息一秒钟</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、新建线程池</span></span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//将任务放入线程池，并执行10次</span></span><br><span class="line">        MyTask task = <span class="keyword">new</span> MyTask();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            es.submit(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中这里让一个线程执行后休眠1秒钟，然后线程池大小设置为5，让线程池执行10次任务，可以看到任务5个5个分批次执行，而且每一批都为相同的几个线程，结果如下所示。</p>
<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BC%94%E7%A4%BA1.png" class title="This is an example image">

<p>但是如果使用的是newCachedThreadPool()，则可以10个线程一批执行完。</p>
<p>但是有些时候，Executors工厂类中提供的线程池不能满足需求，这时候可以通过ThreadPoolExecutor构造函数去创建线程池。</p>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4>

<p>线程池整个的应用逻辑为：线程池由工作队列WorkQueue来存储各个队列提交的工作任务。工作队列可以是容量为0的SynchronizedQueue，主要用于newCachedThreadPool；也可以是newFixedThreadPool中的LinkedBlockingQueue。队列接到任务后，排队提交给线程池，即工作队列的集合，该集合负责在运行的过程中管理线程的创建和销毁。线程池的<strong>工作线程</strong>被抽象为静态内部类WorkerThread，线程池维护的其实是一组<strong>Worker对象</strong>。</p>
<p>Worker类是ThreadPoolExecutor类中的内部类，继承自AQS，实现了Runnable，由firstTast保存传入的任务，thread保存创建出来的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">            <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当Worker启动的时候，调用run()方法来启动里面的逻辑。</p>
<p>ThreadPoolExecutor构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                             TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                             RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<p>5个参数比较关键</p>
<ul>
<li>corePoolSize：核心线程数量（长期驻留的线程数，不同实现差别很大）</li>
<li>maximumPoolSize：线程不够用时能够创建的最大线程数（有的固定于核心线程一样，有的可以创建更多）</li>
<li>keepAliveTime：抢占的顺序不一定，看运气（线程池维护线程允许的空闲时间，当线程池中线程数量大于corePoolSize的时候，若没有新任务提交，核心线程外的线程不会立即被销毁，而是等待时间超过keepAliveTime）</li>
<li>workQueue：任务等待队列（当任务提交时，若线程池中线程数量大于等于PoolSize，将任务封装为Worker对象放入等待队列中）<ul>
<li>直接提交的队列：SynchronousQueue<strong>没有容量</strong>，是<strong>无缓冲等待队列</strong>，是一个不存储元素的<strong>阻塞</strong>队列，一个插入操作要等待一个删除操作。提交的任务不会被真实保存，总是将新任务给线程执行，若没有空闲的线程，尝试创建新的线程。一般要求maximumPoolSizes设置很大，避免线程拒绝执行操作。</li>
<li>有界的任务队列：ArrayBlockingQueue，构造函数必须传入其最大容量，当有新任务执行，线程数小于核心线程数，优先创建线程，若大于，将新任务加进等待队列。若队列满了，无法加入，在总线程数不大于最大线程数时，创建新线程执行任务；否则执行拒绝策略。因此有界队列仅在任务队列装满时才可能将线程数扩充到核心线程数之上。</li>
<li>无界的任务队列：LinkedBlockingQueue，当有新任务执行，线程数小于设定核心线程数，生成新线程执行任务，当线程数达到核心线程数后，线程不会增加，若有任务没有被消费，放进队列等待，队列可以一直增长直到耗尽系统资源。每个线程完全独立于其他线程。生产者和消费者使用<strong>独立的锁</strong>来控制数据的同步，即在高并发的情况下可以并行操作队列中的数据。</li>
<li>优先任务队列：PriorityBlockingQueue，可控制任务先后执行顺序，特殊的无界队列，ArrayBlockingQueue与LinkedBlockingQueue按照先进先出顺序执行，而此队列确保高优先级的任务先执行。</li>
</ul>
</li>
<li>threadFactory：创建新线程，Executors.defaultThreadFactory()（使用这个创建，新线程有一样的优先级，且是非守护线程，同时设置了线程的名称）</li>
</ul>
<p>而其中的handle，是线程池的饱和策略</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记</title>
    <url>/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="OJ处理技巧"><a href="#OJ处理技巧" class="headerlink" title="OJ处理技巧"></a>OJ处理技巧</h1><p>类名为public class Main</p>
<p>较好的做法是将要用到的类都封装好，不要放在Main类中，主类只需要持有要用到的类的对象，然后调用即可。</p>
<p>StringBuilder类的append方法，res.append(str1).append(str2)比res.append(str1+str2)效率高。</p>
<a id="more"></a>

<h2 id="获取不知次数的输入"><a href="#获取不知次数的输入" class="headerlink" title="获取不知次数的输入"></a>获取不知次数的输入</h2><p>使用BufferedReader来获取，需要Import，主函数需要抛出异常</p>
<p>valueOf返回值类型为Integer，parseInt返回值类型为int</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((s = br.readLine())!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//获取第一行输入，输入为一个数</span></span><br><span class="line">            <span class="keyword">int</span> len = Integer.valueOf(s);</span><br><span class="line">            <span class="comment">//获取第二行输入，输入为数组</span></span><br><span class="line">            String[] arrStr = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">int</span> [] arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                arr[i] = Integer.valueOf(arrStr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(要求的函数);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取有限次数的输入"><a href="#获取有限次数的输入" class="headerlink" title="获取有限次数的输入"></a>获取有限次数的输入</h2><p>输出的结果先用StringBuilder类存起来，如果有多行，每一行最后要加上换行标识。最后要输出的时候，将stringbuilder转变为String类输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="comment">//要持有的写的类</span></span><br><span class="line">        DogCatQueue dq = <span class="keyword">new</span> DogCatQueue();</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s = br.readLine();</span><br><span class="line">        <span class="keyword">int</span> count = Integer.valueOf(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            String[] strArr = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//if或者switch判断</span></span><br><span class="line">            <span class="keyword">switch</span> (strArr[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"add"</span>:</span><br><span class="line">                    String type=strArr[<span class="number">1</span>];</span><br><span class="line">                    dq.add(<span class="keyword">new</span> Pet(type,Integer.valueOf(strArr[<span class="number">2</span>])));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"pollAll"</span>:</span><br><span class="line">                    <span class="keyword">while</span>(!dq.isEmpty())&#123;</span><br><span class="line">                        pet = dq.pollAll();</span><br><span class="line">                        res.append(pet.getPetType()+<span class="string">" "</span>+pet.getPetIndex()+<span class="string">"\n"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"isDogEmpty"</span> :</span><br><span class="line">                    res.append(dq.isDogEmpty()?<span class="string">"yes\n"</span>:<span class="string">"no\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res.substring(<span class="number">0</span>,res.length()-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取输入矩阵"><a href="#获取输入矩阵" class="headerlink" title="获取输入矩阵"></a>获取输入矩阵</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="comment">//要持有的写的类</span></span><br><span class="line">        <span class="comment">//PringtEdge pe = new PringtEdge();</span></span><br><span class="line">        String[] s = <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="comment">//获取第一行的矩阵行与列</span></span><br><span class="line">        <span class="keyword">int</span> row = Integer.valueOf(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> col = Integer.valueOf(s[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        <span class="comment">//获取后面几行的矩阵数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            s = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                arr[i][j] = Integer.valueOf(s[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过自己编写方法获取结果</span></span><br><span class="line">        <span class="comment">//res = pe.printCircle(arr);</span></span><br><span class="line">        System.out.println(res.substring(<span class="number">0</span>,res.length()-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取数组"><a href="#获取数组" class="headerlink" title="获取数组"></a>获取数组</h2><p>输入只有一行，为数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">	<span class="comment">//交换数组中的数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//打印数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArr</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            System.out.print(arr[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        String[] strArray = str.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span>[] intArray = <span class="keyword">new</span> <span class="keyword">int</span>[strArray.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;strArray.length;i++) &#123;</span><br><span class="line">            intArray[i] = Integer.parseInt(strArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//要解决的</span></span><br><span class="line">        Solution(intArray);</span><br><span class="line">    	<span class="comment">//输出数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;intArray.length;i++) &#123;</span><br><span class="line">            System.out.print(intArray[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//or</span></span><br><span class="line">    	printArr(printArr);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输入有两行，第一行为数组长度，第二行为数组</p>
<p>获取long类型的数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">int</span> len = Integer.parseInt(br.readLine());</span><br><span class="line">        <span class="keyword">long</span>[] arr = <span class="keyword">new</span> <span class="keyword">long</span>[len];</span><br><span class="line">        String[] strArray = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">            arr[i] = Long.parseLong(strArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        LessMoney lm = <span class="keyword">new</span> LessMoney();</span><br><span class="line">        System.out.println(lm.getLessMoney(arr));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="获取链表"><a href="#获取链表" class="headerlink" title="获取链表"></a>获取链表</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node next;</span><br><span class="line">    Node pre;</span><br><span class="line">    Node(<span class="keyword">int</span> value)&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建单向链表</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">createNode</span><span class="params">(String[] str,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        Node head = <span class="keyword">new</span> Node(Integer.parseInt(str[<span class="number">0</span>]));</span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(Integer.parseInt(str[i]));</span><br><span class="line">            node.next = newNode;</span><br><span class="line">            node = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建双向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">createNodeDL</span><span class="params">(String[] str,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        Node head = <span class="keyword">new</span> Node(Integer.parseInt(str[<span class="number">0</span>]));</span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(Integer.parseInt(str[i]));</span><br><span class="line">            node.next = newNode;</span><br><span class="line">            node.next.pre = node;</span><br><span class="line">            node = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//打印列表</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            builder.append(node.value).append(<span class="string">" "</span>);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(builder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//主函数部分</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="comment">//创建第一个链表</span></span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(input.readLine());</span><br><span class="line">        String[] strings1 = input.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        Node list1 = createNode(strings1,n);</span><br><span class="line">        <span class="comment">//创建第二个链表</span></span><br><span class="line">        <span class="keyword">int</span> m = Integer.parseInt(input.readLine());</span><br><span class="line">        String[] strings2 = input.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        Node list2 = createNode(strings2,m);</span><br><span class="line">        <span class="comment">//要操作的函数</span></span><br><span class="line">        <span class="comment">//printCommonPart(list1,list2);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取树"><a href="#获取树" class="headerlink" title="获取树"></a>获取树</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="comment">//读取总的节点数与根节点数</span></span><br><span class="line">        String[] s=reader.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> rootIdx = Integer.parseInt(s[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//构造桶，将每个节点放入对应值，分别存其左、右结点的值</span></span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="comment">//将节点的数放入对应的桶中，构造得到数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            String[] sts = reader.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            t = Integer.parseInt(sts[<span class="number">0</span>]);</span><br><span class="line">            arr[t][<span class="number">0</span>] = Integer.parseInt(sts[<span class="number">1</span>]);</span><br><span class="line">            arr[t][<span class="number">1</span>] = Integer.parseInt(sts[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拿出头节点</span></span><br><span class="line">        Node head = <span class="keyword">new</span> Node(rootIdx);</span><br><span class="line">        createTree(head,arr);</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        preOrderRecur(head,res);</span><br><span class="line">        System.out.println(res.substring(<span class="number">0</span>,res.length()-<span class="number">1</span>));</span><br><span class="line">        res.delete(<span class="number">0</span>,res.length());</span><br><span class="line">        inOrderRecur(head,res);</span><br><span class="line">        System.out.println(res.substring(<span class="number">0</span>,res.length()-<span class="number">1</span>));</span><br><span class="line">        res.delete(<span class="number">0</span>,res.length());</span><br><span class="line">        posOrderRecur(head,res);</span><br><span class="line">        System.out.println(res.substring(<span class="number">0</span>,res.length()-<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createTree</span><span class="params">(Node root,<span class="keyword">int</span>[][] a)</span></span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=root.value;</span><br><span class="line">        <span class="keyword">int</span> l=a[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> r=a[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//左子树不为空，构造左子树</span></span><br><span class="line">        <span class="keyword">if</span>(l!=<span class="number">0</span>)&#123;</span><br><span class="line">            Node leftNode=<span class="keyword">new</span> Node(l);</span><br><span class="line">            root.left=leftNode;</span><br><span class="line">            <span class="comment">//递归产生左子树</span></span><br><span class="line">            createTree(leftNode,a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右子树不为空，构造右子树</span></span><br><span class="line">        <span class="keyword">if</span>(r!=<span class="number">0</span>)&#123;</span><br><span class="line">            Node rightNode=<span class="keyword">new</span> Node(r);</span><br><span class="line">            root.right=rightNode;</span><br><span class="line">            createTree(rightNode,a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="左神算法笔记"><a href="#左神算法笔记" class="headerlink" title="左神算法笔记"></a>左神算法笔记</h1><h2 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a>排序问题</h2><h3 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h3><p>题目描述：</p>
<p>数组小和的定义如下：</p>
<p>例如，数组s = [1, 3, 5, 2, 4, 6]，在s[0]的左边小于或等于s[0]的数的和为0；在s[1]的左边小于或等于s[1]的数的和为1；在s[2]的左边小于或等于s[2]的数的和为1+3=4；在s[3]的左边小于或等于s[3]的数的和为1；</p>
<p>在s[4]的左边小于或等于s[4]的数的和为1+3+2=6；在s[5]的左边小于或等于s[5]的数的和为1+3+5+2+4=15。所以s的小和为0+1+4+1+6+15=27</p>
<p>给定一个数组s，实现函数返回s的小和</p>
<p>[要求]</p>
<p>时间复杂度为O(nlogn)，空间复杂度为O(n)</p>
<p>思路：找小和，就是看当前数右边哪些数比他大 ，顺序并没有关系，因此可以用mergesort的思想，先分再合，产生小和的过程为merge的过程，如果右边数比左边大，那么总的小和个数为左边当前数*右边数个数，然后将两个数组sort中产生的数和当前merge共三部门数相加即可。</p>
<p>坑：</p>
<p>最后的小和可能很大，需要long类型才能过OJ，小和为小于等于，因此merge外排时判断为&lt;=</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        String s = null;</span><br><span class="line">        while((s=br.readLine())!=null)&#123;</span><br><span class="line">            int len = Integer.valueOf(s);</span><br><span class="line">            String[] arrStr = br.readLine().split(" ");</span><br><span class="line">            int[] arr = new int[len];</span><br><span class="line">            for(int i = 0;i &lt; len;i++)&#123;</span><br><span class="line">                arr[i] = Integer.parseInt(arrStr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(smallSum(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static long smallSum(int[] arr)&#123;</span><br><span class="line">        if(arr == null || arr.length &lt; 2)</span><br><span class="line">            return 0;</span><br><span class="line">        return sortProcess(arr,0,arr.length-1);</span><br><span class="line">    &#125;</span><br><span class="line">    public static long sortProcess(int[] arr,int l,int r)&#123;</span><br><span class="line">        if(l == r)</span><br><span class="line">            return 0;</span><br><span class="line">        int mid = l + (r - l)/2;</span><br><span class="line">        return sortProcess(arr,l,mid)+sortProcess(arr,mid+1,r)+<span class="keyword">merge</span>(arr,l,<span class="keyword">mid</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    public static long <span class="keyword">merge</span>(<span class="built_in">int</span>[] arr,<span class="built_in">int</span> l,<span class="built_in">int</span> <span class="keyword">mid</span>, <span class="built_in">int</span> r)&#123;</span><br><span class="line">        <span class="built_in">int</span> p1 = l,p2 = <span class="keyword">mid</span>+<span class="number">1</span>,i = <span class="number">0</span>;</span><br><span class="line">        int[] <span class="keyword">help</span> = <span class="keyword">new</span> <span class="built_in">int</span>[r-l+<span class="number">1</span>];</span><br><span class="line">        long res = 0;</span><br><span class="line">        while(p1&lt;=mid &amp;&amp; p2 &lt;= r)&#123;</span><br><span class="line">            if(arr[p1] &lt;= arr[p2])&#123;</span><br><span class="line">                res += arr[p1] * (r-p2+1);</span><br><span class="line">                <span class="keyword">help</span>[i++] = arr[p1++];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                <span class="keyword">help</span>[i++] = arr[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(p1&lt;=mid)&#123;</span><br><span class="line">            <span class="keyword">help</span>[i++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        while(p2&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">help</span>[i++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        for(i = 0;i&lt;help.length;i++)&#123;</span><br><span class="line">            arr[l+i] = <span class="keyword">help</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组排序后相邻数的最大差值"><a href="#数组排序后相邻数的最大差值" class="headerlink" title="数组排序后相邻数的最大差值"></a>数组排序后相邻数的最大差值</h3><p>题目描述</p>
<p>给定一个整形数组arr，返回排序后相邻两数的最大差值</p>
<p>arr = [9, 3, 1, 10]。如果排序，结果为[1, 3, 9, 10]，9和3的差为最大差值，故返回6。</p>
<p>arr = [5, 5, 5, 5]。返回0。</p>
<p>[要求]</p>
<p>时间复杂度为O(n)，空间复杂度为O(n)</p>
<p>当要排序，然后时间复杂度给定O(n)，那么只能使用桶排序，思路为把n个数放在n+1个桶中，那么肯定有1个桶中没有数字，这样最大的差值一定出现在两个桶之间，那么桶中有哪些数字不重要，只需要关注桶中是否有数字，最大数字和最小数字即可，最大差值为当前非空桶的最小值减去上一个非空桶的最大值。将数字放入桶，依据为将min-max的数据，放入0-len的桶中，数据长度为为len，桶的个数为len+1。在计算时为了避免越界，采用long型，然后转换为int。可以优化的点在于，如果算出来数组的最大值和最小值相等，那么可以直接返回0，不用建立桶。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((s=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> len = Integer.valueOf(s);</span><br><span class="line">            <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">            String[] arrStr = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                arr[i] = Integer.valueOf(arrStr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(maxGap(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxGap</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计数组最大和最小值</span></span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            min = Math.min(min,arr[i]);</span><br><span class="line">            max = Math.max(max,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果max=min，那么可以直接返回0</span></span><br><span class="line">        <span class="keyword">if</span>(max == min)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//建立桶，范围是0-len</span></span><br><span class="line">        <span class="comment">//有三个属性，是否进来过数，最大值，最小值</span></span><br><span class="line">        <span class="keyword">boolean</span>[] hasNum = <span class="keyword">new</span> <span class="keyword">boolean</span>[len+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] maxs = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] mins = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> bid = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将每一个数装入桶</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len;i++)&#123;</span><br><span class="line">            <span class="comment">//计算当前数应该在哪个桶</span></span><br><span class="line">            bid = bucket(arr[i],len,min,max);</span><br><span class="line">            <span class="comment">//统计桶的最大最小值，是否进去过数</span></span><br><span class="line">            maxs[bid] = hasNum[bid]?Math.max(maxs[bid],arr[i]):arr[i];</span><br><span class="line">            mins[bid] = hasNum[bid]?Math.min(mins[bid],arr[i]):arr[i];</span><br><span class="line">            hasNum[bid] = <span class="keyword">true</span>;<span class="comment">//当前桶进去了数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始计算差值</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lastMax = maxs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hasNum[i])&#123;</span><br><span class="line">                res = Math.max(res,mins[i]-lastMax);</span><br><span class="line">                lastMax = maxs[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bucket</span><span class="params">(<span class="keyword">long</span> num,<span class="keyword">long</span> len, <span class="keyword">long</span> min, <span class="keyword">long</span> max)</span></span>&#123;</span><br><span class="line">        <span class="comment">//目的，让值为min的在0桶，让值为max的在len桶</span></span><br><span class="line">        <span class="comment">//范围变换，从min-max变化为0-len</span></span><br><span class="line">        <span class="keyword">int</span> res = (<span class="keyword">int</span>)((num-min)*len/(max-min));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列和栈"><a href="#队列和栈" class="headerlink" title="队列和栈"></a>队列和栈</h2><h3 id="用数组实现栈和队列"><a href="#用数组实现栈和队列" class="headerlink" title="用数组实现栈和队列"></a>用数组实现栈和队列</h3><p>用数组实现栈比较简单，此类需要持有一个数组和当前位置标记，有初始化构造函数，获取最上面一个数peek方法，入栈push方法，出栈pop方法，要注意的是执行者三个方法时第一步为判断index范围，pop方法返回类型要是Integer而不是int，因为换成int不能返回null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用数组实现栈，应该持有数组，当前位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The init size is less than 0"</span>);</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//peek，获取最上面的数</span></span><br><span class="line">    <span class="comment">//返回类型为Integer，不然不能返回NULL</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> arr[index-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> obj)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果超出范围，报错</span></span><br><span class="line">        <span class="keyword">if</span> (index == arr.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"The stack is full"</span>);</span><br><span class="line">        <span class="comment">//如果正常，放入数据</span></span><br><span class="line">        arr[index++] = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"The stack is empty"</span>);</span><br><span class="line">        <span class="keyword">return</span> arr[--index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用数组实现队列，需要持有一个数组，一个入队列位置end，一个出队列位置start，一个队列大小size，用size来给end和start解耦</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用数组实现队列，需要持有数组，队列末尾，队列开始，size</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> initSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initSize &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The init size is less than 0"</span>);</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[initSize];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        end = <span class="number">0</span>;</span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//peek方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> arr[start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//push方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == arr.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"The queue is full"</span>);</span><br><span class="line">        size++;</span><br><span class="line">        arr[end] = obj;</span><br><span class="line">        <span class="comment">//循环队列</span></span><br><span class="line">        end = (end + <span class="number">1</span>) % arr.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//poll方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"The queue is empty"</span>);</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[start];</span><br><span class="line">        start = (start+<span class="number">1</span>)%arr.length;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getMin-功能的栈"><a href="#getMin-功能的栈" class="headerlink" title="getMin()功能的栈"></a>getMin()功能的栈</h3><p>实现一个特殊功能的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。</p>
<p>思路：持有两个栈，一个为数据栈，一个为最小栈，数据栈正常进出，而最小栈有两种方法实现。</p>
<p>方法一：当进来的数比最小数要小，直接入栈；当比最小数大，入栈最小数出栈时。两个栈正常出栈，返回data栈的值。</p>
<p>方法二：当进来的数比最小数要小，直接入栈；当比最小数大，min不入栈 。出栈时，当data出栈数等于最小数才出栈 ，其他时候min不出栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第二种方法，入栈的时候，如果当前数比较大，则min栈不进</span></span><br><span class="line">    <span class="comment">//出栈的时候，如果当前数比min栈小，min栈不出</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; dataStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getMin()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果栈为空，返回空</span></span><br><span class="line">        <span class="keyword">if</span> (minStack.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入栈方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minStack.empty()) &#123;</span><br><span class="line">            minStack.push(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt;= getMin()) &#123;</span><br><span class="line">            minStack.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        dataStack.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出栈方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dataStack.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> num = dataStack.pop();</span><br><span class="line">        <span class="comment">//只有当前数等于getmin，min栈才出</span></span><br><span class="line">        <span class="comment">//只有等于，没有小于</span></span><br><span class="line">        <span class="keyword">if</span> (num == getMin())</span><br><span class="line">            minStack.pop();</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h3><p>用队列来实现栈的功能，要有2个队列，当push的时候，正常进入队列，当peek的时候，先弹出其他的进入辅助队列，然后获取剩下来的一个的值，再将其放入辅助队列，再交换两个的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoQueueStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用两个队列实现栈</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; help;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoQueueStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        help = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//push</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        queue.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue.size()!=<span class="number">1</span>)&#123;</span><br><span class="line">            help.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = queue.poll();</span><br><span class="line">        help.add(res);</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            help.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = queue.poll();</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换两个队列引用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; temp = queue;</span><br><span class="line">        queue = help;</span><br><span class="line">        help = queue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><p>准备两个栈，一个push栈只用于push数据进去，一个pop栈只用于pop数据出来。从push栈倒数据进pop栈有两个要求，一个是pop栈中不能有数据，另一个是倒就要全部倒完。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoStackQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackPush;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackPop;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoStackQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stackPush = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stackPop = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        stackPush.push(num);</span><br><span class="line">        goTo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关键的倒数据步骤</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goTo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (stackPop.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//要倒完</span></span><br><span class="line">            <span class="keyword">while</span> (!stackPush.isEmpty())&#123;</span><br><span class="line">                stackPop.push(stackPush.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//peek步骤</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackPush.isEmpty() &amp;&amp; stackPop.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"The stack is empty"</span>);</span><br><span class="line">        goTo();</span><br><span class="line">        <span class="keyword">return</span> stackPop.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackPush.isEmpty() &amp;&amp; stackPop.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"The stack is empty"</span>);</span><br><span class="line">        goTo();</span><br><span class="line">        <span class="keyword">return</span> stackPop.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="猫狗队列"><a href="#猫狗队列" class="headerlink" title="猫狗队列"></a>猫狗队列</h3><p>实现一种猫狗队列的结构，要求如下：</p>
<ol>
<li><p>用户可以调用 add 方法将 cat 或者 dog 放入队列中</p>
</li>
<li><p>用户可以调用 pollAll 方法将队列中的 cat 和 dog 按照进队列的先后顺序依次弹出</p>
</li>
<li><p>用户可以调用 pollDog 方法将队列中的 dog 按照进队列的先后顺序依次弹出</p>
</li>
<li><p>用户可以调用 pollCat 方法将队列中的 cat 按照进队列的先后顺序依次弹出</p>
</li>
<li><p>用户可以调用 isEmpty 方法检查队列中是否还有 dog 或 cat</p>
</li>
<li><p>用户可以调用 isDogEmpty 方法检查队列中是否还有 dog</p>
</li>
<li><p>用户可以调用 isCatEmpty 方法检查队列中是否还有 cat</p>
</li>
</ol>
<p>思路：将Pet封装上一个index数据项，这样使用一个新类将二者封装。然后持有一个狗队列，一个猫队列，持有index，初始为0，在add操作中，如果是狗，就加入狗队列，是猫就加入猫队列。从队列中弹出较早入队列的，比较猫、狗队列中较小的index，弹出即可。</p>
<p>坑点：牛客网上的题目相比于原始题目，Pet自己也需要封装上一个index项，而比较的时候，比的是封装后的宠物队列类自己定义的index，而不是pet的index。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pet</span><span class="params">(String type,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.x = index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPetType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPetIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PetEnterQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//持有Pet和index</span></span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PetEnterQueue</span><span class="params">(Pet pet, <span class="keyword">long</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pet = pet;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//API：获取当前类型，index</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">getPet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPetType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pet.getPetType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DogCatQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//猫狗队列，一个持有猫，，一个持有狗</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;PetEnterQueue&gt; dogQueue;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;PetEnterQueue&gt; catQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DogCatQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dogQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        catQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Pet pet)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果为狗，加到狗；如果为猫，加到猫</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"dog"</span>.equals(pet.getPetType()))&#123;</span><br><span class="line">            dogQueue.add(<span class="keyword">new</span> PetEnterQueue(pet,index++));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"cat"</span>.equals(pet.getPetType()))&#123;</span><br><span class="line">            catQueue.add(<span class="keyword">new</span> PetEnterQueue(pet,index++));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"error, no dog or cat"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹出猫或者狗中较小的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">pollAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果两个均不为空</span></span><br><span class="line">        <span class="keyword">if</span> (!dogQueue.isEmpty() &amp;&amp; !catQueue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (dogQueue.peek().getIndex() &lt; catQueue.peek().getIndex())&#123;</span><br><span class="line">                <span class="keyword">return</span> dogQueue.poll().getPet();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> catQueue.poll().getPet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!dogQueue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//狗不为空</span></span><br><span class="line">            <span class="keyword">return</span> dogQueue.poll().getPet();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!catQueue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//猫不为空</span></span><br><span class="line">            <span class="keyword">return</span> catQueue.poll().getPet();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"The queue is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹出狗队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">pollDog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dogQueue.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Dog queue is empty"</span>);</span><br><span class="line">        <span class="keyword">return</span> dogQueue.poll().getPet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹出猫队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">pollCat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (catQueue.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Dog queue is empty"</span>);</span><br><span class="line">        <span class="keyword">return</span> catQueue.poll().getPet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isCatEmpty()&amp;&amp;isDogEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCatEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> catQueue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDogEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dogQueue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入输出的处理比较麻烦，使用StringBuilder来添加结果，最后用substring方法将其转换为字符串，要记得添加换行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        DogCatQueue dq = <span class="keyword">new</span> DogCatQueue();</span><br><span class="line">        Pet pet = <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s = br.readLine();</span><br><span class="line">        <span class="keyword">int</span> count = Integer.valueOf(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            String[] strArr = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">switch</span> (strArr[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"add"</span>:</span><br><span class="line">                    String type=strArr[<span class="number">1</span>];</span><br><span class="line">                    dq.add(<span class="keyword">new</span> Pet(type,Integer.valueOf(strArr[<span class="number">2</span>])));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"pollAll"</span>:</span><br><span class="line">                    <span class="keyword">while</span>(!dq.isEmpty())&#123;</span><br><span class="line">                        pet = dq.pollAll();</span><br><span class="line">                        res.append(pet.getPetType()+<span class="string">" "</span>+pet.getPetIndex()+<span class="string">"\n"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"pollCat"</span>:</span><br><span class="line">                    <span class="keyword">while</span>(!dq.isCatEmpty())&#123;</span><br><span class="line">                        pet = dq.pollCat();</span><br><span class="line">                        res.append(pet.getPetType()+<span class="string">" "</span>+pet.getPetIndex()+<span class="string">"\n"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"pollDog"</span>:</span><br><span class="line">                    <span class="keyword">while</span>(!dq.isDogEmpty())&#123;</span><br><span class="line">                        pet = dq.pollDog();</span><br><span class="line">                        res.append(pet.getPetType()+<span class="string">" "</span>+pet.getPetIndex()+<span class="string">"\n"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"isDogEmpty"</span> :</span><br><span class="line">                    res.append(dq.isDogEmpty()?<span class="string">"yes\n"</span>:<span class="string">"no\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"isCatEmpty"</span>:</span><br><span class="line">                    res.append(dq.isCatEmpty()?<span class="string">"yes\n"</span>:<span class="string">"no\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"isEmpty"</span>:</span><br><span class="line">                    res.append(dq.isEmpty()?<span class="string">"yes\n"</span>:<span class="string">"no\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res.substring(<span class="number">0</span>,res.length()-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="RandomPool结构"><a href="#RandomPool结构" class="headerlink" title="RandomPool结构"></a>RandomPool结构</h3><p>题目：</p>
<p>设计一种结构，在该结构中加入如下三种功能</p>
<p>insert(key)：将某个key加入到该结构，做到不重复加入</p>
<p>delete(key)：将原本在结构中的某个key移除</p>
<p>getRandom()：等概率随机返回结构中的任何一个key</p>
<p>要求：这三种方法的时间复杂度均为O(1)</p>
<p>思路：一个不行就两个。持有两个哈希表，一个为key-index映射，一个为index-key映射，麻烦的地方在于删除后如何保证之后的随机性，解决方法为每次找到要删除的位置，然后获取其key，获取最后行的key和index，然后将最后行的数据存到要删除行，再删除最后行数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomPool</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//持有两个哈希表，一个索引</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;K,Integer&gt; keyIndexMap;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer,K&gt; indexKeyMap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        keyIndexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        indexKeyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果已经存在了，返回</span></span><br><span class="line">        <span class="keyword">if</span> (keyIndexMap.containsKey(key))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        keyIndexMap.put(key,index);</span><br><span class="line">        indexKeyMap.put(index++,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//随机返回方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getRandom</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果没有数据，返回空</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> res = (<span class="keyword">int</span>)(Math.random()*index);</span><br><span class="line">        <span class="keyword">return</span> indexKeyMap.get(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!keyIndexMap.containsKey(key))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//1、找到要删除位置的index</span></span><br><span class="line">        <span class="keyword">int</span> deleteIndex = keyIndexMap.get(key);</span><br><span class="line">        <span class="comment">//2、找到最后的index和key</span></span><br><span class="line">        <span class="keyword">int</span> lastIndex = --index;</span><br><span class="line">        K lastKey = indexKeyMap.get(lastIndex);</span><br><span class="line">        <span class="comment">//3、将待删除位置的值替换为最后行的值</span></span><br><span class="line">        keyIndexMap.put(lastKey,deleteIndex);</span><br><span class="line">        indexKeyMap.put(deleteIndex,lastKey);</span><br><span class="line">        <span class="comment">//4、删除最后行数据，将行数-1</span></span><br><span class="line">        keyIndexMap.remove(key);</span><br><span class="line">        indexKeyMap.remove(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="转圈打印矩阵"><a href="#转圈打印矩阵" class="headerlink" title="转圈打印矩阵"></a>转圈打印矩阵</h3>

<p>思路：打印矩阵的思路一般都是宏观调度，用有限个变量去约束要打印的范围，然后循环调用打印函数。此处用左上角和右下角的点去约束范围，调用打印函数，然后将左上角和右下角的点进行收缩。打印矩阵函数为分别判断一行，一列和多行多列的情况，如果为单行单列的，用for循环控制行和列，如果为多行多列，分四次打印。</p>


<p>说明的是，在原方法中采用的是直接sout输出，此处使用StringBuilder进行添加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PringtEdge</span> </span>&#123;</span><br><span class="line">    <span class="comment">//转圈打印矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">printCircle</span><span class="params">(<span class="keyword">int</span>[][] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、找两个边界点</span></span><br><span class="line">        <span class="keyword">int</span> row1 = <span class="number">0</span>, col1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row2 = arr.length-<span class="number">1</span>,col2 = arr[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//只要满足边界条件，循环调用打印函数</span></span><br><span class="line">        <span class="keyword">while</span> (row1 &lt;= row2 &amp;&amp; col1 &lt;= col2)&#123;</span><br><span class="line">            printEdge(arr,sb,row1++,col1++,row2--,col2--);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(<span class="keyword">int</span>[][] arr, StringBuilder sb, <span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、如果只有一行</span></span><br><span class="line">        <span class="keyword">if</span> (row1 == row2)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = col1; i &lt;= col2; i++) &#123;</span><br><span class="line">                sb.append(arr[row1][i]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(col1 == col2)&#123;</span><br><span class="line">            <span class="comment">//2、如果只有一列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = row1; i &lt;= row2; i++) &#123;</span><br><span class="line">                sb.append(arr[i][col1]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//3、分四部分打印</span></span><br><span class="line">            <span class="keyword">int</span> curR = row1;<span class="comment">//当前行</span></span><br><span class="line">            <span class="keyword">int</span> curL = col1;<span class="comment">//当前列</span></span><br><span class="line">            <span class="keyword">while</span> (curL &lt; col2)&#123;</span><br><span class="line">                sb.append(arr[curR][curL++]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curR &lt; row2)&#123;</span><br><span class="line">                sb.append(arr[curR++][curL]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curL &gt; col1)&#123;</span><br><span class="line">                sb.append(arr[curR][curL--]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curR &gt; row1)&#123;</span><br><span class="line">                sb.append(arr[curR--][curL]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="comment">//要持有的写的类</span></span><br><span class="line">        PringtEdge pe = <span class="keyword">new</span> PringtEdge();</span><br><span class="line">        String[] s = <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span> row = Integer.valueOf(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> col = Integer.valueOf(s[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            s = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                arr[i][j] = Integer.valueOf(s[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = pe.printCircle(arr);</span><br><span class="line">        System.out.println(res.substring(<span class="number">0</span>,res.length()-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="之字型打印矩阵"><a href="#之字型打印矩阵" class="headerlink" title="之字型打印矩阵"></a>之字型打印矩阵</h3>

<p>思路：宏观调度，打印的是两个点之间的对角线的值，那么只要解决点的运动路径和打印对角线即可。要注意的是点在运动过程中时，如果变量A依靠变量B来约束其行为，要先改变变量A，再改变B，不然B先改变则A会缺少值。而对角线打印的时候有方向变化，可以用标记变量来控制。</p>
<p>这种题目依靠的是宏观调度，不要去想每个点到底怎么变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//之字型打印矩阵，找宏观规律</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">printZhi</span><span class="params">(<span class="keyword">int</span>[][] m)</span></span>&#123;</span><br><span class="line">        <span class="comment">//往右，再下</span></span><br><span class="line">        <span class="keyword">int</span> row1 = <span class="number">0</span>,col1 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//往下，再右</span></span><br><span class="line">        <span class="keyword">int</span> row2 = <span class="number">0</span>,col2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> endR = m.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> endC = m[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//先下，再上</span></span><br><span class="line">        <span class="keyword">boolean</span> fromUp = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (row1 &lt;= endR)&#123;</span><br><span class="line">            printProcess(m,res,row1,col1,row2,col2,fromUp);</span><br><span class="line">            <span class="comment">//路径变化</span></span><br><span class="line">            <span class="comment">//关键为将引发判断的值后判断</span></span><br><span class="line">            row1 = col1 == endC ? row1+<span class="number">1</span>:row1;</span><br><span class="line">            col1 = col1 == endC ? col1:col1+<span class="number">1</span>;</span><br><span class="line">            col2 = row2 == endR ? col2+<span class="number">1</span> : col2;</span><br><span class="line">            row2 = row2 == endR ? row2:row2+<span class="number">1</span>;</span><br><span class="line">            fromUp = !fromUp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printProcess</span><span class="params">(<span class="keyword">int</span>[][] m,StringBuilder res, <span class="keyword">int</span> row1,<span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2,<span class="keyword">boolean</span> fromUp)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果fromUp为false，从左下向右上打印</span></span><br><span class="line">        <span class="keyword">if</span> (!fromUp)&#123;</span><br><span class="line">            <span class="keyword">while</span> (row1 &lt;= row2)&#123;</span><br><span class="line">                res.append(m[row2--][col2++]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (row1 &lt;= row2)&#123;</span><br><span class="line">                res.append(m[row1++][col1--]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="在行列都排好序的矩阵中找数"><a href="#在行列都排好序的矩阵中找数" class="headerlink" title="在行列都排好序的矩阵中找数"></a>在行列都排好序的矩阵中找数</h3>

<p>思路：从右上角或者左下角开始找，此处选右上角，要是当前数小了就往下，当前数大了就往左。</p>
<p>精髓的点在于开始寻找的位置，利用矩阵的特征，可以将部分不可能的情况给排除掉，这题从右上角或者左下角开始找都可以。但是左上和右下不行，因为没办法缩小规模。核心在于右上或左下，<strong>一边比它大，一边比它小</strong>。这样子存在<strong>要么去一边，要么另一边</strong>的0 1情况，即非黑即白。</p>
<p>实质是将没有可能的数据直接舍弃，即将问题的规模进行缩小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在已排序的矩阵中找到数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNum</span><span class="params">(<span class="keyword">int</span>[][] m,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//选择右上角的数</span></span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>,col = m[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> endR = m.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (row&lt;=endR &amp;&amp; col &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//如果当前数小，往下走</span></span><br><span class="line">        <span class="keyword">if</span> (m[row][col] == k)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(m[row][col]&gt;k)&#123;</span><br><span class="line">            <span class="comment">//当前数比较大，往左走</span></span><br><span class="line">            col--;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="打印两个链表的公共部分"><a href="#打印两个链表的公共部分" class="headerlink" title="打印两个链表的公共部分"></a>打印两个链表的公共部分</h3><p>给定两个升序链表，打印两个升序链表的公共部分。</p>
<p>思路：类似于外排，谁小动谁，如果相等，打印并两个一起动</p>
<p>值得注意的点：将head1或者2为空的情况放在最上面，直接返回；将head1.value==head2.value的情况放在三种判断的第一个，这样可以缩短判断时间；整理链表基本结构及生成链表的套路。StringBuilder添加时候，使用两次append比一次append两个str效率高。原因是使用+的时候多了生成String的步骤，这样降低了效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印两个链表公共部分</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCommonPart</span><span class="params">(Node head1,Node head2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将不可能的情况先列出</span></span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//类似外排</span></span><br><span class="line">    <span class="comment">//谁小动谁，如果相等，添加并两个一起动</span></span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//将相等的判断放在最上面</span></span><br><span class="line">        <span class="keyword">if</span> (head1.value == head2.value) &#123;</span><br><span class="line">            <span class="comment">//这样比直接append(value+" ")效率高</span></span><br><span class="line">            res.append(head1.value).append(<span class="string">" "</span>);</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(head1.value &lt; head2.value)&#123;</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(res.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合并两个有序的链表"><a href="#合并两个有序的链表" class="headerlink" title="合并两个有序的链表"></a>合并两个有序的链表</h3><p>给定两个升序的单链表的头节点 head1 和 head2，请合并两个升序链表， 合并后的链表依然升序，并返回合并后链表的头节点。</p>
<p>思路：类似于外排，如果两个均不为空，谁小动谁；如果哪个为空，把另一个不为空的接到新链表后即可。</p>
<p>小技巧：新链表自己先做一个头节点会比较方便，在动链表的时候，流程为让新链表的下一个指向小节点，新链表当前节点跳到下一个，小节点链表头节点跳到下一个。另外如果有一个链表已经为空了，则不需要一个个节点去添加，直接把整个加上去即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//合并链表</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">mergeLink</span><span class="params">(Node head1, Node head2)</span></span>&#123;</span><br><span class="line">       <span class="comment">//类似于外排</span></span><br><span class="line">       Node res = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">       Node cur = res;</span><br><span class="line">       <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span> (head1.value &lt;= head2.value)&#123;</span><br><span class="line">               cur.next = head1;</span><br><span class="line">               cur = head1;</span><br><span class="line">               head1 = head1.next;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               cur.next = head2;</span><br><span class="line">               cur = head2;</span><br><span class="line">               head2 = head2.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//将空的链表部分直接拼接到新链表后面即可</span></span><br><span class="line">       cur.next = head1 == <span class="keyword">null</span> ? head2 : head1;</span><br><span class="line">       cur = res.next;</span><br><span class="line">       res = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">return</span> cur;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断链表是否为回文结构"><a href="#判断链表是否为回文结构" class="headerlink" title="判断链表是否为回文结构"></a>判断链表是否为回文结构</h3><p>给定链表的头结点，判断是否为回文链表</p>
<p>方式一：将链表元素全部存进栈中，利用栈先进后出的特点，与链表逐个比较，额外空间复杂度O(N)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解法1：将链表中的数据用栈存起来，然后一个个取出来进行对比</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome1</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//准备一个栈</span></span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Node node = head;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取出来比较</span></span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.value != stack.pop().value)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：只放一半的元素进栈中，缩短一半的额外空间。</p>
<p>为了找到链表中点，用到的方法为快慢指针，是链表题目中比较常见的方法，慢指针一下子走一步，快指针走两步，当快指针走到末尾时，慢指针正好走到中间。注意：如果是要中点位置，慢指针从头结点开始，如果是中点位置下一个，慢指针从头节点下一个开始。此处慢指针的起始点就是头节点下一个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解法2：只需要判断链表的一半即可，问题是如何找到链表的中点</span></span><br><span class="line">    <span class="comment">//用快慢指针</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome2</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Node slow = head.next;</span><br><span class="line">        Node fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时slow来到中点位置，将剩下的节点存入栈中</span></span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(slow);</span><br><span class="line">        &#125;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (slow.value != stack.pop().value)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>方法三：进阶方式，额外空间复杂度为O(1)，不依靠栈，而是先找到链表中点，将链表右半部分进行翻转，这里有个操作是将中点节点指向null，方便后面判断。然后从链表两端进行判断，注意不能直接返回值，因为还需要将链表还原。判断结束后，将链表右半部分还原。</p>
<p>注意：反转链表，删除链表节点需要利用3个指针，一个指向当前节点，一个指向当前节点的前序节点，一个指向当前节点的后序节点。先保存其下一个进行位置的，再进行操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解法3，不利用栈，先找到链表的中点，反转剩下的链表</span></span><br><span class="line">    <span class="comment">//进行判断，然后将链表还原</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome3</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//找到链表中点</span></span><br><span class="line">        Node n1 = head;</span><br><span class="line">        Node n2 = head;</span><br><span class="line">        <span class="keyword">while</span>(n2.next != <span class="keyword">null</span> &amp;&amp; n2.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            n1 = n1.next;</span><br><span class="line">            n2 = n2.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时n1来到中点，反转链表，先要记录n1下一个位置</span></span><br><span class="line">        n2 = n1.next;</span><br><span class="line">        n1.next = <span class="keyword">null</span>;</span><br><span class="line">        Node n3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//反转链表</span></span><br><span class="line">        <span class="keyword">while</span> (n2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            n3 = n2.next;</span><br><span class="line">            n2.next = n1;</span><br><span class="line">            n1 = n2;</span><br><span class="line">            n2 = n3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时n1为链表末尾，进行记录</span></span><br><span class="line">        n3 = n1;</span><br><span class="line">        <span class="comment">//开始判断头和尾的值是否相等</span></span><br><span class="line">        n2 = head;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (n2 != <span class="keyword">null</span> &amp;&amp; n1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (n2.value != n1.value)&#123;</span><br><span class="line">                <span class="comment">//不能直接返回假，这样链表没有被调整回来</span></span><br><span class="line">                res = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n2 = n2.next;</span><br><span class="line">            n1 = n1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//还原链表</span></span><br><span class="line">        n2 = n3.next;</span><br><span class="line">        n3.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (n2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            n1 = n2.next;</span><br><span class="line">            n2.next = n3;</span><br><span class="line">            n3 = n2;</span><br><span class="line">            n2 = n1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="单向链表的基础partition"><a href="#单向链表的基础partition" class="headerlink" title="单向链表的基础partition"></a>单向链表的基础partition</h3><p>题目描述：</p>
<p>给定一个链表，再给定一个整数 pivot，请将链表调整为左部分都是值小于 pivot 的节点，中间部分都是值等于 pivot 的节点， 右边部分都是大于 pivot 的节点。</p>
<p>除此之外，对调整后的节点顺序没有更多要求。</p>
<p>思路：将链表用数组存起来，然后对数组partition，再将数组组合成链表，返回arr[0]，要注意的是将数组的最后个元素的next指向null，以及partition过程的约束条件是index&lt;more，不能取等于，不然会越界。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单链表的partition基础问题，利用数组来实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listPartition</span><span class="params">(Node head,<span class="keyword">int</span> pivot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//1、统计链表长度</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、造数组，将链表中元素填充进去</span></span><br><span class="line">        Node[] arr = <span class="keyword">new</span> Node[len];</span><br><span class="line">        node = head;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            arr[i++] = node;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、数组的partition问题</span></span><br><span class="line">        <span class="comment">//将其封装为函数</span></span><br><span class="line">        partitionArr(arr,pivot);</span><br><span class="line">        <span class="comment">//将数组组合成链表</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            arr[i-<span class="number">1</span>].next = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将最后个节点指针指向null</span></span><br><span class="line">        arr[i-<span class="number">1</span>].next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">partitionArr</span><span class="params">(Node[] arr, <span class="keyword">int</span> pivot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> less = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> more = arr.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//约束条件为i &lt; more或者i != more</span></span><br><span class="line">        <span class="comment">//如果是等于，当more为数组最后，会越界</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; more)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i].value &lt; pivot)&#123;</span><br><span class="line">                swap(arr,i++,++less);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[i].value &gt; pivot)&#123;</span><br><span class="line">                swap(arr,i,--more);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="单链表的partition进阶"><a href="#单链表的partition进阶" class="headerlink" title="单链表的partition进阶"></a>单链表的partition进阶</h3><p>要求：在原来基础之上，partition后每个部分的节点从左至右的顺序和原链表中节点的顺序一致。要时间复杂度O（N）,额外空间复杂度O（1）。</p>
<p>思路：将原链表拆分为小，等，大三个区域，遍历链表，来一个就丢到对应的位置中去（将节点从原链表中断开），最后将三个链表合并，考察的是扣边界能力。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表的复杂partition</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listPartition2</span><span class="params">(Node head,<span class="keyword">int</span> pivot)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//分三个部分，小于、等于、大于区，来个节点就丢到对应的地方去</span></span><br><span class="line">    <span class="comment">//最后将三个部分合并</span></span><br><span class="line">    Node sH = <span class="keyword">null</span>;</span><br><span class="line">    Node sT = <span class="keyword">null</span>;</span><br><span class="line">    Node eH = <span class="keyword">null</span>;</span><br><span class="line">    Node eT = <span class="keyword">null</span>;</span><br><span class="line">    Node bH = <span class="keyword">null</span>;</span><br><span class="line">    Node bT = <span class="keyword">null</span>;</span><br><span class="line">    Node next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//将当前节点丢到三个部分中</span></span><br><span class="line">        <span class="keyword">if</span> (head.value &lt; pivot)&#123;</span><br><span class="line">            <span class="comment">//如果为空</span></span><br><span class="line">            <span class="keyword">if</span> (sH == <span class="keyword">null</span>)&#123;</span><br><span class="line">                sH = head;</span><br><span class="line">                sT = head;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sT.next = head;</span><br><span class="line">                sT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(head.value == pivot)&#123;</span><br><span class="line">            <span class="keyword">if</span> (eH == <span class="keyword">null</span>)&#123;</span><br><span class="line">                eH = head;</span><br><span class="line">                eT = head;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                eT.next = head;</span><br><span class="line">                eT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (bH == <span class="keyword">null</span>)&#123;</span><br><span class="line">                bH = head;</span><br><span class="line">                bT = head;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                bT.next = head;</span><br><span class="line">                bT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将三个链表连接</span></span><br><span class="line">    <span class="keyword">if</span> (sT != <span class="keyword">null</span>)&#123;</span><br><span class="line">        sT.next = eH;</span><br><span class="line">        eT = eT == <span class="keyword">null</span> ? sT:eT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (eT != <span class="keyword">null</span>)&#123;</span><br><span class="line">        eT.next = bH;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sH != <span class="keyword">null</span> ? sH : eH != <span class="keyword">null</span> ? eH : bH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复制含有随机节点的链表"><a href="#复制含有随机节点的链表" class="headerlink" title="复制含有随机节点的链表"></a>复制含有随机节点的链表</h3><p>方法一：用哈希表，将key为原链表节点，value为新链表节点，然后再复制下一个和rand指针关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">copyListWithRand1</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建存储用的HashMap，key与value均为Node</span></span><br><span class="line">    HashMap&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;Node,Node&gt;();</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="comment">//对每个结点进行拷贝</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        map.put(cur, <span class="keyword">new</span> Node(cur.value));</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//将复制节点的next与random指向cur相同部分</span></span><br><span class="line">        <span class="comment">//get(x)为得到x节点的拷贝结点x'</span></span><br><span class="line">        map.get(cur).next = map.get(cur.next);<span class="comment">//1' 指向 2(1.next)的对应节点2'</span></span><br><span class="line">        map.get(cur).random = map.get(cur.random);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：不使用其他数据结构，在原来链表中每个节点后面复制一个新节点，然后复制rand指针关系，再将两个链表拆分开来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">copyListWithRand2</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// copy node and link to every node</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        next = cur.next;</span><br><span class="line">        cur.next = <span class="keyword">new</span> Node(cur.value);</span><br><span class="line">        cur.next.next = next;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head;</span><br><span class="line">    Node curCopy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// set copy node rand</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        next = cur.next.next;</span><br><span class="line">        curCopy = cur.next;</span><br><span class="line">        curCopy.random = cur.random != <span class="keyword">null</span> ? cur.random.next : <span class="keyword">null</span>;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node res = head.next;<span class="comment">//记录下复制链表的头结点</span></span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="comment">// split</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        next = cur.next.next;</span><br><span class="line">        curCopy = cur.next;</span><br><span class="line">        cur.next = next;</span><br><span class="line">        curCopy.next = next != <span class="keyword">null</span> ? next.next : <span class="keyword">null</span>;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>非递归实现</p>
<p>反转单链表和双链表，基本思路是持有三个节点，当前节点的前序节点，当前节点，下一个节点。</p>
<p>对于单链表，如果当前节点不为空，保存其下一个节点next，当前节点指向前序节点pre，pre=当前节点，当前节点=next，这样便实现了反转；对于双向链表，只是多了一步让当前节点的前序节点=next，其他和单向链表一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反转单向链表</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseListSL</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">       <span class="comment">//准备三个节点</span></span><br><span class="line">       Node pre = <span class="keyword">null</span>;</span><br><span class="line">       Node cur = head;</span><br><span class="line">       Node next = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">           next = cur.next;</span><br><span class="line">           cur.next = pre;</span><br><span class="line">           pre = cur;</span><br><span class="line">           cur = next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pre;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//反转双向链表</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseListDL</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">       <span class="comment">//准备三个节点</span></span><br><span class="line">       Node pre = <span class="keyword">null</span>;</span><br><span class="line">       Node cur = head;</span><br><span class="line">       Node next = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">           next = cur.next;</span><br><span class="line">           cur.next = pre;</span><br><span class="line">           cur.pre = next;</span><br><span class="line">           pre = cur;</span><br><span class="line">           cur = next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pre;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>递归实现</p>
<p>看其是否可以分解成具有相同解决思路的子问题。反转链表1-&gt;2-&gt;3-&gt;4，如果把1以后的链表都反转好了，让2指向1,1指向空即可。对于1后面的子链表，也可以这样去处理。因此可以使用递归去解决</p>
<ol>
<li><p>定义递归函数，明确函数功能及返回值</p>
<p>此递归函数实现的功能是反转某个节点开始的链表，返回的是反转后的新的结点</p>
</li>
<li><p>寻找递归公式</p>
<ul>
<li>先反转当前节点以后的链表，这样1-&gt;2-&gt;3-&gt;4变为1-&gt;2&lt;-3&lt;-4</li>
<li>将当前node(1)的下一个节点(node.next)的指向(node.next.next)改为当前节点(node)，node的后继结点变为空</li>
<li>返回新的头结点</li>
</ul>
</li>
<li><p>将递推公式带入定义好的递归函数中</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反转链表的递归实现</span></span><br><span class="line"><span class="comment">//递归函数要实现的功能是反转链表，返回的是反转后的链表头节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseList2</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (node.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    <span class="comment">//对当前节点做操作</span></span><br><span class="line">    <span class="comment">//把后面的链表进行反转</span></span><br><span class="line">    Node newHead = reverseList2(node.next);</span><br><span class="line">    <span class="comment">//把后面的反转好后，让当前node的下一个节点的下一个指向当前节点</span></span><br><span class="line">    <span class="comment">//让当前节点的下一个指向空</span></span><br><span class="line">    node.next.next = node;</span><br><span class="line">    node.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//返回新的头节点</span></span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反转部分单向链表"><a href="#反转部分单向链表" class="headerlink" title="反转部分单向链表"></a>反转部分单向链表</h3><p>给定一个单链表，在链表中把第 L 个节点到第 R 个节点这一部分进行反转。</p>
<p>思路：找到from-1,from,to,to+1处的四个链表，如果from或者to为空，直接返回，反转from-to之间的链表，然后让from-1指向to，from指向to+1。如果from-1为空，那么to变为新链表的头结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反转from-to之间的链表</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reversePartList</span><span class="params">(Node head, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       <span class="comment">//找到from-1,fro,to,to+1处的链表节点</span></span><br><span class="line">       Node fromPre = <span class="keyword">null</span>;</span><br><span class="line">       Node from = <span class="keyword">null</span>;</span><br><span class="line">       Node to = <span class="keyword">null</span>;</span><br><span class="line">       Node toPos = <span class="keyword">null</span>;</span><br><span class="line">       Node cur = head;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//如果from和to的距离超过了链表长度，就不进行操作</span></span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">           count++;</span><br><span class="line">           <span class="keyword">if</span> (count == fromIndex - <span class="number">1</span>)&#123;</span><br><span class="line">               fromPre = cur;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> (count == fromIndex)&#123;</span><br><span class="line">               from = cur;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> (count == toIndex)&#123;</span><br><span class="line">               to = cur;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> (count == toIndex + <span class="number">1</span>)&#123;</span><br><span class="line">               toPos = cur;</span><br><span class="line">           &#125;</span><br><span class="line">           cur = cur.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (from == <span class="keyword">null</span> || to == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       <span class="comment">//反转from-to之间的结点</span></span><br><span class="line">       Node pre = <span class="keyword">null</span>;</span><br><span class="line">       cur = from;</span><br><span class="line">       Node next = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (cur != toPos)&#123;</span><br><span class="line">           next = cur.next;</span><br><span class="line">           cur.next = pre;</span><br><span class="line">           pre = cur;</span><br><span class="line">           cur = next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果from为头结点，新的头结点为to</span></span><br><span class="line">       <span class="keyword">if</span> (fromPre == <span class="keyword">null</span>)&#123;</span><br><span class="line">           head = to;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           fromPre.next = to;</span><br><span class="line">       &#125;</span><br><span class="line">       from.next = toPos;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="两链表相交问题（五星级）"><a href="#两链表相交问题（五星级）" class="headerlink" title="两链表相交问题（五星级）"></a>两链表相交问题（五星级）</h3><p>在本题中，单链表可能有环，也可能无环。给定两个链表的头节点，实现函数，如果两链表相交，返回相交的第一个节点；如果不相交，返回null即可。</p>
<p>要求：如果链表1的长度为N，链表2的长度为M，时间复杂度达到O（N+M），额外空间复杂度达到O（1）。</p>
<p>思路：遇到复杂问题进行拆解，首先需要判断两个链表是否有环，如果两个都没有环，那就是两个无环链表的相交问题；如果两个都有环，那就是两个有环链表的相交问题；如果一个有环，一个无环，是没有这种结构的。因此将问题差结成了三个，首先需要求解链表的入环节点。</p>
<p>判断链表是否有环有两种方法，一种是利用哈希表，如果当前节点在哈希表中，返回当前节点，否则加入哈希表，并遍历到下一个节点，此方法额外空间复杂度不为O(1)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getFirstLoopNode</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(head))&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方法是利用快慢指针，如果快指针没有遇到慢指针，快指针走2步，慢指针走1步，如果快指针后面为空，返回空。当快慢指针相遇，让快指针从链表头开始，和慢指针一起每次走一步，二者相遇的地方即为链表的入环节点。</p>


<p>假设起始点到入环处的长度为<code>a</code>，环的长度为<code>L</code>，当快指针与慢指针相遇时，设慢指针所走的路程为<code>b</code>，当慢指针入环时，快指针已经在环上了，设快指针距离入环点距离为c，这时候当慢指针继续走c步时，快指针就会赶上慢指针了，c&lt;=L，此时慢指针还没有走一圈。</p>
<p>当快慢指针相遇时 ，两个指针走的距离为</p>
<p>p慢=a+b=n</p>
<p>p快=a+b+k*L=2n（快指针比慢指针多走k圈）</p>
<p>因此有<code>n=a+b=k*L</code>。此时若让快指针从头节点重新走a步，<code>a=k*L-b</code>，对于慢指针，因为其已经走了b步，此时再走a步，正好在环上走了k圈（a+b=k*L）,因此两个指针会在入环点相遇。</p>
<p>判断条件是快慢指针没有相遇，而一旦快指针后面为null，返回即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLoopNode</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node slow = head.next;</span><br><span class="line">    Node fast = head.next.next;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样便可以判断出链表是否有环。对于两个都没有环的链表，如果他们相交，则最后个节点一定相等，让更长的链表先将多的部分走完，两个链表再一起走，便会在第一个相交的地方相遇。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两条链表没有环的情况</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">noLoop</span><span class="params">(Node head1, Node head2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node cur1 = head1;</span><br><span class="line">    Node cur2 = head2;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找到最后个节点并求两条链表长度差</span></span><br><span class="line">    <span class="keyword">while</span> (cur1.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        n++;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cur2.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        n--;</span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后节点不相同，一定不相交</span></span><br><span class="line">    <span class="keyword">if</span>(cur1 != cur2)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//将cur1指向更长的链表</span></span><br><span class="line">    cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">    cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">    n = Math.abs(n);<span class="comment">//得到较长链表需要多走的步数</span></span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>)&#123;</span><br><span class="line">        n--;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//共同走到相同的节点</span></span><br><span class="line">    <span class="keyword">while</span> (cur1 != cur2)&#123;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于两个都有环的链表，有如下的三种结构。</p>


<p>其中如果两个链表的入环节点为同一个，则是第二种结构，可以简化为无环链表的相交问题；如果入环节点不为同一个，则让一个节点从环上走一圈，如果没有碰到另一个链表的入环节点，则说明是第一种，否则返回其中一个链表的入环节点即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两个链表都有环的情况</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">bothLoop</span><span class="params">(Node head1, Node loop1, Node head2, Node loop2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//有3种情况</span></span><br><span class="line">    Node cur1 = <span class="keyword">null</span>;</span><br><span class="line">    Node cur2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//演变为无环链表的相交问题</span></span><br><span class="line">    <span class="keyword">if</span>(loop1 == loop2)&#123;</span><br><span class="line">        cur1 = head1;</span><br><span class="line">        cur2 = head2;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != loop1)&#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur2 != loop2)&#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">        cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">        n = Math.abs(n);</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != cur2)&#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//遍历loop1到自己，看是否遇到loop2</span></span><br><span class="line">        cur1 = loop1.next;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != loop1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1 == loop2)&#123;</span><br><span class="line">                <span class="keyword">return</span> loop1;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下的主方法就比较简单，求两个链表的入环节点，然后对无环链表相交，有环链表相交和一个有环一个无环进行判断即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getIntersectNode</span><span class="params">(Node head1, Node head2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node loop1 = getLoopNode(head1);</span><br><span class="line">    Node loop2 = getLoopNode(head2);</span><br><span class="line">    <span class="keyword">if</span>(loop1 == <span class="keyword">null</span> &amp;&amp; loop2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> noLoop(head1, head2);</span><br><span class="line">    <span class="keyword">if</span>(loop1 != <span class="keyword">null</span> &amp;&amp; loop2 != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> bothLoop(head1,loop1,head2,loop2);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆本质是一个二叉树 ，在Java中实现为优先级队列（PriorityQueue），默认为小根堆，即最小的在最上面。可以通过在新建堆时传入比较器对象来定义大根堆或者小根堆。其中如果比较器只用到一次，没有必要去专门定义一个类，可以用匿名内部类，实现compare()方法即可，更简单的是用lambda表达式，更简洁。</p>
<p>堆的结构很好用，在取中位数，第k大or第k小的数，前k大or前k小，贪心中经常用到。</p>
<h3 id="随时找到数据流的中位数"><a href="#随时找到数据流的中位数" class="headerlink" title="随时找到数据流的中位数"></a>随时找到数据流的中位数</h3><p>题目描述：有一个源源不断的吐出整数的数据流，假设你有足够的空间来保存吐出的数。请设计一个名叫MedianHolder的结构，MedianHolder可以随时取得之前吐出所有数的中位数。</p>
<p>[要求]</p>
<ol>
<li><p>如果MedianHolder已经保存了吐出的N个数，那么将一个新数加入到MedianHolder的过程，其时间复杂度是O(logN)。</p>
</li>
<li><p>取得已经吐出的N个数整体的中位数的过程，时间复杂度为O(1)</p>
</li>
</ol>
<p>思路：持有两个堆，一个大根堆，一个小根堆，大根堆中存放较小的一半数，小根堆中存放较大的一半数，这样中位数就被大根堆和小根堆夹着。如果两个堆大小相等，则取平均；不然就返回较多的那个堆的堆顶元素。</p>
<p>其中比较关键的是将数加入堆的操作，如果大根堆为空或者当前数比大根堆顶的数小，则直接放入大根堆中，否则放入小根堆。然后进行堆的调整：哪个堆中的数据比另一个堆中数据多了2个，则拿一个到另一个堆中。这样将放数和调整堆进行了<strong>解耦</strong>，可以让代码变得更简洁。</p>
<p>其中牛客网要求格式化输出数据，可以用DecimalFormat类，进行一位小数的输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedianHolder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//随时找到数据流的中位数，需要持有两个堆</span></span><br><span class="line">    <span class="comment">//大根堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//小根堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 取出所有整数部分和一位小数，格式化输出</span></span><br><span class="line">    DecimalFormat df = <span class="keyword">new</span> DecimalFormat(<span class="string">"#.0"</span>);</span><br><span class="line">    <span class="comment">//构造方法，初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianHolder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((o1,o2)-&gt;o2-o1);</span><br><span class="line">        minHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((o1,o2)-&gt;o1-o2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将数添加进堆中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果大根堆为空或者数比大根堆顶的数小，添加到大根堆</span></span><br><span class="line">        <span class="keyword">if</span> (maxHeap.isEmpty() || num &lt;= maxHeap.peek())&#123;</span><br><span class="line">            maxHeap.add(num);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minHeap.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//堆的调整</span></span><br><span class="line">        modifyTwoHeap();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//调整堆</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">modifyTwoHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果大根堆比小根堆多两个，放一个进小根堆</span></span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() == minHeap.size() + <span class="number">2</span>)&#123;</span><br><span class="line">            minHeap.add(maxHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minHeap.size() == maxHeap.size() + <span class="number">2</span>)&#123;</span><br><span class="line">            maxHeap.add(minHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找中位数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMedian</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果两个为空，返回空</span></span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果两个堆中数相等，取两个堆顶平均</span></span><br><span class="line">        <span class="keyword">if</span> (minHeap.size() == maxHeap.size())&#123;</span><br><span class="line">            System.out.println(df.format((maxHeap.peek()+minHeap.peek())/<span class="number">2.0</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//哪个多返回哪个的</span></span><br><span class="line">            System.out.println(df.format(maxHeap.size() &gt; minHeap.size() ? maxHeap.peek() : minHeap.peek()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s = br.readLine();</span><br><span class="line">        <span class="keyword">int</span> count = Integer.valueOf(s);</span><br><span class="line">        <span class="comment">//要持有的写的类</span></span><br><span class="line">        MedianHolder m = <span class="keyword">new</span> MedianHolder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="comment">//读一行数据</span></span><br><span class="line">            String[] str = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"2"</span>.equals(str[<span class="number">0</span>]))&#123;</span><br><span class="line">                m.getMedian();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                m.addNum(Integer.valueOf(str[<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="切金条"><a href="#切金条" class="headerlink" title="切金条"></a>切金条</h3><p>题目描述：给定一个正数数组arr，arr的累加和代表金条的总长度，arr的每个数代表金条要分成的长度。规定长度为k的金条分成两块，费用为k个铜板。返回把金条分出arr中的每个数字需要的最小代价。</p>
<p>要求：时间复杂度为O(n log n)，空间复杂度为O(n)</p>
<p>题目说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果先分成40和20两块，将花费60个铜板，再把长度为40的金条分成10和30两块，将花费40个铜板，总花费为100个铜板；</span><br><span class="line">如果先分成10和50两块，将花费60个铜板，再把长度为50的金条分成20和30两块，将花费50个铜板，总花费为110个铜板；</span><br><span class="line">如果先分成30和30两块，将花费60个铜板，再把其中一根长度为30的金条分成10和20两块，将花费30个铜板，总花费为90个铜板；</span><br><span class="line">因此最低花费为90</span><br></pre></td></tr></table></figure>

<p>思路：哈夫曼编码问题，即每次选出权重最小的数，新节点权重为二者相加，将新节点加入，再拿出两个，直到之后只有一个数，其值就是总的权重。</p>
<p>哈夫曼编码的应用：给出传递的电文，计算每个字母的权重，选出较小的两个节点构造成一个二叉树（小的在左，大的在右），新二叉树的权重为二者权重之和，然后将新二叉树放入，再重新拿出两个权重最小的。树构造好后，进行编码，左边为0，右边为1，只有叶子节点在存储了信息，这样从头节点找到叶子节点，便可以找到每个字母对应的编码。当给定了编码后，要如何去找到对应的字母呢？可以从字符串中取出字符，然后在树中进行寻找，如果找到了叶子节点，就得到了一个字母，再继续找下去。</p>
<h3 id="做项目"><a href="#做项目" class="headerlink" title="做项目"></a>做项目</h3><p>题目描述：</p>
<p>输入：</p>
<p>参数1：正数数组costs</p>
<p>参数2：正数数组profits</p>
<p>参数3：正数k</p>
<p>参数4：正数m</p>
<p>参数说明：cost[i]表示i号项目的花费，profits[i]表示i号项目在扣除花费后还能挣到的钱（利润），k表示你不能并行、只能串行的最多做k个项目，m表示你初始的资金。</p>
<p>说明：你每做完一个项目，马上获得的收益，可以支持你去做下一个项目</p>
<p>输出：你最后获得的最大钱数。</p>
<p>分析：标准的贪心问题，选择项目的标准是：在花费比资金小的项目中，选择利润最多的，积累利润后，再选择花费比当前资金小的项目，直到做了k个项目。</p>
<p>思路：持有两个堆，一个小根堆，一个大根堆，小根堆依照项目花费排序，大根堆中依靠项目利润排序，从小根堆中弹出花费比当前资金少的项目进大根堆，然后从大根堆中弹出一个项目来做，累积资金，直到做了k个项目。</p>
<p>坑点：返回的收益需要是<strong>long</strong>类型，<strong>避免溢出</strong>！！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将项目的花费和利润封装为一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">proNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> p;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proNode</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">        <span class="keyword">this</span>.p = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindMaximizedCapital</span> </span>&#123;</span><br><span class="line">    <span class="comment">//持有两个堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;proNode&gt; minHeap;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;proNode&gt; maxHeap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FindMaximizedCapital</span><span class="params">()</span></span>&#123;</span><br><span class="line">        minHeap = <span class="keyword">new</span> PriorityQueue&lt;proNode&gt;((o1,o2)-&gt;o1.c-o2.c);</span><br><span class="line">        maxHeap = <span class="keyword">new</span> PriorityQueue&lt;proNode&gt;((o1,o2)-&gt;o2.p-o1.p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算项目最大利润</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">findMaximizedCapital</span><span class="params">(<span class="keyword">int</span>[] costs,<span class="keyword">int</span>[] profits,<span class="keyword">int</span> k,<span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将花费和利润封装放进小根堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; costs.length; i++) &#123;</span><br><span class="line">            minHeap.add(<span class="keyword">new</span> proNode(costs[i],profits[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行k次循环做项目</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="comment">//知道小根堆不为空且堆顶项目花费比m少，弹进大根堆</span></span><br><span class="line">            <span class="keyword">while</span> (!minHeap.isEmpty() &amp;&amp; minHeap.peek().c &lt;= m)&#123;</span><br><span class="line">                maxHeap.add(minHeap.poll());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//需要考虑到大根堆为空的情况，即虽然没有到k次，但没有项目可做</span></span><br><span class="line">            <span class="keyword">if</span> (maxHeap.isEmpty())</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            <span class="comment">//选出一个项目来做</span></span><br><span class="line">            m += maxHeap.poll().p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String[] str = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span> n = Integer.valueOf(str[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> w = Integer.valueOf(str[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> k = Integer.valueOf(str[<span class="number">2</span>]);</span><br><span class="line">        String[] strC = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        String[] strP = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span>[] costs = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] profits = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            costs[i] = Integer.parseInt(strC[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            profits[i] = Integer.parseInt(strP[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        FindMaximizedCapital fm = <span class="keyword">new</span> FindMaximizedCapital();</span><br><span class="line">        <span class="keyword">long</span> win = fm.findMaximizedCapital(costs,profits,k,w);</span><br><span class="line">        System.out.println(win);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>给定一个字符串类型的数组strs，找到一种拼接方式，使得把所有字符串拼起来之后形成的字符串具有最低的字典序。</p>
<p>​    字典序：每个字母相当于26进制的数，如果位数相同则比较字面值，长度不能的时候，把短的补到跟长的一样，补的内容相当于ASCII表中最小的内容，然后从最高位开始比较。</p>
<p>比较两个字符串，若str1+str2&lt;= str2 + str1，则str1放前面，否则str2放前面。不要去证明贪心问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比较器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//负数认为o1小，谁作为前缀小谁放前面</span></span><br><span class="line">        <span class="keyword">return</span> (o1 + o2).compareTo(o2 + o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用比较器来排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">lowestString</span><span class="params">(String[] strs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    Arrays.sort(strs,<span class="keyword">new</span> MyComparator());</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (String s : strs)&#123;</span><br><span class="line">        sb.append(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树的深度遍历"><a href="#树的深度遍历" class="headerlink" title="树的深度遍历"></a>树的深度遍历</h3><h4 id="递归遍历方法"><a href="#递归遍历方法" class="headerlink" title="递归遍历方法"></a>递归遍历方法</h4><p>先序遍历：先中、再左、再右。对每一个结点，先打印当前结点，再打印其左子树所有结点，再打印右子树所有结点。</p>
<p>中序遍历：先左、再中、再右。对每一个结点，先打印其左子树所有结点，再打印当前结点，再打印右子树所有结点。</p>
<p>后序遍历：先左、再右、再中。对每一个结点，先打印其左子树所有结点，再打印右子树所有结点，再打印当前结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序打印二叉树的递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//先打印当前节点</span></span><br><span class="line">    System.out.print(head.value+<span class="string">" "</span>);</span><br><span class="line">    <span class="comment">//递归打印左子树</span></span><br><span class="line">    preOrderRecur(head.left);</span><br><span class="line">    <span class="comment">//递归打印右子树</span></span><br><span class="line">    preOrderRecur(head.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序打印二叉树的递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//先打印左子树，再打印中间，再打印右子树</span></span><br><span class="line">    inOrderRecur(head.left);</span><br><span class="line">    System.out.print(head.value +<span class="string">" "</span>);</span><br><span class="line">    inOrderRecur(head.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序打印二叉树的递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">posOrderRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//先打印左子树，再打印右子树，再打印当前节点</span></span><br><span class="line">    posOrderRecur(head.left);</span><br><span class="line">    posOrderRecur(head.right);</span><br><span class="line">    System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="非递归遍历方法"><a href="#非递归遍历方法" class="headerlink" title="非递归遍历方法"></a>非递归遍历方法</h4><p>先序遍历用栈结构实现，顺序为先中，再左，再右。将头结点放入栈，如果栈不为空，弹出当前节点，弹出就打印。如果右不为空，把右边的放入栈中。如果左不为空，把左边的放入栈中。为了让先弹左，再弹右，因此放入栈的时候要先右再左。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderUnRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"pre-order: "</span>);</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//准备一个栈</span></span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        <span class="comment">//将头结点压入</span></span><br><span class="line">        stack.add(head);</span><br><span class="line">        <span class="comment">//只要栈不为空</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//弹出并打印头结点</span></span><br><span class="line">            head = stack.pop();</span><br><span class="line">            System.out.print(head.value+<span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//如果右节点不为空，压入</span></span><br><span class="line">            <span class="keyword">if</span>(head.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果左节点不为空，压入</span></span><br><span class="line">            <span class="keyword">if</span>(head.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中序遍历用栈结构实现，顺序为先左，再中，再右。栈中先放所有的左边界，head从头往左移动，直到空，这样所有的左边界都到栈中了。当往左移动不下去了，从栈中弹出一个并打印，并向右移动。</p>
<p>​    因为从中一直往左压栈，因此弹出的时候一定是从左到中，往右跑是因为要把右子树也按照这种方法压入栈。那么整个顺序是先左再中再右。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderUnRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"in-order: "</span>);</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//只要栈不为空或者head不为空就循环</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果head不为空，一直将左节点压入栈</span></span><br><span class="line">            <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head);</span><br><span class="line">                head = head.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果head为空，弹出并打印栈中元素，</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                head = stack.pop();</span><br><span class="line">                System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">                head = head.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后续遍历是先左再右再中。中左右，是先弹出中，然后压入右，压入左。那么中右左就是先弹出中，然后压入左，压入右。然后该打印的时候不打印，放入一个help，再弹出来，就是先左再右再中了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后序遍历非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">posOrderUnRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"pos order: "</span>);</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Node&gt; help = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//先把头节点压入</span></span><br><span class="line">        stack.push(head);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            head = stack.pop();</span><br><span class="line">            <span class="comment">//该输出的时候弹入辅助栈</span></span><br><span class="line">            help.push(head);</span><br><span class="line">            <span class="comment">//先压左后压右</span></span><br><span class="line">            <span class="keyword">if</span>(head.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将辅助栈中数据弹出</span></span><br><span class="line">        <span class="keyword">while</span> (!help.isEmpty())&#123;</span><br><span class="line">            System.out.print(help.pop().value+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="折纸问题"><a href="#折纸问题" class="headerlink" title="折纸问题"></a>折纸问题</h4>

<p>这个问题实质是二叉树的中序遍历问题，头结点为下，左孩子为下，右孩子为下，用递归方式解决，递归函数参数列表有当前树高度，为左还是右（左为下，右为上）</p>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直观打印折纸</span></span><br><span class="line"><span class="comment">//本质上是树的中序遍历，左结点为下，右结点为上，头节点为下</span></span><br><span class="line"><span class="comment">//用递归实现，功能是中序打印二叉树，需要传入当前树的高度，左还是右</span></span><br><span class="line"><span class="comment">//因为只有两种可能，所以可以用布尔类型的变量来表示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAllFolds</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    printProcess(<span class="number">1</span>,N,<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printProcess</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n, <span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; n)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//left,cur,right</span></span><br><span class="line">    printProcess(i+<span class="number">1</span>,n,<span class="keyword">true</span>);</span><br><span class="line">    System.out.println(b ? <span class="string">"下"</span> : <span class="string">"上"</span>);</span><br><span class="line">    printProcess(i+<span class="number">1</span>,n,<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在二叉树中找到一个节点的后继节点"><a href="#在二叉树中找到一个节点的后继节点" class="headerlink" title="在二叉树中找到一个节点的后继节点"></a>在二叉树中找到一个节点的后继节点</h4><p>现在树结点多了一个parent结点，指向父节点，头节点的parent指向null。只给一个在二叉树中某个节点node，实现返回node的后继节点的函数。在二叉树的后序遍历的序列中，node的下一个节点叫做node的后继节点。</p>
<p>中序遍历为左、中、右，考虑当前节点为中的情况，因此如果有右子树，后继节点应该是右子树的最左结点。当前节点如果为左，其为父节点的左孩子，则父节点就是后继节点。如果当前节点为右，表明其所在的左子树已被遍历完，需要找到某个节点，其为父节点的左孩子，返回此父节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getNextNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//node有右子树，找到右子树最左节点</span></span><br><span class="line">    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> getLeftMost(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有右子树</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node parent = node.parent;<span class="comment">//拿到父节点</span></span><br><span class="line">        <span class="comment">//只要此节点不为父节点的左子树</span></span><br><span class="line">        <span class="comment">//跳到node是parent左节点停，返回parent</span></span><br><span class="line">        <span class="comment">//加上Parent不为空是为了兼顾没有后继的情况</span></span><br><span class="line">        <span class="comment">//其中parent不为空要放在前面，不然就算空了，因为parent左孩子不为node，循环仍继续</span></span><br><span class="line">        <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; parent.left != node)&#123;</span><br><span class="line">            <span class="comment">//当前节点不是父节点的左孩子则继续</span></span><br><span class="line">            node = parent;</span><br><span class="line">            parent = node.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找最左节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLeftMost</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="树的先序方式序列化与反序列化"><a href="#树的先序方式序列化与反序列化" class="headerlink" title="树的先序方式序列化与反序列化"></a>树的先序方式序列化与反序列化</h4><p>中、左、右。将遍历的结果用字符串进行记录。当一个节点的左子树为空时，可以用一个特殊符号来记录，如#。</p>
<p>序列化思路：利用递归来进行中序遍历，如果是空节点，则添加#！，如果不为空，添加value!，然后遍历左子树与右子树。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>反序列化思路：将字符串用！进行分割，然后将数组中的字符一个个构造成节点，可以将其加入到队列中，也可以用index+数组来取，这样当为#，返回空，构造一个新节点，递归构造其左子树与右子树，然后返回头节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="树的层序方式序列化与反序列化"><a href="#树的层序方式序列化与反序列化" class="headerlink" title="树的层序方式序列化与反序列化"></a>树的层序方式序列化与反序列化</h4><p>层序方式也是广度优先遍历。</p>
<p>序列化思路：将头节点加入队列，并将其添加进StringBuilder，从队列中弹出一个节点，将其左右子树的值加入，没有就加入#，而不选择在弹出的时候添加是因为空节点无法加入队列。如果左子树不为空，加入队列；如果右子树不为空，加入队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按层序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">serialByLevel</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(head);</span><br><span class="line">        sb.append(head.value).append(<span class="string">"!"</span>);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            head = queue.poll();</span><br><span class="line">            <span class="comment">//在节点进去的时候就添加，不然添加不了空节点</span></span><br><span class="line">            <span class="keyword">if</span> (head.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.offer(head.left);</span><br><span class="line">                sb.append(head.left.value).append(<span class="string">"!"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(<span class="string">"#!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.offer(head.right);</span><br><span class="line">                sb.append(head.right.value).append(<span class="string">"!"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(<span class="string">"#!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>按层方式反序列化 思路：将字符串分割，建造头节点并放入队列中，记录头节点。从队列中弹出一个节点，建造其左子树与右子树，如果左子树不为空，加入队列；如果右子树不为空，加入队列。此处用index+数组来控制当前要利用的字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按层方式反序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reconByLevelString</span><span class="params">(String levelStr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将字符串分割</span></span><br><span class="line">        String[] str = levelStr.split(<span class="string">"!"</span>);</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//产生头节点，并放进队列中</span></span><br><span class="line">        Node res = generateNode(str[value++]);</span><br><span class="line">        Node head = res;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(head);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            head = queue.poll();</span><br><span class="line">            head.left = generateNode(str[value++]);</span><br><span class="line">            head.right = generateNode(str[value++]);</span><br><span class="line">            <span class="keyword">if</span> (head.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.offer(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.offer(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断树是否为平衡二叉树"><a href="#判断树是否为平衡二叉树" class="headerlink" title="判断树是否为平衡二叉树"></a>判断树是否为平衡二叉树</h4><p>平衡二叉树中，在任何一个节点，左子树与右子树高度差，不超过1。</p>
<p>思路：以每一个节点为头节点的树为平衡二叉树，总体才是，对当前节点，需要其左子树为平衡二叉树，右子树为平衡二叉树，两个子树高度差不超过1，才是平衡二叉树。可以用树的后序遍历递归方式解决，当前函数需要给下一级函数传递当前子树是否平衡，树的高度，如果树不平衡，则高度没有用。可以将是否平衡与树的高度信息进行封装。关键是看函数功能是什么，需要传递什么参数。</p>
<p>平衡性用来解决效率问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isB</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> process(head).isB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ReturnData <span class="title">process</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="comment">//空树是高度为0的平衡树</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">    ReturnData leftData = process(head.left);</span><br><span class="line">    <span class="comment">//左子树不平衡，则直接不平衡</span></span><br><span class="line">    <span class="comment">//在不满足时高度为0是因为高度用不上</span></span><br><span class="line">    <span class="keyword">if</span> (!leftData.isB) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ReturnData rightData = process(head.right);</span><br><span class="line">    <span class="keyword">if</span> (!rightData.isB)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左、右树均平衡</span></span><br><span class="line">    <span class="keyword">if</span> (Math.abs(leftData.h - rightData.h) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在满足的时候，子结构要给父过程提供高度，为二者中较高的+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">true</span>,Math.max(leftData.h, rightData.h)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="剑指Offer"><a href="#剑指Offer" class="headerlink" title="剑指Offer"></a>剑指Offer</h1><h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><h3 id="数组中重复数字"><a href="#数组中重复数字" class="headerlink" title="数组中重复数字"></a>数组中重复数字</h3><h4 id="允许修改数组"><a href="#允许修改数组" class="headerlink" title="允许修改数组"></a>允许修改数组</h4><p>长度为n的数组里所有数字均出现在o~n-1的范围内，数组内某些数字是重复的，但不知道几个重复了，也不知道数字重复了几次。找出数组中任意一个重复的数字。如 ，长度为7的数组{2,3,1,0,2,5,3}，对应的输出为重复数字为2或者3。</p>
<p>方法1：使用哈希表，如果一个元素添加进哈希表了，就返回此元素，如果没有加入过，就加入。</p>
<p>时间复杂度O(n)，额外空间复杂度O(n)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用哈希表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">findNumHash</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(arr[i]))</span><br><span class="line">            <span class="keyword">return</span> arr[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            set.add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下解决的是找到第一个重复元素的问题，但是要额外建立一个哈希表。</p>
<p>方法2：抽屉原理</p>
<p>如果有n个数分布为0-n-1，在没有重复的时候，必然是一个萝卜一个坑，即可以将值为<code>i</code>的元素（i=0~n-1）放在第<code>i</code>个坑中，但是因为有重复的元素存在，会出现在第<code>i</code>个坑中值不为i的情况，这时候可以将它放在它原本应在的地方，直到当前坑中放了对应的萝卜，如果此时第<code>i</code>个坑中元素为<code>k</code>，但第<code>k</code>个坑中元素也为<code>k</code>，说明当前元素就是重复的。</p>
<p>总的时间复杂度为O(n)，额外空间复杂度O(1)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到第一个重复的数字，抽屉原理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">findNum</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果数组的长度不在0-arr.length-1之间，返回</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; <span class="number">0</span> || arr[i] &gt; arr.length-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从第一个到最后一个</span></span><br><span class="line">        <span class="comment">//如果当前数和角标不等，交换，直到相等或和要交换角标处的值相等</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[i] != i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] == arr[arr[i]])&#123;</span><br><span class="line">                    <span class="keyword">return</span> arr[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//swap(arr,i,arr[i])</span></span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[arr[i]];</span><br><span class="line">                <span class="comment">//不能直接使用arr[arr[i]]，因为此时arr[i]已经变化了</span></span><br><span class="line">                arr[temp] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="不修改数组找到重复数字"><a href="#不修改数组找到重复数字" class="headerlink" title="不修改数组找到重复数字"></a>不修改数组找到重复数字</h4><p>在长度为n+1的数组里的所有数字都在1~n的范围之内，因此数组中至少有一个数字是重复的。找出任意一个重复的数字，但不能修改输入的数组，如输入长度为8的数组{2,3,5,4,3,2,6,7}，输出为重复的数字2或者3。额外空间复杂度为O(1)。</p>
<p>不能使用哈希表，不能使用抽屉原理，这时候可以考虑二分。因为如果<code>1~n</code>的数字没有重复，那么<code>1~(n-1)/2</code>和<code>(n-1)/2+1~n</code>中元素个数应该和其角标left-right之间的范围相同，但是因为有重复的，那么假设重复数字为3，那么<code>1~7</code>分为<code>1~4</code>和<code>5~7</code>，这时候<code>1~4</code>中的元素个数肯定会多于4，然后再到<code>1~4</code>中进行寻找，直到找到left=right，如果这时候left值的数字出现个数&gt;1，则输出left。</p>
<p>用到的为二分的模板</p>
<p>核心为</p>
<ol>
<li>left与right的取值很重要，需要夹住所有可能的情况</li>
<li>while循环中用left &lt; right，这样退出循环的时候一定有left==right，不用思考返回left还是right</li>
<li>mid选择左中位数（left + ((right - left) &gt;&gt; 1)）或者右中位数（left + ((right - left+1) &gt;&gt; 1)）</li>
<li>只用两个判断，一次排除一半的结果</li>
<li>可以选择是否在循环结束后对夹住的数进行判断</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> left = 数<span class="number">1</span>, right = 数<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(判断条件<span class="number">1</span>)&#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//或者</span></span><br><span class="line">    <span class="keyword">if</span>(判断条件<span class="number">1</span>)&#123;</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        left = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在while结束后，对left处的值选择性进行判断</span></span><br><span class="line"><span class="comment">//多种输出可能</span></span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line"><span class="keyword">return</span> arr[left];</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>此题具体的实现代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用二分的思路</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">findNum2</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//看是否在0-n-1范围之内</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; <span class="number">0</span> || arr[i] &gt; arr.length-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二分，看哪边的数字更多，再继续找</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right-left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//计算个数</span></span><br><span class="line">            <span class="keyword">int</span> count = getFre(arr,left,mid);</span><br><span class="line">            <span class="keyword">if</span> (count &gt; mid + <span class="number">1</span> - left)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//去另一半</span></span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = getFre(arr,left,right);</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        <span class="comment">//没有找到</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计在l-m之间出现的次数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getFre</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt;= l &amp;&amp; arr[i] &lt;= m)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>左神算法</tag>
        <tag>剑指offer</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>前端学习</title>
    <url>/2020/02/13/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<blockquote>
<p>html与css相关学习</p>
</blockquote>
<p>​    HTML用于描述页面的结构，CSS用于控制页面中元素的样式，JavaScript用于响应用户操作</p>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="HTML简介"><a href="#HTML简介" class="headerlink" title="HTML简介"></a>HTML简介</h3><p>HTML（Hypertext Markup Language）为超文本标记语言，负责结构，使用标签的形式来标识网页中的不同组成部分，所谓超文本指的是超链接，使用超链接可以实现页面间的跳转。</p>
<a id="more"></a>

<ul>
<li><p>纯文本：只能保持文本内容，图片、音频、视频等格式化的内容都不能设置，网页就是纯文本编写的。</p>
</li>
<li><p>标签：给组成部分做标记，标签一般是成对出现的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>文本<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>网页标准标签：</p>
<ul>
<li><p>根标签：html，网页所有内容应该写在根标签里面</p>
</li>
<li><p>两个子标签</p>
<ul>
<li><p>head</p>
<p>设置网页头部信息，有title子标签，title中内容不会在网页中直接显示，默认显示在浏览器的标题栏中，搜索引擎在检索页面时，会首先检索title中的内容，是网页中对于搜索引擎最重要的内容，会影响到网页在搜索引擎中的排名。title一般为SEU写。</p>
<p>head帮助浏览器解析</p>
</li>
<li><p>body</p>
<p>网页主体，页面中所有可见内容应写在body中</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span></span><br><span class="line">        好网页</span><br><span class="line">		<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">		第一个网页</span><br><span class="line">		<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/2020/02/13/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5.png" class title="This is an example image">

<h3 id="HTML注释"><a href="#HTML注释" class="headerlink" title="HTML注释"></a>HTML注释</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释 --&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>可以通过属性来处理标签中的内容。可以在开始标签中添加属性，在标签后空格，然后key=“value”。实际为名值对的结构，值一定要加引号。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">"red"</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">font</span>&gt;</span>网页</span><br></pre></td></tr></table></figure>

<p>​    可以通过文档查阅标签中具体属性。</p>
<h3 id="HTML版本"><a href="#HTML版本" class="headerlink" title="HTML版本"></a>HTML版本</h3><p>最早为HTML，中间有XHTML，现在为HTML5，为了让浏览器识别正确版本，在head前面需要加上文档说明。</p>
<p>H5的文档说明为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    编写网页时要将H5的文档说明写在网页最上面，如果不写声明，可能会让某些浏览器进入怪异模式，浏览器解析页面可能会无法正常显示。怪异模式是网页为了兼容旧的模式设置的。</p>
<h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><p>几进制就是满几进1。</p>
<p>16进制：0-9，a-f</p>
<h3 id="乱码"><a href="#乱码" class="headerlink" title="乱码"></a>乱码</h3><p>编码与解码字符集不一样。</p>
<p>中文系统默认GB2312，UTF-8万国码，支持地球上所有的文字，开发时使用UTF-8。</p>
<p>在中文的浏览器中，默认都是使用GB2312进行解码。</p>
<p>​    或者告诉浏览器网页采用的编码字符集,meta标签用来设置网页的元数据，如网页的字符集，关键字，简介，meta是自结束标签。编写自结束标签时，可以在开始标签中添加一个/</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>放在title前。ANSI为智能编码，采用系统的默认编码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>网页的标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个漂亮的网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span>	</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h3><h4 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h4><p>在HTML中，一共有六级标题标签，</p>
<blockquote>
<p>h1-h6，从大到小</p>
</blockquote>
<p>​    在显示效果上h1最大，h6最小，但文字的大小并不关心，CSS做的。使用HTML标签时，关心的是标签的语义，我们使用的标签都是语义化标签。</p>
<p>​    6级标题中，h1最重要，表示一个网页的主要内容，h2~h6的重要性依次降低。</p>
<p>​    对浏览器，h1的重要性仅次于title，搜索引擎检索完title，会立即查看h1中的内容。h1标签非常重要，会影响到页面在搜索引擎中的排名。<strong>页面只能有一个h1</strong>。</p>
<p>​    一般页面中标题标签只使用h1 h2 h3，<strong>h3以后的基本不使用</strong>。</p>
<img src="/2020/02/13/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E6%A0%87%E9%A2%98.png" class title="This is an example image">

<h4 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签"></a>段落标签</h4><p>​    段落标签用于表示内容中的一个自然段，使用p标签来表示一个小段落。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    p标签中的文字，默认会独占一行，并且段与段之间会有一个间距。</p>
<p>​    重要的是语义，表示一个段落。</p>
<h4 id="换行标签"><a href="#换行标签" class="headerlink" title="换行标签"></a>换行标签</h4><p>在HTML中，字符之间再多的空格，浏览器也会当成一个空格解析，换行也会当做一个空格解析。</p>
<p>在页面中可以使用br标签来表示一个换行，br标签是一个自结束标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">武汉加油，<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">湖北加油，<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">中国加油！<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    显示效果为如下</p>
<img src="/2020/02/13/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E6%8D%A2%E8%A1%8C.png" class title="This is an example image">

<p>​    <strong>hr标签</strong>也是一个自结束标签，可以在页面中生成一条水平线。</p>
<h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p>​    需求：想在网页上写a小于b大于c，直接这样写，会组成一个标签结构。</p>
<p>​    在HTML中，一些如&lt;  &gt; 等特殊字符不能直接使用，需要使用一些特殊的符号来表示这些特殊字符，这些特殊字符称为实体（转义字符串）。浏览器解析到实体时，会自动将实体转换为其对应的字符。</p>
<p>​    实体的语法：&amp;开头，;结尾</p>
<blockquote>
<p>&amp;实体的名字;</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;   &amp;lt;  &lt;!-- less than --&gt;</span><br><span class="line">&gt;   <span class="symbol">&amp;gt;</span>  <span class="comment">&lt;!-- great than --&gt;</span></span><br><span class="line">空格  <span class="symbol">&amp;nbsp;</span>  <span class="comment">&lt;!-- 不会换行的空格 --&gt;</span></span><br><span class="line">版权符号  <span class="symbol">&amp;copy;</span></span><br></pre></td></tr></table></figure>

<p>​    具体的可以查询手册。</p>
<img src="/2020/02/13/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E4%BD%93.png" class title="This is an example image">

<h3 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h3><p>使用img标签来向网页中引入一个外部标签，img标签也是一个自结束标签。</p>
<p>属性：</p>
<ul>
<li><p>src：设置一个外部图片的路径</p>
</li>
<li><p>alt：可以设置在图片不能显示时，对图片的描述</p>
<p>搜索引擎可以通过alt属性来识别不同的图片</p>
<p>如果不写alt属性，则搜索引擎不会对img中的图片进行收录</p>
</li>
<li><p>width：修改图片的宽度，一般使用px</p>
</li>
<li><p>height：修改图片的高度，一般使用px</p>
<p>宽度和高度两个属性如果只设置一个，另一个也会同时等比例调整大小</p>
<p>一般开发中除了自适应的页面，不建议设置width和height</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"2.gif"</span> <span class="attr">alt</span>=<span class="string">"这是一个大松鼠"</span> <span class="attr">width</span>=<span class="string">"200px"</span> <span class="attr">height</span>=<span class="string">"200px"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="图片路径"><a href="#图片路径" class="headerlink" title="图片路径"></a>图片路径</h4><p>src属性配置图片的路径，目前所要使用的路径都是相对路径。</p>
<p>相对路径：相对于当前资源所在目录的位置。</p>
<p>可以使用../来返回一级，返回几级目录，就写几个../。 </p>
<p>为了相对路径填写方便，图片与网页文件最好不要放太远。</p>
<h4 id="图片的格式"><a href="#图片的格式" class="headerlink" title="图片的格式"></a>图片的格式</h4><ul>
<li>JPEG（JPG）<ul>
<li>JPEG图片支持的颜色比较多，图片可以压缩，但是不支持透明</li>
<li>一般使用JPEG保存照片等颜色丰富的图片</li>
</ul>
</li>
<li>GIF<ul>
<li>GIF支持的颜色少，只支持简单的透明（直线透明），支持动态图</li>
<li>图片颜色单一或动态图使用GIF</li>
</ul>
</li>
<li>PNG<ul>
<li>PNG支持的颜色多，并且支持复杂的透明</li>
<li>可以用来显示颜色复杂的透明的图片</li>
</ul>
</li>
</ul>
<p>图片的使用原则：</p>
<ul>
<li>效果不一致，使用效果好的</li>
<li>效果一致，使用小的</li>
</ul>
<h3 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h3><p>meta标签还可以设置网页的关键字</p>
<ul>
<li>name</li>
<li>content</li>
</ul>
<p>name值是对content的描述，content内容是网页的关键字</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"HTML5,JavaScript,Java"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>还可以用来指定网页的描述</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"发布前端信息"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>搜索引擎在检索页面时，会同时检索页面中的关键词和描述，但是这两个值不会影响页面在搜索引擎中的排名。</p>
<p>可以做请求的重定向</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"5;url=http://www.baidu.com"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    5秒后重定向到指定的url中。5那里是秒数，url=目标路径</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul>
<li>ctrl+d  快速复制一行，在notepad++中</li>
</ul>
]]></content>
      <tags>
        <tag>html,css</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2020/02/09/MySQL/</url>
    <content><![CDATA[<blockquote>
<p>尚硅谷MySQL课程笔记</p>
</blockquote>
<h1 id="数据库操作基础"><a href="#数据库操作基础" class="headerlink" title="数据库操作基础"></a>数据库操作基础</h1><h2 id="数据库概述"><a href="#数据库概述" class="headerlink" title="数据库概述"></a>数据库概述</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><strong>可将数据持久化到硬盘</strong></li>
<li><strong>可存储大量数据</strong></li>
<li><strong>方便检索</strong></li>
<li>保证数据的一致性，完整性</li>
<li>安全，可共享</li>
<li>通过组合分析，可以产生新数据</li>
</ul>
<a id="more"></a>

<h3 id="常见数据库产品"><a href="#常见数据库产品" class="headerlink" title="常见数据库产品"></a>常见数据库产品</h3><ul>
<li>Oracle：甲骨文（产品免费，服务收费）</li>
<li>DB2：IBM（兼容性相对不好）</li>
<li>SQL Server：微软（兼容性不好）</li>
<li>MySQL：甲骨文（开源，免费，性能高）</li>
</ul>
<h3 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h3><ul>
<li><p>DB</p>
<p>数据库（database）：存储数据的“仓库”，保存了一系列有组织的数据</p>
</li>
<li><p>DBMS</p>
<p>数据库管理系统（Database Management System）：数据库是通过DBMS创建和操作的容器</p>
</li>
<li><p>SQL</p>
<p>结构化查询语言（Structure Query Language）：专门用来与数据库软件通信的语言</p>
</li>
</ul>
<h3 id="数据库存储数据特点"><a href="#数据库存储数据特点" class="headerlink" title="数据库存储数据特点"></a>数据库存储数据特点</h3><ol>
<li><p>将数据放到<strong>表</strong>中，表再放到库中</p>
</li>
<li><p>一个数据库可以有多个表，每个表有唯一性的用于标识的表名</p>
</li>
<li><p>表的<strong>特性</strong>定义了数据在表中如何存储，类似java中“类”的设计</p>
</li>
<li><p>表由<strong>列</strong>组成，也称为字段。所有表都是由一个或多个列组成，每一列类似java中的“<strong>属性</strong>”</p>
</li>
<li><p>表中的数据按<strong>行</strong>存储，每一行类似java中的“<strong>对象</strong>”</p>
</li>
<li><p>表中的所有记录，类似于“<strong>对象的集合</strong>”</p>
</li>
</ol>
<p>orm设计思想：object relation mapping 对象关系映射</p>
<h2 id="初识MySQL"><a href="#初识MySQL" class="headerlink" title="初识MySQL"></a>初识MySQL</h2><h3 id="MySQL数据库介绍"><a href="#MySQL数据库介绍" class="headerlink" title="MySQL数据库介绍"></a>MySQL数据库介绍</h3><p>​    MySQL前身为瑞典公司AB，2008年被sun公司收购，2009sun被oracle收购。</p>
<p>特点：</p>
<ol>
<li>体积小，安装较方便</li>
<li>开源，免费</li>
<li>性能高，稳定性好</li>
<li>兼容性好</li>
</ol>
<p>​    MySQL是一种开源的关系型数据库管理系统，广泛应用在中小型网站中。</p>
<h3 id="DBMS分类"><a href="#DBMS分类" class="headerlink" title="DBMS分类"></a>DBMS分类</h3><ul>
<li><p>基于共享文件系统的DBMS（Access）</p>
</li>
<li><p>基于客户机–服务器的DBMS   C/S  （MySQL，Oracle，SqlServer）</p>
<p>主要安装服务端。</p>
</li>
</ul>
<h3 id="MySQL服务的启动与停止"><a href="#MySQL服务的启动与停止" class="headerlink" title="MySQL服务的启动与停止"></a>MySQL服务的启动与停止</h3><p><strong>方式一：图形化</strong></p>
<p>右击–计算机管理–服务–MySQL服务</p>
<p><strong>方式二：通过管理员身份运行dos</strong></p>
<p>net start 服务名</p>
<p>net stop 服务名</p>
<h3 id="MySQL服务的登录与退出"><a href="#MySQL服务的登录与退出" class="headerlink" title="MySQL服务的登录与退出"></a>MySQL服务的登录与退出</h3><p><strong>方式一：通过dos命令</strong></p>
<p>mysql -h主机名 -P端口号 -u用户名 -p密码</p>
<p>注意：</p>
<p>​    如果是本机，则-h主机名可以省略</p>
<p>​    如果端口号是3306，则-P端口号可以省略</p>
<p>​    默认端口号3306，要先开启服务端，以管理员身份开cmd输入net start mysql5.5，后面为自定义的mysql服务名，然后开启mysql服务，普通用户打开cmd，输入mysql -u用户名 -p密码，即可。</p>
<p>使用exit退出，也可以mysql -uroot -p，然后再输入密码，这样可以隐藏密码。</p>
<p>连接其他主机上的数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -h主机名 -P端口号 -u用户名 -p密码</span><br></pre></td></tr></table></figure>

<p><strong>方式二：通过图形化界面客户端</strong></p>
<p>通过sqlyog，直接输入用户名，密码等</p>
<h2 id="MySQL的常见命令和语法规范"><a href="#MySQL的常见命令和语法规范" class="headerlink" title="MySQL的常见命令和语法规范"></a>MySQL的常见命令和语法规范</h2><h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><ul>
<li><p>show databases; 看数据库有哪些</p>
<ul>
<li><p>information_schema 服务端基本信息数据</p>
</li>
<li><p>mysql 用户信息，表信息等</p>
</li>
<li><p>performance_schema 性能分析</p>
<p><strong>前三个都不要改动！！！</strong></p>
</li>
<li><p>test</p>
<p>默认为空</p>
</li>
</ul>
</li>
<li><p>show tables;                            显示当前库中所有表</p>
</li>
<li><p>show tables from  库名;        直接看某个数据库的表 不影响当前库，因为<strong>没有使用use切换库</strong>。</p>
</li>
<li><p>show columns from 表名;     显示指定表中所有列</p>
</li>
<li><p>desc 表名;                                看表结构  describe</p>
</li>
<li><p>use 库名;                                  使用/打开指定数据库</p>
</li>
<li><p>select database();                   查看当前所在库</p>
</li>
</ul>
<h3 id="语法规范"><a href="#语法规范" class="headerlink" title="语法规范"></a>语法规范</h3><ul>
<li><p>不区分大小写</p>
</li>
<li><p>每条命令结尾建议用分号，也可以用\g</p>
</li>
<li><p>注释</p>
<ul>
<li><p>单行注释：#注释文字</p>
</li>
<li><p>单行注释：– 注释文字，中间要有空格</p>
</li>
<li><p>多行注释：/* 注释文字 */</p>
</li>
</ul>
</li>
<li><p>每条命令如果根据需要，可以进行缩进或换行</p>
<p>关键字最好单独一行</p>
</li>
</ul>
<h2 id="DQL语言"><a href="#DQL语言" class="headerlink" title="DQL语言"></a>DQL语言</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>DDL（Data Definition Language）：数据定义语言，用来定义数据库对象：库、表、列等；</p>
<p>create/drop/alter</p>
</li>
<li><p><strong>DML</strong>（Data Manipulation Language）：数据操作语言，用来定义数据库记录（数据）；</p>
<p><strong>insert/update/delete</strong></p>
</li>
<li><p>DCL（Data Control Language）：数据控制语言，用来定义访问权限和安全级别；</p>
<p>TCL(Transaction Control Language)</p>
</li>
<li><p><strong>DQL</strong>（Data Query Language）：数据查询语言，用来查询记录（数据）。</p>
<p><strong>select</strong></p>
</li>
</ul>
<h3 id="进阶一：基础查询"><a href="#进阶一：基础查询" class="headerlink" title="进阶一：基础查询"></a>进阶一：基础查询</h3><p>语法：</p>
<p>select 查询列表 from 表名;</p>
<p>特点：</p>
<ol>
<li><p>查询的结果集是一个虚拟表</p>
</li>
<li><p>select 查询列表 类似于System.out.println(打印内容);</p>
<p>select后面跟的查询列表，可以有多个部分组成，中间用逗号隔开</p>
<p>例如：select 字段1,字段2, 表达式 from 表;</p>
<p>System.out.println()的打印内容，只能有一个。</p>
</li>
<li><p>执行顺序</p>
<p>select first_name from employees;</p>
<p>先执行from语句，查询是否有此表，然后执行select语句，输出查询的列</p>
</li>
<li><p>查询列表可以是：字段，表达式，常量，函数等，也可以是这些的组合</p>
</li>
</ol>
<h4 id="查询常量"><a href="#查询常量" class="headerlink" title="查询常量"></a>查询常量</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<h4 id="查询表达式"><a href="#查询表达式" class="headerlink" title="查询表达式"></a>查询表达式</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span>/<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h4 id="查询单个字段"><a href="#查询单个字段" class="headerlink" title="查询单个字段"></a>查询单个字段</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`last_name`</span> <span class="keyword">FROM</span> <span class="string">`employees`</span>;</span><br><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>​    注意，着重号的使用是为了区分关键字，如某一column名为name，但同时NAME为关键字，这时候需要加着重号。如果不为关键字，则不用加。为了快捷输入，可以双击名称。</p>
<img src="/2020/02/09/MySQL/%E6%9F%A5%E8%AF%A2%E5%8D%95%E4%B8%AA%E5%AD%97%E6%AE%B5.png" class title="This is an example image">

<h4 id="查询多个字段"><a href="#查询多个字段" class="headerlink" title="查询多个字段"></a>查询多个字段</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`first_name`</span>,<span class="string">`last_name`</span>,<span class="string">`email`</span> <span class="keyword">FROM</span> <span class="string">`employees`</span>;</span><br></pre></td></tr></table></figure>

<p>​    中间用逗号隔开。</p>
<img src="/2020/02/09/MySQL/%E6%9F%A5%E8%AF%A2%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5.png" class title="This is an example image">

<h4 id="查询所有字段"><a href="#查询所有字段" class="headerlink" title="查询所有字段"></a>查询所有字段</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`employees`</span>;</span><br></pre></td></tr></table></figure>

<img src="/2020/02/09/MySQL/%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E5%AD%97%E6%AE%B5.png" class title="This is an example image">

<p>​    不好点在于字段顺序为表中定义顺序，因此开发中更常用的是将所有字段按照需要的顺序点击，如果太长不方便阅读，使用快捷键F12，来自动换行。</p>
<h4 id="查询函数（调用函数，获取返回值）"><a href="#查询函数（调用函数，获取返回值）" class="headerlink" title="查询函数（调用函数，获取返回值）"></a>查询函数（调用函数，获取返回值）</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATABASE</span>(); <span class="comment">#查询当前的数据库</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">VERSION</span>();  <span class="comment">#查询当前数据库服务器版本</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>();     <span class="comment">#查询当前用户</span></span><br></pre></td></tr></table></figure>

<h4 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h4><p>方式一：使用as关键字</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>() <span class="keyword">AS</span> 用户名;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>() <span class="keyword">AS</span> <span class="string">`用户名`</span>;</span><br></pre></td></tr></table></figure>

<p>使用前</p>
<img src="/2020/02/09/MySQL/%E8%B5%B7%E5%88%AB%E5%90%8D%E5%89%8D.png" class title="This is an example image">

<p>使用后</p>
<img src="/2020/02/09/MySQL/%E8%B5%B7%E5%88%AB%E5%90%8D%E5%90%8E.png" class title="This is an example image">

<p>​    加<strong>着重号</strong>是为了方便识别，如下面例子。注意：是着重号而不是引号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">AS</span> 姓 名 <span class="keyword">FROM</span> <span class="string">`employees`</span>;    <span class="comment">#报错，因为不知道名是干嘛的</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">AS</span> <span class="string">"姓 名"</span> <span class="keyword">FROM</span> <span class="string">`employees`</span>;</span><br></pre></td></tr></table></figure>

<p>​    如果姓名中间有空格，不加<strong>着重号</strong>会报错。</p>
<p>方式二：使用空格</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>() <span class="string">`用户名`</span>;</span><br></pre></td></tr></table></figure>

<h4 id="concat的使用"><a href="#concat的使用" class="headerlink" title="concat的使用"></a>concat的使用</h4><p>– 需求：查询 first_name和last_name拼接成的全名，最终起别名为：姓 名</p>
<p>方案一：使用+号</p>
<p>​    如果是按照Java的思路</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> first_name+last_name <span class="keyword">AS</span> <span class="string">"姓 名"</span> <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>但是出来结果为</p>
<img src="/2020/02/09/MySQL/%E5%8A%A0%E6%B3%95.png" class title="This is an example image">

<p>​    这是因为在Java中+可以执行加法运算，也可以实现字符串的拼接（至少要求一个为字符串）。</p>
<p>​    但在MySQL中，+作用为</p>
<ol>
<li><p>加法运算</p>
<ul>
<li><p>两个操作数为数值型</p>
<p>100+1.5</p>
</li>
<li><p>其中一个操作数为字符型</p>
<p>将字符型数据强制转换成数值型，如果无法转换，则直接当做0处理</p>
<p>‘张无忌’+100 ===&gt; 100</p>
</li>
<li><p>其中一个操作数为null</p>
<p>null+null ===&gt; null</p>
<p>null+100 ===&gt; null</p>
</li>
</ul>
</li>
</ol>
<p>因此两个char直接相加，都不能识别，结果为0。</p>
<p>方案二：使用concat()拼接函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(first_name,last_name) <span class="keyword">AS</span> <span class="string">"姓 名"</span> </span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>​    concat()函数中支持任意长度的String。</p>
<img src="/2020/02/09/MySQL/concat%E6%8B%BC%E6%8E%A5.png" class title="This is an example image">

<h4 id="distinct去重"><a href="#distinct去重" class="headerlink" title="distinct去重"></a>distinct去重</h4><p>需求：查询员工涉及到的部门编号有哪些</p>
<p>​    如有10个员工都是部门90，有10个员工都是部分80，将所有部门编号不重复的显示出来。</p>
<p>如果直接敲入SELECT department_id FROM employees;，那么会出现重复的编号如下。</p>
<img src="/2020/02/09/MySQL/%E9%87%8D%E5%A4%8D%E9%83%A8%E9%97%A8%E7%BC%96%E5%8F%B7.png" class title="This is an example image">

<p>​    可以通过增加distinct关键字来去重</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="string">`department_id`</span> <span class="keyword">FROM</span> <span class="string">`employees`</span>;</span><br></pre></td></tr></table></figure>

<p>​    显示结果为</p>
<img src="/2020/02/09/MySQL/%E7%BC%96%E5%8F%B7%E5%8E%BB%E9%87%8D.png" class title="This is an example image">

<h4 id="查看表的结构"><a href="#查看表的结构" class="headerlink" title="查看表的结构"></a>查看表的结构</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DESC employees;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">COLUMNS</span> <span class="keyword">FROM</span> <span class="string">`employees`</span>;</span><br></pre></td></tr></table></figure>

<p>​    上面两种都可以显示表所有列的结构</p>
<img src="/2020/02/09/MySQL/%E6%98%BE%E7%A4%BA%E8%A1%A8%E7%BB%93%E6%9E%84.png" class title="This is an example image">

<h3 id="练习题1"><a href="#练习题1" class="headerlink" title="练习题1"></a>练习题1</h3><p>1、下面的语句是否可以执行成功</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  last_name,</span><br><span class="line">  job_id,</span><br><span class="line">  salary <span class="keyword">AS</span> sal </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  employees ;</span><br></pre></td></tr></table></figure>

<p>​    可以，输出多个，将salary起名为sal。</p>
<p>2、下面语句是否可以执行成功</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees ;</span><br></pre></td></tr></table></figure>

<p>​    可以，输出eployees中全部。</p>
<p>3、找出下面语句中的错误</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  employee_id,</span><br><span class="line">  last_name，</span><br><span class="line">  salary * <span class="number">12</span> “ ANNUAL SALARY ” </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  employees ;</span><br></pre></td></tr></table></figure>

<p>​    错误在于last_name后面的逗号为中文逗号，12后面的双引号为中文的符号，更改即可。salary*12起名为ANNUAL SALARY。</p>
<p>4、显示表 departments 的结构，并查询其中的全部数据 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DESC departments;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> departments;</span><br></pre></td></tr></table></figure>

<p>​    可以使用desc，也可以使用SHOW COLUMNS FROM departments;</p>
<p>5、显示出表 employees 中的全部 job_id （不能重复）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> job_id <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>​    考distinct关键字的使用，查哪个表，就from哪个。</p>
<p>6、显示出表 employees 的全部列，各个列之间用逗号连接，列头显示成 OUT_PUT </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(employee_id,<span class="string">','</span>,first_name,<span class="string">','</span>,last_name,<span class="string">','</span>,commission_pct) <span class="keyword">AS</span> <span class="string">"OUT_PUT"</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>​    考concat使用，在不同列之间还要拼接上‘,’，然后起名。</p>
<p>​    但是有的为null，有的是正常的。</p>
<img src="/2020/02/09/MySQL/%E5%B8%A6%E9%80%97%E5%8F%B7%E6%8B%BC%E6%8E%A5.png" class title="This is an example image">

<p>​    然后调用SELECT commission_pct FROM employees;，发现有的commission_pct为null值。在拼接时，只要有一个为null，那么就不能直接拼接。这时候需要判断，只有在不为空的时候才进行拼接。使用函数ifnull。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> commission_pct, <span class="keyword">IFNULL</span>(commission_pct,<span class="string">"空"</span>) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>​    此函数需要输入两个参数，一个是进行判断的参数，第二个是如果此参数为null要显示的参数。</p>
<img src="/2020/02/09/MySQL/IFNULL%E4%BD%BF%E7%94%A8.png" class title="This is an example image">

<p>​    因此将commission进行替换为ifnull即可</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(employee_id,<span class="string">','</span>,first_name,<span class="string">','</span>,last_name,<span class="string">','</span>,<span class="keyword">IFNULL</span>(commission_pct,<span class="string">''</span>)) <span class="keyword">AS</span> <span class="string">"OUT_PUT"</span> <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<h3 id="进阶二：条件查询"><a href="#进阶二：条件查询" class="headerlink" title="进阶二：条件查询"></a>进阶二：条件查询</h3><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><p>select 查询列表 </p>
<p>from 表名</p>
<p><strong>where 筛选条件</strong>;</p>
<p>​    执行顺序：1，from；2，where；3，select。</p>
<p>​    在没有索引时逐行查询，再筛选有where满足的语句，进行select输出。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`first_name`</span>,<span class="string">`last_name`</span> <span class="keyword">FROM</span> <span class="string">`employees`</span> <span class="keyword">WHERE</span> <span class="string">`salary`</span>&gt;<span class="number">2000</span>;</span><br></pre></td></tr></table></figure>

<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ol>
<li><p>按关系表达式筛选</p>
<p>关系运算符：</p>
<table>
<thead>
<tr>
<th>小于</th>
<th>&lt;</th>
</tr>
</thead>
<tbody><tr>
<td>小于等于</td>
<td>&lt;=</td>
</tr>
<tr>
<td>大于</td>
<td>&gt;</td>
</tr>
<tr>
<td>大于等于</td>
<td>&gt;=</td>
</tr>
<tr>
<td>等于</td>
<td>=</td>
</tr>
<tr>
<td>不等于</td>
<td>&lt;&gt;</td>
</tr>
</tbody></table>
<p>补充：不等于!=也可以，但不建议</p>
</li>
<li><p>按逻辑表达式</p>
<p>逻辑运算符</p>
<table>
<thead>
<tr>
<th>与</th>
<th>and</th>
</tr>
</thead>
<tbody><tr>
<td>或</td>
<td>or</td>
</tr>
<tr>
<td>非</td>
<td>not</td>
</tr>
</tbody></table>
<p>补充：也可以使用&amp;&amp;   ||    !   但不建议</p>
</li>
<li><p>模糊查询</p>
<ul>
<li>like</li>
<li>in</li>
<li>between and</li>
<li>is null</li>
</ul>
</li>
</ol>
<h4 id="按关系表达式查询"><a href="#按关系表达式查询" class="headerlink" title="按关系表达式查询"></a>按关系表达式查询</h4><p>案例1：查询部门编号不是100的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id &lt;&gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>​    先按照select,from,where写好，然后进行填充。输出的是员工信息，但是不确定，用*号，然后选择的表是员工表，条件是部门编号不为100。的后跟什么，select后加什么。的前面是什么，where后加什么</p>
<p>案例2：查询工资小于15000的姓名、工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary&lt;<span class="number">15000</span>;</span><br></pre></td></tr></table></figure>

<p>​    的后为姓名工资，放在select后，的前为工资小于15000，放在where后。</p>
<h4 id="按逻辑表达式查询"><a href="#按逻辑表达式查询" class="headerlink" title="按逻辑表达式查询"></a>按逻辑表达式查询</h4><p>案例1：查询部门编号不是50-100之间员工姓名、部门编号、邮箱</p>
<p>方式1：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_id,email</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id &gt; <span class="number">100</span> <span class="keyword">OR</span> department_id &lt; <span class="number">50</span>;</span><br></pre></td></tr></table></figure>

<p>方式2：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_id,email</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span>(department_id &gt;= <span class="number">50</span> <span class="keyword">AND</span> department_id &lt;= <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>案例2：查询奖金率&gt;0.03 或者员工编号在60-110之间的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct &gt; <span class="number">0.03</span> <span class="keyword">OR</span> (employee_id &gt;= <span class="number">60</span> <span class="keyword">AND</span> employee_id &lt;= <span class="number">110</span>);</span><br></pre></td></tr></table></figure>

<h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><h5 id="like"><a href="#like" class="headerlink" title="like"></a>like</h5><p>功能：一般和通配符搭配使用，对字符型数据进行<strong>部分匹配查询</strong></p>
<p>like/ not like</p>
<p>常见的通配符：</p>
<ul>
<li>_    任意单个字符</li>
<li>%   任意多个字符，支持0到多个字符</li>
</ul>
<p>案例1：查询姓名中包含字符a的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">'%a%'</span>;</span><br></pre></td></tr></table></figure>

<p>​    姓名中包含a，使用like，因为a前面有几个字符不知道，因此a前面加%；a后面有几个字符不知道，因此a后面加%。而sql中字符要用单引号括起来，因此是like ‘%a%’。</p>
<p>案例2：查询姓名中最后一个字符为e的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">'%e'</span>;</span><br></pre></td></tr></table></figure>

<p>​    最后个字符为e，因此e前面有几个字符不知道，但e后面没有字符，因此是like ‘%e’。</p>
<p>案例3：查询姓名中第一个字符为e的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">'e%'</span>;</span><br></pre></td></tr></table></figure>

<p>​    第一个个字符为e，因此e后面有几个字符不知道，但e前面没有字符，因此是like ‘e%’。</p>
<p>案例4：查询姓名中第三个字符为x的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">'__x%'</span>;</span><br></pre></td></tr></table></figure>

<p>​    x前面有2个字符，因此添加2个下划线_，然后x后面的字符个数位置，使用%，因此为‘__x%’。</p>
<p>案例5：查询姓名中包含第二个字符为_的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">'_\_%'</span>;</span><br></pre></td></tr></table></figure>

<p>​    第二个下划线需要使用转义字符在转义。</p>
<p>​    但这种在sql中不是常见语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">'_$_%'</span> ESCAPE <span class="string">'$'</span>;</span><br></pre></td></tr></table></figure>

<p>​    使用一个喜欢的而且不常见的字符作为转义字符，利用ESCAPE来标记其为转义字符。</p>
<h5 id="in"><a href="#in" class="headerlink" title="in"></a>in</h5><p>功能：查询某字段的值是否<strong>属于指定的列表</strong>之内</p>
<p>a  in(常量值1,常量值2,常量值3,….)  意思是看a是否是在这些值之内</p>
<p>a not in(常量值1,常量值2,常量值3,….)  意思是看a是否是均在这些值之内</p>
<p>in/not in  在或者不在</p>
<p>案例1：查询部门编号是30/50/90的员工名和部门编号</p>
<p>方式1：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span>(<span class="number">30</span>,<span class="number">50</span>,<span class="number">90</span>);</span><br></pre></td></tr></table></figure>

<p>方式2：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id =<span class="number">30</span></span><br><span class="line"><span class="keyword">OR</span> department_id =<span class="number">50</span></span><br><span class="line"><span class="keyword">OR</span> department_id =<span class="number">90</span>;</span><br></pre></td></tr></table></figure>

<p>案例2：查询工种编号不是SH_CLERK或IT_PROG的员工信息</p>
<p>方式1：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> job_id <span class="keyword">NOT</span> <span class="keyword">IN</span>(<span class="string">'SH_CLERK'</span>,<span class="string">'IT_PROG'</span>);</span><br></pre></td></tr></table></figure>

<p>方式2：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> (job_id = <span class="string">'SH_CLERK'</span></span><br><span class="line"><span class="keyword">OR</span> job_id = <span class="string">'IT_PROG'</span>);</span><br></pre></td></tr></table></figure>

<h5 id="between-and"><a href="#between-and" class="headerlink" title="between and"></a>between and</h5><p>功能：判断某个字段的值是否介于xx之间。判断的是区间值。<strong>包含临界值</strong>。</p>
<p>between and / not between and</p>
<p>案例1：查询部门编号是30-90之间的部门编号、员工姓名</p>
<p>方式1：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id,last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">BETWEEN</span> <span class="number">30</span> <span class="keyword">AND</span> <span class="number">90</span>;</span><br></pre></td></tr></table></figure>

<p>​    between和and之间，要<strong>先写小的数，再写大的</strong>。</p>
<p>方式2：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id,last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id &gt;= <span class="number">30</span> <span class="keyword">AND</span> department_id &lt;= <span class="number">90</span>;</span><br></pre></td></tr></table></figure>

<p>​    两种方式是等价的，因此一定要先写小的，不然查询不到。</p>
<p>案例2：查询年薪不是100000-200000之间的员工姓名、工资、年薪</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,salary,salary*<span class="number">12</span>*(<span class="number">1</span>+<span class="keyword">IFNULL</span>(commission_pct,<span class="number">0</span>)) 年薪</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary*<span class="number">12</span>*(<span class="number">1</span>+<span class="keyword">IFNULL</span>(commission_pct,<span class="number">0</span>)) <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">100000</span> <span class="keyword">AND</span> <span class="number">200000</span>;</span><br></pre></td></tr></table></figure>

<p>​    首先在表格中没有年薪，因此要明确年薪的计算</p>
<blockquote>
<p>年薪=月薪x12x(1+奖金率)</p>
</blockquote>
<p>​    但奖金率有可能为空，因此要使用ifnull进行判断，如果为空则设置为0，然后给年薪起名，条件语句是年薪不在100000和200000之间，因此使用not between。</p>
<p>​    小技巧：可以先进行select和from进行判断语句是否写正确，然后再写where语句。</p>
<h5 id="is-null"><a href="#is-null" class="headerlink" title="is null"></a>is null</h5><p>is null / is not null</p>
<p>案例1：查询没有奖金的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>​    直接用=null无法判断出来。</p>
<p>案例2：查询有奖金的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>=与is null比较</p>
<ul>
<li>=               只能判断普通的内容</li>
<li>IS              只能判断NULL值</li>
<li>&lt;=&gt;          安全等于，既能判断普通内容，又能判断NULL值，但<strong>可读性差</strong></li>
</ul>
<h3 id="进阶三：排序查询"><a href="#进阶三：排序查询" class="headerlink" title="进阶三：排序查询"></a>进阶三：排序查询</h3><p>语法：</p>
<p>select 查询列表</p>
<p>from 表格</p>
<p>where 筛选条件  （<strong>可省略</strong>）</p>
<p>order by 排序列表</p>
<p>执行顺序</p>
<ol>
<li><p>from 子句</p>
</li>
<li><p>where 子句</p>
</li>
<li><p>select 子句</p>
</li>
<li><p>order by 子句</p>
<p><strong>先查出来，再排序</strong></p>
</li>
</ol>
<p>特点：</p>
<ol>
<li><p>排序列表可以是单个字段、多个字段、表达式、函数、列数以及以上的组合</p>
</li>
<li><p>升序，通过  asc ， 默认行为</p>
<p>降序，通过 desc</p>
</li>
<li><p>order by的位置一般放在查询语句的最后（除limit语句之外）</p>
</li>
</ol>
<h4 id="按单个字段排序"><a href="#按单个字段排序" class="headerlink" title="按单个字段排序"></a>按单个字段排序</h4><p>案例1：将员工编号大于120的员工信息进行工资的升序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id &gt; <span class="number">120</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<p>​    其中ASC可以省略。</p>
<p>案例2：将员工编号大于120的员工信息进行工资的降序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id &gt; <span class="number">120</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h4 id="按表达式排序"><a href="#按表达式排序" class="headerlink" title="按表达式排序"></a>按表达式排序</h4><p>案例1：对有奖金的员工，按年薪降序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *,salary*<span class="number">12</span>*(<span class="number">1</span>+<span class="keyword">IFNULL</span>(commission_pct,<span class="number">0</span>))  年薪</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary*<span class="number">12</span>*(<span class="number">1</span>+<span class="keyword">IFNULL</span>(commission_pct,<span class="number">0</span>)) <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>​    计算出年薪表达式，然后选择奖金率不为空，再按照年薪排序，但表达式太长。</p>
<h4 id="按别名排序"><a href="#按别名排序" class="headerlink" title="按别名排序"></a>按别名排序</h4><p>案例1：对有奖金的员工，按年薪降序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *,salary*<span class="number">12</span>*(<span class="number">1</span>+<span class="keyword">IFNULL</span>(commission_pct,<span class="number">0</span>))  年薪</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 年薪 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>​    计算出年薪表达式，然后选择奖金率不为空，再按照年薪排序，但表达式太长。</p>
<p>​    判断：where判断处是否能使用年薪？</p>
<p>​    不能，因为执行顺序是from,where,select,order by，在where处别名年薪还没有被定义，因此只能在order by后使用。</p>
<p>​    这里语法可以被简化，因为经过where判断后，已经不存在奖金率为null的情况，因此不用在select中加上对奖金率IFNULL的判断。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *,salary*<span class="number">12</span>*(<span class="number">1</span>+commission_pct)  年薪</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 年薪 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h4 id="按函数的结果排序"><a href="#按函数的结果排序" class="headerlink" title="按函数的结果排序"></a>按函数的结果排序</h4><p>案例1：按姓名的字数长度进行升序</p>
<p>获取字数长度可以使用LENGTH()函数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LENGTH</span>(last_name),last_name</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<img src="/2020/02/09/MySQL/LENGTH%E5%87%BD%E6%95%B0.png" class title="This is an example image">

<p>​    因此直接order by length(last_name)即可</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">LENGTH</span>(last_name);</span><br></pre></td></tr></table></figure>

<h4 id="按多个字段排序"><a href="#按多个字段排序" class="headerlink" title="按多个字段排序"></a>按多个字段排序</h4><p>案例1：查询员工的姓名、工资、部门编号，先按工资升序，再按部门编号降序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,salary,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">ASC</span>, department_id <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>​    总体先 按照工资排序，当有工资相同的情况，按照部门编号降序</p>
<img src="/2020/02/09/MySQL/%E5%B7%A5%E8%B5%84%E5%8D%87%E5%BA%8F%E7%BC%96%E5%8F%B7%E9%99%8D%E5%BA%8F.png" class title="This is an example image">

<p>​    中间用逗号隔开，每个排序方式都是相独立指定的。</p>
<h4 id="按列数排序，用的少"><a href="#按列数排序，用的少" class="headerlink" title="按列数排序，用的少"></a>按列数排序，用的少</h4><p>案例1：查询员工信息，按照第二列排序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>​    用的较少，阅读性较差</p>
<h3 id="练习题2"><a href="#练习题2" class="headerlink" title="练习题2"></a>练习题2</h3><p>1、查询员工的姓名和部门号和年薪，按年薪降序 按姓名升序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_id,salary*<span class="number">12</span>*(<span class="number">1</span>+<span class="keyword">IFNULL</span>(commission_pct,<span class="number">0</span>)) 年薪</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 年薪 <span class="keyword">DESC</span>, last_name <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<p>疑问：当order by中别名加了引号后就不能正确排序，如下所示</p>
<img src="/2020/02/09/MySQL/%E5%BC%95%E5%8F%B7%E6%8E%92%E5%BA%8F.png" class title="This is an example image">

<p>​    后经人提醒，应该是<strong>着重号</strong>而不是引号，因此正确的使用别名方式应该如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_id,salary*<span class="number">12</span>*(<span class="number">1</span>+<span class="keyword">IFNULL</span>(commission_pct,<span class="number">0</span>)) <span class="string">`年 薪`</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`年 薪`</span> <span class="keyword">DESC</span>, last_name <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<p>2、选择工资不在8000到17000的员工的姓名和工资，按工资降序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">8000</span> <span class="keyword">AND</span> <span class="number">17000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>3、查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> email <span class="keyword">LIKE</span> <span class="string">'%e%'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">LENGTH</span>(email) <span class="keyword">DESC</span>, department_id <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<h3 id="进阶四：常见函数"><a href="#进阶四：常见函数" class="headerlink" title="进阶四：常见函数"></a>进阶四：常见函数</h3><p>函数：类似于java中的“方法”，为了解决某个问题，将编写的一系列的命令集合封装在一起，对外仅仅暴露方法名，供外部调用。</p>
<p>1、自定义方法（函数）</p>
<p>2、调用方法啊（函数）</p>
<ul>
<li>叫什么：函数名</li>
<li>干什么：函数功能</li>
</ul>
<p>常见函数：</p>
<ul>
<li>字符函数</li>
<li>数学函数</li>
<li>日期函数</li>
<li>流程控制函数</li>
</ul>
<h4 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h4><p>1、CONCAT 拼接函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(<span class="string">'hello,'</span>,first_name,last_name) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>​    可以指定多个参数</p>
<p>2、LENGTH 获取<strong>字节</strong>长度</p>
<p>​    一个汉字识别为3个字节</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LENGTH</span>(<span class="string">'hello,李四'</span>);</span><br></pre></td></tr></table></figure>

<p>​    输出为12。</p>
<p>3、CHAR_LENGTH 获取<strong>字符</strong>长度</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(<span class="string">'hello,李四'</span>);</span><br></pre></td></tr></table></figure>

<p>​    输出为8。</p>
<p>4、SUBSTRING 截取子串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUBSTR</span>(<span class="string">'武汉加油，中国加油'</span>,<span class="number">1</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>substr(str，起始索引，截取的字符长度)  <strong>起始索引从1开始</strong>！！！    </p>
<p>substr(str，起始索引)    默认将后面全部截取</p>
<p>第一个参数为完整字符串，第二个参数为起始位置，其中SQL中从1开始，第三个参数为截取长度。</p>
<p>5、INSTR 获取字符第一次出现的索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">INSTR</span>(<span class="string">'三打白骨精aa白骨精'</span>,<span class="string">'白骨精'</span>);</span><br></pre></td></tr></table></figure>

<p>​    结果为3，因为白骨精第一次出现的索引是3。</p>
<p>6、TRIM 去前后指定的字符，默认是去空格</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRIM</span>(<span class="string">'   虚 竹   '</span>) <span class="keyword">AS</span> <span class="string">`a`</span>;</span><br></pre></td></tr></table></figure>

<p>结果为虚 竹。前后空格被去掉，中间不去掉</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRIM</span>(<span class="string">'x'</span> <span class="keyword">FROM</span> <span class="string">'xxxxx虚xx竹xxxx'</span>) <span class="keyword">AS</span> <span class="string">`a`</span>;</span><br></pre></td></tr></table></figure>

<p>结果为虚xx竹，将指定的字符从字符串中去掉了，中间的不受影响。</p>
<p>7、LPAD/RPAD  左填充/右填充</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LPAD</span>(<span class="string">'武汉加油'</span>,<span class="number">10</span>,<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>

<p>结果为aaaaaa武汉加油，往左边填充指定的字符，至指定长度。</p>
<p>也可以用来<strong>截取字符串</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LPAD</span>(<span class="string">'庆历四年滕子京谪守巴陵郡'</span>,<span class="number">4</span>,<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>

<p>当指定长度比输入字符串长度更短时，会截取字符串为指定长度，因此输出为庆历四年。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> RPAD(<span class="string">'武汉加油'</span>,<span class="number">10</span>,<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>

<p>​    输出结果为武汉加油aaaaaa，在右边填充。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> RPAD(<span class="string">'庆历四年滕子京谪守巴陵郡'</span>,<span class="number">4</span>,<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>

<p>​    结果同样为庆历四年。</p>
<p>8、UPPER/LOWER  变大写/小写</p>
<p>案例：查询员工表中的姓名，要求格式：姓首字符大写，其他字符小写，名所有字符大写，且姓和名之间用_分割，最后起别名“OUTPUT”。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(<span class="keyword">SUBSTR</span>(first_name,<span class="number">1</span>,<span class="number">1</span>),<span class="keyword">LOWER</span>(<span class="keyword">SUBSTR</span>(first_name,<span class="number">2</span>)),<span class="string">'_'</span>,<span class="keyword">UPPER</span>(last_name)) <span class="keyword">AS</span> <span class="string">`OUTPUT`</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>9、STRCMP 比较两个字符大小</p>
<p>STRCMP(str1,str2)</p>
<p>​    如果str1比较大，输出1；如果str2比较大，输出-1；如果两个一样大，返回0。</p>
<p>​    <strong>字符均用单引号括起来</strong>。</p>
<p>​    对应String compareTo()方法，其从首位比较两个字符串，如果第一个不等，则返回二者ASCII码差值，如果相等，再比较第二个，以此类推。如果比较到最后都一样（较短长度的字符串位置），则返回二者长度的差值。</p>
<p>10、LEFT/RIGHT  截取子串</p>
<p>​    从左边截取指定的长度或从右边截取指定的长度</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LEFT</span>(<span class="string">'武汉加油'</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RIGHT</span>(<span class="string">'武汉加油'</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>分别输出武和加油。</p>
<p>11、REPLACE 替换</p>
<p>REPLACE（str, a, b）    用字符串b替换字符串str中所有出现的字符串a</p>
<h4 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h4><p>1、ABS 绝对值</p>
<p>2、CEIL 向上取整，返回<strong>&gt;=</strong>该参数的最小整数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CEIL</span>(<span class="number">1.1</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CEIL</span>(<span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CEIL</span>(<span class="number">-1.09</span>);</span><br></pre></td></tr></table></figure>

<p>​    结果为2和1和-1，因为是大于等于。</p>
<p>3、FLOOR 向下取整，返回&lt;=该参数的最大整数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FLOOR</span>(<span class="number">-1.09</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FLOOR</span>(<span class="number">0.09</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FLOOR</span>(<span class="number">1.00</span>);</span><br></pre></td></tr></table></figure>

<p>​    结果为-2,0和1，因为是小于等于。</p>
<p>4、ROUND 四舍五入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ROUND</span>(<span class="number">1.87</span>);</span><br></pre></td></tr></table></figure>

<p>​    结果为2，小数点后没有保存位数。</p>
<p>​    但是想保留两个小数，可以增加一个参数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ROUND</span>(<span class="number">1.8712345</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>​    结果为1.87。</p>
<p>5、<strong>TRUNCATE</strong> 截断</p>
<p>truncate(num,count)</p>
<p>​    在数字小数点后保留指定位数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRUNCATE</span>(<span class="number">1.8723131</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>​    小数点后保留一位小数，结果为1.8。</p>
<p>6、MOD 取余</p>
<p><strong>被除数的正负决定了结果的正负</strong></p>
<p>​    与%结果一样。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MOD</span>(<span class="number">-10</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MOD</span>(<span class="number">10</span>,<span class="number">-3</span>);</span><br></pre></td></tr></table></figure>

<p>​    结果为-1和1，正负决定于被除数，即前面一个数。</p>
<p> A%B = A - (A/B)*B</p>
<p>​    小技巧：绝对值取余再看正负。</p>
<p>6、RAND 随机数</p>
<p>RAND(x)    返回0~1的随机值</p>
<p>7、SQRT 平方根</p>
<p>SQRT(x)    返回x的平方根</p>
<p>8、POW 次方</p>
<p>POW(x,y)    返回x的y次方</p>
<h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><p>1、NOW  获取当前时间+时间，包括日期、小时</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NOW</span>();</span><br></pre></td></tr></table></figure>

<img src="/2020/02/09/MySQL/NOW%E5%87%BD%E6%95%B0.png" class title="This is an example image">

<p>2、CURDATE  获取当前日期</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CURDATE</span>();</span><br></pre></td></tr></table></figure>

<img src="/2020/02/09/MySQL/%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F.png" class title="This is an example image">

<p>3、CURTIME 获取当前时间，只有小时</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CURTIME</span>();</span><br></pre></td></tr></table></figure>

<img src="/2020/02/09/MySQL/%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4.png" class title="This is an example image">

<p>4、DATEDIFF 获取两个日期之差</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATEDIFF</span>(<span class="string">'2020-2-17'</span>,<span class="string">'2018-6-24'</span>);</span><br></pre></td></tr></table></figure>

<p>​    输出两个日期时间，前面日期减去后面，得到天数。</p>
<p>5、DATE_FORMAT 格式转换</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>(<span class="string">'2020-2-17'</span>,<span class="string">'%Y年%m月%d日 %H小时%i分钟%s秒'</span>) <span class="string">`当前日期`</span>;</span><br></pre></td></tr></table></figure>

<p>年月日小时分秒有规定的格式</p>
<img src="/2020/02/09/MySQL/%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2.png" class title="This is an example image">

<p>​    如可以查看员工的入职日期</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>(hiredate,<span class="string">'%Y年%m月%d日 %H小时%i分钟%s秒'</span>) <span class="string">`入职日期`</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>6、STR_TO_DATE 按指定格式解析字符串为日期</p>
<p>查看入职日期比指定日期小的人</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> hiredate &lt; <span class="keyword">STR_TO_DATE</span>(<span class="string">'3/15 1998'</span>,<span class="string">'%m/%d %Y'</span>);</span><br></pre></td></tr></table></figure>

<p>这样就可以进行比较。</p>
<p>7、返回具体的时间值</p>
<p>YEAR(date)<br>MONTH(date)<br>DAY(date)<br>HOUR(time)<br>MINUTE(time)<br>SECOND(time)    </p>
<h4 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h4><p>version 当前数据库服务器的版本</p>
<p>database 当前打开的数据库</p>
<p>user 当前用户</p>
<p>password(‘字符’) 返回该字符的密码形式</p>
<p>md5(‘字符’) 返回该字符的md5加密形式</p>
<h4 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h4><p>1、IF函数</p>
<p>if(条件表达式，表达式1，表达式2)</p>
<p>如果条件表达式成立，返回表达式1，否则返回表达式2</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">IF</span>(<span class="number">100</span>&gt;<span class="number">9</span>,<span class="string">'good'</span>,<span class="string">'bad'</span>);</span><br></pre></td></tr></table></figure>

<p>​    如果成立，输出第二个，不然输出第三个。类似于三目运算符。</p>
<p>需求：如果有奖金，则显示最终奖金，如果没有，则显示0</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">IF</span>(commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,salary*<span class="number">12</span>*commission_pct,<span class="number">0</span>) <span class="string">`奖金`</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`奖金`</span> <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<p>2、CASE函数</p>
<p>情况1：类似于switch语句，可以实现等值判断</p>
<p>CASE 表达式</p>
<p>WHEN 值1 THEN 结果1</p>
<p>WHEN 值2 THEN 结果2</p>
<p>…</p>
<p>ELSE 结果n</p>
<p>END</p>
<p>案例：部门编号是30，工资显示为2倍；部门编号是50，工资显示为3倍；部门编号是60，工资显示为4倍；否则不变。显示部门编号，新工资，旧工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id,salary,</span><br><span class="line"><span class="keyword">CASE</span> department_id</span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">30</span> <span class="keyword">THEN</span> salary*<span class="number">2</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">50</span> <span class="keyword">THEN</span> salary*<span class="number">3</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">60</span> <span class="keyword">THEN</span> salary*<span class="number">4</span></span><br><span class="line"><span class="keyword">ELSE</span> salary </span><br><span class="line"><span class="keyword">END</span> <span class="string">`new salary`</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>​    case开头到end结尾均为新工资，因此要起别名的话要<strong>写在end后面</strong>。</p>
<p>情况2：类似于多重IF语句，实现区间判断。</p>
<p>CASE</p>
<p>WHEN 条件1 THEN 结果1</p>
<p>WHEN条件2 THEN 结果2</p>
<p>…</p>
<p>ELSE 结果n</p>
<p>END</p>
<p>案例：如果工资&gt;20000，显示级别A；如果工资&gt;15000，显示级别B；如果工资&gt;10000，显示级别C；否则，显示D。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> salary,</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> salary&gt;<span class="number">20000</span> <span class="keyword">THEN</span> <span class="string">'A'</span></span><br><span class="line"><span class="keyword">WHEN</span> salary&gt;<span class="number">15000</span> <span class="keyword">THEN</span> <span class="string">'B'</span></span><br><span class="line"><span class="keyword">WHEN</span> salary&gt;<span class="number">10000</span> <span class="keyword">THEN</span> <span class="string">'C'</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">'D'</span></span><br><span class="line"><span class="keyword">END</span> <span class="string">`grade`</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>​    WHEN后面记得要加THEN。</p>
<h3 id="练习题3"><a href="#练习题3" class="headerlink" title="练习题3"></a>练习题3</h3><p>1、显示系统时间（注：日期+时间）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NOW</span>();</span><br></pre></td></tr></table></figure>

<p>2、查询员工号，姓名，工资，以及工资提高百分之20%后的结果（new salary）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,salary,salary*<span class="number">1.2</span> <span class="string">`new lalary`</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>3、将员工的姓名按首字母排序，并写成姓名的长度（length）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LENGTH</span>(last_name) <span class="string">`长度`</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">SUBSTR</span>(last_name,<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<p>或者使用LEFT函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LENGTH</span>(last_name) <span class="string">`长度`</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">LEFT</span>(last_name,<span class="number">1</span>) <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<p>4、做一个查询，产生下面的效果</p>
<p><last_name> earns &lt; salary&gt; monthly but wants &lt;salary*3&gt; Dream Salary</last_name></p>
<p>King earns 24000 monthly but wants 72000</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(last_name,<span class="string">' earns '</span>,salary,<span class="string">' monthly but wants '</span>,salary*<span class="number">3</span>) <span class="string">`Dream Salary`</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>5、使用case-when，按照下面的条件：</p>
<p>job grade</p>
<p>AD_PRES A</p>
<p>ST_MAN B</p>
<p>IT_PROG C</p>
<p>SA_REP D</p>
<p>ST_CLERK E</p>
<p>产生下面的结果</p>
<p>Last_name Job_id Grade </p>
<p>king AD_PRES A</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,job_id,</span><br><span class="line"><span class="keyword">CASE</span> job_id</span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'AD_PRES'</span> <span class="keyword">THEN</span> <span class="string">'A'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'ST_MAN'</span> <span class="keyword">THEN</span> <span class="string">'B'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'IT_PROG'</span> <span class="keyword">THEN</span> <span class="string">'C'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'SA_REP'</span> <span class="keyword">THEN</span> <span class="string">'D'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'ST_CLERK'</span> <span class="keyword">THEN</span> <span class="string">'E'</span></span><br><span class="line"><span class="keyword">END</span> <span class="string">`Grade`</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>​    <strong>凡是常量值均瑶用引号括起来</strong>！！！</p>
<p>以上为单行函数，一列出来一个值，还有分组函数，多列进去出来一个值。</p>
<h3 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h3><p>​    分组函数往往用于实现将一组数据进行统计计算，最终得到一个值，又称为聚合函数或统计函数</p>
<p>1、分组函数清单</p>
<ul>
<li>sum(字段名) ：求和</li>
<li>avg(字段名) ：求平均数</li>
<li>max(字段名) ：求最大值</li>
<li>min(字段名)：求最小值</li>
<li>count(字段名) ：计算非空字段值的个数</li>
</ul>
<p>2、支持的类型：</p>
<ul>
<li>sum和avg一般用于处理数值型</li>
<li>max，min，count可以处理任何数据类型</li>
</ul>
<p>3、以上分组函数都忽略NULL</p>
<p>4、都可以搭配DISTINCT使用，实现去重的统计</p>
<p>select max(distinct 字段) from 表</p>
<p>5、和分组函数一同查询的字段，要求是group by后出现的字段</p>
<p>案例1：查询员工信息表中，所有员工的工资和、工资平均值、最低工资、最高工资、有工资的个数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(salary),<span class="keyword">AVG</span>(salary),<span class="keyword">MIN</span>(salary),<span class="keyword">MAX</span>(salary),<span class="keyword">COUNT</span>(salary) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>案例2：添加筛选条件</p>
<p>1、查询emp表中记录数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(employee_id) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>​    选择一个不可能为空的，计算其count即可</p>
<p>2、查询emp表中有佣金的人数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(salary) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>3、查询emp表中月薪大于2500的人数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(salary) <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary&gt;<span class="number">2500</span>;</span><br></pre></td></tr></table></figure>

<p>​    天剑查询写在where中。</p>
<p>4、查询有领导的人数</p>
<p>COUNT本身去掉了空值，因此可以不用WHERE判断</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(manager_id) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<h4 id="count的补充介绍"><a href="#count的补充介绍" class="headerlink" title="count的补充介绍"></a>count的补充介绍</h4><p>1、统计结果集的行数，推荐使用count(*)</p>
<p>查询结果中的总行数，用*统计行数较多。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id = <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<p>这样可以不用关心count中到底要写哪个字段，可以用于方便获取行数。</p>
<p>也可以使用常量值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>相当于加了一个常量列，但是效率与可读性没*高。</p>
<p>效率上：</p>
<p>MyISAM存储引擎，count(*)最高</p>
<p>InnoDB存储引擎，count(*)和count(1)效率&gt;count(字段)</p>
<p>2、搭配distinct实现去重的统计</p>
<p>需求：查询有员工的部门个数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> department_id) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<h3 id="进阶五：分组查询"><a href="#进阶五：分组查询" class="headerlink" title="进阶五：分组查询"></a>进阶五：分组查询</h3><h4 id="分组查询引入"><a href="#分组查询引入" class="headerlink" title="分组查询引入"></a>分组查询引入</h4><p>思考题：求每个部门的总工资，平均工资。需要使用分组查询。</p>
<img src="/2020/02/09/MySQL/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2.png" class title="This is an example image">

<p>​    使用CROUP BY 关键字</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(salary) <span class="string">`总工资`</span>,<span class="keyword">AVG</span>(salary) <span class="string">`平均工资`</span>,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br></pre></td></tr></table></figure>

<p>出来结果如下</p>
<img src="/2020/02/09/MySQL/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C.png" class title="This is an example image">

<p>​    查询需要一一对应，否则无意义。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>select 查询列表</p>
<p>from 表名</p>
<p>where 筛选条件</p>
<p>group by 分组列表</p>
<p>having 分组后筛选</p>
<p>order by 排序列表;</p>
<p>执行顺序</p>
<ol>
<li>from子句</li>
<li>where子句</li>
<li>group by子句</li>
<li>having子句</li>
<li>select子句</li>
<li>order by子句</li>
</ol>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li><p>查询列表往往是   分组函数和被分组的字段</p>
</li>
<li><p>分组查询中的筛选分为两类</p>
<table>
<thead>
<tr>
<th></th>
<th>筛选的基表</th>
<th>使用的关键词</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>分组前筛选</td>
<td>原始表(from后的表)</td>
<td>where</td>
<td>group by前面</td>
</tr>
<tr>
<td>分组后筛选</td>
<td>分组后的结果集</td>
<td>having</td>
<td>group by后面</td>
</tr>
</tbody></table>
<p>where—group by—having</p>
<p>分组函数做条件只可能放在having后面</p>
</li>
<li><p>group by后面可以接函数</p>
</li>
</ol>
<h4 id="简单的分组"><a href="#简单的分组" class="headerlink" title="简单的分组"></a>简单的分组</h4><p>案例1：查询每个工种的员工平均工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary),job_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id;</span><br></pre></td></tr></table></figure>

<p>select后将分组函数和被分组字段放在一起。</p>
<p>案例2：查询每个领导的手下人数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*),manager_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> manager_id <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> manager_id;</span><br></pre></td></tr></table></figure>

<p>人数，使用COUNT(*)来查询，用领导id来分组。将领导id为空的去掉。</p>
<h4 id="可以实现分组前的筛选"><a href="#可以实现分组前的筛选" class="headerlink" title="可以实现分组前的筛选"></a>可以实现分组前的筛选</h4><p>案例1：查询邮箱中包含a字符的每个部门的最高工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary) <span class="string">`最高工资`</span>,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> email <span class="keyword">LIKE</span> <span class="string">'%a%'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br></pre></td></tr></table></figure>

<p>案例2：查询每个领导收下有奖金的员工的平均工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary) <span class="string">`平均工资`</span>,manager_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> manager_id;</span><br></pre></td></tr></table></figure>

<p>按照领导分组。</p>
<h4 id="可以实现分组后的筛选"><a href="#可以实现分组后的筛选" class="headerlink" title="可以实现分组后的筛选"></a>可以实现分组后的筛选</h4><p>案例1：查询哪个部门的员工个数&gt;5</p>
<p>分析1：查询每个部门的员工个数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="string">`员工个数`</span>,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br></pre></td></tr></table></figure>

<p>分析2：在刚才的结果基础上，筛选哪个部门的员工个数&gt;5</p>
<p>因此思路是在where后加count(<em>)&gt;5的判断，但会报错，原因在于select执行在where后，count函数此时还无意义。此时where的条件只能看到from后面emp的表，没有包含count()这一列，因此应该放在group by后面，但会报错，因为此时不应该用where，而是使用having连接词，*</em>having才支持后面加分组函数和分组后的筛选**。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="string">`员工个数`</span>,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*)&gt;<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>小结：分组前筛选，还没有group by，此时能够筛选的列只能够从from后面的原始表格列中获取；而分组后筛选，基于的表是分组后的表，因此此时可以按照分组后的结果来筛选。为了区分分组前和分组后，使用关键词不同，分组前为where，分组后为having。</p>
<p>案例2：每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> job_id,<span class="keyword">MAX</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">MAX</span>(salary)&gt;<span class="number">12000</span>;</span><br></pre></td></tr></table></figure>

<p>有奖金的判断在分组前，最高工资的判断在分组后。</p>
<p>案例3：领导编号&gt;102的每个领导手下的最低工资大于5000的领导编号和最低工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> manager_id,<span class="keyword">MIN</span>(salary) <span class="string">`最低工资`</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> manager_id &gt; <span class="number">102</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> manager_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">MIN</span>(salary) &gt; <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<p>将题干分段，先查询每个领导手下的最低工资，筛选刚才的结果。领导编号可以在分组前计算出来，因此可以放在where这。也可以放在having那，虽然结果一样，但这样效率比较低。因此既能放where和having的，优先放在where后面。</p>
<h4 id="可以实现排序"><a href="#可以实现排序" class="headerlink" title="可以实现排序"></a>可以实现排序</h4><p>案例：查询没有奖金的员工的最高工资&gt;6000的工种编号和最高工资，按最高工资升序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> job_id,<span class="keyword">MAX</span>(salary) <span class="string">`最高工资`</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="string">`最高工资`</span> &gt; <span class="number">6000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`最高工资`</span> <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<p>先按照工种分类，查询每个工种没有奖金的员工的最高工资；筛选刚才的 结果，看哪个最高工资&gt;6000；按最高工资升序。</p>
<h4 id="按多个字段分组"><a href="#按多个字段分组" class="headerlink" title="按多个字段分组"></a>按多个字段分组</h4><p>案例：查询每个工种每个部门的最低工资，并按最低工资降序</p>
<p>​    多个分组字段用<strong>逗号隔开</strong>，两个字段没有顺序要求。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(salary) <span class="string">`最低工资`</span>,job_id,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id,department_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`最低工资`</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h3 id="进阶六：连接查询"><a href="#进阶六：连接查询" class="headerlink" title="进阶六：连接查询"></a>进阶六：连接查询</h3><p>含义：又称多表查询，当查询的字段来自多个表时，就会用到连接查询。</p>
<p>如果直接使用以下语法，相当于用第一张表每一行内容去匹配第二张表每行内容，这样均能匹配成功。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,boyName <span class="keyword">from</span> beauty,boys;</span><br></pre></td></tr></table></figure>

<p>这样一个人的“理想男友”会变成多个。即为笛卡尔乘积现象，两个表所有行数相乘。两个表实现完全连接。</p>
<p>笛卡尔成绩现象：表1有m行，表2有n行，结果=m*n行</p>
<p>发生原因：没有有效的连接条件</p>
<p>如何避免：添加有效的连接条件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`name`</span>,boyName <span class="keyword">FROM</span> beauty,boys</span><br><span class="line"><span class="keyword">WHERE</span> beauty.<span class="string">`boyfriend_id`</span> = boys.<span class="string">`id`</span>;</span><br></pre></td></tr></table></figure>

<p>用点号来标识属性的归属。</p>
<p>分类：</p>
<ul>
<li><p>按年代分类</p>
<ul>
<li>sql92标准：MySQL中仅仅支持内连接</li>
<li>sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接</li>
</ul>
</li>
<li><p>按功能分类</p>
<ul>
<li><p>内连接</p>
<ul>
<li>等值连接</li>
<li>非等值连接</li>
<li>自连接</li>
</ul>
</li>
<li><p>外连接</p>
<ul>
<li>左外连接</li>
<li>右外连接</li>
<li>全外连接</li>
</ul>
</li>
<li><p>交叉连接</p>
</li>
</ul>
</li>
</ul>
<h4 id="sql92标准"><a href="#sql92标准" class="headerlink" title="sql92标准"></a>sql92标准</h4><h5 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h5><p>1、等值连接</p>
<p>语法：</p>
<p>select 查询列表</p>
<p>from 表1 别名，表2，别名</p>
<p>where 表1.key=表2.key</p>
<p>【and 筛选条件】</p>
<p>【group by 分组字段】</p>
<p>【having 分组后的筛选】</p>
<p>【order by 排序字段】</p>
<p>特点：</p>
<ul>
<li>多表等值连接额结果为多表的交集部分</li>
<li>n表连接，至少需要n-1个连接条件</li>
<li>多表的顺序没有要求</li>
<li>一般需要为表起别名</li>
<li>可以搭配前面介绍的所有子句使用，如筛选，分组，排序</li>
</ul>
<p>案例1：查询女神名和对应的男神名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`name`</span>,boyName </span><br><span class="line"><span class="keyword">FROM</span> beauty,boys</span><br><span class="line"><span class="keyword">WHERE</span> beauty.<span class="string">`boyfriend_id`</span> = boys.<span class="string">`id`</span>;</span><br></pre></td></tr></table></figure>

<p>将要查询的两个属性写在select中，查询的表写在from中，用逗号隔开，最重要的是写where语句。</p>
<p>用第一个表的每一行去匹配第二个表的每一行。</p>
<p>案例2：查询员工名和对应的部门名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.<span class="string">`department_id`</span> = departments.<span class="string">`department_id`</span>;</span><br></pre></td></tr></table></figure>

<p>2、为表起别名</p>
<ul>
<li>提高语句的简洁度</li>
<li>区分多个重名的字段</li>
</ul>
<p>注意：如果为表起了别名，则查询的字段就不能使用原来的表名去限定。</p>
<p>案例：查询员工名，工种号，工种名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,employees.<span class="string">`job_id`</span>,job_title</span><br><span class="line"><span class="keyword">FROM</span> employees,jobs</span><br><span class="line"><span class="keyword">WHERE</span> employees.<span class="string">`job_id`</span> = jobs.<span class="string">`job_id`</span>;</span><br></pre></td></tr></table></figure>

<p>如果一个字段在多个表中都出现，为了避免歧义，那么需要加上完整的表名，为了方便，给表起别名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name,e.<span class="string">`job_id`</span>,j.job_title</span><br><span class="line"><span class="keyword">FROM</span> employees e,jobs j</span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`job_id`</span> = j.<span class="string">`job_id`</span>;</span><br></pre></td></tr></table></figure>

<p><strong>起了别名后，就不能再使用原来的名称了</strong>，因为from先执行，这样表就有了别名。</p>
<p>3、两个表的顺序是否可以调换</p>
<p>可以替换</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name,e.<span class="string">`job_id`</span>,j.job_title</span><br><span class="line"><span class="keyword">FROM</span> jobs j,employees e</span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`job_id`</span> = j.<span class="string">`job_id`</span>;</span><br></pre></td></tr></table></figure>

<p>表的交集</p>
<p>4、加筛选</p>
<p>案例1：查询有奖金的员工名、部门名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e,departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">AND</span> e.<span class="string">`commission_pct`</span> <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>在WHERE后利用AND添加筛选</p>
<p>案例2：查询城市名中第二个字符为o的部门名和城市名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_name,city</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`departments`</span> d,<span class="string">`locations`</span> l</span><br><span class="line"><span class="keyword">WHERE</span> d.<span class="string">`location_id`</span>=l.<span class="string">`location_id`</span></span><br><span class="line"><span class="keyword">AND</span> city <span class="keyword">LIKE</span> <span class="string">'_o%'</span>;</span><br></pre></td></tr></table></figure>

<p>关键：找到两个的连接关系。一般都给表起别名，更方便。</p>
<p>5、加分组</p>
<p>案例1：查询每个城市的部门个数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="string">`部门个数`</span>,city</span><br><span class="line"><span class="keyword">FROM</span> departments d,locations l</span><br><span class="line"><span class="keyword">WHERE</span> d.<span class="string">`location_id`</span>=l.<span class="string">`location_id`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> city;</span><br></pre></td></tr></table></figure>

<p>部门个数，为count(*)，部门个数跟城市在两个表中，利用location_id进行连接，然后每个城市，用城市来进行分组。</p>
<p>案例2：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_name,d.manager_id,<span class="keyword">MIN</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`departments`</span> d,<span class="string">`employees`</span> e</span><br><span class="line"><span class="keyword">WHERE</span> d.<span class="string">`department_id`</span> = e.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">AND</span> e.<span class="string">`commission_pct`</span> <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_name,manager_id;</span><br></pre></td></tr></table></figure>

<p>先把要查询的写在select，然后来自的表，先加表格的连接条件，然后增加筛选，最后加上按照部门名和领导编号进行分组。</p>
<p>因为要查询的有两个列，不能确定这两个列是否一一对应，因此分组的时候最好将这两个组都添加上。</p>
<p>6、加排序</p>
<p>案例：查询每个工种的工种名和员工的个数，并且按员工个数降序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> job_title,<span class="keyword">COUNT</span>(*) <span class="string">`员工个数`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`jobs`</span> j,<span class="string">`employees`</span> e</span><br><span class="line"><span class="keyword">WHERE</span> j.<span class="string">`job_id`</span>=e.<span class="string">`job_id`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_title</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`员工个数`</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>7、三表连接</p>
<p>案例：查询员工名、部门名和所在的城市</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_name,city</span><br><span class="line"><span class="keyword">FROM</span> employees e,departments d,locations l</span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">AND</span> d.<span class="string">`location_id`</span>=l.<span class="string">`location_id`</span>;</span><br></pre></td></tr></table></figure>

<h5 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h5><p>语法：</p>
<p>select 查询列表</p>
<p>from 表1 别名，表2，别名</p>
<p>where 非等值条件</p>
<p>【and 筛选条件】</p>
<p>【group by 分组字段】</p>
<p>【having 分组后的筛选】</p>
<p>【order by 排序字段】</p>
<p>案例1：查询员工的工资和工资级别</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> salary,grade_level</span><br><span class="line"><span class="keyword">FROM</span> employees e,job_grades j</span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`salary`</span> <span class="keyword">BETWEEN</span> j.<span class="string">`lowest_sal`</span> <span class="keyword">AND</span> j.<span class="string">`highest_sal`</span>;</span><br></pre></td></tr></table></figure>

<p>salary在最低和最高之间的范围即可。也可以在后面加AND用于筛选或者增加排序。</p>
<h5 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h5><p>案例：查询员工名和上级的名称</p>
<p>​    如员工有对应的领导编号，然后用领导编号再找为此编号的员工姓名。相当于<strong>一个表和自己相连接</strong>。</p>
<img src="/2020/02/09/MySQL/%E8%87%AA%E8%BF%9E%E6%8E%A5.png" class title="This is an example image">

<p>将一张表当成2张或更多来使用。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.employee_id,e.last_name,m.employee_id,m.last_name</span><br><span class="line"><span class="keyword">FROM</span> employees e,employees m</span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`manager_id`</span>=m.<span class="string">`employee_id`</span>;</span><br></pre></td></tr></table></figure>

<p>这时候就体现出了起别名的好处，增加了代码可读性。</p>
<h3 id="练习题4"><a href="#练习题4" class="headerlink" title="练习题4"></a>练习题4</h3><p>1、显示员工表的最大工资，工资平均值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(salary),<span class="keyword">avg</span>(salary) <span class="keyword">from</span> employees;</span><br></pre></td></tr></table></figure>

<p>2、查询员工表的employee_id，job_id，last_name，按department_id降序，salary升序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> employee_id，job_id，last_name</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> department_id <span class="keyword">desc</span>,salary <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure>

<p>3、查询员工表的job_id中包含a和e的，并且a在e的前面</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> job_id</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> job_id <span class="keyword">like</span> <span class="string">'%a%e%'</span>;</span><br></pre></td></tr></table></figure>

<p>4、已知表student，里面有id(学号)，name,grade_id(年级编号)；已知表grade，里面有id(年级编号),name(年级名)；已知表result，里面有id，score，studentNo(学号)。要求查询姓名、年级名、成绩。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.name,g.name,r.score</span><br><span class="line"><span class="keyword">from</span> student s,grade g,<span class="keyword">result</span> r</span><br><span class="line"><span class="keyword">where</span> s.grade_id=g.id</span><br><span class="line"><span class="keyword">and</span> s.id=r.studentNo;</span><br></pre></td></tr></table></figure>

<p>5、显示当前日期，以及去前后空格，截取子字符串的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select now();</span><br><span class="line">select trim(字符 from &#39;&#39;);</span><br><span class="line">select substr(str,startIndex);</span><br><span class="line">select substr(str,startIndex,length);</span><br></pre></td></tr></table></figure>

<p>6、显示所有员工的姓名，部门号和部门名称</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,d.department_id,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e,departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span>;</span><br></pre></td></tr></table></figure>

<p>7、查询90号部门员工的job_id和90号部门的location_id</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.job_id,d.location_id</span><br><span class="line"><span class="keyword">FROM</span> employees e,departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">AND</span> e.<span class="string">`department_id`</span>=<span class="number">90</span>;</span><br></pre></td></tr></table></figure>

<p>限定条件为员工的部门编号为90</p>
<p>8、选择所有有奖金的员工的last_name,department_name,location_id,city</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name,d.department_name,d.location_id,l.city</span><br><span class="line"><span class="keyword">FROM</span> employees e,departments d,locations l</span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">AND</span> d.<span class="string">`location_id`</span>=l.<span class="string">`location_id`</span></span><br><span class="line"><span class="keyword">AND</span> e.<span class="string">`commission_pct`</span> <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>9、选择city在Toronto工作的员工的last_name，job_id，department_id，department_name</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name,e.job_id,e.department_id,d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e,departments d,locations l</span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">AND</span> d.<span class="string">`location_id`</span>=l.<span class="string">`location_id`</span></span><br><span class="line"><span class="keyword">AND</span> l.<span class="string">`city`</span>=<span class="string">'Toronto'</span>;</span><br></pre></td></tr></table></figure>

<p>10、查询每个工种、每个部门的部门名、工种名和最低工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> d.department_name,j.job_title,<span class="keyword">MIN</span>(salary) <span class="string">`最低工资`</span></span><br><span class="line"><span class="keyword">FROM</span> departments d,jobs j,employees e</span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">AND</span> e.<span class="string">`job_id`</span>=j.<span class="string">`job_id`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> j.job_title,d.department_name;</span><br></pre></td></tr></table></figure>

<p>11、查询每个国家下的部门个数大于2的国家编号</p>
<p>将位置表和部门表连接，这时候部门编号没有重复，每个部门编号都有对应的国家名，然后利用国家分组，就可以算出其部门个数。</p>
<img src="/2020/02/09/MySQL/%E5%9B%BD%E5%AE%B6%E5%AF%B9%E9%83%A8%E9%97%A8%E8%A1%A8.png" class title="This is an example image">

<p>最后加上分组后的筛选条件，放在having语句后</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> country_id,<span class="keyword">COUNT</span>(*) <span class="string">`部门个数`</span></span><br><span class="line"><span class="keyword">FROM</span> locations l,departments d</span><br><span class="line"><span class="keyword">WHERE</span> d.<span class="string">`location_id`</span>=l.<span class="string">`location_id`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> country_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*)&gt;<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>having后也可以支持别名，但不太建议。</p>
<p>12、选择指定员工的姓名，员工号，以及他的管理者的姓名和员工号</p>
<p>格式类似于</p>
<p>employees     Emp#        manager            Mgr#</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name employees,e.employee_id <span class="string">`Emp#`</span>,m.last_name manager,m.employee_id <span class="string">`Mgr#`</span></span><br><span class="line"><span class="keyword">FROM</span> employees e,employees m</span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`manager_id`</span>=m.<span class="string">`employee_id`</span>;</span><br></pre></td></tr></table></figure>

<h4 id="sql99标准"><a href="#sql99标准" class="headerlink" title="sql99标准"></a>sql99标准</h4><p>语法：</p>
<p>select 查询列表</p>
<p>from 表1 别名【连接类型】</p>
<p>join 表2 别名</p>
<p>on连接条件</p>
<p>【where 筛选条件】</p>
<p>【group by 分组】</p>
<p>【having 筛选条件】</p>
<p>【order by 排序列表】</p>
<p>对比sql92，将连接条件和筛选条件进行了分类，提高可读性</p>
<p>分类：</p>
<ul>
<li><p><strong>内连接</strong>（重点）：inner</p>
</li>
<li><p>外连接</p>
<ul>
<li><strong>左外</strong>（重点）：left 【outer】</li>
<li><strong>右外</strong>（重点）：right【outer】</li>
<li>全外：full【outer】</li>
</ul>
</li>
<li><p>交叉连接：cross</p>
</li>
</ul>
<h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p>select 查询列表</p>
<p>from 表1 别名</p>
<p>inner join 表2 别名</p>
<p>on 连接条件</p>
<p>【join 表3 别名 on 连接条件】</p>
<p>可以<strong>多个join相连接</strong>。</p>
<p>特点：</p>
<ul>
<li>添加排序、分组、筛选</li>
<li>inner可以省略</li>
<li>筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读</li>
<li>inner join连接和sql92语法中的等值连接效果是一样，都是查询多表的交集</li>
</ul>
<p>1、等值连接</p>
<p>案例1：查询员工名、部门名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span>;</span><br></pre></td></tr></table></figure>

<p>将两个表的位置调换顺序也可以</p>
<p>案例2：查询名字中包含e的员工名和工种名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,job_title</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> jobs j</span><br><span class="line"><span class="keyword">ON</span> e.<span class="string">`job_id`</span>=j.<span class="string">`job_id`</span></span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">'%e%'</span>;</span><br></pre></td></tr></table></figure>

<p>案例3：查询部门个数&gt;3的城市名和部门个数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> city,<span class="keyword">COUNT</span>(*) 部门个数</span><br><span class="line"><span class="keyword">FROM</span> locations l</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> l.<span class="string">`location_id`</span>=d.<span class="string">`location_id`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> city</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*)&gt;<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>可以分步来做，先按照城市来分组，然后按照部门个数来筛选</p>
<p>案例4：查询哪个部门的部门员工个数&gt;3的部门名和员工个数，并按个数降序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_name,<span class="keyword">COUNT</span>(*) 员工个数</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_name</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*)&gt;<span class="number">3</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">COUNT</span>(*) <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>案例5：查询员工名、部门名、工种名，并按部门名排序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_name,job_title</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> jobs j <span class="keyword">ON</span> e.<span class="string">`job_id`</span>=j.<span class="string">`job_id`</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department_name;</span><br></pre></td></tr></table></figure>

<p>三表连接，先写一个inner join 表1 别名 on 连接条件，然后再写一个inner join 表2 别名 on 连接条件。保证第三个表和前两个表中的<strong>至少一个有连接条件</strong>。</p>
<p>2、非等值连接</p>
<p>案例1：查询员工的工资级别</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> salary,grade_level</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> job_grades g</span><br><span class="line"><span class="keyword">ON</span> e.<span class="string">`salary`</span> <span class="keyword">BETWEEN</span> g.<span class="string">`lowest_sal`</span> <span class="keyword">AND</span> g.<span class="string">`highest_sal`</span>;</span><br></pre></td></tr></table></figure>

<img src="/2020/02/09/MySQL/jobgrades.png" class title="This is an example image">

<p>案例2：查询工资级别的个数&gt;2的个数，并且按工资级别降序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> grade_level,<span class="keyword">COUNT</span>(*) 工资级别个数</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> job_grades g</span><br><span class="line"><span class="keyword">ON</span> e.<span class="string">`salary`</span> <span class="keyword">BETWEEN</span> g.<span class="string">`lowest_sal`</span> <span class="keyword">AND</span> g.<span class="string">`highest_sal`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> grade_level</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*)&gt;<span class="number">2</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> grade_level <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>3、自连接</p>
<p>案例：查询姓名中包含字符k员工的名字，上级的名字</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name,m.last_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> employees m</span><br><span class="line"><span class="keyword">ON</span> e.<span class="string">`manager_id`</span>=m.<span class="string">`employee_id`</span></span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`last_name`</span> <span class="keyword">LIKE</span> <span class="string">'%k%'</span>;</span><br></pre></td></tr></table></figure>

<h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p>应用场景：用于查询一个表中有，另一个表没有的记录</p>
<p>特点：</p>
<ol>
<li><p>外连接的查询结果为主表中的所有记录</p>
<ul>
<li>如果从表中有和它匹配的，则显示匹配的值</li>
<li>如果从表中没有和它匹配的，则显示null</li>
<li>外连接查询结果=内连接结果+主表中有而从表没有的记录</li>
</ul>
</li>
<li><p>左外连接，left join左边的是左表</p>
<p>右外连接，right join右边的是主表</p>
</li>
<li><p>左外和右外交换两个表的顺序，可以实现同样的效果</p>
</li>
<li><p>全外连接=内连接的结果+表1中有但表2没有的+表2中有但表1没有的</p>
</li>
</ol>
<p>引入：查询男朋友不在男神表的女神名</p>
<p>之前的内连接查两个表的交集部分，因此无法直接用来实现这里的需求。</p>
<p>做外连接实现</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b.name,bo.*</span><br><span class="line"><span class="keyword">FROM</span> beauty b</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> boys bo</span><br><span class="line"><span class="keyword">ON</span> b.<span class="string">`boyfriend_id`</span>=bo.<span class="string">`id`</span>;</span><br></pre></td></tr></table></figure>

<img src="/2020/02/09/MySQL/%E5%B7%A6%E6%9F%A5%E8%AF%A21.png" class title="This is an example image">

<p>如果只想看没有男朋友不在表中的女神信息，可以加入筛选</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b.name,bo.*</span><br><span class="line"><span class="keyword">FROM</span> beauty b</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> boys bo</span><br><span class="line"><span class="keyword">ON</span> b.<span class="string">`boyfriend_id`</span>=bo.<span class="string">`id`</span></span><br><span class="line"><span class="keyword">WHERE</span> bo.<span class="string">`id`</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>选择id来判断是因为boys中的id为主键，不能为null。判断时最好选从表中的主键列。</p>
<p>右外连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b.name,bo.*</span><br><span class="line"><span class="keyword">FROM</span> boys bo</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> beauty b</span><br><span class="line"><span class="keyword">ON</span> b.<span class="string">`boyfriend_id`</span>=bo.<span class="string">`id`</span></span><br><span class="line"><span class="keyword">WHERE</span> bo.<span class="string">`id`</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>案例1：查询哪个部门没有员工</p>
<p>左外</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> d.*,e.employee_id</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> employees e</span><br><span class="line"><span class="keyword">ON</span> d.<span class="string">`department_id`</span>=e.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`employee_id`</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>查询的没有员工的部门，因此主表是部门，然后与员工表左连接，筛选条件为没有员工即员工的id为NULL。</p>
<p>右外</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> d.*,e.employee_id</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d </span><br><span class="line"><span class="keyword">ON</span> d.<span class="string">`department_id`</span>=e.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`employee_id`</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h5 id="全外"><a href="#全外" class="headerlink" title="全外"></a>全外</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> b.*,bo.*</span><br><span class="line"><span class="keyword">from</span> beauty b</span><br><span class="line"><span class="keyword">full</span> <span class="keyword">join</span> boys bo</span><br><span class="line"><span class="keyword">on</span> b.boyfriend_id=bo.id</span><br></pre></td></tr></table></figure>

<p>MySQL不支持</p>
<h5 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b.*,bo.*</span><br><span class="line"><span class="keyword">FROM</span> beauty b</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> boys bo;</span><br></pre></td></tr></table></figure>

<p>结果就为笛卡尔乘积</p>
<h4 id="sql92与sql99"><a href="#sql92与sql99" class="headerlink" title="sql92与sql99"></a>sql92与sql99</h4><p>功能：sql99支持的更多</p>
<p>可读性：sql99实现连接条件和筛选条件的分离，可读性较高</p>
<p>下为内连接，左外，右外的比较</p>
<img src="/2020/02/09/MySQL/%E4%B8%89%E7%A7%8D%E8%BF%9E%E6%8E%A5.png" class title="This is an example image">

<p>下为左外，右外加筛选和全外的比较</p>
<img src="/2020/02/09/MySQL/%E5%B7%A6%E5%A4%96%E5%8F%B3%E5%A4%96%E5%85%A8%E5%A4%96.png" class title="This is an example image">

<h3 id="多表连接练习"><a href="#多表连接练习" class="headerlink" title="多表连接练习"></a>多表连接练习</h3><p>1、查询编号&gt;3的女神的男朋友信息，如果有则列出详细，如果没有，用null填充</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b.name,b.<span class="string">`id`</span>,bo.*</span><br><span class="line"><span class="keyword">FROM</span> beauty b</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> boys bo</span><br><span class="line"><span class="keyword">ON</span> b.<span class="string">`boyfriend_id`</span>=bo.<span class="string">`id`</span></span><br><span class="line"><span class="keyword">WHERE</span> b.<span class="string">`id`</span>&gt;<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>2、查询哪个城市没有部门</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> city</span><br><span class="line"><span class="keyword">FROM</span> locations l</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> l.<span class="string">`location_id`</span>=d.<span class="string">`location_id`</span></span><br><span class="line"><span class="keyword">WHERE</span> d.<span class="string">`department_id`</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>用从表的主键去判断</p>
<p>3、查询部门名为SAL或IT的员工信息</p>
<p>这两个部门可能没有员工，会外连接会比较全。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_name,e.*</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> employees e</span><br><span class="line"><span class="keyword">ON</span> d.<span class="string">`department_id`</span>=e.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">WHERE</span> d.<span class="string">`department_name`</span> <span class="keyword">IN</span>(<span class="string">'SAL'</span>,<span class="string">'IT'</span>);</span><br></pre></td></tr></table></figure>

<p>如果用departments来当主表，信息会比较全，会将空的员工信息也显示上去。用d来当主表对比用e来当主表，会多出NULL的员工信息，因为有的部门中没有员工。想要哪个表信息更全，就用哪个表来当主键。差的是部门的员工信息，因此主要是看部门。如果用员工表当主表，会去掉空的员工信息。</p>
<h3 id="进阶七：子查询"><a href="#进阶七：子查询" class="headerlink" title="进阶七：子查询"></a>进阶七：子查询</h3><h4 id="含义："><a href="#含义：" class="headerlink" title="含义："></a>含义：</h4><p>出现在其他语句中的select语句，称为子查询或内查询</p>
<p>外部的查询语句，称为主查询或外查询</p>
<p>外面的语句可以是insert、update、delete、<strong>select</strong>等，一般select作为外面语句较多</p>
<h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><p>按子查询出现的位置：</p>
<ul>
<li>select后面<ul>
<li>仅仅支持标量子查询</li>
</ul>
</li>
<li>from后面<ul>
<li>支持表子查询</li>
</ul>
</li>
<li><strong>where或having后面</strong>（重点）<ul>
<li><strong>标量子查询</strong>（单行）（重点）</li>
<li><strong>列子查询</strong>（多行）（重点）</li>
<li>行子查询（较少）</li>
</ul>
</li>
<li>exists后面（相关子查询）<ul>
<li>表子查询    </li>
</ul>
</li>
</ul>
<p>按结果集的行列数不同：</p>
<ul>
<li>标量子查询（结果集只有一行一列）</li>
<li>列子查询（结果集有只一列多行）</li>
<li>行子查询（结果集有一行多列）</li>
<li>表子查询（结果集一般为多行多列）</li>
</ul>
<h4 id="where或having后面"><a href="#where或having后面" class="headerlink" title="where或having后面"></a>where或having后面</h4><p>1、标量子查询（单行子查询）</p>
<p>2、列子查询（多行子查询）</p>
<p>3、行子查询（多列多行）</p>
<p>特点：</p>
<ul>
<li><p>子查询放在小括号内</p>
</li>
<li><p>子查询一般放在条件的右侧</p>
</li>
<li><p>标量子查询，一般搭配着单行操作符使用</p>
<p>&lt;  &gt;  &lt;=  &gt;=  =  &lt;&gt;</p>
</li>
<li><p>列子查询，一般搭配多行操作符使用</p>
<p>IN,ANY/SOME,ALL</p>
</li>
<li><p>子查询的的执行优先于主查询执行，主查询的条件用到了子查询的结果</p>
</li>
</ul>
<p>1、标量子查询</p>
<p>案例1：谁的工资比Abel高</p>
<p>步骤1：查询Abel的工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name=<span class="string">'Abel'</span>;</span><br></pre></td></tr></table></figure>

<p>出来的结果为一行一列，因此为标量子查询</p>
<p>步骤2：查询员工的信息，满足salary大于步骤1结果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary&gt;(</span><br><span class="line">	<span class="keyword">SELECT</span> salary</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> last_name=<span class="string">'Abel'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>案例2：返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id和工资</p>
<p>步骤1：查询141号员工的job_id</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> job_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id=<span class="number">141</span>;</span><br></pre></td></tr></table></figure>

<p>步骤2：查询143号员工的salary</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> salary</span><br><span class="line"><span class="keyword">FROM</span>  employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id=<span class="number">143</span>;</span><br></pre></td></tr></table></figure>

<p>步骤3：查询员工的姓名，job_id和工资，要求job_id=步骤1，并且salary&gt;步骤2</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,job_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> job_id=(</span><br><span class="line">	<span class="keyword">SELECT</span> job_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> employee_id=<span class="number">141</span></span><br><span class="line">) <span class="keyword">AND</span> salary&gt;(</span><br><span class="line">	<span class="keyword">SELECT</span> salary</span><br><span class="line">	<span class="keyword">FROM</span>  employees</span><br><span class="line">	<span class="keyword">WHERE</span> employee_id=<span class="number">143</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>案例3：返回公司工资最少的员工的last_name,job_id和salary</p>
<p>步骤1：查询公司的最低工资</p>
<p>步骤2：查询last_name,job_id和salary，要求salary=步骤1</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,job_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary=(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>案例4：查询最低工资大于50号部门最低工资的部门id和其最低工资</p>
<p>步骤1：查询50号部门最低工资</p>
<p>步骤2：查询每个部门的最低工资</p>
<p>步骤3：在步骤2基础上筛选，满足min(salary)&gt;步骤1结果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(salary),department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">MIN</span>(salary)</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> department_id=<span class="number">50</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>非法使用标量子查询</p>
<p>子查询结果不为一行一列，可能为空或者多行，都不可以。</p>
<p>2、列子查询（多行子查询）</p>
<ul>
<li>使用多行</li>
<li>使用多行比较操作符</li>
</ul>
<table>
<thead>
<tr>
<th><strong>操作符</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>IN/NOT IN</strong></td>
<td>等于列表中的<strong>任意一个</strong></td>
</tr>
<tr>
<td>ANY|SOME</td>
<td>和子查询返回的<strong>某一个</strong>值比较</td>
</tr>
<tr>
<td>ALL</td>
<td>和子查询返回的<strong>所有</strong>值比较</td>
</tr>
</tbody></table>
<p>a &gt; any(10,15,20)，意思为a比其中某一个大即可，此时可以替换成min</p>
<p>a&gt;all(10,15,20)，要大于所有，此时可以替换成max</p>
<p>案例1：返回location_id是1400或1700的部门中的所有员工姓名</p>
<p>步骤1：查询location_id是1400或1700的部门标号</p>
<p>最好去重</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id</span><br><span class="line"><span class="keyword">FROM</span> departments</span><br><span class="line"><span class="keyword">WHERE</span> location_id <span class="keyword">IN</span>(<span class="number">1400</span>,<span class="number">1700</span>)</span><br></pre></td></tr></table></figure>

<p>步骤2：查询员工姓名，要求部门号是步骤1结果中的某一个</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id</span><br><span class="line">    <span class="keyword">FROM</span> departments</span><br><span class="line">    <span class="keyword">WHERE</span> location_id <span class="keyword">IN</span>(<span class="number">1400</span>,<span class="number">1700</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>也可以将IN替换为= ANY，因为IN意思为在其中某个就可以，与= ANY意思相同。如果是NOT IN，表示全不在这个范围内，那么可以替换为NOT ALL，所有的都不在。</p>
<p>案例2：返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary</p>
<p>步骤1：查询job_id为‘IT_PROG’部门任一工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> job_id=<span class="string">'IT_PROG'</span></span><br></pre></td></tr></table></figure>

<p>步骤2：查询员工号、姓名、job_id 以及salary，salary&lt;any（步骤1结果），job_id不为IT</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,job_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary&lt;<span class="keyword">ANY</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> salary</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> job_id=<span class="string">'IT_PROG'</span></span><br><span class="line">) <span class="keyword">AND</span> job_id &lt;&gt; <span class="string">'IT_PROG'</span>;</span><br></pre></td></tr></table></figure>

<p>或者小于其中任意工资，就是小于其最大工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,job_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary&lt;(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> job_id=<span class="string">'IT_PROG'</span></span><br><span class="line">) <span class="keyword">AND</span> job_id &lt;&gt; <span class="string">'IT_PROG'</span>;</span><br></pre></td></tr></table></figure>

<p>案例3：返回其它工种中比job_id为‘IT_PROG’工种所有工资都低的员工的员工号、姓名、job_id 以及salary</p>
<p>相比于案例2，相当于把any替换为all</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,job_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary&lt;<span class="keyword">ALL</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> salary</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> job_id=<span class="string">'IT_PROG'</span></span><br><span class="line">) <span class="keyword">AND</span> job_id &lt;&gt; <span class="string">'IT_PROG'</span>;</span><br></pre></td></tr></table></figure>

<p>或者小于所有，就是小于最小工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,job_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary&lt;(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">Min</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> job_id=<span class="string">'IT_PROG'</span></span><br><span class="line">) <span class="keyword">AND</span> job_id &lt;&gt; <span class="string">'IT_PROG'</span>;</span><br></pre></td></tr></table></figure>

<p>3、行子查询（结果集一行多列或多行多列）</p>
<p>案例：查询员工编号最小并且工资最高的员工信息</p>
<p>之前的写法</p>
<p>步骤1：查询最小的员工编号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(employee_id) </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br></pre></td></tr></table></figure>

<p>步骤2：查询最高工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary) </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br></pre></td></tr></table></figure>

<p>步骤3：查询员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id=(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(employee_id) </span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">) <span class="keyword">AND</span> salary=(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary) </span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>利用行子查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> (employee_id,salary)=(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(employee_id),<span class="keyword">MAX</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>比较有局限性，要求查询的多个结果能用相同的运算符计算得出。</p>
<h4 id="select后面"><a href="#select后面" class="headerlink" title="select后面"></a>select后面</h4><p>案例1：查询每个部门的员工个数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> d.*,(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</span><br><span class="line">	<span class="keyword">FROM</span> employees e</span><br><span class="line">	<span class="keyword">WHERE</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span></span><br><span class="line">) <span class="string">`个数`</span></span><br><span class="line"><span class="keyword">FROM</span> departments d;</span><br></pre></td></tr></table></figure>

<p>查询员工个数，然后显示在select后，因为要查询的员工数有要求和部门数id相同，需要加上筛选</p>
<p>如果用<strong>左外连接</strong>来做，如果直接查询count(*）这样查询到的员工数最少为1，错误将员工数为0的部门员工数查询为1，因为忽略了NULL值，应该使用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> d.*,<span class="keyword">COUNT</span>(employee_id)</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> employees e</span><br><span class="line"><span class="keyword">ON</span> d.<span class="string">`department_id`</span>=e.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> d.<span class="string">`department_id`</span></span><br></pre></td></tr></table></figure>

<p>案例2：查询员工号=102的部门名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> department_name</span><br><span class="line">	<span class="keyword">FROM</span> departments d</span><br><span class="line">	<span class="keyword">JOIN</span> employees e</span><br><span class="line">	<span class="keyword">ON</span> d.<span class="string">`department_id`</span>=e.<span class="string">`department_id`</span></span><br><span class="line">	<span class="keyword">WHERE</span> e.<span class="string">`employee_id`</span>=<span class="number">102</span></span><br><span class="line">) <span class="string">`部门名`</span>;</span><br></pre></td></tr></table></figure>

<p>没必要多加一层select。可以被其他方式代替</p>
<h4 id="from后面"><a href="#from后面" class="headerlink" title="from后面"></a>from后面</h4><p>将子查询结果充当一张表，要求必须起别名</p>
<p>案例：查询每个部门的平均工资的工资等级</p>
<p>步骤1：查询每个部门的平均工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary),department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br></pre></td></tr></table></figure>

<p>这样就得到了平均工资的表</p>
<p>步骤2：连接步骤1的结果集和job_grades表，筛选平均工资在最低和最高之间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ag_dep.*,g.<span class="string">`grade_level`</span></span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary) ag,department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">) ag_dep</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> job_grades g</span><br><span class="line"><span class="keyword">ON</span> ag_dep.ag <span class="keyword">BETWEEN</span> g.<span class="string">`lowest_sal`</span> <span class="keyword">AND</span> g.<span class="string">`highest_sal`</span>;</span><br></pre></td></tr></table></figure>

<p>注意，步骤1得到的表需要起别名，要用到的平均工资也起别名，将1得到的表和登记表内连接，然后输出1的所有信息和等级表的等级。</p>
<h4 id="exists后面（相关子查询）"><a href="#exists后面（相关子查询）" class="headerlink" title="exists后面（相关子查询）"></a>exists后面（相关子查询）</h4><p>语法：</p>
<p>exists（完整的查询语句）</p>
<p>结果：1或0</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> employee_id <span class="keyword">FROM</span> employees);</span><br></pre></td></tr></table></figure>

<p>输出为1，表示子查询有值。输出0，表示子查询没有值</p>
<p>案例 1：查询有员工的部门名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_name</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> *</span><br><span class="line">	<span class="keyword">FROM</span> employees e</span><br><span class="line">	<span class="keyword">WHERE</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>或者使用WHERE后加IN</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_name</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">WHERE</span> d.<span class="string">`department_id`</span> <span class="keyword">IN</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>案例2：查询没有女朋友的男神信息</p>
<p>in的方式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> bo.*</span><br><span class="line"><span class="keyword">from</span> boys bo</span><br><span class="line"><span class="keyword">where</span> bo.id <span class="keyword">not</span> <span class="keyword">in</span>(</span><br><span class="line">	<span class="keyword">select</span> boyfiend_id</span><br><span class="line">	<span class="keyword">from</span> beauty</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>exists方式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> bo.*</span><br><span class="line"><span class="keyword">from</span> boys bo</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(</span><br><span class="line">	<span class="keyword">select</span> boyfriend_id</span><br><span class="line">	<span class="keyword">from</span> beauty b</span><br><span class="line">	<span class="keyword">where</span> bo.id=b.boyfriend_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="练习题5"><a href="#练习题5" class="headerlink" title="练习题5"></a>练习题5</h3><p>1、查询和Zlotkey相同部门的员工姓名和工资</p>
<p>步骤1：查询Zlotkey的部门</p>
<p>步骤2：查询部门号=步骤1的姓名和工资 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id=(</span><br><span class="line">	<span class="keyword">SELECT</span> department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> last_name=<span class="string">'Zlotkey'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>2、查询工资比公司平均工资高的员工的员工号，姓名和工资</p>
<p>步骤1：查询平均工资</p>
<p>步骤2：查询工资大于步骤1的员工号，姓名和工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> employee_id,last_name,salary</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> salary&gt;(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>3、查询各部门中工资比本部门平均工资高的员工的员工号，姓名和工资</p>
<p>步骤1：查询各部门的平均工资</p>
<p>步骤2：连接步骤1结果集和employee表，进行筛选</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,e.salary,<span class="string">`avg`</span></span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> department_id dep,<span class="keyword">AVG</span>(salary) <span class="string">`avg`</span></span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">) avg_dep</span><br><span class="line"><span class="keyword">ON</span> e.department_id=dep</span><br><span class="line"><span class="keyword">WHERE</span> e.salary &gt; <span class="string">`avg`</span>;</span><br></pre></td></tr></table></figure>

<p>技巧：先要自己知道大概是什么样的结果，再写了去验证</p>
<p>4、查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名</p>
<p>步骤1：查询姓名中包含u的员工部门（去重）</p>
<p>步骤2：查询部门号=步骤1中任意一个的员工号和姓名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id,last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">'%u%'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>5、查询在部门的location_id为1700的部门工作的员工的员工号</p>
<p>步骤1：查询location_id为1700的部门</p>
<p>步骤2：查询部门号=步骤1中任意一个的员工号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id</span><br><span class="line">	<span class="keyword">FROM</span> departments</span><br><span class="line">	<span class="keyword">WHERE</span> location_id=<span class="number">1700</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>6、查询管理者是King的员工姓名和工资</p>
<p>步骤1：查询姓名为King的员工编号</p>
<p>步骤2：查询哪个员工 的manager_id=步骤1</p>
<p>当不知道用in还是=的时候，用in即可。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> manager_id <span class="keyword">IN</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> employee_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> last_name=<span class="string">'K_ing'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>7、查询工资最高的员工的姓名，要求first_name和last_name显示为一列，列名为姓.名</p>
<p>步骤1：查询最高工资</p>
<p>步骤2：查询工资=步骤1的结果的姓，名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(first_name,<span class="string">'.'</span>,last_name) <span class="string">`姓.名`</span></span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> salary=(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span>  employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="进阶八：分页查询"><a href="#进阶八：分页查询" class="headerlink" title="进阶八：分页查询"></a>进阶八：分页查询</h3><p>应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 查询列表</span><br><span class="line"><span class="keyword">from</span> 表</span><br><span class="line">【<span class="keyword">join</span> <span class="keyword">type</span>  <span class="keyword">join</span> 表<span class="number">2</span></span><br><span class="line"><span class="keyword">on</span> 连接条件</span><br><span class="line"><span class="keyword">where</span>筛选条件</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>分组字段</span><br><span class="line"><span class="keyword">having</span> 分组后的筛选</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 排序的字段】</span><br><span class="line"><span class="keyword">limit</span> 【<span class="keyword">offset</span>】,<span class="keyword">size</span>;</span><br><span class="line">offset：要显示条目的起始索引（起始索引从0开始）</span><br><span class="line">size：要显示的条目个数</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li><p>limit语句放在查询语句的最后，执行也是最后，select–order by–limit</p>
</li>
<li><p>公式</p>
<p>要显示的页数page，每页的条目数size</p>
<p>select 查询列表</p>
<p>from 表</p>
<p>limit (page-1)*size,size</p>
</li>
</ul>
<p>案例1：查询前五条员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">LIMIT</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>offset是可选的</p>
<p>案例2：查询第11条-25条</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">LIMIT</span> <span class="number">10</span>,<span class="number">15</span>;</span><br></pre></td></tr></table></figure>

<p>案例3：有奖金的员工信息，并且工资较高的前10名显示</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="练习题6"><a href="#练习题6" class="headerlink" title="练习题6"></a>练习题6</h3><p>已知表 stuinfo，包含有以下字段</p>
<ul>
<li>id    学号</li>
<li>name姓名</li>
<li>email 邮箱 <a href="mailto:john@126.com">john@126.com</a></li>
<li>gradeId 年级编号</li>
<li>sex 性别 男/女</li>
<li>age 年龄</li>
</ul>
<p>已知表grade</p>
<ul>
<li>id 年级编号</li>
<li>gradeName 年级名称</li>
</ul>
<p>1、查询所有学员邮箱的用户名（注：邮箱中@前面的字符）</p>
<p>select substr(email,1,instr(email,’@’)-1)</p>
<p>from stuinfo;</p>
<p>用到的函数有截取字符串，获取指定字符在字符串中的位置</p>
<p>2、查询男生和女生的个数</p>
<p>select count(*) 个数,sex</p>
<p>from stuinfo</p>
<p>group by sex;</p>
<p>主要为对性别进行分组，然后计数</p>
<p>3、查询年龄&gt;18岁的所有学生的姓名和年级名称</p>
<p>select name,gradeName</p>
<p>from stuinfo s</p>
<p>inner join grade g</p>
<p>on s.gradeId=g.id</p>
<p>where age&gt;18;</p>
<p>考察连接查询</p>
<p>4、查询哪个年级的学生最小年龄&gt;20</p>
<p>步骤1：查询每个年级的最小年龄</p>
<p>select min(age),gradeId</p>
<p>from stuinfo</p>
<p>group by gradeId</p>
<p>步骤2：在步骤1的结果上进行筛选，因此直接加上having判断即可</p>
<p>select min(age) ,gradeId</p>
<p>from stuinfo</p>
<p>group by gradeId</p>
<p>having min(age)&gt;20;</p>
<p>5、说出查询语句中涉及到的所有的关键字，以及执行先后顺序</p>
<p>select 查询列表</p>
<p>from 表                                                </p>
<p>连接类型 join 表2</p>
<p>on    连接条件</p>
<p>where    筛选条件</p>
<p>group by    分组列表</p>
<p>having    分组后的筛选</p>
<p>order by    排序列表</p>
<p>limit 偏移,条目数;</p>
<p>执行顺序：1、from锁定数据源；2、join两表连接生成笛卡尔乘积表；3、on将满足条件的数据过滤出生成新表；4、where在3的基础上筛选生成新表；5、group by分组生成新的虚拟表格；6、having将分组后的表格进行筛选；7、select将筛选完毕后的表选出进行查看；8、order by进行排序；9、limit记性分页显示。</p>
<p>注意：<strong>having后执行的是select</strong>！！！<strong>select在order by前面</strong>！！！</p>
<p>6、查询生日在“1988-1-1”后的学生姓名、专业名称</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`studentname`</span>,<span class="string">`majorname`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span> s</span><br><span class="line"><span class="keyword">JOIN</span> <span class="string">`major`</span> m</span><br><span class="line"><span class="keyword">ON</span> s.<span class="string">`majorid`</span>=m.<span class="string">`majorid`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">DATEDIFF</span>(<span class="string">`borndate`</span>,<span class="string">'1988-1-1'</span>)&gt;<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>生日在某个日期之后，可以使用DATEDIFF函数来判断。或者使用WHERE borndate&gt;’1988-1-1’;也可以。</p>
<p>7、<strong>查询每个专业的男生人数和女生人数分别是多少</strong></p>
<p>方式一：</p>
<p>按照专业和性别进行分组，<strong>多个分组条件用逗号隔开</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) 个数,sex,<span class="string">`majorid`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sex,<span class="string">`majorid`</span></span><br></pre></td></tr></table></figure>

<p>但是这样显示效果不好，不是非常直观</p>
<p>方式二：</p>
<p>希望显示的效果是专业，男生，女神</p>
<p>因此基本语法应该为</p>
<p>select majorid,男，女</p>
<p>from student</p>
<p>group by major id;</p>
<p>然后男生，女生个数 可以使用子查询。如果直接使用select count(*) from student where sex=‘男’或者女，这样查到的人数是总体的，而并不是某个年级的。因此还需要附加条件，加上majorid的限制。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> majorid,</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sex=<span class="string">'男'</span> <span class="keyword">AND</span> majorid=s.majorid) 男,</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sex=<span class="string">'女'</span> <span class="keyword">AND</span> majorid=s.majorid) 女</span><br><span class="line"><span class="keyword">FROM</span> student s</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> majorid;</span><br></pre></td></tr></table></figure>

<img src="/2020/02/09/MySQL/%E7%94%B7%E7%94%9F%E5%A5%B3%E7%94%9F.png" class title="This is an example image">

<p>8、查询专业和张翠山一样的学生的最低分<br>步骤1：查询张翠山的专业</p>
<p>步骤2：查询学生最低分，筛选条件为专业为步骤1结果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(score)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span> s</span><br><span class="line"><span class="keyword">JOIN</span> <span class="string">`result`</span> r</span><br><span class="line"><span class="keyword">ON</span> s.<span class="string">`studentno`</span>=r.<span class="string">`studentno`</span></span><br><span class="line"><span class="keyword">WHERE</span> s.<span class="string">`majorid`</span>=(</span><br><span class="line">	<span class="keyword">SELECT</span> majorid</span><br><span class="line">	<span class="keyword">FROM</span> student</span><br><span class="line">	<span class="keyword">WHERE</span> <span class="string">`studentname`</span>=<span class="string">'张翠山'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>或者可以先查张翠山专业，然后查哪些编号学生在这个专业中，然后查这些学生的最低分</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(score)</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">result</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`studentno`</span> <span class="keyword">IN</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="string">`studentno`</span></span><br><span class="line">	<span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line">	<span class="keyword">WHERE</span> <span class="string">`majorid`</span>=(</span><br><span class="line">		<span class="keyword">SELECT</span> majorid</span><br><span class="line">		<span class="keyword">FROM</span> student</span><br><span class="line">		<span class="keyword">WHERE</span> <span class="string">`studentname`</span>=<span class="string">'张翠山'</span></span><br><span class="line">	)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>9、查询大于60分的学生的姓名、密码、专业名</p>
<p>使用sql92写法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`studentname`</span>,<span class="string">`loginpwd`</span>,<span class="string">`majorname`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span> s,<span class="string">`result`</span> r,<span class="string">`major`</span> m</span><br><span class="line"><span class="keyword">WHERE</span> s.<span class="string">`studentno`</span>=r.<span class="string">`studentno`</span></span><br><span class="line"><span class="keyword">AND</span> s.<span class="string">`majorid`</span>=m.<span class="string">`majorid`</span></span><br><span class="line"><span class="keyword">AND</span> r.<span class="string">`score`</span>&gt;<span class="number">60</span>;</span><br></pre></td></tr></table></figure>

<p>使用sql99写法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`studentname`</span>,<span class="string">`loginpwd`</span>,<span class="string">`majorname`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span> s</span><br><span class="line"><span class="keyword">JOIN</span> <span class="string">`major`</span> m <span class="keyword">ON</span> s.<span class="string">`majorid`</span>=m.<span class="string">`majorid`</span></span><br><span class="line"><span class="keyword">JOIN</span> <span class="string">`result`</span> r <span class="keyword">ON</span> s.<span class="string">`studentno`</span>=r.<span class="string">`studentno`</span></span><br><span class="line"><span class="keyword">WHERE</span> r.<span class="string">`score`</span>&gt;<span class="number">60</span>;</span><br></pre></td></tr></table></figure>

<p>建议用99写法，更加直观，可读性较高。</p>
<p>10、<strong>按邮箱位数分组，查询每组的学生个数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*),<span class="keyword">LENGTH</span>(email)</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">LENGTH</span>(email);</span><br></pre></td></tr></table></figure>

<p><strong>group by后面也可以接函数</strong>。</p>
<p>11、查询学生名、专业名、分数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`studentname`</span>,<span class="string">`majorname`</span>,<span class="string">`score`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span> s</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="string">`major`</span> m <span class="keyword">ON</span> s.<span class="string">`majorid`</span>=m.<span class="string">`majorid`</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="string">`result`</span> r <span class="keyword">ON</span> s.<span class="string">`studentno`</span>=r.<span class="string">`studentno`</span></span><br></pre></td></tr></table></figure>

<p>因为有的人分数为空，为了显示所有情况，使用左连接。</p>
<p>12、查询哪个专业没有学生，分别用左连接和右连接实现</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> m.<span class="string">`majorid`</span>,m.<span class="string">`majorname`</span>,s.<span class="string">`studentno`</span></span><br><span class="line"><span class="keyword">FROM</span> major m</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student s</span><br><span class="line"><span class="keyword">ON</span> s.<span class="string">`majorid`</span>=m.<span class="string">`majorid`</span></span><br><span class="line"><span class="keyword">WHERE</span> s.<span class="string">`studentno`</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>专业表为主表，为了显示没有学生即null的情况，需要使用左连接或者右连接（一个表有另一个没有），筛选条件为学生的主键为NULL。</p>
<p>13、查询没有成绩的学生人数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) 学生人数</span><br><span class="line"><span class="keyword">FROM</span> student s</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="string">`result`</span> r</span><br><span class="line"><span class="keyword">ON</span> s.<span class="string">`studentno`</span>=r.<span class="string">`studentno`</span></span><br><span class="line"><span class="keyword">WHERE</span> r.<span class="string">`id`</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>先将没有成绩学生查出来，即用左连接，学生为主表，筛选条件为成绩的主键为空，然后在此基础上统计人数。</p>
<h3 id="子查询经典案例"><a href="#子查询经典案例" class="headerlink" title="子查询经典案例"></a>子查询经典案例</h3><p>1、查询工资最低的员工信息：last_name，salary</p>
<p>步骤1：查询最低工资</p>
<p>步骤2：查询员工信息，要求salary=最低工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary=(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>2、查询平均工资最低的部门信息</p>
<p>方式一：</p>
<p>步骤1：查询各部门的平均工资</p>
<p>步骤2：查询最低的平均工资</p>
<p>步骤3：查询部门编号等于最低平均工资的</p>
<p>步骤4：查询此部门信息</p>
<p>过于麻烦和啰嗦</p>
<p>方式二：</p>
<p>步骤1：查询各部门的平均工资</p>
<p>步骤2：求出最低平均工资的部门编号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">AVG</span>(salary)</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>步骤3：查询部门信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> departments</span><br><span class="line"><span class="keyword">WHERE</span> department_id = (</span><br><span class="line">	<span class="keyword">SELECT</span> department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">AVG</span>(salary)</span><br><span class="line">	<span class="keyword">LIMIT</span> <span class="number">1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>思路：在得到部门与平均工资表后，按照平均工资排序并只要最小的，得到部门编号，效率较高。</p>
<p>方式三：</p>
<p>步骤1：查询各部门的平均工资</p>
<p>步骤2：查询平均工资最低的部门信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary) <span class="string">`平均工资`</span>,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">) avg_dep <span class="keyword">ON</span> d.department_id=avg_dep.department_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`平均工资`</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>思路：得到表后与部门表连接，然后排序后选出1条，效率较低。</p>
<p>3、查询平均工资最低的部门信息和该部门的平均工资</p>
<p>查询出最低工资及部门编号的表，和部门表进行连接输出</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> d.*,ag</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">JOIN</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary) ag,department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">AVG</span>(salary)</span><br><span class="line">	<span class="keyword">LIMIT</span> <span class="number">1</span></span><br><span class="line">) avg_dep </span><br><span class="line"><span class="keyword">ON</span> d.department_id=avg_dep.department_id;</span><br></pre></td></tr></table></figure>

<p>表子查询及连接的方式</p>
<p>4、查询平均工资最高的job信息</p>
<p>步骤1：查询每个job的平均工资（先排序，再limit）</p>
<p>步骤2：找到最高的平均工资的job_id</p>
<p>步骤3：得到此job信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> jobs</span><br><span class="line"><span class="keyword">WHERE</span> job_id = (</span><br><span class="line">	<span class="keyword">SELECT</span> job_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id</span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">AVG</span>(salary) <span class="keyword">DESC</span></span><br><span class="line">	<span class="keyword">LIMIT</span> <span class="number">1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>5、查询平均工资高于公司平均工资的部门有哪些</p>
<p>步骤1：查询公司平均工资</p>
<p>步骤2：查询每个部门的平均工资表，筛选条件为工资大于平均工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary) ag,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> ag &gt;(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>6、查询出公司中所有manager的详细信息</p>
<p>方式一：</p>
<p>两个表自连接，输出m表的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> m.*</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> employees m</span><br><span class="line"><span class="keyword">ON</span> e.manager_id=m.employee_id;</span><br></pre></td></tr></table></figure>

<p>方式二：</p>
<p>步骤1：查询出所有的manager_id</p>
<p>步骤2：查询员工信息，需要满足employee_id在步骤1的结果中</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="keyword">IN</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> manager_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>查询结果：自连接更快</p>
<p>7、各个部门中，最高工资中最低的那个部门的最低工资是多少 </p>
<p>步骤1：选出各个部门的最高工资</p>
<p>步骤2：找到最高工资最低的部门编号（order by,limit）</p>
<p>步骤3：得到id=步骤2的部门的最低工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id = (</span><br><span class="line">	<span class="keyword">SELECT</span> department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">MAX</span>(salary) <span class="keyword">ASC</span></span><br><span class="line">	<span class="keyword">LIMIT</span> <span class="number">1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>8、查询平均工资最高的部门的manager的详细信息：last_name，department_id，email，salary</p>
<p>方法一：</p>
<p>步骤1：查询平均工资最高的部门Id</p>
<p>步骤2：在departments表中找到id=步骤1结果的manager_id</p>
<p>步骤3：查询em_id=步骤2结果中的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_id,email,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id = (</span><br><span class="line">	<span class="keyword">SELECT</span> manager_id</span><br><span class="line">	<span class="keyword">FROM</span> departments</span><br><span class="line">	<span class="keyword">WHERE</span> department_id = (</span><br><span class="line">		<span class="keyword">SELECT</span> department_id</span><br><span class="line">		<span class="keyword">FROM</span> employees</span><br><span class="line">		<span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">		<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">AVG</span>(salary) <span class="keyword">DESC</span></span><br><span class="line">		<span class="keyword">LIMIT</span> <span class="number">1</span></span><br><span class="line">	)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<p>步骤1：查询平均工资最高的部门Id</p>
<p>步骤2：将员工表和部门表进行连接，筛选条件为步骤1结果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,d.department_id,email,salary</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.employee_id=d.manager_id</span><br><span class="line"><span class="keyword">WHERE</span> e.department_id=(</span><br><span class="line">	<span class="keyword">SELECT</span> department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">AVG</span>(salary) <span class="keyword">DESC</span></span><br><span class="line">	<span class="keyword">LIMIT</span> <span class="number">1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>两表连接效率比较低，执行时间比方式一更长。</p>
<h3 id="进阶九：union联合查询"><a href="#进阶九：union联合查询" class="headerlink" title="进阶九：union联合查询"></a>进阶九：union联合查询</h3><p>union：联合，合并，将多条查询语句结果合成一个结果</p>
<p>引入案例：查询部门编号&gt;90或邮箱中包含a的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id&gt;<span class="number">90</span> <span class="keyword">OR</span> email <span class="keyword">LIKE</span> <span class="string">'%a%'</span>;</span><br></pre></td></tr></table></figure>

<p>如果使用union</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id&gt;<span class="number">90</span> </span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> email <span class="keyword">LIKE</span> <span class="string">'%a%'</span>;</span><br></pre></td></tr></table></figure>

<p>语法：</p>
<p>查询语句1</p>
<p>union</p>
<p>查询语句2</p>
<p>union</p>
<p>…</p>
<p>应用场景：要查询的结果来自多个表，且多个表没有直接的连接关系，但查询的信息一致时</p>
<p>特点：</p>
<ol>
<li>要求多条查询语句的查询列数是一致的</li>
<li>要求多条查询语句的查询的每一列的类型和顺序最好是一致的</li>
<li>使用union关键字默认去重，如果使用<strong>union all</strong>可以包含重复项</li>
</ol>
<h3 id="查询总结"><a href="#查询总结" class="headerlink" title="查询总结"></a>查询总结</h3><p>select 查询列表                       7</p>
<p>from 表1 别名                         1</p>
<p>连接类型 join 表2 别名          2</p>
<p>on 连接条件                            3</p>
<p>where 筛选                             4</p>
<p>group by 分组列表                 5</p>
<p>having 筛选                            6</p>
<p>order by 排序列表                 8</p>
<p>limit offset,limit;                    9</p>
<p>group by和having别名使用相对较少。select *输出全部信息，但实际为了可读性，最好写完整对应列。</p>
<h2 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h2><p>数据操作语言</p>
<ul>
<li>插入：insert</li>
<li>修改：update</li>
<li>删除：delete</li>
</ul>
<h3 id="插入语句"><a href="#插入语句" class="headerlink" title="插入语句"></a>插入语句</h3><h4 id="方式一：经典插入"><a href="#方式一：经典插入" class="headerlink" title="方式一：经典插入"></a>方式一：经典插入</h4><p>语法：</p>
<p>insert into 表名(列名,…) values(值1,…),(值2,…),…;</p>
<p>1、插入的值的类型要与列的类型一致或兼容</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(<span class="keyword">id</span>,<span class="keyword">NAME</span>,sex,borndate,phone,photo,boyfriend_id) </span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">13</span>,<span class="string">'唐艺昕'</span>,<span class="string">'女'</span>,<span class="string">'1990-4-23'</span>,<span class="string">'18988888888'</span>,<span class="literal">NULL</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>如果插入数据是‘1234’也可以插入到int列中，可以隐式转换。</p>
<p>2、不可以为null的列必须插入值，可以为null的列如何插入值</p>
<p>方式一：值直接写null</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(<span class="keyword">id</span>,<span class="keyword">NAME</span>,sex,borndate,phone,photo,boyfriend_id) </span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">13</span>,<span class="string">'唐艺昕'</span>,<span class="string">'女'</span>,<span class="string">'1990-4-23'</span>,<span class="string">'18988888888'</span>,<span class="literal">NULL</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>方式二：列和值均不写</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(<span class="keyword">id</span>,<span class="keyword">NAME</span>,sex,borndate,phone,boyfriend_id) </span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">14</span>,<span class="string">'金星'</span>,<span class="string">'女'</span>,<span class="string">'1990-4-23'</span>,<span class="string">'13888888888'</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>photo列和值均被省略</p>
<p>3、列的顺序可以调换，但要一一对应</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(<span class="keyword">NAME</span>,sex,<span class="keyword">id</span>,phone)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'蒋欣'</span>,<span class="string">'女'</span>,<span class="number">16</span>,<span class="string">'123'</span>);</span><br></pre></td></tr></table></figure>

<p>4、列数和值的个数必须一致</p>
<p>5、可以省略列名，默认所有列，而且列的顺序和表中的顺序一致</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">18</span>,<span class="string">'张飞'</span>,<span class="string">'男'</span>,<span class="literal">NULL</span>,<span class="string">'1212'</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<h4 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h4><p>语法：</p>
<p>insert into 表名</p>
<p>set 列名=值,列名=值,…</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">id</span>=<span class="number">19</span>,<span class="keyword">NAME</span>=<span class="string">'刘涛'</span>,phone=<span class="string">'9001'</span>;</span><br></pre></td></tr></table></figure>

<h4 id="两种方式比较"><a href="#两种方式比较" class="headerlink" title="两种方式比较"></a>两种方式比较</h4><p>1、方式一支持插入多行，方式二不支持</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(<span class="keyword">id</span>,<span class="keyword">NAME</span>,sex,borndate,phone,photo,boyfriend_id) </span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">23</span>,<span class="string">'唐艺昕1'</span>,<span class="string">'女'</span>,<span class="string">'1990-4-23'</span>,<span class="string">'18988888888'</span>,<span class="literal">NULL</span>,<span class="number">2</span>)</span><br><span class="line">,(<span class="number">24</span>,<span class="string">'唐艺昕2'</span>,<span class="string">'女'</span>,<span class="string">'1990-4-23'</span>,<span class="string">'18988888888'</span>,<span class="literal">NULL</span>,<span class="number">2</span>)</span><br><span class="line">,(<span class="number">25</span>,<span class="string">'唐艺昕3'</span>,<span class="string">'女'</span>,<span class="string">'1990-4-23'</span>,<span class="string">'18988888888'</span>,<span class="literal">NULL</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>在values后用逗号隔开，然后加括号写要插入的值。</p>
<p>2、方式一支持子查询，方式二不支持</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(<span class="keyword">id</span>,<span class="keyword">NAME</span>,phone) </span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">26</span>,<span class="string">'宋茜'</span>,<span class="string">'183298'</span>;</span><br></pre></td></tr></table></figure>

<p>这样也可以实现插入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(<span class="keyword">id</span>,<span class="keyword">NAME</span>,phone) </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,boyname,<span class="string">'1423432'</span></span><br><span class="line"><span class="keyword">FROM</span> boys</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span>&lt;<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h3 id="修改语句"><a href="#修改语句" class="headerlink" title="修改语句"></a>修改语句</h3><h4 id="修改单表的记录【重要】"><a href="#修改单表的记录【重要】" class="headerlink" title="修改单表的记录【重要】"></a>修改单表的记录【重要】</h4><p>语法：</p>
<p>update 表名</p>
<p>set 列=新值，列=新值,…</p>
<p>where 筛选条件;</p>
<p>案例1：修改beauty表中姓唐的女神电话为13888888888</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> beauty <span class="keyword">SET</span> phone=<span class="string">'13888888888'</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NAME</span> <span class="keyword">LIKE</span> <span class="string">'唐%'</span>;</span><br></pre></td></tr></table></figure>

<p>案例2：修改boys表中id号为2的名称为张飞，魅力值为10</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> boys <span class="keyword">SET</span> boyName=<span class="string">'张飞'</span>,userCp=<span class="number">10</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h4 id="修改多表的记录【补充】"><a href="#修改多表的记录【补充】" class="headerlink" title="修改多表的记录【补充】"></a>修改多表的记录【补充】</h4><p>语法：</p>
<p>sql92语法</p>
<p>update 表1 别名，表2 别名</p>
<p>set 列=值,….</p>
<p>where 连接条件</p>
<p>and 筛选条件;</p>
<p>sql99语法</p>
<p><strong>update 表1 别名</strong></p>
<p><strong>inner|left|right|full join 表2 别名</strong></p>
<p><strong>on 连接条件</strong></p>
<p><strong>set 列=值,….</strong></p>
<p><strong>where 筛选条件;</strong></p>
<p>案例1：修改张无忌的女朋友的手机号为114</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> boys bo</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> beauty b</span><br><span class="line"><span class="keyword">ON</span> bo.<span class="string">`id`</span>=b.<span class="string">`boyfriend_id`</span></span><br><span class="line"><span class="keyword">SET</span> b.<span class="string">`phone`</span>=<span class="string">'114'</span></span><br><span class="line"><span class="keyword">WHERE</span> bo.<span class="string">`boyName`</span>=<span class="string">'张无忌'</span>;</span><br></pre></td></tr></table></figure>

<p>案例2：修改没有男朋友的女神的男朋友编号都为2号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> boys bo</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> beauty b</span><br><span class="line"><span class="keyword">ON</span> bo.<span class="string">`id`</span>=b.<span class="string">`boyfriend_id`</span></span><br><span class="line"><span class="keyword">SET</span> b.<span class="string">`boyfriend_id`</span>=<span class="number">2</span></span><br><span class="line"><span class="keyword">WHERE</span> bo.<span class="string">`id`</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>筛选条件为从表的主键为空</p>
<h3 id="删除语句"><a href="#删除语句" class="headerlink" title="删除语句"></a>删除语句</h3><p>方式一：delete</p>
<p>语法：</p>
<ol>
<li><p>单表的删除【重点】</p>
<p>delete from 表名【 where 筛选条件】【limit 条目数】</p>
<p>筛选条件是可选的，如果不写删除条件，就是删除整个表数据。</p>
</li>
<li><p>多表的删除【补充】</p>
<ul>
<li><p>sql92语法</p>
<p>delete 删除表的别名 【，表2的别名，…】</p>
<p>from 表1 别名，表2 别名</p>
<p>where 连接条件</p>
<p>and 筛选条件;</p>
</li>
<li><p>sql99语法</p>
<p>delete 表1的别名【,表2的别名】</p>
<p>from 表1 别名</p>
<p>inner|left|right join 表2 别名 on 连接条件</p>
<p>where 筛选条件;</p>
</li>
</ul>
</li>
</ol>
<p>方式二：truncate</p>
<p>语法：truncate table 表名</p>
<p>清空数据，不能加where，将表中信息全部删除</p>
<h4 id="方式一：delete"><a href="#方式一：delete" class="headerlink" title="方式一：delete"></a>方式一：delete</h4><p>1、单表的删除</p>
<p>案例：删除手机号以9结尾的女神信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> beauty <span class="keyword">WHERE</span> phone <span class="keyword">LIKE</span> <span class="string">'%9'</span>;</span><br></pre></td></tr></table></figure>

<p>delete 和from 之间不能加列，删除的是一整行的信息。</p>
<p>2、多表 的删除</p>
<p>案例1：删除张无忌的女朋友的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除哪个表信息就delete那个表</span></span><br><span class="line"><span class="keyword">DELETE</span> b</span><br><span class="line"><span class="keyword">FROM</span> boys bo</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> beauty b <span class="keyword">ON</span> bo.<span class="string">`id`</span>=b.<span class="string">`boyfriend_id`</span></span><br><span class="line"><span class="keyword">WHERE</span> bo.<span class="string">`boyName`</span>=<span class="string">'张无忌'</span>;</span><br></pre></td></tr></table></figure>

<p>案例2：删除黄晓明的信息及他女朋友的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> bo,b</span><br><span class="line"><span class="keyword">FROM</span> beauty b</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> boys bo <span class="keyword">ON</span> b.<span class="string">`boyfriend_id`</span>=bo.<span class="string">`id`</span></span><br><span class="line"><span class="keyword">WHERE</span> bo.<span class="string">`boyName`</span>=<span class="string">'黄晓明'</span>;</span><br></pre></td></tr></table></figure>

<p>将要删除的表写在delete后面。</p>
<h4 id="方式二：truncate语句"><a href="#方式二：truncate语句" class="headerlink" title="方式二：truncate语句"></a>方式二：truncate语句</h4><p>案例：将魅力值&gt;100的男神信息删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> boys;</span><br></pre></td></tr></table></figure>

<p>不能加where筛选，只能把表全部删除。</p>
<h4 id="两种方式比较【面试题，重要】"><a href="#两种方式比较【面试题，重要】" class="headerlink" title="两种方式比较【面试题，重要】"></a>两种方式比较【面试题，重要】</h4><ol>
<li>delete 可以加where条件，truncate不能加</li>
<li>truncate删除，效率高一点</li>
<li>加入要删除的表中有自增长列，用<strong>delete</strong>删除后，再插入数据，<strong>自增长列的值从断点开始</strong>；而用<strong>truncate</strong>删除后，再插入数据，<strong>自增长列的值从1</strong>开始</li>
<li><strong>truncate</strong>删除<strong>没有返回值</strong>，<strong>delete</strong>删除<strong>有返回值</strong></li>
<li>truncate删除不能回滚，delete删除可以回滚</li>
</ol>
<h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><p>1、插入语法的两种方式</p>
<p>方式一：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> my_employees</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'patel'</span>,<span class="string">'Ralph'</span>,<span class="string">'Rpatel'</span>,<span class="number">895</span>)</span><br><span class="line">,(<span class="number">2</span>,<span class="string">'Dancs'</span>,<span class="string">'Betty'</span>,<span class="string">'Bdancs'</span>,<span class="number">860</span>)</span><br><span class="line">,(<span class="number">3</span>,<span class="string">'Biri'</span>,<span class="string">'Ben'</span>,<span class="string">'Bbiri'</span>,<span class="number">1100</span>)</span><br><span class="line">,(<span class="number">4</span>,<span class="string">'Newman'</span>,<span class="string">'Chad'</span>,<span class="string">'Cnewman'</span>,<span class="number">750</span>)</span><br><span class="line">,(<span class="number">5</span>,<span class="string">'Ropeburn'</span>,<span class="string">'Audrey'</span>,<span class="string">'Aropebur'</span>,<span class="number">1550</span>);</span><br></pre></td></tr></table></figure>

<p>方式二：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> my_employees</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span>,<span class="string">'patel'</span>,<span class="string">'Ralph'</span>,<span class="string">'Rpatel'</span>,<span class="number">895</span> <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">2</span>,<span class="string">'Dancs'</span>,<span class="string">'Betty'</span>,<span class="string">'Bdancs'</span>,<span class="number">860</span> <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">3</span>,<span class="string">'Biri'</span>,<span class="string">'Ben'</span>,<span class="string">'Bbiri'</span>,<span class="number">1100</span> <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">4</span>,<span class="string">'Newman'</span>,<span class="string">'Chad'</span>,<span class="string">'Cnewman'</span>,<span class="number">750</span> <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">5</span>,<span class="string">'Ropeburn'</span>,<span class="string">'Audrey'</span>,<span class="string">'Aropebur'</span>,<span class="number">1550</span>;</span><br></pre></td></tr></table></figure>

<p>insert into后面可以跟select语句，利用union将多条select语句变为一条，最后一个select后不用加union。</p>
<p>2、将3号员工的last_name修改为“drelxer”</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> my_employees</span><br><span class="line"><span class="keyword">SET</span> Last_name=<span class="string">'drelxer'</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>3、将userid 为Bbiri的user表和my_employees表的记录全部删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> my,us</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">users</span> us</span><br><span class="line"><span class="keyword">JOIN</span> my_employees my <span class="keyword">ON</span> us.<span class="string">`userid`</span>=my.<span class="string">`Userid`</span></span><br><span class="line"><span class="keyword">WHERE</span> us.<span class="string">`userid`</span>=<span class="string">'Bbiri'</span>;</span><br></pre></td></tr></table></figure>

<p>4、检查表所做的修正</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> my_employees;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span>;</span><br></pre></td></tr></table></figure>

<h2 id="DDL语言"><a href="#DDL语言" class="headerlink" title="DDL语言"></a>DDL语言</h2><p>数据定义语言，库和表的管理</p>
<p>1、库的管理</p>
<p>创建、修改、删除</p>
<p>2、表的管理</p>
<p>创建、修改、删除</p>
<p>与数据操作语言区分，这里管理的是表的结构，而不是数据</p>
<ul>
<li>创建：create</li>
<li>修改：alter</li>
<li>删除：drop</li>
</ul>
<h3 id="库的管理"><a href="#库的管理" class="headerlink" title="库的管理"></a>库的管理</h3><h4 id="库的创建"><a href="#库的创建" class="headerlink" title="库的创建"></a>库的创建</h4><p>语法：</p>
<p>create database 【if not exsits】库名 【character set 字符集名】;</p>
<p>案例：创建库books</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> books;</span><br></pre></td></tr></table></figure>

<p>但是这样创建完成后，再次执行会报错，采用下面语句提高语句容错性</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> books;</span><br></pre></td></tr></table></figure>

<h4 id="库的修改"><a href="#库的修改" class="headerlink" title="库的修改"></a>库的修改</h4><p><strong>基本不修改</strong></p>
<p>库名不能使用sql语句去修改</p>
<p>可以更改库的字符集</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> books <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> gbk;</span><br></pre></td></tr></table></figure>

<h4 id="库的删除"><a href="#库的删除" class="headerlink" title="库的删除"></a>库的删除</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> books;</span><br></pre></td></tr></table></figure>

<p>存在才删除</p>
<h3 id="表的管理"><a href="#表的管理" class="headerlink" title="表的管理"></a>表的管理</h3><h4 id="表的创建【重要】"><a href="#表的创建【重要】" class="headerlink" title="表的创建【重要】"></a>表的创建【重要】</h4><p>create table 【if not exists】表名(</p>
<p>​    列名 列的类型【（长度）约束】，</p>
<p>​    列名 列的类型【（长度）约束】，</p>
<p>​    ….</p>
<p>​    列名 列的类型【（长度）约束】</p>
<p>);</p>
<p>案例：创建表book</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span>,<span class="comment">#编号</span></span><br><span class="line">	bName <span class="built_in">VARCHAR</span>(<span class="number">20</span>),<span class="comment">#书名</span></span><br><span class="line">	price <span class="keyword">DOUBLE</span>,<span class="comment">#价格</span></span><br><span class="line">	authorId <span class="built_in">INT</span>,<span class="comment">#作者编号</span></span><br><span class="line">	publishDate DATETIME<span class="comment">#出版日期</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>不同字段用逗号隔开，最后个不用加逗号。</p>
<h4 id="表的修改"><a href="#表的修改" class="headerlink" title="表的修改"></a>表的修改</h4><p><strong>alter table 表名 add|drop|modify|change column 列名 【列类型 约束】;</strong></p>
<p>1、修改列名</p>
<p>alter table 表名 change column 旧列名 新列名 新列名类型</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book <span class="keyword">CHANGE</span> <span class="keyword">COLUMN</span> publishDate pubDate DATETIME;</span><br></pre></td></tr></table></figure>

<p>change column要求加上新的列名和类型。column可以省略。</p>
<p>2、修改列的类型或约束</p>
<p>alter table 表名 modify column 列名 新类型 【新约束】</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> pubDate <span class="built_in">TIMESTAMP</span> 【新约束】;</span><br></pre></td></tr></table></figure>

<p>用到的为modify。</p>
<p>3、添加新列</p>
<p>默认添加在最后列，可以自己指定位置。在最开头，使用first，在某个字段后面，使用after字段名。</p>
<p>alter table 表名 add column 列名 类型 【first|after 字段名】</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> author <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> annual <span class="keyword">DOUBLE</span> 【<span class="keyword">first</span>|<span class="keyword">after</span> 字段名】;</span><br></pre></td></tr></table></figure>

<p>用到的为add。同样需要加上类型。</p>
<p>4、删除列</p>
<p>alter table 表名 drop column 列名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> annual;</span><br></pre></td></tr></table></figure>

<p>用到的为drop，这时候就不需要指定类型了。</p>
<p>5、修改表名</p>
<p>alter table 表名 rename 【to】新表名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> author <span class="keyword">RENAME</span> <span class="keyword">TO</span> book_author;</span><br></pre></td></tr></table></figure>

<h4 id="表的删除"><a href="#表的删除" class="headerlink" title="表的删除"></a>表的删除</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> 【<span class="keyword">IF</span> <span class="keyword">EXISTS</span>】 book_author;</span><br></pre></td></tr></table></figure>

<p>通用写法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> 旧库名;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> 新库名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> 旧库名;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名();</span><br></pre></td></tr></table></figure>

<h4 id="表的复制"><a href="#表的复制" class="headerlink" title="表的复制"></a>表的复制</h4><p>1、仅复制表的结构</p>
<p>create table 表名 like 旧表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> copy <span class="keyword">LIKE</span> author;</span><br></pre></td></tr></table></figure>

<p>没有复制内容。</p>
<p>2、复制表的结构+数据</p>
<p>create table 表名</p>
<p>select 查询列表 from 表 【where 筛选】</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> copy2 </span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> author;</span><br></pre></td></tr></table></figure>

<p>后面跟select查询语句</p>
<p>复制部门数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> copy3</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,au_name</span><br><span class="line"><span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">WHERE</span> nation=<span class="string">'中国'</span>;</span><br></pre></td></tr></table></figure>

<p>仅复制某些字段</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> copy4</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,au_name</span><br><span class="line"><span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">WHERE</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>利用where 0来获取数据。</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>1、将其他库中的表信息复制进当前库中的表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept2</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">`department_id`</span>,<span class="string">`department_name`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`myemployees`</span>.<span class="string">`departments`</span>;</span><br></pre></td></tr></table></figure>

<p>使用库名.表名来进行调用。利用create后面+select子查询。</p>
<p>2、复制其他库中表的结构</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees2 <span class="keyword">LIKE</span> <span class="string">`myemployees`</span>.employees;</span><br></pre></td></tr></table></figure>

<p>3、删除表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> emp5;</span><br></pre></td></tr></table></figure>

<h3 id="常见的数据类型"><a href="#常见的数据类型" class="headerlink" title="常见的数据类型"></a>常见的数据类型</h3><ul>
<li>数值型<ul>
<li>整数</li>
<li>小数<ul>
<li>定点数</li>
<li>浮点数</li>
</ul>
</li>
</ul>
</li>
<li>字符型<ul>
<li>较短的文本：char,varchar</li>
<li>较长的文本：text，blob（较长的二进制数据）</li>
</ul>
</li>
<li>日期型</li>
</ul>
<h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><p>所选择的类型越简单越好，能保存数值的类型越小越好</p>
<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>分类：</p>
<p>tinyint（1字节）、smallint（2字节）、mediumint（3字节）、int/integer（4字节）、bigint（8字节）</p>
<p>特点：</p>
<ol>
<li><p>如果不设置有符号还是无符号，默认是有符号，如果要设置无符号，加上关键字unsigned</p>
</li>
<li><p>如果插入的数值超出了整形的范围，会报out of range异常，并且插入临界值</p>
<p>临界值为对应允许范围内最接近插入值的值如果tinyint范围是-128-127，插入-129，存入-128；插入128，存入127</p>
</li>
<li><p>如果不设置长度，会有默认长度</p>
<p>宽度效果为：如果数据长度没有达到指定长度，则在左方用0补齐，需要搭配关键字<strong>zerofill</strong>使用，此时整形默认变为<strong>无符号</strong>类型</p>
</li>
</ol>
<p>1、设置无符号和有符号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_int (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">	id2 <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h4><p>分类</p>
<ol>
<li>浮点型<ul>
<li>float(M,D)  4字节</li>
<li>double(M,D) 8字节</li>
</ul>
</li>
<li>定点型<ul>
<li>dec(M,D)  M+2字节，最大取值范围与double相同</li>
<li>decimal(M,D)</li>
</ul>
</li>
</ol>
<p>特点：</p>
<ol>
<li><p>M：整数部位+小数部位的总长度</p>
<p>D：小数部位</p>
<p>如果超过范围，则插入临界值</p>
</li>
<li><p>M和D都可以省略</p>
<p>如果是decimal，则M默认是10，D默认是0</p>
<p>如果是float和double，则会根据插入数值的精度来决定精度</p>
</li>
<li><p>定点型的精确度较高，如果要求插入数值的精度较高，如货币运算则考虑使用</p>
</li>
</ol>
<h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><p>分类：</p>
<p>较短的文本：char、varchar</p>
<p>其他：</p>
<p>binary和varbiary用于保存较短的二进制</p>
<p>enum用于保存枚举</p>
<p>set用于保存集合</p>
<p>较长的文本：text、blob（较大的二进制数据）</p>
<p>特点：</p>
<h5 id="char和varchar类型【重要】"><a href="#char和varchar类型【重要】" class="headerlink" title="char和varchar类型【重要】"></a>char和varchar类型【重要】</h5><table>
<thead>
<tr>
<th>字符串类型</th>
<th>最多字符数</th>
<th>描述及存储需求</th>
<th>空间耗费</th>
<th>效率</th>
</tr>
</thead>
<tbody><tr>
<td>char(M)</td>
<td>M，可以省略，默认为1</td>
<td>M为0-255之间的整数</td>
<td>固定长度字符，比较耗费空间</td>
<td>高</td>
</tr>
<tr>
<td>varchar(M)</td>
<td>M，不可省略</td>
<td>M为0-65535之间的整数</td>
<td>可变长度字符，比较节省空间</td>
<td>低</td>
</tr>
</tbody></table>
<p>M为字符，一个汉字或者一个英文字符均为1字符。char固定长度，代表所有字符均用统一长度存储；varchar可变长度，代表存储长度随数据具体情况而变化。如果字符长度较为固定，用char，如性别；如果字符长度变化较大，用varchar，如姓名。</p>
<h5 id="binary和varbinary类型"><a href="#binary和varbinary类型" class="headerlink" title="binary和varbinary类型"></a>binary和varbinary类型</h5><p>类似于char和varchar，不同的是它们包含二进制字符串而不包含非二进制字符串</p>
<h5 id="Enum类型"><a href="#Enum类型" class="headerlink" title="Enum类型"></a>Enum类型</h5><p>枚举类型，要求插入的值必须属于列表中指定的值之一。如果列表成员为1~255，则需要1个字节存储，如果列表成员为255-65535，则需要2个字节存储，最多需要65535个成员！</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">c1 Enum('a','b','c');</span><br></pre></td></tr></table></figure>

<p>如果插入为对应的大写，保存为小写。如果插入类型不在枚举类型中，插入为空。</p>
<h5 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h5><p>说明：和ENUM类型类似，里面可以保存0~64个成员。和ENUM类型最大的区别是：SET类型一次可以选<strong>取多个成员</strong>，而ENUM只能选一个<br>根据成员个数不同，存储所占的字节也不同</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">s1 <span class="keyword">SET</span>(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_set <span class="keyword">values</span>(<span class="string">'a,b,c'</span>)</span><br></pre></td></tr></table></figure>

<p>同样不区分大小写。</p>
<h4 id="日期型"><a href="#日期型" class="headerlink" title="日期型"></a>日期型</h4><p>分类：</p>
<p>date 只保存日期</p>
<p>time 只保存时间</p>
<p>year 只保存年</p>
<p>datetime 保存日期+时间</p>
<p>timestamp 保存日期+时间</p>
<p>特点：</p>
<table>
<thead>
<tr>
<th></th>
<th>字节</th>
<th>范围</th>
<th>时区的影响</th>
</tr>
</thead>
<tbody><tr>
<td>datetime</td>
<td>8</td>
<td>1000-9999</td>
<td>不受</td>
</tr>
<tr>
<td>timestamp</td>
<td>4</td>
<td>1970-2038</td>
<td>受</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>日期和时间类型</th>
<th>字节</th>
<th>最小值</th>
<th>最大值</th>
</tr>
</thead>
<tbody><tr>
<td>date</td>
<td>4</td>
<td>1000-01-01</td>
<td>9999-12-31</td>
</tr>
<tr>
<td>datetime</td>
<td>8</td>
<td>1000-01-01 00:00:00</td>
<td>9999-12-31 23:59:59</td>
</tr>
<tr>
<td>timestam</td>
<td>4</td>
<td>19700101080001</td>
<td>2038年的某个时刻</td>
</tr>
<tr>
<td>time</td>
<td>3</td>
<td>-838:59:59</td>
<td>838:59:59</td>
</tr>
<tr>
<td>year</td>
<td>1</td>
<td>1901</td>
<td>2155</td>
</tr>
</tbody></table>
<p>重点为datatime和timestam。</p>
<h5 id="datetime和timestamp区别"><a href="#datetime和timestamp区别" class="headerlink" title="datetime和timestamp区别"></a>datetime和timestamp区别</h5><p>1、<strong>Timestamp</strong>支持的时间<strong>范围较小</strong>，取值范围：<br>    19700101080001——2038年的某个时间<br>    Datetime的取值范围：1000-1-1 ——9999-12-31<br>2、timestamp和<strong>实际时区</strong>有关，更能反映<strong>实际的日期</strong>，而datetime则只能反映出<strong>插入时的当地时区</strong><br>3、timestamp的属性受Mysql版本和SQLMode的影响很大</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_date(</span><br><span class="line">	t1 DATETIME,</span><br><span class="line">	t2 <span class="built_in">TIMESTAMP</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_date <span class="keyword">VALUES</span>(<span class="keyword">NOW</span>(),<span class="keyword">NOW</span>());</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tab_date;</span><br></pre></td></tr></table></figure>

<p>这时候出来结果相同，但是当更改时区后</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">time_zone</span>=<span class="string">'+9:00'</span>;<span class="comment">#从东八更改为东九</span></span><br></pre></td></tr></table></figure>

<p>这时候，timestamp类型数据存储的时间比datetime存储的时间快一个小时，随着时区而变化了。</p>
<h3 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h3><p>含义：一种限制，用于限制表中的数据，为了保证表中数据的准确和可靠性</p>
<p>分类：六大约束</p>
<ul>
<li><p>NOT NULL：非空，用于保证该字段的值不能为空</p>
<p>如姓名，学号等</p>
</li>
<li><p>DEFAULT：默认，用于保证该字段有默认值</p>
<p>如性别</p>
</li>
<li><p>PRIMARY KEY：主键，用于保证该字段的值有<strong>唯一性</strong>，且要<strong>非空</strong></p>
<p>如学号，员工编号等，可以多个列组合成一个主键</p>
<p>primary key(id,stuname)，插入值要求不能所有组成主键的列相同</p>
</li>
<li><p>UNIQUE：唯一，用于保证该字段的值具有唯一性，可以为空</p>
<p>如座位号，但<strong>最多只能有一个为空</strong></p>
</li>
<li><p>CHECK：检查约束【mysql不支持】</p>
<p>比如年龄，性别</p>
</li>
<li><p>FOREIGN KEY：外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值</p>
<p>在从表添加外键约束，用于引用主表中某列的值</p>
<p>如专业编号，员工表的部门编号，员工表的工种编号</p>
</li>
</ul>
<p><strong>一个字段可以添加多个约束，用空格隔开，无顺序要求</strong></p>
<p>添加约束的时机：</p>
<ol>
<li>创建表时</li>
<li>修改表时</li>
</ol>
<p>约束的添加分类：</p>
<ol>
<li><p>列级约束</p>
<p>六大约束语法上都支持，但外键约束没有效果</p>
</li>
<li><p>表级约束</p>
<p>除了<strong>非空</strong>，<strong>默认</strong>，其他都支持</p>
</li>
</ol>
<p>CREATE TABLE 表名(</p>
<p>​    字段名 字段类型 列级约束，</p>
<p>​    字段名 字段类型，</p>
<p>​    表级约束</p>
<p>)</p>
<h4 id="列级约束与表级约束"><a href="#列级约束与表级约束" class="headerlink" title="列级约束与表级约束"></a>列级约束与表级约束</h4><table>
<thead>
<tr>
<th></th>
<th>位置</th>
<th>支持的约束类型</th>
<th>是否可以起约束名</th>
</tr>
</thead>
<tbody><tr>
<td>列级约束</td>
<td>列的后面</td>
<td>语法都支持，但外键没有效果</td>
<td>不可以</td>
</tr>
<tr>
<td>表级约束</td>
<td>所有列下面</td>
<td>默认和非空不支持，其他支持</td>
<td>可以（对主键没有效果）</td>
</tr>
</tbody></table>
<h4 id="主键和唯一的对比【面试考-，重要】"><a href="#主键和唯一的对比【面试考-，重要】" class="headerlink" title="主键和唯一的对比【面试考 ，重要】"></a>主键和唯一的对比【面试考 ，重要】</h4><table>
<thead>
<tr>
<th></th>
<th>保证唯一性</th>
<th>是否允许为空</th>
<th>一个表中可以有多少个</th>
<th>是否允许组合</th>
</tr>
</thead>
<tbody><tr>
<td>主键</td>
<td>是</td>
<td>否</td>
<td>至多有1个</td>
<td>是，但不推荐</td>
</tr>
<tr>
<td>唯一</td>
<td>是</td>
<td>是，但最多一个为空</td>
<td>可以有多个</td>
<td>是，但不推荐</td>
</tr>
</tbody></table>
<h4 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h4><ol>
<li>要求在从表设置外键关系</li>
<li>从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求</li>
<li>主表的关联列<strong>必须是一个key</strong>（一般是<strong>主键</strong>或唯一）</li>
<li>插入数据时，先插入主表，再插入从表</li>
<li>删除数据时，先删除从表，再删除主表</li>
</ol>
<p>可通过以下两种方式删除主表的记录</p>
<p>方式一：级联删除</p>
<p>一般直接删除主表的信息不行因为要先删除从表，但加上级联删除后，直接删除主表信息后，从表信息也会被删除。</p>
<p>在添加外键的约束后加上on delete cascade</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stuinfo <span class="keyword">add</span> <span class="keyword">constraint</span> fk_stu_major <span class="keyword">foreign</span> <span class="keyword">key</span>(majorid) <span class="keyword">references</span> major(<span class="keyword">id</span>) <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">cascade</span>;</span><br></pre></td></tr></table></figure>

<p>方式二：级联置空</p>
<p>如果不想删除主表信息时从表信息也被删除，就是用级联置空，主表信息被删除后，从表相应位置信息置空</p>
<p>在添加外键的约束后加上on delete set null</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stuinfo <span class="keyword">add</span> <span class="keyword">constraint</span> fk_stu_major <span class="keyword">foreign</span> <span class="keyword">key</span>(majorid) <span class="keyword">references</span> major(<span class="keyword">id</span>) <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">set</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h4 id="创建表时添加约束"><a href="#创建表时添加约束" class="headerlink" title="创建表时添加约束"></a>创建表时添加约束</h4><p>1、添加列级约束</p>
<p>语法：</p>
<p>直接在字段名和类型后面追加约束类型即可</p>
<p>只支持：主键、唯一、默认、非空</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stuinfo(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,<span class="comment">#主键</span></span><br><span class="line">	stuName <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,<span class="comment">#非空</span></span><br><span class="line">	gender <span class="built_in">CHAR</span>(<span class="number">1</span>) <span class="keyword">CHECK</span>(gender <span class="keyword">IN</span> (<span class="string">'男'</span>,<span class="string">'女'</span>)),<span class="comment">#检查</span></span><br><span class="line">	seat <span class="built_in">INT</span> <span class="keyword">UNIQUE</span>,<span class="comment">#唯一</span></span><br><span class="line">	age <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">18</span>,<span class="comment">#默认约束</span></span><br><span class="line">	majorId <span class="built_in">INT</span> <span class="keyword">REFERENCES</span> major(<span class="keyword">id</span>)<span class="comment">#外键</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>外键在列级约束时没有用</strong>。主键，外键，唯一键自动生成索引，使用下面语句查看索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> stuinfo;</span><br></pre></td></tr></table></figure>

<p>2、添加表级约束</p>
<p>语法：在各个字段的最下面，constraint 约束名可省略</p>
<p>【constraint 约束名】 约束类型（字段名）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stuinfo(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">	stuName <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	gender <span class="built_in">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">	seat <span class="built_in">INT</span>,</span><br><span class="line">	age <span class="built_in">INT</span>,</span><br><span class="line">	majorId <span class="built_in">INT</span>,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> pk PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>),<span class="comment">#主键</span></span><br><span class="line">	<span class="keyword">CONSTRAINT</span> uk <span class="keyword">UNIQUE</span>(seat),<span class="comment">#唯一键</span></span><br><span class="line">	<span class="keyword">CONSTRAINT</span> ck <span class="keyword">CHECK</span>(gender <span class="keyword">IN</span> (<span class="string">'男'</span>,<span class="string">'女'</span>)),<span class="comment">#检查</span></span><br><span class="line">	<span class="keyword">CONSTRAINT</span> fk_stuinfo_major <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(majorid) <span class="keyword">REFERENCES</span> major(<span class="keyword">id</span>)<span class="comment">#外键</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>主键名是默认的，改了没有效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">外键名一般为fk_当前表名_主键名</span><br></pre></td></tr></table></figure>

<p>通用写法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> stuinfo(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">	stuname <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	gender <span class="built_in">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">	age <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">18</span>,</span><br><span class="line">	seat <span class="built_in">INT</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">	majorid <span class="built_in">INT</span>,</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> fk_stuinfo_major <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(majorid) <span class="keyword">REFERENCES</span> major(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="修改表时添加约束"><a href="#修改表时添加约束" class="headerlink" title="修改表时添加约束"></a>修改表时添加约束</h4><p>总结：</p>
<p>1、添加列级约束</p>
<p>alter table 表名 <strong>modify column</strong> 字段名 字段类型 新约束；</p>
<p>2、添加表级约束</p>
<p>alter table 表名 <strong>add</strong> 【constraint 约束名】 约束类型（字段名）【外键的引用】；</p>
<p>1、添加非空约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> stuname <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>2、添加默认约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> age <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure>

<p>3、添加主键</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、列级约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>;</span><br><span class="line"><span class="comment">#2、表级约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure>

<p>4、添加唯一键</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、列级约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> seat <span class="built_in">INT</span> <span class="keyword">UNIQUE</span>;</span><br><span class="line"><span class="comment">#2、表级约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span>(seat);</span><br></pre></td></tr></table></figure>

<p>5、添加外键</p>
<p>关键词为ADD，只有表级约束才有效果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(majorid) <span class="keyword">REFERENCES</span> major(<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure>

<h4 id="修改表时删除约束"><a href="#修改表时删除约束" class="headerlink" title="修改表时删除约束"></a>修改表时删除约束</h4><p>1、删除非空约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> stuname <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>2、删除默认约束</p>
<p>不加约束即可</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> age <span class="built_in">INT</span>;</span><br></pre></td></tr></table></figure>

<p>3、删除主键</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span>;</span><br></pre></td></tr></table></figure>

<p>4、删除唯一</p>
<p>drop index 唯一键名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">DROP</span> <span class="keyword">INDEX</span> seat;</span><br></pre></td></tr></table></figure>

<p>5、删除外键</p>
<p>drop foreign key 外键名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> fk_stuinfo_major;</span><br></pre></td></tr></table></figure>

<h3 id="标识列"><a href="#标识列" class="headerlink" title="标识列"></a>标识列</h3><p>又称为自增长列，关键字为auto_increament</p>
<p>含义：可以<strong>不用手动的插入值</strong>，系统提供默认的序列值，默认从1开始，步长为1</p>
<p>特点：</p>
<ol>
<li><p>标识列必须和<strong>key搭配</strong></p>
</li>
<li><p>一个表中<strong>至多</strong>有一个标识列</p>
</li>
<li><p>标识列的类型只能是<strong>数值型</strong></p>
</li>
<li><p>标识列可以通过SET auto_increment_increment=2;设置步长</p>
<p>可以通过手动插入值，设置起始值</p>
</li>
</ol>
<p>一、创建表时设置标识列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_identity(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">	<span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_identity <span class="keyword">VALUES</span>(<span class="literal">NULL</span>,<span class="string">'john'</span>);</span><br></pre></td></tr></table></figure>

<p>可以设置自增长的步长，一般不会改</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'%auto_increment%'</span>;</span><br><span class="line"><span class="keyword">SET</span> auto_increment_increment=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>二、修改表时设置标识列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tab_identity <span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT;</span><br></pre></td></tr></table></figure>

<p>三、修改表时删除标识列</p>
<p>去掉自增长列标识即可</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tab_identity <span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">INT</span>;</span><br></pre></td></tr></table></figure>

<h2 id="TCL语言"><a href="#TCL语言" class="headerlink" title="TCL语言"></a>TCL语言</h2><p>Transaction Control Language 事务控制语言</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务：</p>
<p>一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。每个sql语句是相互依赖的。整个单独单元作为一个不可分割的整体，如果单元中某条sql语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事务开始以前的状态；如果单元中的所有sql语句均执行成功，则事务被顺利执行。</p>
<h4 id="了解存储引擎"><a href="#了解存储引擎" class="headerlink" title="了解存储引擎"></a>了解存储引擎</h4><p>1、概念：在mysql中的数据用各种不同的技术存储在文件（或内存）中。</p>
<p>2、通过show engines;来查看mysql支持的存储引擎</p>
<p>3、在mysql中用的最多的存储引擎有：innodb，myisam，memory等。其中innodb支持事务，而myisam，memory等不支持事务</p>
<h4 id="事务的ACID（acid）属性【重要】"><a href="#事务的ACID（acid）属性【重要】" class="headerlink" title="事务的ACID（acid）属性【重要】"></a>事务的ACID（acid）属性【重要】</h4><p>事务的特性：</p>
<ol>
<li><p><strong>原子性</strong>（Atomicity）</p>
<p>原子性指事务是一个<strong>不可分割</strong>的工作单位，事务中的操作要么都发生，要么都不发生</p>
</li>
<li><p><strong>一致性</strong>（Consistency）</p>
<p>事务必须使数据库从一个一致性状态变换到另外一个一致性状态，保证数据的可靠性</p>
<p>数据要准确，可靠    </p>
</li>
<li><p><strong>隔离性</strong>（Isolation）</p>
<p>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。类似于锁？</p>
</li>
<li><p><strong>持久性</strong>（Durability）</p>
<p>持久性指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响</p>
</li>
</ol>
<h4 id="事务的创建"><a href="#事务的创建" class="headerlink" title="事务的创建"></a>事务的创建</h4><p><strong>隐式事务</strong>：事务没有明显的开启和结束的标记</p>
<p>比如insert、update、delete语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表 <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>显式事务</strong>：事务具有明显的开启和结束的标记</p>
<p>前提：必须先设置自动提交功能为禁用</p>
<p>只针对当前会话有效</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'%autocommit'</span>;</span><br><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>步骤1：开启事务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;<span class="comment">#可选的</span></span><br></pre></td></tr></table></figure>

<p>步骤2：编写事务中的sql语句（<strong>select insert update delete</strong>）</p>
<p>语句1；</p>
<p>语句2；</p>
<p>…</p>
<p>【设置回滚点：</p>
<p>savepoint 回滚点名;】</p>
<p>步骤3：结束事务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">commit</span>;提交事务</span><br><span class="line"><span class="keyword">rollback</span>;回滚事务</span><br><span class="line">[回滚到指定的地方：<span class="keyword">rollback</span> <span class="keyword">to</span> 回滚点名;]</span><br></pre></td></tr></table></figure>

<p>savepoint 节点名;#设置保存点</p>
<h5 id="演示事务的使用步骤"><a href="#演示事务的使用步骤" class="headerlink" title="演示事务的使用步骤"></a>演示事务的使用步骤</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、开启事务</span></span><br><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="comment">#2、编写sql语句</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> balance = <span class="number">500</span> <span class="keyword">WHERE</span> username=<span class="string">'张无忌'</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> balance = <span class="number">1500</span> <span class="keyword">WHERE</span> username=<span class="string">'赵敏'</span>;</span><br><span class="line"><span class="comment">#3、结束事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>如果使用commit，可以正常修改数据，如果使用的是rollback，那么对数据没有影响</p>
<h3 id="并发事务【重要】"><a href="#并发事务【重要】" class="headerlink" title="并发事务【重要】"></a>并发事务【重要】</h3><p>对于同时运行的<strong>多个事务</strong>，当这些事务访问<strong>数据库中相同的数据</strong>时，如果没有采取必要的隔离机制，就会导致各种并发问题： </p>
<ul>
<li><strong>脏读</strong>：对于两个事务T1、T2，T1读取了已经被T2更新但<strong>还没有提交</strong>的字段，之后若T2回滚，T1读取的内容就是<strong>临时且无效</strong>的</li>
<li><strong>不可重复读</strong>：对于两个事务T1、T2，T1读取了一个字段，然后T2更新了该字段，之后T1再次读取同一个字段，值就不同了</li>
<li><strong>幻读</strong>：对于两个事务T1、T2，T1从一个表中读取了一个字段，然后T2在该表中<strong>插入</strong>了一些新的行，之后如果T1再次读取同一个表，就会多出几行</li>
</ul>
<p>脏读与幻读相对比，脏读侧重于字段的<strong>更新</strong>，幻读侧重于行的<strong>插入</strong>。</p>
<h4 id="解决并发问题【重要】"><a href="#解决并发问题【重要】" class="headerlink" title="解决并发问题【重要】"></a>解决并发问题【重要】</h4><p><strong>数据库的隔离级别</strong>：数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题</p>
<p>数据库提供的4种事务隔离级别</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>READ UNCOMMITTED（读未提交数据）</td>
<td>允许事务读取未被其他事务提交的变更，<strong>脏读、不可重复度和幻读</strong>的问题都会出现</td>
</tr>
<tr>
<td>READ COMMITTED（读已提交数据）</td>
<td>只允许事务读取已经被其他事务提交的变更，可以避免脏读，但<strong>不可重复读和幻读</strong>问题仍可能出现</td>
</tr>
<tr>
<td>REPEATABLE READ（可重复读）</td>
<td>确保事务可以多次从一个字段中读取相同的值，在这个事务持续期间，禁止其他事务对这个字段进行更新，可以避免脏读和不可重复读，但<strong>幻读</strong>的问题仍然存在</td>
</tr>
<tr>
<td>SERIALIZABLE（串行化）</td>
<td>确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入，更新和删除操作，所有并发问题都可以避免，但性能十分低下</td>
</tr>
</tbody></table>
<p>Oracle支持的2种事务级别：<strong>READ COMMITTED</strong>，SERIALIZABLE。Oracle默认的事务隔离级别为READ COMMITTED</p>
<p>Mysql支持4种事务级别，Mysql默认的事务隔离级别为<strong>REPETABLE READ</strong></p>
<h4 id="具体演示"><a href="#具体演示" class="headerlink" title="具体演示"></a>具体演示</h4><p>查看当前隔离级别</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @@tx_isolation;</span><br><span class="line">8.0后改为<span class="keyword">select</span> @@transaction_isolation;</span><br></pre></td></tr></table></figure>

<p>将隔离级别设置成最低</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> uncommitted;</span><br></pre></td></tr></table></figure>

<p>如果中文显示为乱码，更改字符集</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">names</span> gbk;</span><br></pre></td></tr></table></figure>

<p>这时候如果开启两个事务，一个将表中姓名更改但没有提交，这时候另一个事务去读表中内容，读到了没有提交的内容，当事务1回滚，再次读的时候事务2仍读到原来的，出现脏读。</p>
<p>当更改事务1的隔离级别为读已提交，更改数据但不提交，更改事务2的隔离级别为读已提交，查看表中数据，无法看到表格修改的内容。因此脏读被避免。但当事务1提交后，事务2再查看表中内容，发现两次看的数据不一样，出现不可重复读。</p>
<p>当更改事务1和2的隔离级别为可重复读，更改事务1的数据但不提交，事务2查看表中数据，为未修改前的；当事务1提交，事务2查看仍是未修改的。只有事务2提交后，再次查看才是修改后的。解决了脏读和不可重复读。但当事务1要更改所有行数据的名字，还未执行，在此时事务2插入了一条数据并commit了，这样当事务1执行的时候多影响到了事务2插入的这一条数据，有幻读出现。只有执行插入语句的事务提交后，事务1的更改语句才能执行成功。</p>
<p>当事务1,2的隔离级别修改为串行化后，当事务1，2均开启，事务1要执行update操作，事务2执行插入语句，但无法执行成功，只有事务1提交后，事务2才能执行。一次只能执行一个事务。</p>
<p>经过试验，在最高等级下，哪个事务先被开启不重要，如果同时有两个事务被开启，事务1要执行插入操作，事务2没有执行sql语句，此时事务1的插入操作可以成功；但一旦事务2执行了sql语句，插入操作便不能成功，当插入数据的事务没有提交前，其他事务不能进行查询操作。小结：只要其他表使用了sql语句查看or操作表，修改表的操作就不能被执行；只要有其他事务修改了表，就不能查看表。看了不能改，改了不能看。</p>
<h4 id="Mysql中设置隔离级别"><a href="#Mysql中设置隔离级别" class="headerlink" title="Mysql中设置隔离级别"></a>Mysql中设置隔离级别</h4><ul>
<li><p>每启动一个mysql程序，就会获得一个单独的数据库连接，每个数据库连接都有一个全局变量@@tx_isolation，表示当前的事务隔离级别</p>
</li>
<li><p>查看当前的隔离级别：select @@tx_isolation;</p>
</li>
<li><p>设置当前mysql连接的隔离级别</p>
<p>set session transaction isolation level <strong>read uncommitted</strong>;将其替换为需要的级别</p>
</li>
<li><p>设置数据库的全局隔离级别</p>
<p>set <strong>global</strong> transaction isolation level <strong>read uncommitted</strong>;</p>
</li>
</ul>
<h4 id="delete和truncate在事务使用时的区别"><a href="#delete和truncate在事务使用时的区别" class="headerlink" title="delete和truncate在事务使用时的区别"></a>delete和truncate在事务使用时的区别</h4><p>delete和truncate是针对数据的操作语言，而不是针对表结构的，要删除表使用drop table，删除数据使用delete from 表名和truncate table 表名。</p>
<p>演示delete</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">account</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<p>数据并没有被删除。</p>
<p>演示truncate</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> <span class="keyword">account</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<p>这时候数据仍然被删除了，没有回滚。因此truncate不支持回滚。</p>
<h4 id="savepoint的使用"><a href="#savepoint的使用" class="headerlink" title="savepoint的使用"></a>savepoint的使用</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">account</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SAVEPOINT</span> a;<span class="comment">#设置保存点</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">account</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> a;<span class="comment">#回滚至保存点</span></span><br></pre></td></tr></table></figure>

<p>savepoint搭配rollback使用，回滚到保存点，因此id=1的行被删除，但是id=3的行没有。</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>含义：虚拟表，和普通表一起使用</p>
<p>mysql5.1版本出现的新特性，行和列的数据来自自定义视图的查询中使用的表，并且是在使用视图时<strong>动态生成</strong>的，<strong>只保存了sql逻辑，不保存查询结果</strong></p>
<p>应用场景：</p>
<ul>
<li>多个地方用到<strong>同样的查询结果</strong></li>
<li>该查询结果使用的sql语句<strong>较复杂</strong></li>
</ul>
<p>好处：</p>
<p>1、简化了sql语句</p>
<p>2、提高了sql的重用性</p>
<p>3、保护了基表的数据，提高了安全性    </p>
<p>案例：查询姓张的学生名和专业名</p>
<p>以前的做法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> stuname,majorName</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`stuinfo`</span> s</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="string">`major`</span> m <span class="keyword">ON</span> s.<span class="string">`majorId`</span>=m.<span class="string">`id`</span></span><br><span class="line"><span class="keyword">WHERE</span> stuname <span class="keyword">LIKE</span> <span class="string">'张%'</span>;</span><br></pre></td></tr></table></figure>

<p>现在可以将常用的语句封装为视图</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v1</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> stuname,majorName</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`stuinfo`</span> s</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="string">`major`</span> m <span class="keyword">ON</span> s.<span class="string">`majorId`</span>=m.<span class="string">`id`</span>;</span><br></pre></td></tr></table></figure>

<p>要调用的时候</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> v1 <span class="keyword">WHERE</span> stuname <span class="keyword">LIKE</span> <span class="string">'张%'</span>;</span><br></pre></td></tr></table></figure>

<h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><p>语法：</p>
<p>create view 视图名</p>
<p>as</p>
<p>查询语句;</p>
<p>1、查询姓名中包含a字符的员工名、部门名和工种信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myv1</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name,job_title</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`employees`</span> e</span><br><span class="line"><span class="keyword">JOIN</span> <span class="string">`departments`</span> d <span class="keyword">ON</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">JOIN</span><span class="string">`jobs`</span> j <span class="keyword">ON</span> j.<span class="string">`job_id`</span>=e.<span class="string">`job_id`</span>;</span><br><span class="line"><span class="comment">#2、使用</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> myv1 <span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">'%a%'</span>;</span><br></pre></td></tr></table></figure>

<p>2、查询各部门的平均工资级别</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、创建视图查看每个部门的平均工资</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myv2</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary) ag,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"><span class="comment">#2、使用</span></span><br><span class="line"><span class="keyword">SELECT</span> myv2.<span class="string">`ag`</span>,g.grade_level</span><br><span class="line"><span class="keyword">FROM</span> myv2</span><br><span class="line"><span class="keyword">JOIN</span> job_grades g</span><br><span class="line"><span class="keyword">ON</span> myv2.<span class="string">`ag`</span> <span class="keyword">BETWEEN</span> g.<span class="string">`lowest_sal`</span> <span class="keyword">AND</span> g.<span class="string">`highest_sal`</span>;</span><br></pre></td></tr></table></figure>

<p>3、查询平均工资最低的部门信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#平均工资视图已经被创建</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> myv2 <span class="keyword">ORDER</span> <span class="keyword">BY</span> myv2.<span class="string">`ag`</span> <span class="keyword">ASC</span> <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>4、查询平均工资最低的部门名和工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建平均工资最低的部门id表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myv3</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> myv2 <span class="keyword">ORDER</span> <span class="keyword">BY</span> myv2.<span class="string">`ag`</span> <span class="keyword">ASC</span> <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">#将视图与部门表进行连接</span></span><br><span class="line"><span class="keyword">SELECT</span> d.*,m.ag</span><br><span class="line"><span class="keyword">FROM</span> myv3 m</span><br><span class="line"><span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> m.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span>;</span><br></pre></td></tr></table></figure>

<h3 id="视图的好处"><a href="#视图的好处" class="headerlink" title="视图的好处"></a>视图的好处</h3><ul>
<li>重用sql语句</li>
<li>简化复杂的sql操作，不必知道其细节</li>
<li>保护数据，提高安全性</li>
</ul>
<h3 id="视图的修改"><a href="#视图的修改" class="headerlink" title="视图的修改"></a>视图的修改</h3><p>方式一：</p>
<p>意思为存在就替代，不存在就创建</p>
<p><strong>create or replace</strong> view 视图名</p>
<p>as</p>
<p>查询语句;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">VIEW</span> myv3</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary),job_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id;</span><br></pre></td></tr></table></figure>

<p>方式二：</p>
<p>语法：</p>
<p>alter view 视图名</p>
<p>as</p>
<p>查询语句;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> myv3</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<h3 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h3><p>语法：</p>
<p><strong>drop view</strong> 视图名，视图名，…;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> myv1,myv2,myv3;</span><br></pre></td></tr></table></figure>

<h3 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DESC myv3;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myv3;</span><br></pre></td></tr></table></figure>

<h3 id="视图练习"><a href="#视图练习" class="headerlink" title="视图练习"></a>视图练习</h3><p>1、创建视图emp_v1，要求查询电话号码以011开头的员工姓名和工资、邮箱</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">VIEW</span> emp_v1</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary,email</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> phone_number <span class="keyword">LIKE</span> <span class="string">'011%'</span>;</span><br></pre></td></tr></table></figure>

<p>不能先创建没有phone筛选的视图再调用视图筛选，因为视图中没有phone这一列。</p>
<p>2、创建视图emp_v2，要求查询的部门最高工资高于12000的部门信息</p>
<p>之前做法：先得到部门最高工资高于12000的工资和编号表，然后和部门表连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> d.*,m.mx</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">JOIN</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary) mx,department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">	<span class="keyword">HAVING</span> <span class="keyword">MAX</span>(salary)&gt;<span class="number">12000</span></span><br><span class="line">) <span class="keyword">AS</span> m</span><br><span class="line"><span class="keyword">ON</span> d.department_id=m.department_id;</span><br></pre></td></tr></table></figure>

<p>视图的做法，先将部门最高工资高于12000的工资和编号表作为视图，然后用视图和部门表连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> emp_v2</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary) mx,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">MAX</span>(salary)&gt;<span class="number">12000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> d.*,emp_v2.mx</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">JOIN</span> emp_v2</span><br><span class="line"><span class="keyword">ON</span> d.department_id=emp_v2.department_id;</span><br></pre></td></tr></table></figure>

<h3 id="视图的更新"><a href="#视图的更新" class="headerlink" title="视图的更新"></a>视图的更新</h3><p>对视图的数据更新，而不是结构。一般给视图添加权限，只允许读，不允许写。</p>
<p>视图的可更新性和视图中查询的定义有关系，以下类型的视图是不允许更新的</p>
<ul>
<li>包含以下关键字的sql语句：分组函数、distinct、group by、having、union或者union all</li>
<li>常量视图</li>
<li>select中包含子查询</li>
<li>join</li>
<li>from一个不能更新的视图</li>
<li>where子句的子查询引用了from子句中的表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">VIEW</span> myv1</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,email</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>1、插入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> myv1 <span class="keyword">VALUES</span>(<span class="string">'张飞'</span>,<span class="string">'zf@qq.com'</span>);</span><br></pre></td></tr></table></figure>

<p>此时在原始的employees表中也插入了数据。</p>
<p>2、修改</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> myv1 <span class="keyword">SET</span> last_name=<span class="string">'张无忌'</span> <span class="keyword">WHERE</span> last_name=<span class="string">'张飞'</span>;</span><br></pre></td></tr></table></figure>

<p>原始表依然被更改了</p>
<p>3、删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> myv1 <span class="keyword">WHERE</span> last_name=<span class="string">'张无忌'</span>;</span><br></pre></td></tr></table></figure>

<h3 id="视图与表的比较"><a href="#视图与表的比较" class="headerlink" title="视图与表的比较"></a>视图与表的比较</h3><table>
<thead>
<tr>
<th></th>
<th>创建语法的关键字</th>
<th>是否实际占用屋里空间</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>视图</td>
<td>create view</td>
<td>只是保存了sql逻辑</td>
<td>一般仅用来查</td>
</tr>
<tr>
<td>表</td>
<td>create table</td>
<td>保存了数据</td>
<td>增删改查</td>
</tr>
</tbody></table>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>系统变量</p>
<ul>
<li><p>全局变量</p>
<p>作用域：服务器每次启动将为所有的全局变量赋初始值，针对于所有的会话（连接）有效，但不能跨重启。</p>
</li>
<li><p>会话变量</p>
<p>作用域：仅仅针对于当前会话（连接）有效</p>
</li>
</ul>
<p>自定义变量</p>
<ul>
<li>用户变量</li>
<li>局部变量</li>
</ul>
<h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>说明：变量由系统提供，不是用户定义，属于服务器层面</p>
<p>使用的语法    ：</p>
<p>1、查看所有的系统变量</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> <span class="keyword">VARIABLES</span>;<span class="comment">#全局变量</span></span><br><span class="line"><span class="keyword">SHOW</span> 【<span class="keyword">SESSION</span>】 <span class="keyword">VARIABLES</span>;<span class="comment">#会话变量</span></span><br></pre></td></tr></table></figure>

<p>2、查看满足条件的部分系统变量</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span>|[<span class="keyword">SESSION</span>] <span class="keyword">VARIABLES</span> <span class="keyword">like</span> <span class="string">'%查询字符%'</span>;</span><br></pre></td></tr></table></figure>

<p>3、查看指定的某个系统变量的值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @@global.系统变量名;<span class="comment">#全局变量</span></span><br><span class="line"><span class="keyword">select</span> @@[session.]系统变量名;<span class="comment">#会话变量</span></span><br></pre></td></tr></table></figure>

<p>4、为某个系统变量赋值</p>
<p>方式一：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span>|【<span class="keyword">session</span>】 系统变量名=值;</span><br></pre></td></tr></table></figure>

<p>方式二：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @@<span class="keyword">global</span>|【<span class="keyword">session</span>】 .系统变量名=值;</span><br></pre></td></tr></table></figure>

<p>注意：如果是全局级别，则需要加global，如果是会话级别，则需要加session，如果不写，则默认session</p>
<h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>说明：变量是用户自定义的，不是由系统定义的。</p>
<p>使用步骤：</p>
<p>声明</p>
<p>赋值</p>
<p>使用（查看、比较、运算等）</p>
<p>1、用户变量</p>
<p>作用域：针对于当前的会话（连接）有效，同于会话变量的作用域</p>
<p>应用在任何地方，也就是begin end里面或者外面</p>
<p>赋值的操作符：=或:=</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、声明并初始化</span></span><br><span class="line"><span class="keyword">SET</span> @用户变量名=值;或</span><br><span class="line"><span class="keyword">SET</span> @用户变量名:=值;或</span><br><span class="line"><span class="keyword">SELECT</span> @用户变量名:=值;</span><br><span class="line"><span class="comment">#2、赋值（更新用户变量的值）</span></span><br><span class="line">方式一：通过<span class="keyword">SET</span>或<span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">SET</span> @用户变量名=值;或</span><br><span class="line">    <span class="keyword">SET</span> @用户变量名:=值;或</span><br><span class="line">    <span class="keyword">SELECT</span> @用户变量名:=值;</span><br><span class="line">方式二：通过<span class="keyword">SELECT</span> <span class="keyword">INTO</span></span><br><span class="line">    <span class="keyword">SELECT</span> 字段 <span class="keyword">INTO</span> @变量名</span><br><span class="line">    <span class="keyword">FROM</span> 表;</span><br><span class="line"><span class="comment">#3、使用（查看用户变量的值）</span></span><br><span class="line">    <span class="keyword">SELECT</span> @用户变量名;</span><br></pre></td></tr></table></figure>

<p>2、局部变量</p>
<p>作用域：仅仅在定义它的begin end中有效</p>
<p>应用在 begin end中的第一句话</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1、声明</span><br><span class="line">  <span class="keyword">DECLARE</span> 变量名 类型;</span><br><span class="line">  <span class="keyword">DECLARE</span> 变量名 类型 <span class="keyword">DEFAULT</span> 值;</span><br><span class="line">2、赋值</span><br><span class="line">  方式一：通过<span class="keyword">SET</span>或<span class="keyword">SELECT</span></span><br><span class="line">      <span class="keyword">SET</span> 局部变量名=值;或</span><br><span class="line">      <span class="keyword">SET</span> 局部变量名:=值;或</span><br><span class="line">      <span class="keyword">SELECT</span> @局部变量名:=值;</span><br><span class="line">  方式二：通过<span class="keyword">SELECT</span> <span class="keyword">INTO</span></span><br><span class="line">      <span class="keyword">SELECT</span> 字段 <span class="keyword">INTO</span> 局部变量名</span><br><span class="line">      <span class="keyword">FROM</span> 表;</span><br><span class="line">3、使用</span><br><span class="line">  <span class="keyword">SELECT</span> 局部变量名;</span><br></pre></td></tr></table></figure>

<h4 id="对比用户变量和局部变量"><a href="#对比用户变量和局部变量" class="headerlink" title="对比用户变量和局部变量"></a>对比用户变量和局部变量</h4><table>
<thead>
<tr>
<th></th>
<th>作用域</th>
<th>定义和使用的位置</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td>用户变量</td>
<td>当前会话</td>
<td>会话中的任何地方</td>
<td>必须加@符号</td>
</tr>
<tr>
<td>局部变量</td>
<td>BEGIN END中</td>
<td>只能在BEGIN END 中，且为第一句话</td>
<td>一般不用加@符号，需要限定类型</td>
</tr>
</tbody></table>
<p>案例：声明两个变量并赋初值，求和，并打印</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、用户变量</span></span><br><span class="line"><span class="keyword">SET</span> @m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> @n = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">sum</span> = @m + @n;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">sum</span>;</span><br><span class="line"><span class="comment">#语法报错，需要使用在BEGIN END中</span></span><br><span class="line"><span class="comment">#2、局部变量</span></span><br><span class="line"><span class="keyword">DECLARE</span> m <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> n <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="keyword">SUM</span> <span class="built_in">INT</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">SUM</span>=m+n;</span><br></pre></td></tr></table></figure>

<h2 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h2><p>类似Java中的方法</p>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><h4 id="存储过程创建与调用"><a href="#存储过程创建与调用" class="headerlink" title="存储过程创建与调用"></a>存储过程创建与调用</h4><p>含义：一组预先编译好的SQL语句的集合，理解成批处理语句</p>
<p>好处：</p>
<ol>
<li>提高代码的重用性</li>
<li>简化操作</li>
<li>减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</li>
</ol>
<p>一、创建语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">create procedure 存储过程名(in|out|inout 参数名  参数类型,...)</span><br><span class="line">begin</span><br><span class="line">	存储过程体（一组合法的SQL语句）</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>1、参数列表包括三部分</p>
<p>参数模式 参数名 参数类型</p>
<p>举例：</p>
<p>IN stuname VARCHAR(20)</p>
<p>参数模式：</p>
<p>IN：该参数可以作为输入，即该参数需要调入方传入值</p>
<p>OUT：该参数可以作为输出，即该参数可以作为返回值</p>
<p>INOUT：该参数即可以作为输入又可以作为输出，该参数既需要传入值，又可以返回值</p>
<p>2、如果存储过程体只有一句话，begin end可以省略</p>
<p>存储过程中的每条sql语句的结尾必须加分号。存储过程的结尾可以使用DELIMITER重新设置</p>
<p>语法：</p>
<p>DELIMITER 结束标记</p>
<p>DELIMITER $</p>
<p>二、调用语法</p>
<p>CALL 存储过程名（实参列表）；</p>
<p>1、空参列表</p>
<p>案例：插入到admin表中5条记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、创建存储过程</span></span><br><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> myp1()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">admin</span>(username,<span class="string">`password`</span>)</span><br><span class="line">	<span class="keyword">VALUES</span>(<span class="string">'john1'</span>,<span class="string">'0000'</span>),(<span class="string">'lili'</span>,<span class="string">'0000'</span>),(<span class="string">'rose'</span>,<span class="string">'0000'</span>),(<span class="string">'jack'</span>,<span class="string">'0000'</span>),(<span class="string">'tom'</span>,<span class="string">'0000'</span>);</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"><span class="comment">#2、调用</span></span><br><span class="line"><span class="keyword">CALL</span> myp1()$</span><br></pre></td></tr></table></figure>

<p>2、创建带in模式参数的存储过程</p>
<p>案例1：创建存储过程实现根据女神名，查询对应的男神信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、创建</span></span><br><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> myp2(<span class="keyword">IN</span> beautyName <span class="built_in">VARCHAR</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> bo.*</span><br><span class="line">	<span class="keyword">FROM</span> boys bo</span><br><span class="line">	<span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> beauty b</span><br><span class="line">	<span class="keyword">ON</span> bo.id = b.<span class="string">`boyfriend_id`</span></span><br><span class="line">	<span class="keyword">WHERE</span> b.name=beautyName;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"><span class="comment">#2、调用</span></span><br><span class="line"><span class="keyword">CALL</span> myp2(<span class="string">'小昭'</span>);</span><br></pre></td></tr></table></figure>

<p>案例2：创建存储过程实现用户是否登录成功</p>
<p>思路：先创建存储过程来查询表中与输入信息相同的个数（count(*)），然后为了将个数赋值给变量，声明了int类型的变量result，然后用if语句来判断如果个数&gt;0，则输出成功。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> myp4(<span class="keyword">IN</span> username <span class="built_in">VARCHAR</span>(<span class="number">20</span>),<span class="keyword">IN</span> <span class="keyword">PASSWORD</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="comment">#声明并初始化</span></span><br><span class="line">	<span class="keyword">DECLARE</span> <span class="keyword">result</span> <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">INTO</span> <span class="keyword">result</span><span class="comment">#赋值 select into用法</span></span><br><span class="line">	<span class="keyword">FROM</span> <span class="keyword">admin</span> </span><br><span class="line">	<span class="comment">#出现冲突时，使用表名.变量名的形式</span></span><br><span class="line">	<span class="keyword">WHERE</span> admin.username = username</span><br><span class="line">	<span class="keyword">AND</span> admin.password = <span class="keyword">PASSWORD</span>;</span><br><span class="line">	<span class="comment">#使用</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">IF</span>(<span class="keyword">result</span>&gt;<span class="number">0</span>,<span class="string">'成功'</span>,<span class="string">'失败'</span>);</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> myp4(<span class="string">'张飞'</span>,<span class="string">'8888'</span>);</span><br></pre></td></tr></table></figure>

<p>3、创建带out模式的存储过程</p>
<p>案例1：根据女神名，返回对应的男神名</p>
<p>思路：查询后的结果利用select into 参数名进行传递，然后调用时可以定义用户变量在begin end外面接收，然后输出即可。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> myp5(<span class="keyword">IN</span> beautyName <span class="built_in">VARCHAR</span>(<span class="number">20</span>),<span class="keyword">OUT</span> boyName <span class="built_in">VARCHAR</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> bo.<span class="string">`boyName`</span> <span class="keyword">INTO</span> boyName</span><br><span class="line">	<span class="keyword">FROM</span> <span class="string">`boys`</span> bo</span><br><span class="line">	<span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="string">`beauty`</span> b</span><br><span class="line">	<span class="keyword">ON</span> bo.<span class="string">`id`</span> = b.<span class="string">`boyfriend_id`</span></span><br><span class="line">	<span class="keyword">WHERE</span> b.<span class="string">`name`</span>=beautyName;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line"><span class="keyword">SET</span> @bName;</span><br><span class="line"><span class="keyword">CALL</span> myp5(<span class="string">'小昭'</span>,@bName);</span><br><span class="line"><span class="keyword">SELECT</span> @bName;</span><br></pre></td></tr></table></figure>

<p>案例2：根据女神名，返回对应的男神名和男神魅力值</p>
<p>注意：为了输出多个OUT，需要在select写完后，再INTO后面加变量1，变量2。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> myp6(<span class="keyword">IN</span> beautyName <span class="built_in">VARCHAR</span>(<span class="number">20</span>),<span class="keyword">OUT</span> boyName <span class="built_in">VARCHAR</span>(<span class="number">20</span>),<span class="keyword">OUT</span> userCP <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> bo.<span class="string">`boyName`</span> ,bo.<span class="string">`userCP`</span> <span class="keyword">INTO</span> boyName,userCP</span><br><span class="line">	<span class="keyword">FROM</span> <span class="string">`boys`</span> bo</span><br><span class="line">	<span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="string">`beauty`</span> b</span><br><span class="line">	<span class="keyword">ON</span> bo.<span class="string">`id`</span> = b.<span class="string">`boyfriend_id`</span></span><br><span class="line">	<span class="keyword">WHERE</span> b.<span class="string">`name`</span>=beautyName;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> myp6(<span class="string">'小昭'</span>,@bName,@userCP);</span><br><span class="line"><span class="keyword">SELECT</span> @bName,@userCP;</span><br></pre></td></tr></table></figure>

<p>4、创建带inout模式参数的存储过程</p>
<p>案例1：传入a和b两个值，最终a和b都翻倍并返回</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> myp7(INOUT a <span class="built_in">INT</span>, INOUT b <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SET</span> a=a*<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">SET</span> b=b*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @m=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">SET</span> @n=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">CALL</span> myp7(@m,@n);</span><br><span class="line"><span class="keyword">SELECT</span> @m,@n;</span><br></pre></td></tr></table></figure>

<h4 id="存储过程删除"><a href="#存储过程删除" class="headerlink" title="存储过程删除"></a>存储过程删除</h4><p>语法：drop procedure 存储过程名</p>
<h4 id="查看存储过程的信息"><a href="#查看存储过程的信息" class="headerlink" title="查看存储过程的信息"></a>查看存储过程的信息</h4><p>show create procedure 存储过程名</p>
<h4 id="存储过程练习"><a href="#存储过程练习" class="headerlink" title="存储过程练习"></a>存储过程练习</h4><p>1、创建存储过程实现传入用户名和密码，插入到admin表中</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_pro1(<span class="keyword">IN</span> username <span class="built_in">VARCHAR</span>(<span class="number">20</span>), <span class="keyword">IN</span> <span class="keyword">PASSWORD</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">admin</span>(admin.username,admin.<span class="string">`password`</span>)</span><br><span class="line">	<span class="keyword">VALUES</span>(username,<span class="keyword">PASSWORD</span>);</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> test_pro1(<span class="string">'admin'</span>,<span class="string">'0000'</span>);</span><br></pre></td></tr></table></figure>

<p>2、创建存储过程或函数实现传入女神编号，返回女神名称和女神电话</p>
<p>有复制，用select 字段 into 变量名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_pro2(<span class="keyword">IN</span> beautyID <span class="built_in">INT</span>,<span class="keyword">OUT</span> beautyName <span class="built_in">VARCHAR</span>(<span class="number">20</span>),<span class="keyword">OUT</span> beautyPhone <span class="built_in">VARCHAR</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="string">`name`</span> ,<span class="string">`phone`</span> <span class="keyword">INTO</span> beautyName,beautyPhone</span><br><span class="line">	<span class="keyword">FROM</span> <span class="string">`beauty`</span></span><br><span class="line">	<span class="keyword">WHERE</span> <span class="keyword">id</span>=beautyID;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> test_pro2(<span class="number">12</span>,@<span class="keyword">name</span>,@phone);</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">name</span>,@phone;</span><br></pre></td></tr></table></figure>

<p>3、创建存储过程或函数实现传入两个女神生日，返回大小</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_pro3(<span class="keyword">IN</span> birth1 DATETIME, <span class="keyword">IN</span> birth2 DATETIME, <span class="keyword">OUT</span> <span class="keyword">result</span> <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DATEDIFF</span>(birth1,birth2) <span class="keyword">INTO</span> <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> test_pro3(<span class="string">'1988-1-1'</span>,<span class="keyword">NOW</span>(),@<span class="keyword">result</span>);</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">result</span>;</span><br></pre></td></tr></table></figure>

<p>4、创建存储过程或函数传入一个日期，格式化成xx年xx月xx日并返回</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_pro4(<span class="keyword">IN</span> mydate DATETIME, <span class="keyword">OUT</span> <span class="keyword">str</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>(mydate,<span class="string">'%y年%m月%d日'</span>) <span class="keyword">INTO</span> <span class="keyword">str</span>;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> test_pro4(<span class="keyword">NOW</span>(),@<span class="keyword">str</span>);</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">str</span>;</span><br></pre></td></tr></table></figure>

<p>5、创建存储过程或函数传入女神名称，返回：女神 and 男神 格式的字符串</p>
<p>如：传入 小昭</p>
<p>返回：小昭 and 张无忌</p>
<p>思路：正常查询，其中字符串拼接使用CONCAT函数，中间用逗号隔开，输出存入变量，查询用右外连接，加上筛选条件。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_pro5(<span class="keyword">IN</span> beautyName <span class="built_in">VARCHAR</span>(<span class="number">20</span>), <span class="keyword">OUT</span> <span class="keyword">str</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(beautyName,<span class="string">' and '</span>,boyName) <span class="keyword">INTO</span> <span class="keyword">str</span></span><br><span class="line">	<span class="keyword">FROM</span> boys bo</span><br><span class="line">	<span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> beauty b</span><br><span class="line">	<span class="keyword">ON</span> bo.id=b.boyfriend_id</span><br><span class="line">	<span class="keyword">WHERE</span> b.name=beautyName;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> test_pro5(<span class="string">'小昭'</span>,@<span class="keyword">str</span>);</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">str</span>;</span><br></pre></td></tr></table></figure>

<p>但是这样写的话，当boyName为null的时候，拼接在一起也是null，因此最好使用ifnull来进行判断，只要有为空可能的字段，要是跟其他字符串拼接或者要使用它，最好加上IFNULL判断。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_pro5(<span class="keyword">IN</span> beautyName <span class="built_in">VARCHAR</span>(<span class="number">20</span>), <span class="keyword">OUT</span> <span class="keyword">str</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(beautyName,<span class="string">' and '</span>,<span class="keyword">IFNULL</span>(boyName,<span class="string">'null'</span>)) <span class="keyword">INTO</span> <span class="keyword">str</span></span><br><span class="line">	<span class="keyword">FROM</span> boys bo</span><br><span class="line">	<span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> beauty b</span><br><span class="line">	<span class="keyword">ON</span> bo.id=b.boyfriend_id</span><br><span class="line">	<span class="keyword">WHERE</span> b.name=beautyName;</span><br><span class="line"><span class="keyword">END</span> $</span><br></pre></td></tr></table></figure>

<p>6、创建存储过程或函数，根据传入的条目数和起始索引，查询beauty表的记录</p>
<p>其中用到了分页，limit 【offset】，size</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_pro6(<span class="keyword">IN</span> <span class="keyword">size</span> <span class="built_in">INT</span>, <span class="keyword">IN</span> startIndex <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> beauty <span class="keyword">LIMIT</span> startIndex,<span class="keyword">size</span>;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> test_pro6(<span class="number">3</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>与存储过程的区别是：</p>
<ul>
<li>存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新</li>
<li>函数：有且仅有1个返回，适合做处理数据后返回一个结果</li>
</ul>
<h4 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h4><p>1、创建语法</p>
<p>create function 函数名（参数列表）<strong>returns</strong> 返回类型</p>
<p>begin</p>
<p>​    函数体</p>
<p>end</p>
<p>注意：</p>
<ul>
<li><p>参数列表包含两部分，参数名  参数类型</p>
</li>
<li><p>函数体：肯定会有return语句，如果没有会报错，如果return语句不放在函数体最后不报错，但不建议</p>
</li>
<li><p>函数体中仅有一句话，可以省略begin end</p>
</li>
<li><p>使用delimiter语句设置结束标记</p>
</li>
</ul>
<h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>执行语句并显示返回值</p>
<p>语法：</p>
<p>select 函数名（参数列表）</p>
<p>1、无参有返回</p>
<p>案例：返回公司的员工个数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> myf1() <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> c <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;<span class="comment">#定义变量</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">INTO</span> c<span class="comment">#赋值</span></span><br><span class="line">	<span class="keyword">FROM</span> employees;</span><br><span class="line">	RETURN c;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line"><span class="keyword">SELECT</span> myf1();</span><br></pre></td></tr></table></figure>

<p>2、有参有返回</p>
<p>案例1：根据员工名，返回它的工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> myf2(empName <span class="built_in">VARCHAR</span>(<span class="number">20</span>)) <span class="keyword">RETURNS</span> <span class="keyword">DOUBLE</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SET</span> @sal=<span class="number">0</span>;<span class="comment">#定义用户变量</span></span><br><span class="line">	<span class="keyword">SELECT</span> salary <span class="keyword">INTO</span> @sal<span class="comment">#赋值</span></span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> last_name = empName;</span><br><span class="line">	RETURN @sal;<span class="comment">#返回值</span></span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> myf2(<span class="string">'Kochhar'</span>);</span><br></pre></td></tr></table></figure>

<p>案例2：根据部门名，返回该部门的平均工资</p>
<p>规律：</p>
<ul>
<li>记得写returns 变量 类型</li>
<li>在begin end中定义变量（declare sal double）or （set @sal double）</li>
<li>利用select 字段 into 变量赋值</li>
<li>最后return 变量。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> myf3(depName <span class="built_in">VARCHAR</span>(<span class="number">20</span>)) <span class="keyword">RETURNS</span> <span class="keyword">DOUBLE</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="comment">#定义返回值</span></span><br><span class="line">	<span class="keyword">DECLARE</span> sal <span class="keyword">DOUBLE</span>;</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary) <span class="keyword">INTO</span> sal</span><br><span class="line">	<span class="keyword">FROM</span> employees e</span><br><span class="line">	<span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span></span><br><span class="line">	<span class="keyword">WHERE</span> d.<span class="string">`department_name`</span>= depName;</span><br><span class="line">	RETURN sal;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> myf3(<span class="string">'IT'</span>);</span><br></pre></td></tr></table></figure>

<h4 id="查看函数"><a href="#查看函数" class="headerlink" title="查看函数"></a>查看函数</h4><p>语法</p>
<p>show create function 函数名;</p>
<h4 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h4><p>语法</p>
<p>drop function 函数名；</p>
<h4 id="函数练习"><a href="#函数练习" class="headerlink" title="函数练习"></a>函数练习</h4><p>案例：创建函数，实现传入两个float，返回二者之和</p>
<p>这里给变量赋值，可以使用set 变量=语句，也可以使用select 语句 into 变量名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> myf4(num1 <span class="built_in">FLOAT</span>,num2 <span class="built_in">FLOAT</span>) <span class="keyword">RETURNS</span> <span class="built_in">FLOAT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> num3 <span class="built_in">FLOAT</span>;</span><br><span class="line">	<span class="keyword">SET</span> num3 = num1 + num2;</span><br><span class="line">	RETURN num3;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> myf4(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h2 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h2><ul>
<li>顺序结构：程序从上往下一次执行</li>
<li>分支结构：程序从两条或多条路径中选择一条去执行</li>
<li>循环结构：程序在满足一定条件的基础上，重复执行一段代码</li>
</ul>
<h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><h4 id="IF函数"><a href="#IF函数" class="headerlink" title="IF函数"></a>IF函数</h4><p>功能：实现简单的双分支</p>
<p>select If(表达式1，表达式2，表达式3)</p>
<p>执行顺序：如果IF函数成立，则IF函数返回表达式2的值，否则返回表达式3的值</p>
<p>应用在任何地方</p>
<h4 id="CASE结构"><a href="#CASE结构" class="headerlink" title="CASE结构"></a>CASE结构</h4><p>情况1：类似于java中的switch语句，一般用于实现等值判断</p>
<p>语法：</p>
<p>case 变量|表达式|字段</p>
<p>when 要判断的值 then 返回的值1或语句1【；】</p>
<p>when 要判断的值 then 返回的值2或语句2【；】</p>
<p>…</p>
<p>else 要返回的值 n或语句n【；】</p>
<p>end 【case;】</p>
<p>情况2：类似于java中的多重IF语句，一般用于实现区间判断</p>
<p>case </p>
<p>when 要判断的条件1 then 返回的值1或语句1【；】</p>
<p>when 要判断的条件2 then 返回的值2或语句2【；】</p>
<p>…</p>
<p>else 要返回的值 n或语句n【；】</p>
<p>end 【case；】</p>
<p>特点：</p>
<ol>
<li><p>可以作为表达式，嵌套在其他语句中使用，可以放在任何地方，begin end中或外面</p>
<p>可以作为<strong>独立的语句</strong>使用，只能放在begin end中</p>
</li>
<li><p>如果when中的值满足或条件成立，则执行对应的then后面的语句，并且结束case </p>
<p>如果都不满足，则执行else中的语句或值</p>
</li>
<li><p>else可以省略，如果else省略了，并且所有的when条件都不满足，则返回null</p>
</li>
</ol>
<p>案例：创建存储过程，根据传入的成绩来显示等级，如传入成绩：90-100，显示A；80-90，显示B；60-80，显示C；否则显示D</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_case(<span class="keyword">IN</span> score <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">CASE</span> </span><br><span class="line">	<span class="keyword">WHEN</span> score&gt;=<span class="number">90</span> <span class="keyword">AND</span> score&lt;=<span class="number">100</span> <span class="keyword">THEN</span> <span class="keyword">SELECT</span> <span class="string">'A'</span>;</span><br><span class="line">	WHEN score&gt;=80 THEN SELECT 'B';</span><br><span class="line">	WHEN score&gt;=60 THEN SELECT 'C';</span><br><span class="line">	ELSE <span class="keyword">SELECT</span> <span class="string">'D'</span>;</span><br><span class="line">	<span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> test_case(<span class="number">55</span>);</span><br></pre></td></tr></table></figure>

<h4 id="IF结构"><a href="#IF结构" class="headerlink" title="IF结构"></a>IF结构</h4><p>功能：实现多重分支</p>
<p>语法：</p>
<p>if 条件1 then 语句1；</p>
<p>elseif 条件2 then 语句2；</p>
<p>…</p>
<p>【else 语句n;】</p>
<p>end if;</p>
<p>应用场景：应用在begin end中</p>
<p>案例：根据传入的成绩，来显示等级，比如传入成绩：90-100，返回A；80-90，返回B；60-80，返回C；否则返回D</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $	 </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> test_if(score <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">CHAR</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">IF</span> score&gt;=<span class="number">90</span> <span class="keyword">AND</span> score&lt;=<span class="number">100</span> <span class="keyword">THEN</span> <span class="keyword">RETURN</span> <span class="string">'A'</span>;</span><br><span class="line">	ELSEIF score&gt;=80 THEN RETURN 'B';</span><br><span class="line">	ELSEIF score&gt;=60 THEN RETURN 'C';</span><br><span class="line">	ELSE RETURN 'D';</span><br><span class="line">	<span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> test_if(<span class="number">86</span>);</span><br></pre></td></tr></table></figure>

<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>分类：while、loop、repeat</p>
<p>循环控制：</p>
<p>iterate类似于continue，继续，结束本次循环，继续下一次</p>
<p>leave类似于break，跳出，结束当前所在的循环</p>
<h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>语法：</p>
<p>【标签：】while 循环条件 do</p>
<p>​    循环体;</p>
<p>end while【标签】；</p>
<h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h4><p>语法：</p>
<p>【标签：】loop</p>
<p>​    循环体；</p>
<p>end loop【标签】；</p>
<p>可以用来模拟简单的死循环</p>
<h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h4><p>类似于do while，至少执行一次</p>
<p>语法：</p>
<p>【标签：】repeat</p>
<p>​    循环体；</p>
<p>until 结束循环的条件</p>
<p>end repeat 【标签】；</p>
<h4 id="循环的使用"><a href="#循环的使用" class="headerlink" title="循环的使用"></a>循环的使用</h4><p>没有添加循环控制语句</p>
<p>案例：批量插入，根据次数插入到admin表中多条记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> pro_while1(<span class="keyword">IN</span> insertCount <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="comment">#定义循环变量i，int类型初始值为1</span></span><br><span class="line">	<span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">	WHILE i&lt;=insertCount DO</span><br><span class="line">		<span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">admin</span>(username,<span class="string">`password`</span>) <span class="keyword">VALUES</span>(<span class="keyword">CONCAT</span>(<span class="string">'rose'</span>,i),<span class="string">'666'</span>);</span><br><span class="line">		<span class="keyword">SET</span> i=i+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">END</span> <span class="keyword">WHILE</span>; </span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> pro_while1(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>添加leave语句</p>
<p>案例：批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止</p>
<p>这里配合了IF结构来使用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_while1(<span class="keyword">IN</span> insertCount <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">	a:WHILE i&lt;=insertCount DO</span><br><span class="line">		<span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">admin</span>(username,<span class="string">`password`</span>) <span class="keyword">VALUES</span>(<span class="keyword">CONCAT</span>(<span class="string">'hua'</span>,i),<span class="string">'0000'</span>);</span><br><span class="line">		IF i&gt;=20 THEN LEAVE a;</span><br><span class="line">		<span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">		<span class="keyword">SET</span> i=i+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">END</span> <span class="keyword">WHILE</span> a;	</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> test_while1(<span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>添加iterate语句</p>
<p>案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次</p>
<p>思路：在不为偶数次的时候，iterate退出即可。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_while2(<span class="keyword">IN</span> insertCount <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	a:WHILE i&lt;=insertCount DO</span><br><span class="line">		<span class="keyword">SET</span> i=i+<span class="number">1</span>;</span><br><span class="line">		IF MOD(i,2)!=0 THEN ITERATE a;</span><br><span class="line">		<span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">		<span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">admin</span>(username,<span class="string">`password`</span>) <span class="keyword">VALUES</span>(<span class="keyword">CONCAT</span>(<span class="string">'xi'</span>,i),<span class="string">'0000'</span>);</span><br><span class="line">	<span class="keyword">END</span> <span class="keyword">WHILE</span> a;	</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> test_while2(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<h4 id="循环总结"><a href="#循环总结" class="headerlink" title="循环总结"></a>循环总结</h4>

<h2 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h2><h3 id="IFNULL【重要】"><a href="#IFNULL【重要】" class="headerlink" title="IFNULL【重要】"></a>IFNULL【重要】</h3><p>IFNULL（变量名，常量）</p>
<p>如果变量为空，则用常量代替。</p>
<p>只要有为空可能的字段，要是跟其他字符串拼接或者要使用它，最好加上IFNULL判断。</p>
<h3 id="SET-NAMES-gbk"><a href="#SET-NAMES-gbk" class="headerlink" title="SET NAMES gbk;"></a>SET NAMES gbk;</h3><p>要是字符集报错，一般需要重新设置字符集</p>
<h3 id="DATEDIFF（time1-time2）"><a href="#DATEDIFF（time1-time2）" class="headerlink" title="DATEDIFF（time1,time2）"></a>DATEDIFF（time1,time2）</h3><p>返回两个datetime类型的时间差，返回为整数</p>
<h3 id="NOW"><a href="#NOW" class="headerlink" title="NOW()"></a>NOW()</h3><p>返回现在的时间，datetime类型</p>
<h3 id="CONCAT"><a href="#CONCAT" class="headerlink" title="CONCAT()"></a>CONCAT()</h3><p>拼接字符串，中间用逗号隔开</p>
<h3 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h3><p>limit 【offset】，size</p>
<p>用来分页，其中offset为开始的地方，从0开始，size表示数据量。</p>
<h2 id="牛客网题目"><a href="#牛客网题目" class="headerlink" title="牛客网题目"></a>牛客网题目</h2><p>1、查找当前薪水(to_date=’9999-01-01’)排名第二多的员工编号emp_no、薪水salary、last_name以及first_name，不准使用order by</p>
<p>思路：不能使用order by，就只能先找到最高薪水，然后将其排除在salary的选择之中（NOT IN），然后在剩下的工资中选择最大的，即为总体第二大的，用到的是内连接+where子查询的嵌套。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> e.emp_no,<span class="keyword">max</span>(salary) salary ,e.last_name,e.first_name</span><br><span class="line"><span class="keyword">from</span> employees e</span><br><span class="line"><span class="keyword">join</span> salaries s</span><br><span class="line"><span class="keyword">on</span> e.emp_no=s.emp_no</span><br><span class="line"><span class="keyword">where</span> s.to_date=<span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">and</span> s.salary <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">max</span>(salary)</span><br><span class="line">    <span class="keyword">from</span> salaries</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">to_date</span>=<span class="string">'9999-01-01'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>2、查找员工编号emp_no为10001其自入职以来的薪水salary涨幅值growth</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`salaries`</span> (</span><br><span class="line"><span class="string">`emp_no`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`salary`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`from_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`to_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`emp_no`</span>,<span class="string">`from_date`</span>));</span><br></pre></td></tr></table></figure>

<p>将工资按照时间排序，找出第一个和最后一个，然后二者相减。考察的是<strong>select的子句查询</strong>。最外层的select不用加from表，因为用不到。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">(<span class="keyword">select</span> salary <span class="keyword">from</span> salaries <span class="keyword">where</span> emp_no = <span class="number">10001</span> <span class="keyword">order</span> <span class="keyword">by</span> from_date <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>)</span><br><span class="line">-(<span class="keyword">select</span> salary <span class="keyword">from</span> salaries <span class="keyword">where</span> emp_no = <span class="number">10001</span> <span class="keyword">order</span> <span class="keyword">by</span> from_date <span class="keyword">asc</span> <span class="keyword">limit</span> <span class="number">1</span>)</span><br><span class="line"><span class="keyword">as</span> growth;</span><br></pre></td></tr></table></figure>



<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="MySQL客户端"><a href="#MySQL客户端" class="headerlink" title="MySQL客户端"></a>MySQL客户端</h3><ul>
<li>F12 将选中语句自动换行</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记</title>
    <url>/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>黑马程序员视频学习笔记</p>
</blockquote>
<h1 id="视频笔记"><a href="#视频笔记" class="headerlink" title="视频笔记"></a>视频笔记</h1><h2 id="面对对象"><a href="#面对对象" class="headerlink" title="面对对象"></a>面对对象</h2><h3 id="零碎"><a href="#零碎" class="headerlink" title="零碎"></a>零碎</h3><p>javac先编译，生成class文件然后java运行类，一个类中运行需要有一个主函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">pulic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>类名首字母必须大写，如果设定了CLASSPATH，则不用在类名前面加上pulic</p>
<p>Javadoc.exe可以提取java中的注释文档，在写程序的时候，注意在最前面加上注释，包括程序用途，算法说明，在没有思路的时候可以一步一步写出每一步需要实现的功能，代码只是算法功能的<strong>另一种表述</strong>。</p>
<p>若不知道错误出在哪里可以部分注释用来缩小出错范围</p>
<p>8进制是三位的二进制，用0开头，16进制是四位的二进制，用0x开头。</p>
<p>一个2进制为一个bit，一个byte字节为8个二进制位</p>
<p>整数默认<strong>int</strong> 小数默认<strong>double</strong></p>
<p>java里面+号可以表示运算符也可以表示成连接符，如Systen.out.println(a+’,’+b)；</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li><p>^异或，两边结果不同才为真，两边结果相同则为假</p>
</li>
<li><p>&amp;&amp;双与，只要左边为假，右边不运算，若想让右边参与运算，用&amp;</p>
</li>
<li><p>||双或，只要左边为真，右边不运算，若想让右边参与运算，用|</p>
<p>进行循环条件判断的时候，用&amp;&amp;和||效率会更高</p>
</li>
</ul>
<p>而对于位运算符，6&amp;3代表转换为二进制110&amp;011，则全为1则与后为1，否则为0，结果为010，所以6 &amp; 3 = 2；6|3 ，只要二进制位有一个为1则结果为1，所以6|3 = 111(2进制)=7（10进制）</p>
<p>一个数异或同一个数两次，结果还是这个数（<strong>数据加密</strong>）</p>
<p><del>6，相当于对6的每一位进行取反，6全部取反加一得到-6，所以</del>6 = -7</p>
<p>3&lt;&lt;2，表示3左移两位，即0011变为1100,3&lt;&lt;2=12，左移几位就是该数乘以2的几次方，即为&lt;&lt;可以完成2的次幂运算；而对于&gt;&gt;，右移几位就是除以2的几次幂，对于高位保持原来的数字，以保证符号不变。而对于&gt;&gt;&gt;，无论原来高位是什么，都用0来补</p>
<p>想要运算变得高效，首选位运算</p>
<p>​    三元运算符</p>
<blockquote>
<p> （条件表达式）？表达式1：表达式2；</p>
</blockquote>
<p><strong>a)</strong> <strong>判断条件表达式，结果为一个布尔值。</strong></p>
<p><strong>b) true**</strong>，运算结果为表达式<strong>**1</strong></p>
<p><strong>c) false**</strong>，运算结果为表达式<strong>**2</strong></p>
<p>​    局部代码块可以定义局部变量的生命周期</p>
<p>​    switch关键字：switch,case,break,default，可以处理的数据类型是byte,short,int,char</p>
<p>​    break 跳出当前循环，并结束此次循环</p>
<p>​    do while相比while，无论条件是否满足，至少执行一次循环内容，应用相对比较少。</p>
<p>​    for(初始化表达式；循环条件表达式；循环后的操作表达式)</p>
<p>​    其中初始化表达式只在最开始进行执行（执行一次），然后运行条件表达式判断是否循环，如果是则进入循环内执行语句，然后运行循环后的操作表达式。</p>
<h3 id="制表符"><a href="#制表符" class="headerlink" title="制表符"></a>制表符</h3><p>\t为制表符，用于将数据对齐  \n回车  \b退格  \r按下回车键</p>
<p>windows系统中，回车符由两个符号组成，为\r\n linux中回车符为\n</p>
<p>转义字符对后面的字符含义进行转义，如果想输出”，则需要使用\”，在前面加上\</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="定义函数格式"><a href="#定义函数格式" class="headerlink" title="定义函数格式"></a>定义函数格式</h4><p> 修饰符 返回值类型 函数名（参数类型 形式参数1，参数类型 形式参数2，…）</p>
<p>{</p>
<p>   执行语句；</p>
<p>   return 返回值；</p>
<p>}</p>
<p> 如果函数名字有两个以上的单词，第一个单词首字母小写，从第二个单词开始要大写，需要去区分是类还是函数。</p>
<p> 如果函数中没有返回值类型，则用void，可以省略return。</p>
<p> 函数中可以调用其他函数，但是不可以定义其他函数</p>
<p>在内存中，java内存为栈的形式，先进后出，调用的函数结束后即被清理出内存</p>
<h4 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h4><ol>
<li><p>同一个类</p>
</li>
<li><p>同名</p>
</li>
<li><p>参数个数不同or参数类型不同</p>
</li>
</ol>
<p>利用好函数的重载，同样功能的函数起一样的名字，利用传递参数的不同加以区分，同时利用之前已有的函数功能，进行调用，提高代码的复用性。</p>
<h3 id="查表法"><a href="#查表法" class="headerlink" title="查表法"></a>查表法</h3><p>查表法：在数据中出现对应关系，而且对应关系的一方是有序的数字编号，并作为角标使用，这时候就要想到数组的使用。可以将这些数据存储到数组中，根据运算的结果作为角标直接去查数组中对应的元素即可</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组的格式"><a href="#数组的格式" class="headerlink" title="数组的格式"></a>数组的格式</h4><p> 元素类型[] 数组名 = new 元素类型[元素个数或数组长度]</p>
<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC.png" class title="This is an example image">

<p>在栈中开辟内存给arr，在堆中开辟内存，产生一个实体存放每个小数组的地址，初始值为null，然后新建三个小数组实体，每个小数组的初始值为0，将每个小数组的地址赋给大数组，将null改变为三个地址，然后将arr指向大数组的地址，这样二维数组初始化完毕</p>
<p>二维数组赋值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][]arr = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">3</span>][]; arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][]arr = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h3><ol>
<li><p>成员变量定义在类中，整个类中都可以访问；局部变量定义在函数，语句，局部代码块中，只在所属的区域有效。</p>
</li>
<li><p>成员变量存在于堆内存的对象中；局部变量存在于栈内存的方法中。</p>
</li>
<li><p>成员变量随着对象的创建而存在，随着对象的消失而消失；局部变量随着所属区域的执行而存在，随着所属区域的结束而释放。</p>
</li>
<li><p>成员变量都有默认初始化值；局部变量没有默认初始化值。</p>
</li>
</ol>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>​    隐藏对象的属性和实现细节，仅对外提供公共访问方式，笔记本就是种封装</p>
<p>​    将类中变量定义为private，为了改变变量的值，必须要经过类所规定的方法（对设置的变量给予约束）</p>
<p>​    封装原则：将不需要对外提供的内容全都隐藏起来；把属性都隐藏，提供公共方法（set,get）对其访问，使得对数据可控，set一般为viod，而get返回类型和属性相同</p>
<p>​    private为权限修饰符，修饰成员，不能修饰局部。私有的内容只在本类中有效。</p>
<p>​    私有只是封装的一种体现，java中最小的封装体是函数</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>​    名称与类相同，不需要返回值，用于给对象初始化，构造创造对象时调用的函数，<strong>首字母大写</strong>，构造函数里面可以return用以结束函数，但是很少见</p>
<p>​    创建对象都必须要通过构造函数进行初始化；如果一个类中没有定义过构造函数，那么该类中会有一个默认的空参数构造函数。如果在类中定义了指定的构造函数，那么类中的默认构造函数就没有了。</p>
<p>​    当方法中的成员变量和局部变量重名，那么成员变量会变成局部变量，当方法结束调用后出栈，没有改变成员变量的值，可以用this来区分，如this.name = name。this就是<strong>所在函数所属对象的引用</strong>。简单说，哪个对象调用了this所在的函数，this就代表哪个对象。</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><p>​    如果要在构造函数中调用构造函数，不能直接用Person();，因为这句话相当于this.Person，对象还没有初始化不可被调用，这时候可用this(待传入参数)，相当于直接给这个对象进行初始化。</p>
<p>​    this可在构造函数中调用其他构造函数，但是只能定义在构造函数的第一行，因为初始化动作要先执行</p>
<p>​    只要在本类中调用了本类的对象，一般都要用this</p>
<h4 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h4><p>​    修饰数据，可实现数据共享，在对象之前出现，可以被类名调用</p>
<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><ol>
<li><p>static是一个修饰符，用于修饰成员（成员变量和成员函数）。</p>
</li>
<li><p>static修饰的成员被所有的对象共享。</p>
</li>
<li><p>static优先于对象存在，因为static的成员随着类的加载就已经存在了。</p>
</li>
<li><p>static修饰的成员多了一种调用方式，即可以直接被类名所调用，调用格式为类名.静态成员。</p>
</li>
<li><p>静态修饰的数据是共享数据，对象中存储的是特有数据。</p>
</li>
</ol>
<h5 id="成员变量（实例变量）与静态变量（类变量）的区别："><a href="#成员变量（实例变量）与静态变量（类变量）的区别：" class="headerlink" title="成员变量（实例变量）与静态变量（类变量）的区别："></a>成员变量（实例变量）与静态变量（类变量）的区别：</h5><ol>
<li>两个变量的生命周期不一样（静态变量生命周期太长，用以减少占用内存空间）</li>
</ol>
<p>随着对象的创建而存在，随着对象的回收而释放；静态变量随着类的加载而存在，随着类的消失而消失</p>
<ol start="2">
<li>调用方式不同</li>
</ol>
<p>成员变量只能被对象调用，静态变量可以被对象和类调用，不建议用对象调用</p>
<ol start="3">
<li><p>别名不同</p>
<p>成员变量也成为实例变量，静态变量成为类变量</p>
</li>
<li><p>数据存储位置不同</p>
</li>
</ol>
<p>成员变量数据存储在堆内存（堆中存储的都是实体）的对象中，所以也叫对象的特有数据。静态变量数据存储在方法区（的静态区），也叫对象的共享数据</p>
<p>​    静态变量前省略了类名，非静态变量前省略了this</p>
<h5 id="静态使用注意事项"><a href="#静态使用注意事项" class="headerlink" title="静态使用注意事项"></a>静态使用注意事项</h5><ol>
<li><p>静态方法只能访问静态成员（因为其先于对象存在，无法访问对象中存在的成员变量和函数），静态方法可直接被类名调用。非静态既可以访问静态，又可以访问非静态。</p>
</li>
<li><p>静态方法中不可使用this或者super关键字</p>
</li>
<li><p>主函数是静态的（不要在主函数中定义其他函数，要将其他函数封装在类中，在主函数中创建对象，调用对象的函数即可）</p>
</li>
</ol>
<h5 id="主函数特殊之处"><a href="#主函数特殊之处" class="headerlink" title="主函数特殊之处"></a>主函数特殊之处</h5><p>public static void main(String[],args)</p>
<ol>
<li><p>格式是固定的</p>
</li>
<li><p>被jvm所识别和调用</p>
</li>
</ol>
<p>public：因为权限是最大的</p>
<p>static: 不需要对象的，直接用主函数所属类名调用即可</p>
<p>void：主函数没有具体的返回值</p>
<p>main: 函数名，不是关键字，只是一个jvm识别的固定的名字</p>
<p>String[] args：这是主函数的参数列表，是一个数组类型的参数，而且元素都是字符串类型</p>
<p>​    主函数所留了一个args，相当于new String args[0]，留给使用者指定参数，直接java 类名 加所要传入参数</p>
<p>​    类被加载进方法区，方法区用来存放类和静态方法的代码，也加方法表，运行时候进栈存储局部变量</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%B1%BB%E8%A2%AB%E5%8A%A0%E8%BD%BD%E8%BF%9B%E6%96%B9%E6%B3%95%E5%8C%BA.png" class title="This is an example image">

<h4 id="protected关键字"><a href="#protected关键字" class="headerlink" title="protected关键字"></a>protected关键字</h4><p>​    指明“就类用户而言，这是private的，但对于任何继承于此类的导出类或其他任何位于同一个包内的类来说，它却是可以访问的”。（protected提供了包内访问权限。）</p>
<h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><p>final 关键字：</p>
<p>1、 final是一个修饰符，可以修饰类，方法，变量</p>
<p>2、 final修饰的类不可以被继承</p>
<p>3、 final修饰的方法不可以被覆盖</p>
<p>4、 final修饰的变量是一个常量，只能赋值一次变量命名与函数一样，常量所有字母都大写，单词之间用_连接）成员一旦被final ，一般会加静态 static final int x = 7;</p>
<p> public static final 全局变量</p>
<p>​    用final修饰变量原因</p>
<p>其实在程序中如果一个数据是固定的，那么直接使用这个数据就可以了，但是这样阅读性差，所以给该数据起个名称，而且这个变量名称的值不能变化，所以加上final固定。固定常量一律用final修饰</p>
<p>写法规范</p>
<p>常量所有字母都大写，多个单词，中间用_连接。</p>
<p>可能使用到final的三种情况：数据、方法和类</p>
<h5 id="final数据"><a href="#final数据" class="headerlink" title="final数据"></a>final数据</h5><p>不能改变的数据需要是基本数据类型，以final关键字表示，在对常量定义的时候，必须对其赋值。</p>
<p>​    一个既是static又是final的域只占据一段不能改变的存储空间。</p>
<p>​    对对象的引用用final修饰，使其不能指向另一个对象，但是对象本身可以被修改。</p>
<p>​    不能因为某数据是final类型就认为可以在编译时知道它的值，final指向只是不能再次指向另一个新的对象，不代表值不能被改变。</p>
<p>​    如果数据是static的，在装载时已被初始化，而不是每次创建新对象时都初始化。</p>
<p>​    允许生成空白final，即被声明为final但又未给定初值的域。必须在域的定义处或者每个构造器中用表达式对final进行赋值。（如果不在构造器处初始化空白final，会编译报错。）</p>
<h5 id="final参数"><a href="#final参数" class="headerlink" title="final参数"></a>final参数</h5><p>​    允许在参数列表中以生命的方式将参数指明为final，意味着无法在方法中更改参数引用所指向的对象。</p>
<p>​    可以读参数，却无法修改参数，主要用来向匿名内部类传递数据。</p>
<h5 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h5><p>使用final方法原因：</p>
<p>​    一：把方法锁定，以防任何继承类修改它的定义。处于设计的考虑：想要确保在继承中使方法行为保持不变，并且不会被覆盖。</p>
<p>​    二：效率。以前会为了效率，将一个方法指明为final，同意编译器将针对该方法的所有调用都转为内嵌调用。应该让编译器和jvm去处理效率的问题，只有想要明确禁止覆盖时，才将方法设置成final。</p>
<h5 id="final和private关键字"><a href="#final和private关键字" class="headerlink" title="final和private关键字"></a><strong>final和private关键字</strong></h5><p>​    类中所有的private方法都隐式地指定为是final的。“覆盖”只有在某方法是基类的接口的一部分时才会出现，即必须能将一个对象向上转型为它的基本类型并调用相同的方法。如果方法为private，它就不是基类接口的一部分。它仅是一些隐藏于类中的程序代码，只不过是具有相同名称而已。</p>
<h5 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h5><p>​    当某各类的整体定义为final时（将关键字final置于它的定义之前），就表明了不打算继承该类，也不允许其他人这么做。</p>
<p>​    在final类中可以给方法添加final修饰词，但不会增添任何意义。</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h4 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h4><ol>
<li><p>寄存器  CPU处理</p>
</li>
<li><p>本地方法区 和操作系统相关 </p>
</li>
<li><p>方法区</p>
</li>
<li><p>栈内存 存储局部变量，而且变量所属的作用域一旦结束，变量自动释，方法（函数）进栈</p>
</li>
<li><p>堆内存 存储数组（数组就是对象）和对象，凡是new建立在堆中</p>
</li>
</ol>
<p>​    堆的特点：</p>
<ol>
<li>每一个实体都有首地址值</li>
<li>堆内存中的每一个变量都有默认初始化值，根据类型的不同而不同。整数0，小数0.0或0.0f，boolean false，char ‘\u0000’相当于空格的空位</li>
<li>垃圾回收机制，由程序控制不定时清理</li>
</ol>
<h4 id="内存过程"><a href="#内存过程" class="headerlink" title="内存过程"></a>内存过程</h4><p>​    StaticDemo2这个类被加载进方法区，因为其为非静态方法，有一个this用于表示当前对象，同时还有一个默认的空构造函数，因为这个类中有非静态方法，于是static main进入静态方法区，存储相应代码。运行main函数，main进栈。加载Person.method()，jvm寻找Person.class文件，找到后将Person类加载进方法区中非静态方法中，包括Person的代码，也包括一个this，存放非静态方法Person(),show()，将静态方法method存放金静态方法区，其中也包括country这个静态变量。运行method，method进栈，输出静态变量，没有在堆中开辟空间，运行结束后弹栈。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%85%E5%AD%98%E8%BF%87%E7%A8%8B.png" class title="This is an example image">

<p>​    建立新对象p，在堆中开辟内存空间地址为0x0056，初始化name=null,age=0。然后执行Person的构造函数，构造函数进栈，this赋值为此对象地址，将name和age赋值，接下来执行this.name=name和this.age=age，将堆中对象的name和age赋值改变。初始化结束后构造函数弹栈，将p指向0x0056。执行show()，在方法区中寻找show，show进栈，有一个this所属，输出类所属的静态变量country，this所属(对象)的name和age，进行输出，结束后show弹栈。Main执行return后，main也弹栈。</p>
<h3 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h3><p>​    变量在任何方法（包括构造器）被调用前初始化。</p>
<p>​    初始化的顺序是先静态对象（如果他们未因前面的对象创建过程而被初始化），然后是“非静态”对象，然后是构造器。</p>
<p>​    静态对象会随着类的加载而初始化，之后不会再次初始化。</p>
<p>​    实例初始化在构造器之前。</p>
<p>假设有个Dog类</p>
<ol>
<li><p>即使没有显式地使用static关键字，构造器实际上也是静态方法。因此，当首次创建爱你类为Dog的对象时（构造器可以看成静态方法），或者Dog类的静态方法/静态域首次被访问时，Java解释器必须查找类路径，以定位Dog.class文件。</p>
</li>
<li><p>然后载入Dog.class（创建一个Class对象），有关静态初始化的所有动作都会执行。因此静态初始化只在Class对象首次加载的时候执行一次。</p>
</li>
<li><p>当用new Dog()创建对象的时候，首先将在堆上为Dog对象分配足够的存储空间。</p>
</li>
<li><p>这块存储空间就会被清零，这就自动地将Dog对象中的所有基本类型数据都设置成了默认值，引用被设置成null。</p>
</li>
<li><p>执行所有出现于字段定义处的初始化动作。</p>
</li>
<li><p>执行构造器。</p>
</li>
</ol>
<h3 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h3><p>静态什么时候用？</p>
<p>1、 静态变量</p>
<p>当分析对象中所具备的成员变量的值都是相同的，这时这个成员就可以被静态修饰。只要数据在对象中都是不同的，那就是对象的特有数据，必须在对象中是非静态的。如果是相同的数据，对象不需要做修改，只需要使用即可，不需要存储在对象中，定义成静态的。</p>
<p>2、 静态函数</p>
<p>函数是否用静态修饰，就参考一点，就是该函数功能是否有访问到对象的特有数据。简单点即从代码中看，该功能是否需要访问非静态的成员变量，如果需要，该功能就是非静态的；如果不需要，就可以将该功能定义成静态的。当然也可以定义为非静态，但是非静态需要被对象调用，而仅创建对象调用非静态的没有访问对象特有数据的方法，该对象的创建没有意义。</p>
<p>3、静态代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span></span><br><span class="line">&#123;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随着类的加载而执行</p>
<p>作用：用于给类进行初始化。</p>
<p>一般用于全静态变量的类</p>
<p>构造代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造代码块为在类中的代码块，不加static修饰符，用以给所有对象初始化。与构造函数区别是构造函数是给对应的对象有针对性的初始化。构造代码块为对象的通用部分，构造函数为对象的特性部分。</p>
<p>若在函数中为局部代码块，用以限制变量的周期。</p>
<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><p>强制不让创建对象</p>
<p>private ArrayToll(){}该类中的方法都是静态的，所以该类是不需要创建对象的。为了保证不让其他成员创建该类对象，可以将构造函数私有化</p>
<p>设计模式：对问题行之有效的解决方式。其实是一种思想</p>
<p>​    单例设计模式解决问题：可以保证一个类在内存中的对象唯一性</p>
<p>​    必须对多个程序使用同一个配置对象时，就需要保证该对象的唯一性</p>
<p>如何保证对象唯一性？</p>
<p>（1）   不允许其他程序用new创建该类对象</p>
<p>（2）   在该类中创建一个本类实例</p>
<p>（3）   对外提供一个方法让其他程序可以获取该对象</p>
<p>步骤</p>
<p>（1）   私有化该类的构造函数</p>
<p>（2）   通过new在本类中创建一个本类的对象</p>
<p>（3）   定义一个公有的方法，将创建的对象返回</p>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p><strong>开发更多</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类一加载，对象就已经存在了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;  </span><br><span class="line">	<span class="comment">//静态方法只能调用静态变量,为了避免用户直接访问设置权限</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Single s = <span class="keyword">new</span> Single(); </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125; </span><br><span class="line">	<span class="comment">//静态方法可以直接被类调用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 Single ss = Single.getInstance();</p>
<p>当调用getInstance()的时候，此函数进栈，将s的地址赋值给ss，然后弹栈，这样ss就指向了s所指向的对象</p>
<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><p><strong>面试更多</strong> 延迟加载形式（懒汉式）问题：如果被<strong>多线程</strong>调用，可能<strong>不能保证唯一性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类加载进来，没有对象，只有调用了getInstance方法才创建对象，延迟加载形式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single2</span> </span>&#123;   </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Single2 s = <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Single2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;   </span><br><span class="line">		<span class="keyword">if</span>(s==<span class="keyword">null</span>)</span><br><span class="line">			s = <span class="keyword">new</span> Single2();</span><br><span class="line">		 <span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>class Student <strong>extends</strong> Person</p>
<p>Student 子类  Person父类（超类，基类）</p>
<p>继承弊端：打破封装性</p>
<h4 id="继承的好处"><a href="#继承的好处" class="headerlink" title="继承的好处"></a>继承的好处</h4><ol>
<li><p>提高了代码的复用性</p>
</li>
<li><p>让类和类之间产生了关系，给第三个特征多态提供了前提</p>
</li>
</ol>
<p>java中支持单继承，不直接支持多继承，但对C++中的多继承机制进行了改良</p>
<p>单继承：一个子类只能有一个直接父类</p>
<p>多继承：一个子类可以有多个直接父类（java中不允许，进行改良）</p>
<p>​    不直接支持，因为多个父类中有相同成员，会产生调用不确定性,在java中通过“<strong>多实现</strong>”的方式来实现</p>
<p>​    java支持多层（多重）继承</p>
<p>​    C继承B，B继承A。就会出现继承体系。</p>
<h4 id="使用一个继承体系"><a href="#使用一个继承体系" class="headerlink" title="使用一个继承体系"></a>使用一个继承体系</h4><ol>
<li><p>查看该体系中的顶层类，了解该体系的基本功能</p>
</li>
<li><p>创建体系中的最子类对象，完成功能的使用</p>
</li>
</ol>
<p>在子父类中，成员的特点体现</p>
<ol>
<li>成员变量</li>
</ol>
<p>子类中与父类同名变量，值与子类相同。当本类中的成员和局部变量同名用this区分。</p>
<p>当子父类中的成员变量同名可用super区分父类。</p>
<p>this 和 super的用法很相似</p>
<p>this：代表一个本类对象的引用</p>
<p>super：代表一个父类空间</p>
<ol start="2">
<li>成员函数</li>
</ol>
<p>当子父类中出现成员函数一模一样的情况，会运行子类的函数，这种现象称为覆盖操作。</p>
<p>这是函数在子父类中的特性。</p>
<p>​    函数两个特性：</p>
<p>（1）   重载 同一个类中</p>
<p>（2）   覆盖 子类中，覆盖也称为重写，覆写。override,函数声明需要一致</p>
<p>​    覆盖注意事项</p>
<ul>
<li><p>子类方法覆盖父类方法时，子类权限必须要大于等于父类的权限</p>
</li>
<li><p>静态只能覆盖静态，或被静态覆盖</p>
<p>什么时候使用覆盖操作</p>
<p>当对一个类进行子类的扩展时，子类需要保留父类的功能声明，但是要定义子类中该功能的特有内容时，就使用覆盖功能完成</p>
</li>
</ul>
<ol start="3">
<li>构造函数</li>
</ol>
<p>在子类构造对象时，发现访问子类构造函数时，父类也运行。原因：在子类的 构造函数中第一行有一个默认的隐式语句。super()；</p>
<p>子类的实例化过程：子类中所有的构造函数默认都会访问父类中的空参数的构造函数</p>
<p>子类实例化访问父类构造函数原因：</p>
<p>​    子类继承了父类，获取到了父类中的内容（属性），所以在使用父类内容之前要先看父类是如何对自己的内容进行初始化的，所以子类在构造对象时必须访问父类的构造函数。为了完成这个必须的动作，就在子类的构造函数函数中加入了super();语句.如果父类中没有定义空参数构造函数.那么子类的构造函数必须用super明确要调用父类中哪个构造函数。同时子类构造函数中如果使用this()调用了本类构造函数时，super就没有了，因为this和super都只能定义在第一行，所以只能有一个。但是可以保证的是，子类中肯定会有其他的构造函数访问父类的构造函数。</p>
<p>​    注意：super语句必须要定义在子类构造函数的第一行，因为父类的初始化动作要先完成。</p>
<p>所有的类都有 extends Object</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%A7%E6%89%BF%E5%86%85%E5%AD%98%E5%9B%BE%E8%A7%A3.png" class title="This is an example image">

<p>继承内存图解，子类对象中继承了父类对象的num，用super关键字进行引用</p>
<p>子类中不能直接访问父类中私有的内容</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Zi.png" class title="This is an example image">

<p>运行Zi的构造函数，super()为Fu()，此时的show()被子类覆盖，运行zi show…0。通过父类super初始化父类内容时，子类的成员变量并未显示初始化，等父类super（）父类初始化完毕后，才进行子类的成员变量显示初始化。即super后num=8</p>
<h4 id="一个对象实例化过程"><a href="#一个对象实例化过程" class="headerlink" title="一个对象实例化过程"></a>一个对象实例化过程</h4><p>Person p = new Person();</p>
<ol>
<li><p>JVM会读取指定路径下的Person.class文件，并加载进内存，并会先加载Person的父类（如果有直接的父类的情况下）</p>
</li>
<li><p>在堆内存中开辟空间，分配地址</p>
</li>
<li><p>并在对象空间中，对对象的属性进行默认初始化</p>
</li>
<li><p>调用对应的构造函数，进行初始化</p>
</li>
<li><p>在构造函数中，第一行会调用父类中的构造函数进行初始化</p>
</li>
<li><p>父类初始化完毕后，再对子类的属性进行显示初始化</p>
</li>
<li><p>再进行子类构造函数的特定初始化</p>
</li>
<li><p>初始化完毕后，将地址值赋值给引用变量</p>
</li>
</ol>
<h4 id="组合与继承"><a href="#组合与继承" class="headerlink" title="组合与继承"></a>组合与继承</h4><p>​    组合：在一个类中持有另一个类的引用。</p>
<p>“is-a”（是一个）的关系是用继承表达的，而“has-a”（有一个）的关系则是用组合来表达的。</p>
<p> 判断要用组合还是继承，看是否需要从新类向基类进行向上转型，如果必须向上转型，则继承是必要的。</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>​    如果使用继承，会将父类所有方法暴露给子类，可以使用代理，可以选择只提供在成员对象中的方法的某个子集。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>abstract class Demo</p>
<p>{ abstract void show();</p>
<p>}</p>
<p>1、 方法只有声明没有实现时，该方法就是抽象方法，需要被abstract修饰。抽象方法必须定义在抽象类中，该类也必须要被abstract修饰</p>
<p>2、 抽象类不可以被实例化（不可以被new）,调用抽象方法没意义。</p>
<p>3、 抽象类必须有其子类覆盖了所有的抽象方法后，该子类才可以实例化。否则，该子类还是抽象类</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>当一个抽象类中的方法都是抽象的时候，这时可以将该抽象类用另一种形式定义和表示，就是接口 interface。</p>
<p>定义接口用的关键字不是class，是interface</p>
<p>接口中常见的成员：而且这些成员都有固定的修饰符</p>
<ol>
<li><p>全局常量 public static final</p>
</li>
<li><p>抽象方法 public abstract</p>
</li>
</ol>
<p>由此有接口中的成员都是公共的权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;   </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">4</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    类与类之间是继承关系，类与接口之间是实现关系，接口与接口之前是继承关系，而且可以多继承</p>
<p>​    接口不可以实例化，只能由实现了接口的子类并覆盖了接口中所有的抽象方法后，该子类才可以实例化。否则，这个子类就是一个抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoImpl</span> <span class="keyword">implements</span> /*实现*/<span class="title">Demo</span></span>&#123;   </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在java中不直接支持多继承，因为会出现调用的不确定性。所以java将多继承机制进行了改良，在java中变成了多实现。</p>
<p>​    一个类可以有多个接口。</p>
<p>class Test implements A,Z  多实现，如果A,Z中方法名一样，也不会报错，因为A,Z中无方法体，若Test中覆盖此同名方法，则A,Z中方法会被同时覆盖，不会产生不确定性，而继承中因为存在方法体，所以不能多继承。</p>
<p>一个类在继承另一个类的时候，还可以实现多个接口。先继承，再实现接口。</p>
<p>class Test extends Q implements A,Z</p>
<p>​    <strong>接口的出现避免了单继承的局限性</strong>。接口与接口之前是继承关系，而且可以多继承</p>
<p>interface QQ extends CC,MM</p>
<h4 id="接口的特点"><a href="#接口的特点" class="headerlink" title="接口的特点"></a>接口的特点</h4><ul>
<li><p>接口是对外暴露的规则</p>
</li>
<li><p>接口是程序的功能扩展</p>
</li>
<li><p>接口的出现降低耦合性</p>
</li>
<li><p>接口可以用来多实现</p>
</li>
<li><p>类与接口之间是实现关系，而且类可以继承一个类的同时实现多个接口</p>
</li>
<li><p>接口与接口之间可以有继承关系</p>
</li>
</ul>
<h4 id="抽象类和接口的异同点"><a href="#抽象类和接口的异同点" class="headerlink" title="抽象类和接口的异同点"></a>抽象类和接口的异同点</h4><p>相同点：都是不断向上抽取而来的</p>
<p>不同点：</p>
<ol>
<li><p>抽象类需要被继承，而且只能单继承。</p>
<p>接口需要被实现，而且可以多实现</p>
</li>
<li><p>抽象类中可以定义抽象方法和非抽象方法，子类继承后可以直接使用非抽象方法。</p>
<p>接口中只能定义抽象方法，必须由子类去实现</p>
</li>
<li><p>抽象类的继承，是is a 关系。在定义该体系的基本共性内容，基本功能</p>
<p>接口的实现是like a 关系。在定义体系额外功能</p>
</li>
</ol>
<p>在不同的领域中，有不同的分析方式</p>
<p>接口类型对象指向自己的子类对象。接口类型的引用，用于接收（指向）接口的子类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">useUSB(<span class="keyword">null</span>);  </span><br><span class="line">useUSB(<span class="keyword">new</span> Upan());</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useUSB</span><span class="params">(USB u)</span> <span class="comment">//使用了多态，相当于USB u = new Upan()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		u.open();</span><br><span class="line">		u.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>​    在某些情况下，一个类的属性是有限而且固定的，如下面的棋子类，只有两个对象，白棋和黑棋。这种实例有限而且固定的类，在java中称为枚举类，枚举类的关键字是enum，此类中有两个枚举属性BLACK和WHITE，代表黑子与白子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//棋子类，枚举类，为构造器私有，不能直接创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  Chessman &#123;</span><br><span class="line">    BLACK(<span class="string">"●"</span>), WHITE(<span class="string">"○"</span>);</span><br><span class="line">    <span class="keyword">private</span> String chessman;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Chessman</span><span class="params">(String chessman)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.chessman = chessman;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *获取棋子类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 黑棋或者白棋</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getChessman</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.chessman;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    此枚举的构造器权限使用private表明子类不可以通过外部创建，只能通过此类的内部创建，为了保证此对象只有黑子与白子两种类型。红色代码列出了枚举值，实际上是调用私有构造器创建此对象，等效于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Chessman BLACK = <span class="keyword">new</span> Chessman(<span class="string">"●"</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Chessman WHITE = <span class="keyword">new</span> Chessman(<span class="string">"○"</span>);</span><br></pre></td></tr></table></figure>

<p>因为BLACK与WHITE两个属性是静态的，要获取黑子或白字，可使用以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Chessman.BLACK.getChessman();</span><br><span class="line">Chessman.WHITE.getChessman();</span><br></pre></td></tr></table></figure>

<h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><p>对自己所写类添加说明文档，用javadoc</p>
<p>类的文档描述应该包括：</p>
<ol>
<li><p>这个类的作用，包含的内容</p>
</li>
<li><p>@author Hugh</p>
</li>
<li><p>@version V1.0</p>
</li>
</ol>
<p>注释格式为</p>
<p>/**</p>
<p>*/</p>
<p>对于每一个方法，描述其作用，@param arr 接收对象描述  @return 返回值描述</p>
<p>为了能使用javadoc，要将class前面加上public，这样类名和文件名必须要一致</p>
<p>使用语句为 javadoc -d myhelp(自己要放的文件名) –author –version ArrayTool.java（要查看的java文件）然后查看index网页，只提供公有权限的</p>
<p>使用时候若class文件与测试用java文件不在同一目录，使用set classpath=.;c:\myclass（相应目录）.;表示当前目录（用以编译当前测试文件），然后再设置对方所给class文件存放目录。若已经设置好对方classpath目录，则使用set classpath=.;%classpath%</p>
<p>若要清楚classpath，使用 set classpath=,查看路径为set classpath</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态：某一类事物的多种存在形态</p>
<p>用父类类型指向子类对象，猫这类事物既具备了猫的形态，又具备了动物的形态，这就是对象的多态性。一个对象对应着不同类型</p>
<p>在代码中体现：父类或接口的引用指向了其子类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal c = <span class="keyword">new</span> pig();</span><br></pre></td></tr></table></figure>

<p>多态的好处：</p>
<p>​    提高了代码的扩展性，前期定义的代码可以使用后期的内容</p>
<p>多态的弊端：</p>
<p>​    前期定义的内容不能使用（调用）后期子类的特有内容</p>
<p>多态的前提：</p>
<ol>
<li><p>必须有关系，继承，实现。</p>
</li>
<li><p>要有覆盖</p>
</li>
</ol>
<p>Animal a = new cat();//自动类型提升，猫对象提升为了动物类型，但特有功能无法访问，</p>
<p>作用为限制对特有功能的访问</p>
<p>专业讲：向上转型，将子类型隐藏，就不能使用子类型的特有方法</p>
<p>若父类中的内容被子类覆盖，调用向上转型对象的方法所实现的为子类的内容</p>
<p>若想使用特有内容，则将对象进行向下转型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cat c = (Cat)a；<span class="comment">//向下转型的目的是使用子类中的特有方法</span></span><br><span class="line">Animal a1 = <span class="keyword">new</span> dog();</span><br><span class="line">Cat c1 = (Cat)a1;<span class="comment">//  ClassCastException类型转换异常</span></span><br></pre></td></tr></table></figure>

<p>注意：对于转型，自始至终都是子类对象在做着类型的变化</p>
<p>对对象类型的判断</p>
<p>instanceof：用于判断对象的具体类型,只能用于引用数据类型判断，通常在向下转型前用于健壮性的判断。</p>
<p>if(a instanceof Cat){}</p>
<p>转型之前加入逻辑判断，加强代码的健壮性</p>
<h4 id="多态时成员的特点"><a href="#多态时成员的特点" class="headerlink" title="多态时成员的特点"></a>多态时成员的特点</h4><ol>
<li>成员变量</li>
</ol>
<p>编译时：参考引用型变量所属的类中是否有调用的成员变量，有，编译通过；没有，编译失败。</p>
<p>运行时：参考引用型变量所属的类中是否有调用的成员变量，并运行所属类中的成员变量</p>
<p>简单说：编译和运行都参考等号的左边</p>
<ol start="2">
<li>成员函数（非静态，重点）</li>
</ol>
<p>编译时：参考引用型变量所属的类中是否有调用的函数，有，编译通过；没有，编译失败。</p>
<p>运行时：参考的是对象所属的类中是否有调用的函数</p>
<p>简单说：编译看左边，运行看右边</p>
<ol start="3">
<li>静态函数</li>
</ol>
<p>编译时：参考引用型变量所属的类中是否有调用的静态方法</p>
<p>运行时：参考引用型变量所属的类中是否有调用的静态方法</p>
<p>简单说：编译和运行都参考等号的左边</p>
<p>​    其实静态方法是不需要对象的，直接类名调用即可</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类：将一个类定义在另一个类里面，对里面那个类成为内部类（内置类，嵌套类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;   </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;   </span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;print(“show”+num);&#125;</span><br><span class="line">   		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;print(“function”+num);&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主函数中编译，产生Outer.class和Outer$Inner.class文件</p>
<p>若要访问一个类中私有变量，最简单方法是在该类中定义内部类，则可以直接访问该私有变量</p>
<p>内部类访问特点</p>
<ol>
<li><p>内部类可以直接访问外部类中的成员</p>
</li>
<li><p>外部类要访问内部类，必须建立内部类的对象</p>
</li>
</ol>
<p>一般用于类的设计。分析事物时发现该事物描述中还有事物，而且该事物还在访问该事物的内容，这时把这个事物定义为内部类来描述</p>
<p>直接访问外部类中的内部类成员</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.Inner in = <span class="keyword">new</span> Outer().<span class="keyword">new</span> Inner();in.show();<span class="comment">//必须先建立外部类对象</span></span><br></pre></td></tr></table></figure>

<p>如果内部类是静态的，相当于一个外部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.Inner in = <span class="keyword">new</span> Outer.Inner();in.show();<span class="comment">//不需建立内部类对象，此静态方法中只能使用静态变量</span></span><br></pre></td></tr></table></figure>

<p>如果内部类是静态的，成员是静态的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.Inner.function();</span><br></pre></td></tr></table></figure>

<p>当内部类中定义了静态成员，该内部类必须被静态修饰，或者该成员被final修饰</p>
<p>外部类只能用public和default默认修饰符，内部类四种修饰符都可以用</p>
<p>内部类可以直接访问外部类中成员的原因：内部类持有外部类的引用，外部类名.this</p>
<p>外部类和内部类拥有同名的变量和方法时，内部类有需要进行访问外部的同名变量或方法，可以通过<strong>外部类.this.方法名/变量名</strong>进行访问</p>
<ol>
<li>成员内部类</li>
</ol>
<p>当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：</p>
<ul>
<li>外部类.this.成员变量</li>
<li>外部类.this.成员方法</li>
</ul>
<p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。</p>
<ol start="2">
<li>局部内部类</li>
</ol>
<p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。</p>
<ol start="3">
<li>匿名内部类</li>
</ol>
<p>匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p>
<ol start="4">
<li>静态内部类</li>
</ol>
<p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字<strong>static</strong>。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。<strong>只有静态内部类，才能在类中申明静态方法</strong>，普通内部类申明静态方法会报错。</p>
<h4 id="内部类问题解释"><a href="#内部类问题解释" class="headerlink" title="内部类问题解释"></a>内部类问题解释</h4><ol>
<li><p>为什么成员内部类可以无条件访问外部类的成员？</p>
<p>编译器会默认为成员内部类添加了一个指向外部类对象的引用（this）。从这里可以看出，虽然我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用，所以成员内部类中的Outter this&amp;0 指针便指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员。从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法对Outter this&amp;0引用进行初始化赋值，也就无法创建成员内部类的对象了。</p>
</li>
<li><p>为什么局部内部类和匿名内部类只能访问局部final变量？</p>
<p>如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。为了避免在内部类的方法中改变参数造成数据不一致性，局部内部类和匿名内部类中访问成员变量需要被final修饰。</p>
<p>一个类文件中，<strong>只能有一个公共的（**</strong>public<strong>**）外部类</strong>，但可以有多个(public、default、private)内部类，多个（default）外部类，private不能用来修饰外部类！</p>
</li>
</ol>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类。就是内部类的简写格式</p>
<p>​    必须有前提：内部类必须继承或者实现一个外部类或者接口</p>
<p>匿名内部类：其实就是一个匿名子类对象（因此如果父类中无此方法会报错）</p>
<p>格式： new 父类or接口 () { 子类内容 }</p>
<p>new demo()即为匿名内部类，因为是对象所以可以直接调用方法</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB.png" class title="This is an example image">

<p>注意：在匿名内部类中，要将方法权限设置为public，否则无法被实现</p>
<p>通常使用场景之一：当函数参数是接口类型时，而且接口中的方法不超过三个。可以利用匿名内部类作为实际参数进行传递 </p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Object%E7%BC%96%E8%AF%91%E5%A4%B1%E8%B4%A5.png" class title="This is an example image">

<p>new Object(){}相当于创立了子类对象，而Object obj=子类对象，相当于向上转型（多态），隐藏了子类特有属性，编译看左边，Object类中无show方法，因此会编译失败</p>
<p>对象构造：显示初始化在构造器初始化之后</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC10%E5%A4%A91.png" class title="This is an example image">

<p>new Zi()对象后，先执行Zi构造函数，默认第一行为super()，此时调用super中的show，因为子类中show被覆盖，因此输出show…，而此时num还没有被显示初始化，因此num为0.然后执行显示的初始化，这时候num为9</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC10%E5%A4%A92.png" class title="This is an example image">

<p>创立对象时，先默认初始化，即num=0，然后Zi()进栈，执行父类构造函数，show函数在子类对象中被覆盖，执行子类show，父类构造函数出栈后进行显示初始化，此时num=9，然后进行构造代码块输出化，然后才是自定义构造函数语句输出</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC10%E5%A4%A93.png" class title="This is an example image">

<p>​    首先为Fu和Zi开辟内存空间，然后执行子类的构造函数，先执行super()，Fu中super为Object，然后进行显示初始化，此时Fu中num=9，再执行父类中构造代码块初始化，因此<strong>第1个输出Fu</strong>。然后执行show()方法，因为父类中show被覆盖，所以执行子类的，而子类中还未进行显示初始化，因此子类中num=0，<strong>第2步</strong>子类show()输出<strong>zi show num=0</strong>。然后子类中父类构造函数执行完毕出栈，执行子类显示初始化，num=8，然后执行构造代码块初始化，因此<strong>第三步输出Zi</strong>.然后进行Zi类中show方法，<strong>第4步输出zi show num=8</strong>。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常：运行时期发生的不正常情况</p>
<p>java中用类的形式对不正常情况进行了描述和封装对象。描述不正常的类，成为异常类。以前正常流程代码和问题处理代码相结合，现在将正常流程代码和和问题处理代码分离，提高阅读性。</p>
<p>不同的问题用不同的类进行具体的描述，比如角标越界，空指针等。</p>
<p>​    问题很多，意味着描述的类也很多，将其共性向上抽取，形成了异常体系。最终问题（不正常情况）就分成了两大类。</p>
<p>Throwable:无论是error，还是异常，问题，问题发生就应该可以抛出，让调用者知道并处理。</p>
<p>//该体系的特点就在于Throwable及其所有的子类都具有可抛性。</p>
<p>可抛性：通过两个关键字来体现的。throws，throw，凡是可以被这两个关键字所操作的类和对象都具有可抛性。<br>|–1、一般不可处理的。Error</p>
<p>特点：是由jvm抛出的严重性的问题。这种问题发生一般不针对性处理。直接修改程序</p>
<p>|–2、可以处理的。Exception</p>
<p>​    发生错误时，对错误地方进行对象封装， throw一个新错误对象给调用者，虚拟机，然后在控制台输出，实际开发时会以日志的形式存储起来。错误地方后面的功能不予执行，因此抛出错误对象可以结束函数。</p>
<p>throw 抛出对象 throw new …某Exception()</p>
<p>​    对于角标是正数不存在，可以用角标越界表示；对于负数为角标的情况，准备用负数角标异常来表示。负数角标这种异常在java中并没有定义过，那就按照java异常的创建思想，面向对象，将负数角标进行自定义描述，并封装成对象。这种自定义的问题描述称为<strong>自定义异常</strong>。  </p>
<p>​    注意：如果让一个类成为异常类，必须要继承异常体系，因为只有成为异常体系的子类才有资格具备可抛性。才可以被两个关键字所操作。throws throw。 </p>
<p>extends RuntimeException</p>
<p>如果在函数内发生了异常，应该在函数中进行声明 throws 引用在函数声明上，throw用在函数内；调用发生异常函数，必须要处理，处理方式之一为抛出。因为继承了父类的异常体系，在重载自定义的异常构造函数时，若要进行String提示输出，可以用super(Str)来进行相关语言提示。</p>
<h4 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h4><ol>
<li><p>编译时被检测异常：只要是Exception和其子类都是，除了特殊子类RuntimeException体系。这种问题一旦出现，希望在编译时就进行检测，让这种问题有对应的处理方式。</p>
</li>
<li><p>编译时不检测异常（运行时异常）就是Exception中的RuntimeException和其子类</p>
<p>这种问题的发生无法让功能继续，运算无法进行，更多是因为调用者的原因导致的或者引发了内部状态的改变导致的。这种问题一般不处理，直接编译通过，在运行时让调用者调用时的程序强制停止，让调用者对代码进行修正。</p>
</li>
</ol>
<p>如果不需要将问题暴露，编译通过在运行时停止；若需要将问题暴露，则在编译时报错    因此自定义异常时，继承Exception或者RuntimeException</p>
<h4 id="throws和throw区别"><a href="#throws和throw区别" class="headerlink" title="throws和throw区别"></a>throws和throw区别</h4><ol>
<li><p>throws使用在函数上，throw使用在函数内</p>
</li>
<li><p>throws抛出的是异常类，可以抛出多个，用逗号隔开。throw抛出的是异常对象，一次只能抛出一个</p>
</li>
</ol>
<h4 id="异常处理的捕捉形式"><a href="#异常处理的捕捉形式" class="headerlink" title="异常处理的捕捉形式"></a>异常处理的捕捉形式</h4><p>这是可以对异常进行针对性处理的方式。</p>
<p>具体形式是：</p>
<p>try{需要被检测异常的代码}</p>
<p>catch(异常类 变量){处理异常的代码}//该变量用于接收发生的异常对象</p>
<p>finally{一定会被执行的代码}</p>
<p>这个代码块是一个整体</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC11%E5%A4%A91.png" class title="This is an example image">

<p>​    在try中放入待检测代码块（其中为局部变量），此对象调用方法抛出一个异常对象，此对象被catch捕捉，e = new异常对象，然后继续输出负数角标异常，因为问题已经被解决，因此程序可以向下运行输出over</p>
<p>​    如果输出e.getMessage()，则可以输出此异常详细信息。getMessage()为父类throwable中的方法。一般直接打印对象，输出为对象地址和哈希值，但是异常对象相当于使用e.toString()，输出为异常类名加信息。</p>
<p>​    e.printStachTrace()，将其追踪输出至标准错误流（jvm默认的异常处理机制）</p>
<p>该体系的特点：子类的后缀名都是用其父类名作为后缀，阅读性很强</p>
<p>如果有多个catch的情况，在抛出的时候throws 多个异常，然后写多个catch即可。</p>
<p>​    如果在多catch情况下，出现了父类Exception e的处理情况，一定要放在多catch的最后，不然放在最前面其他catch永远不执行(多catch下父类的catch放在最后，否则编译失败)</p>
<p>​    只要使用到了声明异常的方法，就要try</p>
<h4 id="异常处理的原则"><a href="#异常处理的原则" class="headerlink" title="异常处理的原则"></a>异常处理的原则</h4><ol>
<li><p>函数内容如果抛出需要检测的异常，那么函数上必须要声明。否则必须在函数内用try,catch捕捉，否则编译失败。</p>
</li>
<li><p>如果调用到了声明异常到的函数，要么try,catch，要么throws，否则编译失败</p>
</li>
<li><p>什么时候catch，什么时候throws</p>
<p>功能内部可以解决，用catch。解决不了用throws告诉调用者，由调用者解决。</p>
</li>
<li><p>一个功能如果抛出了多个异常，那么调用时必须有对应多个catch进行针对性的处理。</p>
</li>
</ol>
<p>内部有几个需要检测的异常就抛几个异常。抛出几个，就catch几个</p>
<p>finally是一定会被执行到的，除非在catch中用到了System.exit(1)，直接退出jvm。</p>
<p>​    finally通常用于关闭（释放）资源，如数据库查询出异常后要关闭连接，关闭连接就在finally中</p>
<p>​    没catch就没处理</p>
<p>try catch finally代码块组合特点：</p>
<ol>
<li><p>try catch finally</p>
</li>
<li><p>try catch(多个) 当没有必要资源需要释放时，可以不用定义finally</p>
</li>
<li><p>try finally 异常无法直接catch处理，但是资源需要关闭</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> show <span class="keyword">throws</span> <span class="title">Exception</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;<span class="comment">//开启资源</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> Exception();&#125;</span><br><span class="line">	<span class="keyword">finally</span>&#123;<span class="comment">//关闭资源&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常转换：捕捉一个异常，暴露出来的是另一个异常，因为此捕捉异常无法被处理，因此转换为可以被处理的异常</p>
<p>catch(MaoYanException e){</p>
<p>​           System.out.println(e.toString());</p>
<p>​           test();</p>
<p>​           //可以对电脑进行维修</p>
<p>​           //throw e;</p>
<p>​           throw new NoPlanException(“课时进度无法完成”+e.getMessage());</p>
<p>​       }</p>
<p>如果发生问题，内部解决，没有给外部抛出，就是隐藏了问题。异常的封装：解决那些内部解决的，抛出需要被外界知道的异常类信息。</p>
<h4 id="异常的注意事项"><a href="#异常的注意事项" class="headerlink" title="异常的注意事项"></a>异常的注意事项</h4><ol>
<li><p>子类在覆盖父类方法时，如果父类的方法抛出了异常，那么子类的方法只能抛出父类的异常或该异常的子类（可以不抛）</p>
</li>
<li><p>如果父类抛出多个异常，那么子类只能抛出父类异常的子集</p>
</li>
</ol>
<p>简单说，子类覆盖父类，子类只能抛出父类的异常或者子类或者子集</p>
<p>注意：如果父类的方法没有抛出异常，子类覆盖时绝对不能抛，就只能try</p>
<p>子类重写的方法可以抛出任何运行时异常（RuntimeException和ArithmeticException属于运行时异常）</p>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>Object:所有类的根类</p>
<p>Object是不断抽取而来，具备着所有对象都具备的共性内容</p>
<p>常用的共性功能:</p>
<p>boolean equals(Object obj):判断两个对象是否相等，仅当引用同一个对象才返回true，比较的也是地址</p>
<p>​    一般都会覆盖此方法，根据对象的特有内容，建立判断对象是否相同的依据</p>
<p>一般向下转型要进行健壮性判断 用instanceof进行判断，扔出异常（运行时异常）告诉用户</p>
<p>if(classA instanceof classB)</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC11%E5%A4%A92.png" class title="This is an example image">

<p>hashCode()，获得哈希地址值，直接输出对象引用=Integer.toHexString(对象.hashCode())；</p>
<p>​    可以根据对象的特性不同，输出不同的哈希值</p>
<p>比较对象equals是否相同：1、判断哈希值是否相同。2、判断内容是否相同</p>
<p>重写equals时候，一般要重写hashCode()，使得相同的对象要有相同的哈希地址值</p>
<p>getClass() 返回此Object的运行时类，即当前对象所属的字节码对象,类型为Class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span></span>&#123;<span class="comment">//字节码文件</span></span><br><span class="line">	name;名称</span><br><span class="line">    field;字段（属性、成员变量）</span><br><span class="line">    constructor;构造器</span><br><span class="line">    method;方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person p = new Person(20)；</p>
<p>​    先在堆里面产生一个Person.class字节码文件对象，再根据字节码文件对象产生Person对象</p>
<p>​    Class clazz1 = p.getClass();</p>
<p>​    可以使用clazz1.getname()即getConstructor()等方法。</p>
<p>toString()方法</p>
<p>​    输出为p.getclass().getName+”@”+Inthger.toHexString(p.hashCode())</p>
<p>如果想建立每个对象特有的字符串输出方法，就可以将toString()方法覆写</p>
<h3 id="包（package）"><a href="#包（package）" class="headerlink" title="包（package）"></a>包（package）</h3><p>对类文件进行分类管理；对类提供多层命名（名称）空间；写在程序的第一行；类名的全程是 包名.类名；包也是一种封装形式</p>
<p>在java文件第一行写package zc.Demo;</p>
<p>编译时候 javac -d . Hello.java，自动生成相应目录，然后运行java zc.Demo.Hello</p>
<p>​    如果两个java文件在不同的包下，一个需要用到另一个类，则如果直接用类名来新建对象会出错，因为类已经有包的所属，所以必须要明确其包名。记住：Demo这个名称是错的，正确名称是包名.类名 packa.Demo。如果两个java文件不在一个目录下，则编译有主函数的类时会找不到调用类，此时需要将被调用类包所在的路径设置为路径</p>
<p> set classpath=.;+路径。在包中，如果没有写public，就是被封装了。方法也不能使用默认权限，要使用public。</p>
<p>​    总结：包与包之间的类访问，被访问的包中的类必须是public的，被访问的包中的类的方法也必须是public的。</p>
<p>​    protected权限，第四种，只有在不同包中的子类才能使用，即必须要继承才能使用，直接在不同包中创建对象无法使用被保护的方法，其实也叫封装。</p>
<table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>default</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同一类中</td>
<td>ok</td>
<td>ok</td>
<td>ok</td>
<td>ok</td>
</tr>
<tr>
<td>同一包中</td>
<td>ok</td>
<td>ok</td>
<td>ok</td>
<td>no</td>
</tr>
<tr>
<td>子类中</td>
<td>ok</td>
<td>ok</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>不同包中</td>
<td>ok</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
</tbody></table>
<p>不同包中能使用的;1、public 2、不同包中子类的protected</p>
<p>使用import，导入指定包中的类，import packa.<em>；导入packa中的所有类,并不导入其中的包，如果packa下面还有包，则需要加入packa.abc.*；真实开发中不建议写</em></p>
<p>​    使用import可以导入包中的类，不用写包名.类名</p>
<p>​    导包的原则：用到哪个类就导入哪个类。</p>
<p>​    import作用：为了简化类名书写，导入的是包中的类。</p>
<p>Jar：java的压缩包，可以压缩</p>
<p>压缩命令：jar -cvf 压缩包名称.jar 被压缩包名</p>
<p>解压缩命令：jar -xvf 压缩包名称</p>
<p>​    将工具包打包为jar文件，不用解压缩，将jar文件添加到classpath下，然后变可以执行，利用java 包名.类名执行。</p>
<h3 id="外部类与内部类修饰符"><a href="#外部类与内部类修饰符" class="headerlink" title="外部类与内部类修饰符"></a>外部类与内部类修饰符</h3><p>如果类可以使用private来修饰，表示该包下的这个类不能被其它类访问，那么该类也失去了存在的意义，所以不能使用private来修饰类。</p>
<p>如果类可以使用protected来修饰，表示该类所在的包的其它类可以访问该类；该类所在的包的子包的类可以访问该类，但是包没有继承的概念，所以后一句是不对。所以用protected来修饰类也是没有意义的。</p>
<p>​    外部类的修饰权限只能是public或者包访问权限，但是内部类可以是private或者protected。</p>
<p>​    如果没能为访问权限指定一个访问修饰符，它就会默认得到包访问权限，意味着该类的对象可以由包内任何其他类来创建，在包外是不行的。相同目录下所有不明确package声明的文件，都被视作是该目录下默认包的一部分。</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>进程：正在进行中的程序（直译）</p>
<p>线程：负责进程中程序执行的一个控制单元，也称为执行路径，执行情景。</p>
<p>一个进程中可以有多个执行路径，称之为多线程。</p>
<p>一个进程中至少要有一个线程。</p>
<p>开启多个线程是为了同时运行多部分代码；每一个线程都有自己运行的内容，这个内容可以称为线程要执行的内容。</p>
<p>多线程弊端：线程太多导致运行效率低。应用线程的执行都是CPU在做着快速的切换完成的，CPU切换是随机的。</p>
<p>JVM启动时启动了多个线程，至少有2个可以分析出来。</p>
<ol>
<li>执行main函数的线程</li>
</ol>
<p>该线程的任务代码都定义在main函数中。</p>
<ol start="2">
<li>负责垃圾回收的线程</li>
</ol>
<p>​    每个对象都有finalize()方法，当垃圾回收器确定不存在该对象的更多引用时，由对象的垃圾回收器调用此方法。</p>
<h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC13%E5%A4%A91.png" class title="This is an example image">

<p>sleep(time)时间到，线程便从冻结状态变为运行状态。如果使用wait()方法，使用notify()方法才能唤醒线程。</p>
<p>运行状态：具备执行资格，具备执行权</p>
<p>冻结状态：释放执行权的同时释放执行资格</p>
<p>临时阻塞状态：具备着执行资格但是不具备执行权</p>
<p>CPU的执行资格：可以被CPU处理，在处理队列中排队</p>
<p>CPU的执行权：正在被cpu处理</p>
<p>​    如果类已经有父类，要拓展此类的功能，让其中的内容可以作为线程的任务执行，通过接口的形式完成</p>
<h4 id="创建线程方式一"><a href="#创建线程方式一" class="headerlink" title="创建线程方式一"></a>创建线程方式一</h4><p>方式一：继承Thread类</p>
<ol>
<li><p>定义一个类继承Thread类</p>
</li>
<li><p>覆盖Thread类中的run()方法。Thread类用于描述线程，因此Thread类也有对任务的描述，这个任务就是通过Thread类中的run()方法来体现，因此   run()方法就是封装自定义线程运行任务的函数。run方法中定义的是线程要运行的任务代码。</p>
</li>
<li><p>直接创建Thread的子类对象创建线程</p>
</li>
<li><p>调用start()方法，作用为启动线程，调用run()方法</p>
</li>
</ol>
<p>开启线程是为了运行指定代码，所以只有继承Thread类，并覆写run()方法，将运行的代码定义在run()方法中。</p>
<p>​    可以通过Thread的getName(0方法来获取线程的名称 Thread-编号（从0开始），线程一被创建就调用super()，被赋予编号。</p>
<p>​    Thread.currentThread().getName()，获取正在运行的线程名字，主线程的名字就是main。如果想对线程起名，可以用Thread(String name)，用super(“名字”)父类构造器来起名字。</p>
<p>​    对于多线程的内存图解，相当于main函数中开启了多条通道</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC12%E5%A4%A91.png" class title="This is an example image">

<p>​    不同的线程有不同的工作区，每个放大的进栈弹栈在单独的空间内完成，每个方法中的变量互不冲突。</p>
<p>​    只要有一个前台进程还在运行，程序就不会结束。</p>
<p>​    在异常中，会显示异常出现的具体线程，在哪个线程出异常，就显示哪个线程。</p>
<h4 id="创建线程方式二"><a href="#创建线程方式二" class="headerlink" title="创建线程方式二"></a>创建线程方式二</h4><p>方式二：实现Runnable接口</p>
<ol>
<li><p>定义类实现Runnable接口</p>
</li>
<li><p>覆盖接口中的run()方法，将线程的任务代码封装到run()方法中</p>
</li>
<li><p>通过Thread类创建对象，并将Runnable接口的子类对象作为Thread类构造函数的参数进行传递</p>
<p>原因：因为线程的任务都封装在Runnable子类对象run()方法中，所以要在线程对象创建时明确要运行的任务。</p>
</li>
<li><p>调用线程对象的start()方法启动线程</p>
</li>
</ol>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC13%E5%A4%A92.png" class title="This is an example image">

<p>​    实现Runnable接口，如果使用无参数的Thread构造方法，则run()方法不做动作，如果传入Runnable子类，则调用的是子类中的方法。如果使用继承Thread类，则此类将父类中的run()方法覆盖，也没有影响。</p>
<p>​    使用多线程的目的是讲线程任务进行执行，如果直接继承Thread，将所有的线程类中的方法继承没有必要；如果只是实现Runnable接口，则它的出现仅仅是将线程的任务进行了对象的封装。为了运行创建Thread对象并明确线程的任务。</p>
<p>​    Thread类实现Runnable接口原因，此类与其他线程类都有共性：线程方法，但是此方法不是必须的，而是额外的功能，因此被抽取成一个接口。</p>
<h4 id="实现Runnable接口的好处"><a href="#实现Runnable接口的好处" class="headerlink" title="实现Runnable接口的好处"></a>实现Runnable接口的好处</h4><ol>
<li><p>将线程的任务从线程的子类中分离出来，进行了单独的封装。按照面向对象的思想将任务封装成了对象。</p>
</li>
<li><p>避免了java单继承的局限性</p>
</li>
</ol>
<p>所以创建线程的<strong>第二种方式</strong>较为常见</p>
<p>异常：所属线程+异常名称+异常信息+异常位置</p>
<p>​    卖票程序中，如果使用继承，新建多个Thread子类对象，每个对象都有票信息，没实现信息共享。需要利用实现Runnable接口，这样只产生一个对象，将线程任务封装成对象传递给Thread类，然后新建多个Thread类对象调用start()方法，因为只有一个Runnable子类对象，因此在堆内存中只存在一个票数信息。</p>
<p>​    卖票时候会出现，一个线程获取票数准备-1，此时切到另一个线程也获取票数，此时票数仍然符合要求，也准备-1，这样会出现票数&lt;=0的情况，会出现线程安全问题。</p>
<h4 id="线程安全问题产生原因"><a href="#线程安全问题产生原因" class="headerlink" title="线程安全问题产生原因"></a>线程安全问题产生原因</h4><ol>
<li><p>多个线程在操作共享的数据。</p>
</li>
<li><p>操作共享数据的线程代码有多条。（操作共享数据代码在2行以上容易出事）</p>
</li>
</ol>
<p>当一个线程在执行操作共享数据的多条代码中，其他线程参与了运算，就会导致线程安全问题的产生。</p>
<p>​    解决思路：将多条操作共享数据的线程代码封装起来；当有线程在执行这些代码的时候，其他线程是不可以参与运算的。必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算。</p>
<h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><p>​    在java中用同步代码块可以解决这个问题。</p>
<p>格式为：</p>
<p>sysnchronized(对象){需要被同步的代码}</p>
<p>​    此对象不能每次新建 对象，不然不是同一个锁</p>
<p>同步时设置对象相当于一个标志位，所有线程要运行任务时候要先进行状态判断，如果有线程正在进行此任务则需要等待此线程任务执行完毕。后期对同步中的线程进行监视，线程要判断同步锁。</p>
<p>同步的好处：解决了线程的安全问题</p>
<p>同步的弊端：相对降低了效率，因为同步外的线程都会判断同步锁。</p>
<p>Thread.sleep()需要进行try,catch，如果此类实现了接口，则不能抛出错误，只能解决，接口的异常对象为InterruptedException</p>
<p>​    同步的前提：同步中必须有多个线程并使用同一个锁。</p>
<p>如果同步锁的对象是成员变量，一个对象堆中只有一个，可以同步；如果此对象在run()方法中定义，则每个线程栈中都有一个，则不能实现同步。</p>
<p>线程开启必须有任务</p>
<p>​    使用同步函数也能解决线程的安全问题，将函数中加上synchronized修饰符。同步函数使用的锁是this。</p>
<p>​    同步函数和同步代码块的区别：</p>
<p>同步函数的锁是固定的this，同步代码块的锁是任意的对象。建议使用同步代码块。</p>
<p>如果同步函数使用静态修饰，因为静态方法中没有this，所以此时同步代码块中的同步锁对象为该函数所属字节码文件对象，可以用getClass方法获取，也可以用类名.class表示。</p>
<p>​    获取字节码文件：</p>
<p>Class clazz = t.getClass();</p>
<p>Class clazz = Ticket.class;`</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC13%E5%A4%A93.png" class title="This is an example image">

<p>​    使用懒汉式，在第一次的时候进行实例化，如果多个线程进来，先进行s的判断，可能会初始多个对象，这时候就有多线程的安全隐患，将getInstance()方法加上synchronized修饰即可。但是这样每个线程进来都要判断同步锁，降低了效率，可以使用同步代码块，其中同步对象为Single.class。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC13%E5%A4%A94.png" class title="This is an example image">

<p>​    线程0进来，此时s==null，开启同步锁，此时进入if判断，CPU切走，然后线程1进来，进入if判断，同步锁进不去，等线程0切回来，创建一个s对象，再切回到线程1，此时因为不满足if判断，因此结束。如果再有其他线程进来，不满足最外层s==null判断，因此也不会降低效率。</p>
<p>​    加一层同步，是为了解决线程安全问题；加一层判断，是为了解决效率问题。利用双重判断来解决懒汉式的安全和效率问题，因此开发式饿汉式更好。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>常见情形一：同步的嵌套</p>
<p>设置两个状态，同步嵌套，线程A同步锁为a，b；线程B同步锁为b，a。如果两个线程进去时候一个持有锁a，另一个持有锁b，这样就会出错。</p>
<h4 id="线程间通讯"><a href="#线程间通讯" class="headerlink" title="线程间通讯"></a>线程间通讯</h4><p>线程间通讯：多个线程在处理同一资源，但是任务却不同。</p>
<p>需求：有一资源，有输入与输出的方法，要求一个输入就一个输出，这样便涉及到了多线程。</p>
<p>​    设计思路：将资源封装成对象，输出实现Runnable接口，设置循环输出资源的信息；输入实现Runnable方法，设置循环获得资源的信息。因为输入与输出为2个类，而且都要获得资源对象，如果两个分别new资源对象，这样资源没有实现共享。因此要让输入输出 操作同一个对象，可以使用单例设计，也可以采用传参的形式，对输入输出进行构造函数传入参数对象，进行参数的设置。在主函数中，先创建资源，然后创建任务，再创建线程，执行路径，最后开启线程。</p>
<p>​    实现0,1的切换，利用x%2，在输入端进行2种设置，利用x值的不同来切换，如果张三，男；李四，女。</p>
<p>​    在主函数中运行，会出现张三，女和李四，男的情况，这是因为输入在设置的时候，便进行了输出。如果直接使用同步，则无法解决，这时候要思考同步的前提：一个同步锁中是否有多个线程。不符合，因为输入线程中只有一个线程，输出线程不在同步中。如果两边同时加入同步，但是不使用同一个锁，因此还是无法解决。这时候考虑到资源对象是唯一的，使用资源对象作为锁。这样便解决了对象输出错误的问题，但是输出的结果不是一个男，一个女。是因为输入拿到资源，不会只赋值一次，便一直在赋值；输出也一样，不会只输出一次，因此一直输出最后一次赋值结果。需求的效果是一个输入完后就进行输出。</p>
<p>​    为了解决这个问题，应该在资源中加入标记，如果有数据，那么便不进行覆盖，如果没有数据，再进行输入。加入一个数据后，标志位改变，这时候要等待输出线程进行输出。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E5%A4%A91.png" class title="This is an example image">

<p>​    在输入中，如果标记位为false，则没有信息，应该写入信息，将flag置为true，唤醒output线程，如果flag为真（还有信息，没有输出），则冻结input线程。在输出中，如果标记位为true，则有信息，应该输出信息，将flag置为false，唤醒input线程，如果flag为假（没有信息，还没输入），则冻结output线程。</p>
<h4 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h4><p>涉及的方法：</p>
<ol>
<li><p>wait();让线程处于冻结状态，被wait的线程会被存储到线程池中。</p>
</li>
<li><p>notify();唤醒线程池中的一个线程（任意）。</p>
</li>
<li><p>notifyAll();唤醒线程池中的所有线程。</p>
</li>
</ol>
<p>这些方法都必须定义在同步中，因为这些方法是用于操作线程状态的方法。必须要明确到底操作的是哪个锁上的线程。</p>
<p> 其中wait()和notify()方法要有所属，应该是同步锁的对象.wait()和同步锁的对象.notify()。在哪个对象中被等待和唤醒，就用哪个线程唤醒和等待.</p>
<p> 操作线程的方法wait,notify,notifyAll定义在Object类中原因是：因为这些方法是监视器的放法，监视器其实就是锁。锁可以是任意的对象，任意的对象调用的方式一定定义在Object类中。</p>
<p> 其中wait()抛出了InterruptedException异常，要有try,catch。</p>
<p>​    然后利用面向对象的思想，将姓名性别设置为私有属性，设置专门的set和out方法来设置和获取其属性。而因为定义在了资源这一个类中，可以直接利用同步方法来实现同步，同步锁为this，然后加进去flag判断和x切换输入，转变flag并唤醒线程池中线程。其中输出直接调用out方法即可。</p>
<p>​    单生产不会出问题，但是多生产多消费出问题。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E5%A4%A92.png" class title="This is an example image">

<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E5%A4%A93.png" class title="This is an example image">

<p>​    如果t0,t1是生产，t2,t3是消费，那么第一下t0进行生产了第1只烤鸭，此时烤鸭数为2，flag=true，这是t0进入了休眠状态，此时临时阻塞状态的线程有t1,t2,t3。这时候如果t1被CPU执行到，flag=true，t1也进入休眠状态。这时候剩下t2,t3线程。t2被CPU执行到，消费烤鸭1,flag=false，唤醒线程池中的线程，这时线程池中线程有t0和t1，这时候要随机唤醒安全锁中的线程，假设t0被唤醒，这时候t2仍然有执行权，因为flag=false，t2进入休眠，此时有执行权的线程有t0与t3。假设t3抢到了CPU的执行权，因为flag=false，这时候t3也进入等待，只有t0活着。线程唤醒后直接接着执行，不用重新判断flag，因此t0生产烤鸭2。count=3，这时候flag=true。线程池中有3个线程，t0,t2,t3。这时候如果t0被唤醒，活的有t0,t1。这时候如果t0又抢到了CPU运行权，因为flag=true，t0进入休眠。因为t1不用再判断flag，因此直接生产烤鸭3，count=4。到现在为止，生产了烤鸭1,2,3，但是只消费了烤鸭1，产生了安全问题，烤鸭2没有被消费到。</p>
<p>​    原因在线程醒来后<strong>没有重新判断flag标记</strong>。因为if只判断一次标记，因此将if更改为<strong>while</strong>，结束后还会判断条件，便可以解决烤鸭没有被消费到问题。但是会出现<strong>死锁</strong>的问题。当一个烤鸭被生产，flag=true，唤醒另一个生产线程，这时候活的有t0,t1，进入while判断，因为flag均会进入等待，便没有活的线程。</p>
<p>​    解决死锁：没有唤醒对方才导致死锁。不能指定唤醒的线程，但是可以唤醒所有的线程，这样本方的继续等待，对方的进行工作。这样可以使用notifyAll()方法。</p>
<p>​    while判断标记，解决了线程获取执行权后，是否要运行！原因：if判断标记只有一次，会导致不该运行的线程运行了，出现了数据错误的情况。    </p>
<p>​    notifyAll()解决了本方线程一定会唤醒对方线程。原因：notify()只能唤醒1个线程，如果本方唤醒本方，没有意义。而且while判断标记+notify()会导致死锁。</p>
<p>​    仍然存在的问题：还会唤醒本方线程，而唤醒本方是没有意义的。这样便降低了效率。</p>
<h4 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h4><p>​    <strong>JDK1.5后</strong>。同步代码块对于锁的操作是隐式的。后期把锁封装成对象，获取锁与释放锁是锁对象最清楚，变成显示的。现在有lock()与unlock()来对锁进行操作。因此lock对synchronized进行了替代，代码进行改写。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E5%A4%A94.png" class title="This is an example image">

<p>​    之前使用synchronized依靠自定义的obj对象作为锁，现在可以利用自定义的锁对象，语法为Lock lock = new ReentrantLock();。如果代码中发生了异常，释放锁不能执行，因此释放锁一定要进行执行，放在finally中。</p>
<p>​    以前的锁是this.wait()与this.notify()，用哪个锁，就用哪个锁上的方法。因此要利用lock来使用wait()与notify()。以前如果锁是this，那么锁上只有1组方法。当锁变成对象，可以有多个锁，将监视器方法封装成Condition对象。可以将多个Condition挂在锁上。</p>
<p>​    Condition因素出Object监视器方法（ wait ， notify和notifyAll ）成不同的对象，以得到具有多个等待集的每个对象，通过将它们与使用任意的组合的效果Lock来实现。 <strong>Lock替换synchronized方法和语句的使用， Condition取代了对象监视器方法的使用</strong>。可以随时和锁进行绑定，通过lock.newCondition()获取一个Condition对象。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E5%A4%A95.png" class title="This is an example image">

<p>​    将原来的this.wait()替换成con.await()，将this.notify()替换成con.signal()，将this.notifyAll()替换成con.signalAll()。</p>
<p>​    之前只有1个监视器，对生产者消费者区分不开。因此现在可以有2个监视器，1组监视生产者，1组监视消费者（以前这么实现需要生产者与消费者分别有个锁，因为一个锁上只有1个监视器）。因此生产者上唤醒消费者，消费者上唤醒生产者。因此可以不用使用signalAll来避免死锁，只要唤醒相应的线程即可。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E5%A4%A96.png" class title="This is an example image">

<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E5%A4%A97.png" class title="This is an example image">

<p>​    生产者如果不满足，则让生产者进行等待，生产者唤醒的时候要唤醒消费者的线程。即以前只有1个线程池，但是现在有2个监视器，具有不同的线程池。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E5%A4%A98.png" class title="This is an example image">

<p>​    Lock接口：出现替代了同步代码块或者同步函数。将同步的隐式锁操作变成显示锁操作。同时更为灵活，可以一个锁上挂多个监视器。</p>
<p>lock()：获取锁</p>
<p>unlock()：释放锁，通常需要定义在finally代码块中。</p>
<p>​    Condition接口：出现替代了Object中的wait notify notifyAll方法。将这些监视器方法单独进行了封装，变成Condition监视器对象，可以任意锁进行组合。</p>
<p>await():相当于wait()</p>
<p>signal():相当于notify()</p>
<p>signal()All:相当于notify()All</p>
<p><strong>判断条件一定要用while()，因为安全</strong>。</p>
<p>​    使用流程：</p>
<ol>
<li><p>上锁；</p>
</li>
<li><p>try{运行代码，判断条件使用while，满足条件，await，不满足继续进行。然后signal相应监视器}</p>
</li>
<li><p>finally{ 开锁 }</p>
</li>
</ol>
<h4 id="wait与sleep的区别"><a href="#wait与sleep的区别" class="headerlink" title="wait与sleep的区别"></a>wait与sleep的区别</h4><ol>
<li><p>wait可以指定时间也可以不指定，sleep必须指定时间。</p>
</li>
<li><p>在同步中，对cpu的执行权和锁的处理不同。</p>
<p>wait():释放执行权，<strong>释放锁</strong>。</p>
<p>sleep():释放执行权，不释放锁。</p>
</li>
</ol>
<p>不释放执行权，那么电脑就卡死了。</p>
<p>​    在同步中有执行资格不一定能执行，持有相应的锁才能执行。同步中只有一个线程能够执行，但是同步中活着的线程不一定只有一个。</p>
<h4 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h4><ol>
<li><p>stop()方法，已过时</p>
</li>
<li><p>run()方法结束</p>
</li>
</ol>
<p>如何控制线程的任务结束</p>
<p>​    任务中都有循环结构，只要控制住循环，就可以结束任务。</p>
<p>​    控制循环通常用定义标记来完成。while(flag)，然后st.setFlag()来改变标识。但是如果线程在同步中wait()释放执行权与锁，这样便没办法去读标记。</p>
<p>​    线程处于冻结状态就无法读取标记，结束方法是：interrupt()方法，将线程从冻结状态强制恢复到运行状态中来，让线程具备CPU的执行资格，会抛出中断异常。强制执行会发生InterruptedException，记得要处理。   </p>
<p>线程中常见方法</p>
<p>setDaemon(boolean on)：将该线程标记为守护（后台）线程，当所有线程都是守护线程时，jvm退出运行，必须在    线程启动前设置。后台线程与前台线程只有结束时候不一样，前台线程要设置手动结束，后台线程只要所有前台线程结束，则后台线程自动结束。如果想让一个线程依赖于其他线程，则可以设置为后台线程。</p>
<p>join()，常用于临时加入一个线程运算时，先将此对象运行完，将调用此方法的线程冻结，只有在join的方法运行结束后才恢复。</p>
<p>setPriority(优先级1-10)，设置线程运行优先级，1最低，10最高，默认为5。</p>
<p>Thread(ThreadGroup group) 设置线程组</p>
<p>yield()暂停当前线程，执行其他线程。礼让 </p>
<p>线程与匿名内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x ,<span class="number">50</span>;x++)&#123;</span><br><span class="line">			System.out.println(<span class="string">"x="</span>+x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure>

<p>开启一个匿名的线程子类对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable r = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x ,<span class="number">50</span>;x++)&#123;</span><br><span class="line">			System.out.println(<span class="string">"z="</span>+x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Thread(r).start();</span><br></pre></td></tr></table></figure>

<p>新建一个匿名的Runnable子类对象，然后新建线程对象并调用start()方法。</p>
<h3 id="方法定义完整格式"><a href="#方法定义完整格式" class="headerlink" title="方法定义完整格式"></a>方法定义完整格式</h3><p>Java中方法定义的完整格式</p>
<p>访问权限{ public | default | protected | private }[final] [static] [ synchronized]</p>
<p>返回值类型 | void 方法名称{参数类型 参数名称,…}[throws Exception1, Exception2]{</p>
<p>​    [return [返回值|返回调用处]]</p>
<p>}</p>
<h2 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h2><p>从面对对象的思想转变为<strong>使用对象</strong></p>
<h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>​    字符串是一个特殊的对象，字符串一旦初始化就不可以被改变。</p>
<p>​    有字符串常量池，池中没有就建立，池中有，直接用。因为字符串对象不可改变，因此可以实现共享</p>
<p>字符串建立的方式</p>
<ol>
<li><p>String s = “abc”; 创建一个字符串对象在常量池中</p>
</li>
<li><p>String s = new String(“abc”); 创建两个对象一个new一个字符串对象在堆内存中被new对象维护</p>
</li>
</ol>
<p>String类中的equals覆写了Object中的equals建立了String类自己的判断字符串对象是否相同的依据，其实就是比较字符串内容。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC15%E5%A4%A91.png" class title="This is an example image">

<p>​    将字节数组变成字符串，把数字进行ASII码的对应。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC15%E5%A4%A92.png" class title="This is an example image">

<p>String的构造器，可以将数组变成字符串（byte[]与char[]）,传入数字变成对应的字符</p>
<ol>
<li><p>String(byte[] bytes)；String(byte[] bytes, int offset, int length);定义起始位置，长度</p>
</li>
<li><p>String(char[] value);   String(char[] value, int offset, int count)</p>
</li>
</ol>
<p>寻找方法的思路：思考返回类型和传入类型</p>
<p>按照面向对象的思想对字符串功能进行分类</p>
<h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><p>  1.1 获取字符串中字符的个数（长度）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>  1.2 根据位置获取字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br></pre></td></tr></table></figure>

<p>  1.3 根据字符获取在字符串中第一次出现的位置(重点)我们可以根据-1，来判断该字符或者字符串是否存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> 从指定位置进行ch的查找第一次出现位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span> 找字符串的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span></span></span><br></pre></td></tr></table></figure>

<p>​    根据字符获取在字符串中最后一次出现的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> 从指定位置进行ch的查找最后一次出现位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span> 找字符串的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span></span></span><br></pre></td></tr></table></figure>

<p>  1.4 获取字符串中一部分字符串，也叫子串。<strong>包括begin,不包括end</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> 子串开始于指定beginIndex并延伸到字符索引endIndex-1 </span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> 从指定位置到结束</span></span><br></pre></td></tr></table></figure>

<h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><p>  2.1 将字符串变成字符串数组(字符串的切割)按照指定规则切割</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] split(String regex) ,不能直接用.切割，要转义成\\.，涉及到正则表达式</span><br></pre></td></tr></table></figure>

<p>  2.2 将字符串转成字符数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] toCharArray()</span><br></pre></td></tr></table></figure>

<p>  2.3 将字符串转成字节数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] getBytes() 一个中文<span class="number">2</span>字节，ascii为美国的编码表，GB2312中文的编码表最大为<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>  2.4 将字符串中的字母转成大小写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">()</span> 大写</span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">()</span> 大写</span></span><br></pre></td></tr></table></figure>

<p>  2.5 将字符串中的内容进行替换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> 没替换成功，仍然返回原来的字符串</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(String s1,String s2)</span></span></span><br></pre></td></tr></table></figure>

<p>  2.6 将字符串两端的空格去除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>  2.7 将字符串进行连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><p>  3.1 两个字符串是否相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span> 忽略大小写比较字符串是否相同</span></span><br></pre></td></tr></table></figure>

<p>  3.2 字符串中是否包含指定字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span></span></span><br></pre></td></tr></table></figure>

<p>  3.3 字符串是否以指定字符串开头，是否以指定字符串结尾</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>​     int compareTo(String anotherString) 如果参数字符串等于此字符串，则返回值0；如果此字符串按字典顺序小于字符串参数，则返回一个小于0的值；如果此字符串按字典顺序大于字符串参数，则返回一个大于0的值。</p>
<p>​    String intern()当调用intern方法时，如果池已经包含与[equals(Object)](mk:@MSITStore:D:\java学习资料\jdk api 1.8_google.CHM::/java/lang/String.html#equals-java.lang.Object-)方法确定的相当于此String对象的字符串，则返回来自池的字符串。 否则，此String对象将添加到池中，并返回对此String对象的引用。 由此可见，对于任何两个字符串s和t ， s.intern() == t.intern()是true当且仅当s.equals(t)是true 。可以将堆中的数据存到字符串池中去。</p>
<h3 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h3><p>StringBuffer:就是字符串缓冲区，用于存储数据的容器</p>
<p>特点：</p>
<ol>
<li><p>长度是可变的</p>
</li>
<li><p>可以存储不同类型的数据</p>
</li>
<li><p>最终要转成字符串进行使用</p>
</li>
<li><p>可以对字符串进行修改</p>
</li>
</ol>
<p>既然是一个容器对象，应该具备的功能有 </p>
<ol>
<li><p>添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">StringBuffer <span class="title">append</span><span class="params">(data)</span></span>;可以继续在append后面继续添加</span><br><span class="line"><span class="function">StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, <span class="keyword">char</span> c)</span> 在指定位置进行添加</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span>：包含头，不包含尾</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">deleteCharAt</span><span class="params">(<span class="keyword">int</span> index)</span> ：删除指定位置的元素</span></span><br><span class="line"><span class="function">sb.<span class="title">delete</span><span class="params">(<span class="number">0</span>, sb.length()</span>)</span>;清空缓冲区</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">StringBuffer <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCharAt</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span> ch)</span> 不返回本类对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">int</span> newLength)</span> 设置长度</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>增删改查C(create)U(update)R(read)D(delete)</strong></p>
<p>可变长度数组原理，如果长度超出，则新建一个长度与原数组相同的数组，然后将两个数组长度相加，原有的数据复制。</p>
<h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><p>jdk1.5以后出现了功能和StringBuffer一模一样的对象，就是StringBuilder。</p>
<p>不同之处，</p>
<p>StringBuilder是线程同步的,通常用于多线程</p>
<p>StringBuffer是线程不同步的。通常用于单线程，它的出现提高效率</p>
<p>StringBuilder因为没有判断锁，因此单线程使用StringBuilder，如果多线程使用StringBuffer。如果操作全部是字符串，那么就用StringBuilder</p>
<h3 id="jdk升级原则"><a href="#jdk升级原则" class="headerlink" title="jdk升级原则"></a>jdk升级原则</h3><ol>
<li><p>简化书写（可能有弊端）</p>
</li>
<li><p>提高效率（可能有弊端）</p>
</li>
<li><p>提高安全性（书写麻烦）</p>
</li>
</ol>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>8种：byte,int,short,long,double,float,char,Boolean</p>
<p>将基本数据类型包装成类</p>
<p>​    用基本数值类型和字符串做转换</p>
<p>基本数据类型包装类</p>
<p>为了方便操作数据类型值，将其封装成了对象，在对象中定义了属性和行为，丰富了该数据的操作</p>
<p>  用于描述该对象的类就称为基本数据类型包装类</p>
<p>  byte    Byte</p>
<p>  short   Short</p>
<p>  int    Integer   静态方法parseInt(String s)</p>
<p>  long    Long</p>
<p>  float   Float</p>
<p>  double   Double</p>
<p>  char    Character</p>
<p>  boolean Boolean</p>
<p>  该包装对象主要用于基本类型和字符串之间的转换</p>
<h4 id="基本类型—-gt-字符串"><a href="#基本类型—-gt-字符串" class="headerlink" title="基本类型—&gt;字符串"></a>基本类型—&gt;字符串</h4><ol>
<li><p>基本数值类型+””</p>
</li>
<li><p>用String类中的静态方法valueOf(基本数值类型)</p>
</li>
<li><p>用Integer的静态方法toString(int i, int radix)</p>
</li>
</ol>
<h4 id="字符串—-gt-基本类型"><a href="#字符串—-gt-基本类型" class="headerlink" title="字符串—&gt;基本类型"></a>字符串—&gt;基本类型</h4><ol>
<li><p>使用包装类中的静态方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">xxx <span class="title">parseXxx</span><span class="params">(<span class="string">"xxx类型的字符串"</span>)</span></span>;***最常用</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(<span class="string">"intString"</span>)</span></span>;Integer.parseInt()</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">parseLong</span><span class="params">(<span class="string">"longString"</span>)</span></span>;Long.parseInt()</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">parseBoolean</span><span class="params">(<span class="string">"booleanString"</span>)</span></span>; Boolean.parseBoolean()</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果字符串被Integer进行对象的封装。可使用另一个非静态的方法：intValue()</p>
<p>将一个Integer对象转成基本数据类型值</p>
<p>Integer j = new Integer(“123”);</p>
<p>System.out.println(j.intValue());</p>
</li>
</ol>
<h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h4><ul>
<li>十进制–&gt;其他进制</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> String Integer.toBinaryString(<span class="keyword">int</span> i);<span class="comment">//2进制</span></span><br><span class="line"><span class="keyword">static</span> String Integer.toOctalString(<span class="keyword">int</span> i);<span class="comment">//8进制</span></span><br><span class="line"><span class="keyword">static</span> String Integer.toHexString(<span class="keyword">int</span> i);<span class="comment">//16进制</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> radix)</span> 任意进制</span></span><br></pre></td></tr></table></figure>

<ul>
<li>其他进制–&gt;十进制</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s, <span class="keyword">int</span> radix)</span></span></span><br></pre></td></tr></table></figure>

<p>Integer中比较的是数值是否相同。如果用equals方法就是返回boolean，如果用compareTo方法返回的是数值，可以知道哪个比较大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">i +</span>= <span class="number">6</span>;<span class="comment">//i = new Integer(i.intvalue()+6);//i.intvalue()自动拆箱</span></span><br></pre></td></tr></table></figure>

<p>而因为i为对象，因此i可能为null，如果空的调用intvalue()方法会出错，因此在自动拆箱的时候要进行健壮性判断。</p>
<h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><p>集合类的由来</p>
<p>​    对象用于封装特有数据，对象多了就需要存储，如果对象的个数不确定，</p>
<p>​    就使用集合容器进行存储</p>
<h4 id="集合特点："><a href="#集合特点：" class="headerlink" title="集合特点："></a>集合特点：</h4><ol>
<li><p>用于存储对象的容器</p>
</li>
<li><p>集合的长度是可变的</p>
</li>
<li><p>集合中不可以存储基本数据类型</p>
</li>
</ol>
<p>集合容器因为内部的数据结构不同，有多种具体容器。</p>
<p>不断向上抽取，就形成了集合框架</p>
<p>框架的顶层Collection接口：</p>
<h4 id="Collection的常见方法："><a href="#Collection的常见方法：" class="headerlink" title="Collection的常见方法："></a>Collection的常见方法：</h4><ol>
<li>添加</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object obj)</span></span>;添加一个对象</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection coll)</span></span>;添加一堆对象</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>删除</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>;删除一个对象，利用equals方法判断</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection coll)</span></span>;删除一堆对象，将两个集合中的相同元素从调用removeAll的集合中删除</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;将集合中的元素都删掉</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object obj)</span></span>;判断是否有此对象，利用equals方法判断</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection coll)</span></span>;判断是否有一堆对象</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;判断集合中是否有元素</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;获取长度</span><br><span class="line"><span class="function">Iterator <span class="title">iterator</span><span class="params">()</span></span>;取出元素的方式：迭代器</span><br></pre></td></tr></table></figure>

<p>  该对象必须依赖于具体的容器，因为每一个容器的数据结构都不同。</p>
<p>  所以该迭代器对象是在容器中进行内部实现的。</p>
<p>  对于使用容器者而言，具体的实现不重要，只要通过容器获取到该实现的迭代器对象即可，也就是iterator方法。</p>
<ol start="5">
<li>其他</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection coll)</span></span>;取交集，取交集，保留和指定集合相同的元素，而删除不同的元素。与removeAll相反</span><br><span class="line">Object[] toArray();将集合转成数组</span><br></pre></td></tr></table></figure>

<h4 id="集合判断元素依据"><a href="#集合判断元素依据" class="headerlink" title="集合判断元素依据"></a>集合判断元素依据</h4><p>对于ArrayList这样的集合，判断元素的方式是依据equals方法，而对于HashSet这样的集合，依靠的是equals和hashCode方法</p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>取出元素的两种方法</p>
<p>Collection coll = new ArrayList();</p>
<ol>
<li><p>使用while循环，结束后it占用内存空间，开发中不推荐</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator it = coll.iterator();</span><br><span class="line">	<span class="keyword">while</span>(it.hasNext())</span><br><span class="line">		System.out.println(it.next());</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用for循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator it = coll.iterator();it.hasNext();) &#123;</span><br><span class="line">	System.***out\***.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>iterator是一个内部类。类比于娃娃机的夹子，娃娃机是容器，夹子是迭代器，迭代器不能直接new，只能通过容器来操作夹子，但是统一的有移动和按钮。</p>
<p>集成框架的构成</p>
<h4 id="常见集合关系图"><a href="#常见集合关系图" class="headerlink" title="常见集合关系图"></a>常见集合关系图</h4><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC16%E5%A4%A91.png" class title="This is an example image">

<p>虚线框都是接口</p>
<p>Collection</p>
<pre><code>|--List: 有序，(存入和存出的数据一致)，元素都有索引(角标)，元素可以重复。</code></pre><p>​     |–Set: 元素不能重复，无序。</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List特有的常见方法:有一个共性特点就是都可以<strong>操作角标</strong></p>
<ol>
<li><p>添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(index,collection)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">remove</span><span class="params">(index)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">set</span><span class="params">(index,element)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object)</span></span>;</span><br><span class="line"><span class="function">List <span class="title">subList</span><span class="params">(from,to)</span></span>;包含头不包含尾</span><br></pre></td></tr></table></figure>

<p>List集合是可以完成对元素的增删改查</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一般集合的取出方式</span></span><br><span class="line">Iterator it = list.iterator();   </span><br><span class="line">	<span class="keyword">while</span>(it.hasNext())</span><br><span class="line">		System.out.println(it.next());</span><br><span class="line">	<span class="comment">//list特有的取出方式</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;list.size();x++)</span><br><span class="line">		System.out.println(<span class="string">"get:"</span>+list.get(x));</span><br></pre></td></tr></table></figure>

<p>当迭代器与集合同时操作元素，就会产生异常，这样是并发操作。</p>
<p>在迭代过程中不要使用集合操作元素，容易出现异常</p>
<p>可以使用Iterator接口的子接口ListIterator来完成迭代中对元素进行更多的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListIterator it = list.listIterator();<span class="comment">//获取列表迭代器对象</span></span><br><span class="line">		<span class="comment">//它可以实现在迭代过程中完成对元素的增删改查</span></span><br><span class="line">		<span class="comment">//注意：只有List集合具有该迭代功能。</span></span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			Object obj = it.next();</span><br><span class="line">			<span class="keyword">if</span>(obj.equals(<span class="string">"abc2"</span>))</span><br><span class="line">				it.set(<span class="string">"abc9"</span>);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>ListIterator listIterator()从头返回列表迭代器</p>
<p>ListIterator listIterator(int index)从指定位置返回列表迭代器</p>
<p>不仅有hasNext()和next()，还有hasPrevious()和previous()方法</p>
<p>List接口中比较常用的有：<strong>ArrayList</strong>，<strong>LinkList</strong>。</p>
<p>List</p>
<p>​    |–Vector:内部是数组数据结构，是同步的。效率低。增删、查询都很慢！</p>
<p>​    |–ArrayList:内部是数组数据接口，是不同步的。替代了Vector。查询的速度快。</p>
<p>​    |–LinkedList:内部是链表数据结构，是不同步的。增删元素的速度很快。</p>
<p>​    数组增删慢的原因是增加删除一个元素，该元素之后的内存空间均要发生变化，而查询快是因为内存空间是连续的。而链表存储是不连续的，而链表的增删只需要将此对象的地址存给上一个对象或者将此对象所存的下一个对象的地址存入上一个对象即可完成。查询慢是因为要遍历链表才能完成查询，而链表存储空间不是连续的（作为List的子类也有下标索引）。</p>
{% asset_img 第16天2.png This is an example image %}

<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(element)</span> 在链表的开头加入指定的元素</span></span><br><span class="line"><span class="function"><span class="title">getFirst</span><span class="params">()</span> <span class="comment">//获取第一个元素但不删除</span></span></span><br><span class="line"><span class="function"><span class="title">removeFirst</span><span class="params">()</span>)</span>;<span class="comment">//获取第一个元素并删除，remove()会改变长度</span></span><br></pre></td></tr></table></figure>

<h5 id="遍历链表的一种方式"><a href="#遍历链表的一种方式" class="headerlink" title="遍历链表的一种方式"></a>遍历链表的一种方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!link.isEmpty())&#123;<span class="comment">//判断是否为空，为空则为真</span></span><br><span class="line">			System.out.println(link.removeLast());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Linkedist常用方法与1-6改进"><a href="#Linkedist常用方法与1-6改进" class="headerlink" title="Linkedist常用方法与1.6改进"></a>Linkedist常用方法与1.6改进</h5><p>添加</p>
<p>​    addFirst();</p>
<p>​    addLast();</p>
<p><strong>jdk1.6</strong></p>
<p>​    offerFirst();</p>
<p>​    offerLast();</p>
<p>  获取</p>
<pre><code>getFirst();//获取但不移除。如果链表为空，抛出NoSuchElementException

getLast();</code></pre><p> <strong>jdk1.6</strong></p>
<p>​    peekFirst();//获取但不移除。如果链表为空，返回null</p>
<p>​    peekLast();</p>
<p>移除</p>
<p>​    removeFirst();//获取并移除。如果链表为空，抛出NoSuchElementException</p>
<p>​    removeLast();</p>
<p>  <strong>jdk1.6</strong></p>
<p>​    pollFirst();//获取并移除。如果链表为空，返回null</p>
<p>​    pollLast();</p>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>默认新建ArrayList对象的时候，开辟的空间为10。</p>
<p>((Person)it.next()).getName()+”::”+((Person) it.next()).getAge());</p>
<p>//不能直接调用Person的方法，因为此时被提升为了Object，父类中没有此方法,可以使用强制类型转换。如果不给it.next加括号， 那么因为.优先级太高而没有先完成强制转换。</p>
<p>如果在循环中多次调用it.next，那么会出错，因为next一直在往下走。 </p>
<p>  因此如果使用自定义对象，一直要使用强制类型转换，才能获取该对象的特有方法。直接打印it.next()，出现的是类名加哈希值，因为该对象没有覆写toString()方法。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC17%E5%A4%A91.png" class title="This is an example image">

<p>内存图解，集合中存储的均为堆内存对象的引用，迭代器取出元素，也是使用的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList al = <span class="keyword">new</span> ArrayList();</span><br><span class="line">al.add(<span class="number">5</span>);<span class="comment">//al.add(new Integer(5))</span></span><br><span class="line">add()方法不能接受基本数据类型，但是在jdk1<span class="number">.4</span>后可以使用自动装箱。</span><br></pre></td></tr></table></figure>

<p>  当基本数据类型赋值给引用数据类型的时候，会发生自动装箱。因为集合中需要添加对象，直接用数字相当于对5进行了Integer装箱。当引用数据类型与基本数据类型做运算，会发生自动拆箱。</p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><h4 id="枚举-1"><a href="#枚举-1" class="headerlink" title="枚举"></a>枚举</h4><p>使用element方法获取枚举。</p>
<p>Vector中有枚举接口Enumeration，功能与Iterator一样，但是Iterator名称更简单。</p>
<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p>Set:元素不可重复，是无序。</p>
<p>  Set接口中的方法和Collection一致。</p>
<p>|–<strong>HashSet</strong>:内部数据结构是哈希表，是不同步的。</p>
<ul>
<li><p>保证集合元素的唯一性</p>
</li>
<li><p>是通过对象的hashCode和equals方法来完成对象的唯一性的。</p>
</li>
<li><p>如果对象的hashCode值不同，那么不用判断equals方法，就直接存储到哈希表中。</p>
</li>
<li><p>如果对象的hashCode值相同，那么要再次判断对象的equals方法是否为true。</p>
</li>
<li><p>如果为true，视为相同元素，不存。如果 为false，视为不同元素，进行存储。</p>
<pre><code>  **记住：如果元素要存储到HashSet集合中，必须覆盖hashCode方法和equals方法**。

一般情况下，如果定义的类会产生很多对象，比如学生，人，书，通常都要覆盖equals，hashCode方法。

建立对象判断是否相同的依据。</code></pre></li>
</ul>
<p>|–<strong>TreeSet</strong>:可以对Set集合中的元素排序。是不同步的。</p>
<p>​        判断元素唯一性的方式:就是根据比较方法的返回结果是否为0，是0，就是相同元素，不存。</p>
<pre><code>TreeSet对元素进行排序的**方式一**:</code></pre><ul>
<li><p>让<strong>元素自身具备比较功能</strong>，元素就需要实现Comparable接口，覆盖compareTo方法。</p>
</li>
<li><p>如果不要按照对象中具备的自然顺序排序。如果对象中不具备自然顺序。怎么办？</p>
<p> TreeSet对元素进行排序的<strong>方式二</strong>:</p>
</li>
<li><p>让集合自身具备比较功能。定义一个类实现Comparator接口，覆盖compare方法。</p>
</li>
<li><p>将该类对象作为参数传递给TreeSet集合的构造函数。</p>
</li>
<li><p>比较器发开中更为常用，如果有比较器和类自己的compareTo方法，优先使用比较器。</p>
</li>
</ul>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>优化过的数组，根据存的元素的特点来获取其数组中的位置。查找的时候，根据这个元素再计算其对应的位置值，然后直接取出即可。算法为哈希算法。hashCode()为计算对象的哈希值，自定义对象可以覆盖方法。</p>
{% asset_img 第17天2.png This is an example image %}

<p>如自定义哈希算法，根据ab的特点算出一个值，再将值%数组长度，必定会得到数组长度之内的一个值，这样就可以获取到ab的位置。当要寻找ab的时候，再计算ab的哈希值，这样直接在相应的位置去寻找即可。</p>
<p>​    Set的获取只能使用迭代器。</p>
<p>​    哈希算法提高了数组的查询效率，但是不能重复。</p>
<h4 id="哈希表确定元素是否相同"><a href="#哈希表确定元素是否相同" class="headerlink" title="哈希表确定元素是否相同"></a>哈希表确定元素是否相同</h4><ol>
<li><p>判断的是两个元素的哈希值是否相同。如果相同，再判断两个对象的内容是否相同。</p>
</li>
<li><p>判断哈希值相同，其实判断的是对象的hashCode()方法。判断内容相同，用的是equals()方法。</p>
</li>
</ol>
<p>注意：如果哈希值不同，是不需要判断equals的。</p>
<p>哈希值一样，但是对象不一样，称之为哈希冲突。如果冲突则顺延或者串联。在相同位置挂一个出来。</p>
<p>当存入的是自定义对象时候，需要覆写hashCode方法和equals方法。如果是字符串则调用字符串的hashCode()，如果是数字，则乘上一个常数。进行比较的时候，首先判断位置是否相同，然后向下转型之前进行健壮性判断，然后比较对应的信息。为了便于输出信息，可以覆写对象的toString方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="keyword">this</span>+<span class="string">"......hashCode"</span>);</span><br><span class="line">	<span class="keyword">return</span> name.hashCode()+age*<span class="number">27</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>==obj)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Person))</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();<span class="comment">//健壮性判断</span></span><br><span class="line">	Person p = (Person)obj;<span class="comment">//向下转型	</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name.equals(p.name)&amp;&amp; <span class="keyword">this</span>.age==p.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哈希集合中判断元素是否相同的依据是hashCode方法和equals方法。</p>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>哈希表和链表实现了Set接口，具有可预测的迭代次序。 这种实现不同于HashSet，它维持于所有条目的运行双向链表。 该链表定义了迭代排序，它是将元素插入集合（插入顺序 ） 的顺序 。</p>
<p>​    怎么样存就怎么取出来。</p>
<p>​    如果要<strong>唯一而且要有序</strong>，就用LinkedHashSet。</p>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>如果要存入自定义对象，需要此对象<strong>实现Comparable接口</strong>并<strong>覆盖compareTo方法</strong>。</p>
<h4 id="二叉树图解"><a href="#二叉树图解" class="headerlink" title="二叉树图解"></a>二叉树图解</h4>{% asset_img 第17天3.png This is an example image %}

<p>​    28进来不用比较，21进来比28小放在左边，29进来比28大放在右边。25比28小进左边，比21大生叉放在21右边，以此类推。</p>
<p>​    节点的特点：最多持有3个引用，左、右、父。二叉树为了提高效率，会在每次添加新元素时候进行二分查找。</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型:</p>
<p>  jdk1.5后出现的安全机制。</p>
<p>好处:</p>
<ol>
<li><p>将运行时期的问题ClassCastException转到了编译时期。</p>
</li>
<li><p>避免了强制转换的麻烦。</p>
</li>
</ol>
<p>&lt;&gt;:什么时候用？当操作的引用数据类型不确定的时候，就使用&lt;&gt;，将要操作的引用数据类型传入即可。</p>
<p>​     其实&lt;&gt;就是一个用于接收具体引用数据类型的参数范围。</p>
<p>在程序中，只要用到了带有&lt;&gt;的类或者接口，就要明确传入的具体引用数据类型。</p>
<p>泛型技术是给编译期使用的技术，用于编译时期。确保了类型的安全。</p>
<p>运行时，会将泛型去掉，生成的class文件中是不带泛型的，这个称为泛型的擦除。</p>
<p>擦除的原因：为了去兼容运行时的类加载器。</p>
<p>泛型的补偿:在运行时，通过获取元素的类型进行转换动作，不用使用者再强制</p>
<p>泛型中不能使用基本数据类型，只能传入引用数据类型。</p>
<p>Comparable接口上定义了泛型，指定进行比较的参数类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = <span class="keyword">this</span>.age - p.age;</span><br><span class="line">		<span class="keyword">return</span> temp==<span class="number">0</span>?<span class="keyword">this</span>.name.compareTo(p.name):temp;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>​    如果不指定，默认为Object，而且在compareTo方法中还要向下转型。</p>
<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>在jdk1.5后，使用泛型来接收类中要操作的引用数据类型。</p>
<p>泛型类，什么时候用？当类中的操作的引用数据类型不确定的时候，就使用泛型来表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tool</span>&lt;<span class="title">Q</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Q q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>&lt;W&gt; <span class="keyword">void</span> <span class="title">show</span><span class="params">(W str)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"show"</span>+str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将泛型定义在方法上，W为类型名称，待传入，而W要进行声明。</p>
<p>​    当方法静态时，不能访问类上定义的泛型，如果静态方法使用泛型，只能将<strong>泛型定义在方法上</strong>。</p>
<p>泛型一定要放在<strong>返回值的前面</strong>，<strong>修饰符的后面</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;Y&gt;<span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(Y obj)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"method"</span>+obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用泛型，则有些对象才有的方法则不能使用，但是部分方法可以使用，即Object中的方法必定可以使用</p>
<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>实现一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterImp</span> <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InterImp in = <span class="keyword">new</span> InterImp();</span><br><span class="line">in.show(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>

<p>实现二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterImp2</span>&lt;<span class="title">Q</span>&gt; <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">Q</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Q q)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"show"</span>+q);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InterImp2&lt;Integer&gt; in2 = <span class="keyword">new</span> InterImp2&lt;Integer&gt;();</span><br><span class="line">in2.show(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><p>泛型的通配符:?未知类型。</p>
<p>当不能明确传入泛型的类型时候使用。仅在类型不明确并不对这类型操作来表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCollection</span><span class="params">(Collection&lt;?&gt; al)</span> </span>&#123;</span><br><span class="line">		Iterator&lt;?&gt; it = al.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			System.out.println(it.next());</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;Q&gt;<span class="function"><span class="keyword">void</span> <span class="title">printCollection</span><span class="params">(Collection&lt;Q&gt; al)</span> </span>&#123;</span><br><span class="line">		Iterator&lt;Q&gt; it = al.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			System.out.println(it.next());</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是比较麻烦 </p>
<h4 id="泛型限定"><a href="#泛型限定" class="headerlink" title="泛型限定"></a>泛型限定</h4><p>只能有一部分类型能进来</p>
<p>可以对类型进行限定</p>
<p>? <strong>extends</strong> E:接收E类型或者E的子类型对象。上限！    </p>
<p>? <strong>super</strong> E:接收E类型或者E的父类型，下限！</p>
<p>迭代器的泛型和获取迭代器集合的泛型一致。</p>
<p><strong>泛型上限</strong>：</p>
<p>如果有不同的集合，分别创建Person类的子类，一个方法要接收Person类子类的集合，不能直接接收Collection<Person>，因为Person为一具体类型。</Person></p>
<p>  一般两边泛型类型要一致。这样要如果限定只能接收某一对象的子类，可以使用</p>
<p><strong>&lt;? extends Person&gt;</strong>，即只接收Person或者Person的子类。这样<strong>可以直接新建Person类对象</strong>。</p>
<p><strong>泛型下限</strong>:</p>
<p>使用&lt;? super Student&gt;，只能接收学生类及其父类</p>
<p>addAll(Collection&lt;? extends E&gt; e)原因，可以接收该集合类型及子类类型，提高了拓展性和安全性。一般只要写了E就可以接收该类的集合对象，但是为了能接收其子类对象，增加了泛型的上限。</p>
<p><strong>使用情况：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">addAll(Collection&lt;? extends E&gt; e)</span><br><span class="line">		ArrayList&lt;Person&gt; al1 = <span class="keyword">new</span> ArrayList&lt;Person&gt;();		</span><br><span class="line">		ArrayList&lt;Student&gt; al2 = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line">		al1.addAll(al2);</span><br></pre></td></tr></table></figure>

<p>一般存储元素的时候都使用上限，因为这样取出都是按照上限类型来运算的，不会出现类型安全隐患。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span><br><span class="line">		TreeSet&lt;Person&gt; al1 = <span class="keyword">new</span> TreeSet&lt;Person&gt;(<span class="keyword">new</span> CompByName());</span><br><span class="line">		TreeSet&lt;Student&gt; al2 = <span class="keyword">new</span> TreeSet&lt;Student&gt;(<span class="keyword">new</span> CompByName());</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompByName</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = o1.getName().compareTo(o2.getName());</span><br><span class="line">		<span class="keyword">return</span> temp==<span class="number">0</span>?o1.getAge()-o2.getAge():temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>学生的集合中，比较器可以用学生的也可以用父类的，因为其使用的方法源于父类。</p>
<p>  通常<strong>对集合中的元素取出操作</strong>时，可以使用下限。存什么类型，我可以用其类型和父类类型来进行接收。</p>
<p>包含containsAll(Collection&lt;?&gt;coll)为什么用？</p>
<p>  因为Collection的原理为equals，任何对象都具有其方法，因此接收的集合类型可以是任意类型，因此用?来进行接收。只要全部使用Object方法，因此就可以使用?。</p>
<h3 id="集合框架查询技巧"><a href="#集合框架查询技巧" class="headerlink" title="集合框架查询技巧"></a>集合框架查询技巧</h3><p>需要唯一吗？</p>
<p>需要：Set</p>
<p>​    需要指定顺序吗？</p>
<p>​           需要：TreeSet</p>
<p>​           不需要：HashSet</p>
<p>​           但是想要一个和存储一致的顺序（有序）：LinkedHashSet</p>
<p>不需要：List</p>
<p>​    需要频繁增删吗？</p>
<p>​           需要：LinkedList</p>
<p>​           不需要：ArrayList</p>
<p>如何记住每一个容器的结构和所属体系呢？</p>
<p>看名字！</p>
<p>List:</p>
<p>​        |–ArrayList</p>
<p>​        |–LinkedList</p>
<p>Set:</p>
<p>​        |–HashSet</p>
<p>​        |–TreeSet</p>
<p>后缀名就是该集合所属的体系。</p>
<p>前缀名就是该集合的数据结构。</p>
<p>看到arrays：就要想到数组，就要想到查询快，有角标。</p>
<p>看到link：就要想到链表，就要想到增删快，就要想到add get remove+first  last的方法</p>
<p>看到hash：就要想到哈希表，就要想到唯一性，就要想到元素需要覆盖hashCode方法和equals方法。</p>
<p>看到tree：就要想到二叉树，就要想到排序，就要想到两个 接口Comparable，Comparator（比较器）</p>
<p>而且这些通常这些常用的集合容器都是不同步的。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map:一次添加一对元素。Collection:一次添加一个元素。</p>
<p>Map也称为双列集合，Collection称为单列集合。</p>
<p>其实Map集合中存储的是键值对。Map集合中必须保证键的唯一性。</p>
<p>常用方法:</p>
<ol>
<li><p>添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">value <span class="title">put</span><span class="params">(key,value)</span></span>;返回前一个和key关联的值，如果没有返回<span class="keyword">null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;清空map集合</span><br><span class="line"><span class="function">value <span class="title">remove</span><span class="params">(key)</span></span>;根据指定的key删除这个键值对</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">value <span class="title">get</span><span class="params">(key)</span></span>;通过键获取值，如果没有该键，返回<span class="keyword">null</span>。</span><br><span class="line">				当然可以通过返回<span class="keyword">null</span>,来判断是否包含指定键。</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;获取键值对的个数。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="取出Map中所有元素"><a href="#取出Map中所有元素" class="headerlink" title="取出Map中所有元素"></a>取出Map中所有元素</h4><p>方式一：取出丈夫，再取出妻子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line"><span class="comment">//取出Map中的所有元素</span></span><br><span class="line"><span class="comment">//原理，通过keySet方法获取map中所有的键所在的Set集合，再通过Set的迭代器获取到每一个键。</span></span><br><span class="line"><span class="comment">//再对每一个键获取其对应的值即可。</span></span><br><span class="line">Set&lt;Integer&gt; keySet = map.keySet();</span><br><span class="line">Iterator&lt;Integer&gt; it = keySet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	Integer key = it.next();</span><br><span class="line">	String value = map.get(key);</span><br><span class="line">	System.out.println(key+<span class="string">":"</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

{% asset_img 第18天1.png This is an example image %}

<p>首先利用keySet()方法将Map中的键映射到Set集合中，然后通过迭代器可以得到每一个键key，再利用Map的get(key)方法得到每一个键对应的值。</p>
<p>其中被注释的两句相当于下面一句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//		Set&lt;Student&gt; keyset = hm.keySet();</span></span><br><span class="line"><span class="comment">//		Iterator&lt;Student&gt; it = keyset.iterator();</span></span><br><span class="line">		Iterator&lt;Student&gt; it = hm.keySet().iterator();</span><br></pre></td></tr></table></figure>

<p>方式二：得到结婚证书</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 通过Map转成Set就可以迭代，找到了另一个方法	entrySet.</span></span><br><span class="line"><span class="comment">		 * 该方法将键和值的映射关系作为对象存储到了Set集合中，而这个映射关系的类型就是Map.Entry类型(结婚证)</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">		Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = entrySet.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			Map.Entry&lt;Integer, String&gt; me = it.next();</span><br><span class="line">			Integer key = me.getKey();</span><br><span class="line">			String value = me.getValue();</span><br><span class="line">			System.out.println(key+<span class="string">":"</span>+value);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>​    通过entrySet()方法将键值的映射投射到Set集合中，其中将键和值封装成一个对象。</p>
{% asset_img 第18天2.png This is an example image %}

<p>其中上面两句相当于下面一句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//		Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entrySet = map.entrySet();</span></span><br><span class="line"><span class="comment">//		Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = entrySet.iterator();</span></span><br><span class="line">	Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = map.entrySet().iterator();</span><br></pre></td></tr></table></figure>

<p>只获取value值</p>
<p>Collection values();返回value所有值的Collection集合</p>
<h3 id="Map常用的子类"><a href="#Map常用的子类" class="headerlink" title="Map常用的子类"></a>Map常用的子类</h3><p>​    |–Hashtable:内部结构是哈希表，是同步的。不允许null作为键，不允许null作为值。</p>
<p>​    |–Properties:用来存储键值对型的配置文件的信息。可以和IO技术相结合。</p>
<p>​    |–HashMap:内部结构是哈希表，不是同步的。允许null作为键，允许null作为值。</p>
<p>​    |–TreeMap:内部结构是二叉树，不是同步的。可以对Map集合中的键进行排序。 </p>
<p>HashSet是HashMap的一个实例。</p>
<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>​    可以将存储的元素有序输出，即存入什么顺序，取出什么顺序。</p>
<h4 id="Map应用"><a href="#Map应用" class="headerlink" title="Map应用"></a>Map应用</h4><p>  Map集合在有映射关系时可以优先考虑</p>
<p>​    键值关系多，往Map里面存储，不一定需要有序编号，只是建立对象间的关系。</p>
<p>​    Map中的值也可以是集合，如List,Set</p>
<p>​    在查表法中的应用较为多见</p>
<h3 id="集合框架工具类"><a href="#集合框架工具类" class="headerlink" title="集合框架工具类"></a>集合框架工具类</h3><h4 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a>Collections类</h4><p>Collections:是集合框架的工具类，里面的方法都是静态的，<strong>操作集合</strong>。</p>
<p>1、 排序</p>
<p>自然顺序排序</p>
<p>Collections sort(List) </p>
<p>​    如果只对一种类型进行排序，那么就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mySort</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size()-<span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; list.size(); j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(list.get(i).compareTo(list.get(j))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">					String temp = list.get(i);</span><br><span class="line">					list.set(i, list.get(j));</span><br><span class="line">					list.set(j,temp);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>如果想对任意类型的集合进行排序，那么需要使用泛型，可以使用&lt;?&gt;或<T>，但是要对泛型的类型进行限制，因此变成</T></p>
<p>  <strong>public</strong> <strong>static</strong> <T><strong>void</strong> mySort(List<T> list)</T></T></p>
<p>  但是排序中用到了compareTo方法，只有实现了此接口才具有，因此对T进行限定，必须是Comparable接口的子类，则变成</p>
<p><strong>public</strong> <strong>static</strong> &lt;T <strong>extends</strong> Comparable<T>&gt; <strong>void</strong> mySort(List<T> list)</T></T></p>
<p>  而Comparable也要指出泛型的类型，可以使用T。为了提高拓展性，为了可以让T的父类也能接收T，因此Comparable的泛型使用&lt;? super T&gt;，即可以使用T或者T的父类进行接收，因此最终变成</p>
<p><strong>public</strong> <strong>static</strong> &lt;T <strong>extends</strong> Comparable&lt;? <strong>super</strong> T&gt;&gt; <strong>void</strong> mySort(List<T> list)</T></p>
<p>  指定顺序排序</p>
<p><strong>static</strong> <T> <strong>void</strong> sort(List<T> list, Comparator&lt;? <strong>super</strong> T&gt; c) </T></T></p>
<p>  可以使用自定期的比较器进行排序，泛型使用&lt;? super T&gt;是为了让子类能使用父类的比较器，因为可以用父类对象来接收子类。</p>
<p>  <strong>static</strong> <T> <strong>void</strong> sort(List<T> list, Comparator&lt;? <strong>super</strong> T&gt; c) </T></T></p>
<p>  sort还可以利用比较器进行排序。原理是增加一个比较器，然后比较的方法使用比较器中的compare方法，获取元素利用List集合中的get()方法。这时候就不要求List具备比较方法，为了可以用父类对象接收被比较元素，使用&lt;? super T&gt;。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  &lt;T&gt;<span class="function"><span class="keyword">void</span> <span class="title">mySort</span><span class="params">(List&lt;T&gt; list,Comparator&lt;? <span class="keyword">super</span> T&gt; comp)</span></span>&#123;<span class="comment">//不需要list具备比较功能 </span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size()-<span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; list.size(); j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(comp.compare(list.get(i), list.get(j))&gt;<span class="number">0</span>)&#123;<span class="comment">//调用比较器的compare方法，返回一个int值</span></span><br><span class="line">					Collections.swap(list, i, j);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>1.1交换顺序</p>
<p><strong>static</strong> <strong>void</strong> swap(List&lt;?&gt; list, <strong>int</strong> i, <strong>int</strong> j) </p>
<p>1.2折半查找</p>
<p>需要先对元素进行自然排序或者比较器排序后才能使用</p>
<p><strong>static</strong> <T> <strong>int</strong> binarySearch(List&lt;? <strong>extends</strong> Comparable&lt;? <strong>super</strong> T&gt;&gt; list, T key) </T></p>
<p> 如果返回-2，负数表示没有找到，-2为-1减去1，意思是如果插入进去要在角标1处插入元素。减一的目的是避免插入点为0时候不知道是没有找到还是这个点在角标为0的地方。</p>
<p> 可以按照比较器排序然后索引。</p>
<p><strong>public</strong> <strong>static</strong> <T> <strong>int</strong> binarySearch(List&lt;? <strong>extends</strong> T&gt; list,T key,</T></p>
<p>​    Comparator&lt;? <strong>super</strong> T&gt; c)  </p>
<p>2、 求最大值</p>
<p><strong>static</strong> &lt;T <strong>extends</strong> Object &amp; Comparable&lt;? <strong>super</strong> T&gt;&gt; T max(Collection&lt;? <strong>extends</strong> T&gt; coll)</p>
<p>也可以使用比较器进行取最大值。</p>
<p><strong>static</strong> <T> T max(Collection&lt;? <strong>extends</strong> T&gt; coll, Comparator&lt;? <strong>super</strong> T&gt; comp) </T></p>
<p>3、 比较器反向</p>
<p>如果要将一个集合中的元素反向输出，使用TreeSet实现，要加载比较器重新实现，原理如下，其实就是将o1,o2进行互换。</p>
<p>​    TreeSet<String> ts = <strong>new</strong> TreeSet<String>(<strong>new</strong> Comparator<String>() {</String></String></String></p>
<p>​      //匿名内部类</p>
<p>​      @Override</p>
<p>​      <strong>public</strong> <strong>int</strong> compare(String o1, String o2) {</p>
<p>​       <strong>int</strong> temp = o2.compareTo(o1);</p>
<p>​       <strong>return</strong> temp;</p>
<p>​      }</p>
<p>​    });</p>
<p>这样就可以实现反向输出，但是比较麻烦</p>
<p>  <strong>static</strong> <T> Comparator<T> reverseOrder() </T></T></p>
<p>  <strong>static</strong> <T> Comparator<T> reverseOrder(Comparator<T> cmp) //将已有的比较器进行逆转 </T></T></T></p>
<p>实际演示：</p>
<p>TreeSet<String> ts = <strong>new</strong> TreeSet<String>(Collections.<em>reverseOrder</em>());</String></String></p>
<p>  如果自己有比较器，就将比较器输入进去</p>
<p>TreeSet<String> ts = <strong>new</strong> TreeSet<String>(Collections.<em>reverseOrder</em>(<strong>new</strong> ComparatorByLength()));</String></String></p>
<p>反转集合中的元素</p>
<p>  <strong>static</strong> <strong>void</strong> reverse(List&lt;?&gt; list) </p>
<p>4、 初始化集合</p>
<p>用指定元素替代集合中所有元素。</p>
<p> <strong>static</strong> <T> <strong>void</strong> fill(List&lt;? <strong>super</strong> T&gt; list, T obj) </T></p>
<p>5、 随机集合元素</p>
<p>使用默认的随机源随机排列指定的列表</p>
<p> <strong>static</strong> <strong>void</strong> shuffle(List&lt;?&gt; list) </p>
<p>使用指定的随机源随机排列指定的列表</p>
<p><strong>static</strong> <strong>void</strong> shuffle(List&lt;?&gt; list, Random rnd) </p>
<p>就是扑克牌的洗牌。或者掷骰子，只取第一个即可。</p>
<p>6、 枚举的转换</p>
<p>返回指定集合的枚举</p>
<p><strong>static</strong> <T> Enumeration<T> enumeration(Collection<T> c) </T></T></T></p>
<p>返回一个数组列表，其中包含由枚举返回的顺序由指定的枚举返回的元素。</p>
<p><strong>static</strong> <T> ArrayList<T> list(Enumeration<T> e) </T></T></T></p>
<p>7、 <strong>同步！！！！重点</strong></p>
<p>如果要在多线程中使用集合，则自己在集合中加锁，Collections工具类中提供有synchronizedxxx方法，如：</p>
<p><strong>static</strong> <T> Collection<T> synchronizedCollection(Collection<T> c) </T></T></T></p>
<p>返回由指定集合支持的同步（线程安全）集合。 </p>
<p><strong>static</strong> <T> List<T> synchronizedList(List<T> list) </T></T></T></p>
<p>返回由指定列表支持的同步（线程安全）列表。 </p>
<p><strong>static</strong> &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) </p>
<p>返回由指定地图支持的同步（线程安全）映射。</p>
<p>具体的实现原理为</p>
<p>给非同步的集合加锁</p>
<p>List list = new ArrayList();//非同步的</p>
<p>list = MyCollections.synList(list);//返回一个同步的List</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCollections</span></span>&#123;<span class="comment">//将非同步集合变为同步集合</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title">synList</span><span class="params">(List list)</span></span>&#123;<span class="comment">//静态方法</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyList(list);<span class="comment">//多态</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span> <span class="keyword">implements</span> <span class="title">List</span></span>&#123;<span class="comment">//私有内部类，实现List接口</span></span><br><span class="line">	<span class="comment">//目的是实现以后MyList就是List的一个子类，将所有的方法进行覆盖，使得可以同步。具体实现还是调用其具体的方式，只是加锁而已。</span></span><br><span class="line">	<span class="comment">//然后返回自定义的加锁后的集合</span></span><br><span class="line">	<span class="keyword">private</span> List list;<span class="comment">//持有要操作的集合引用</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">	MyList(List list)&#123;<span class="comment">//构造器传入要操作的集合引用</span></span><br><span class="line">		<span class="keyword">this</span>.list = list;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">			<span class="keyword">return</span> list.add(obj);<span class="comment">//具体方法还是调用操作集合自身的方法，只是加锁而已！！！</span></span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">			<span class="keyword">return</span> list.remove(obj);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只是加锁，只是加锁，只是加锁，具体实现方式还是调用其自身的方式。</p>
<p>8、 转数组</p>
<p>集合转成数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用的就是Collection接口中的toArray()方法</span><br><span class="line">	集合转成数组可以对集合中的元素操作的方法进行限定。不允许对其进行增删。</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * toArray方法需要传入一个指定类型的数组。</span></span><br><span class="line"><span class="comment">		 * 长度该如何定义呢？</span></span><br><span class="line"><span class="comment">		 * 如果长度小于集合的size，那么该方法会创建一个同类型并和集合相同size的数组</span></span><br><span class="line"><span class="comment">		 * 如果长度大于集合的size，那么该方法就会使用指定的数组，存储集合中的元素，其他位置默认为null。</span></span><br><span class="line"><span class="comment">		 * 所以建议，最后长度就定为，集合的size。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		String[] arr = list.toArray(<span class="keyword">new</span> String[list.size()]);</span><br><span class="line">		System.out.println(Arrays.toString(arr));<span class="comment">//数组打印调用toString方法</span></span><br></pre></td></tr></table></figure>

<h4 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h4><p>操作数组的工具类</p>
<p>Arrays:集合框架的工具类。里面的方法都是静态的。</p>
<p>1、 二分查找</p>
<p><strong>static</strong> <strong>int</strong> binarySearch(<strong>byte</strong>[] a, <strong>byte</strong> key) </p>
<p><strong>static</strong> <strong>int</strong> binarySearch(<strong>byte</strong>[] a, <strong>int</strong> fromIndex, <strong>int</strong> toIndex, <strong>byte</strong> key)</p>
<p>基本数据类型数组大多都能二分查找，除了boolean</p>
<p>2、 复制</p>
<p>复制全部长度的数组</p>
<p><strong>static</strong> <strong>boolean</strong>[] copyOf(<strong>boolean</strong>[] original, <strong>int</strong> newLength) </p>
<p>复制指定范围的数组</p>
<p><strong>static</strong> <strong>boolean</strong>[] copyOfRange(<strong>boolean</strong>[] original, <strong>int</strong> from, <strong>int</strong> to) </p>
<p>8种基本数据类型数组都能复制 </p>
<p>3、 比较</p>
<p>比较两个数组彼此是否相同，需要传入两个参数，不是Object中的比较。如果两个数组都包含相同数量的元素，则两个数组被认为是相等的，并且两个数组中所有对应的元素对都相等。 换句话说，如果两个数组以相同的顺序包含相同的元素，则它们是相等的。 另外，如果两者都是null ，则两个数组引用被认为是相等的 。</p>
<p> <strong>static</strong> <strong>boolean</strong> equals(<strong>char</strong>[] a, <strong>char</strong>[] a2) </p>
<p>深度比较，不仅比较数组中的对象，还比较对象中的内容</p>
<p>  <strong>static</strong> <strong>boolean</strong> deepEquals(Object[] a1, Object[] a2) </p>
<p>4、 替换</p>
<p>将数组中的全部元素替换为指定元素</p>
<p> <strong>static</strong> <strong>void</strong> fill(<strong>char</strong>[] a, <strong>char</strong> val) </p>
<p>将数组中指定范围的元素替换为指定元素</p>
<p> <strong>static</strong> <strong>void</strong> fill(<strong>char</strong>[] a, <strong>int</strong> fromIndex, <strong>int</strong> toIndex, <strong>char</strong> val) </p>
<p>5、 排序</p>
<p> <strong>static</strong> <strong>void</strong> sort(<strong>char</strong>[] a) </p>
<p>对指定范围的数组进行排序</p>
<p><strong>static</strong> <strong>void</strong> sort(<strong>char</strong>[] a, <strong>int</strong> fromIndex, <strong>int</strong> toIndex)</p>
<p>  对对象进行自然顺序的排序</p>
<p> <strong>static</strong> <strong>void</strong> sort(Object[] a)  </p>
<p>  对泛型数组进行排序</p>
<p> <strong>static</strong> <T> <strong>void</strong> sort(T[] a, Comparator&lt;? <strong>super</strong> T&gt; c)</T></p>
<p>6、 toString</p>
<p>  返回指定数组的字符串表现形式，如果想直接输出字符串，就调用toString</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">char</span>[] a)</span>   </span></span><br><span class="line"><span class="function">	<span class="comment">//toString的经典实现</span></span></span><br><span class="line"><span class="function">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myToString</span><span class="params">(<span class="keyword">int</span>[]a)</span></span>&#123;</span><br><span class="line">		<span class="comment">//健壮性判断</span></span><br><span class="line">		<span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">        <span class="keyword">int</span> iMax = a.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (iMax == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line">        <span class="comment">//利用StringBuilder来增加字符串</span></span><br><span class="line">        StringBuilder b = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        b.append(<span class="string">'['</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;<span class="comment">//中间省略了条件判断，提高了效率</span></span><br><span class="line">            b.append(a[i]);</span><br><span class="line">            <span class="comment">//只要一到末尾，就添加反括号结束</span></span><br><span class="line">            <span class="keyword">if</span> (i == iMax)</span><br><span class="line">                <span class="keyword">return</span> b.append(<span class="string">']'</span>).toString();</span><br><span class="line">            b.append(<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>7、 转成集合</p>
<p>将数组转成List集合</p>
<p>该方法作为基于数组和基于集合的API之间的桥梁，与Collection.toArray()相[结合](mk:@MSITStore:D:\java学习资料\jdk api 1.8_google.CHM::/java/util/Collection.html#toArray–) 。</p>
<p><strong>public</strong> <strong>static</strong> <T> List<T> asList(T… a)</T></T></p>
<p>重点:List asList(数组)将数组转成集合。</p>
<p>好处：可以使用集合的方法操作数组的元素。</p>
<p>注意：数组的长度是固定的，所以 对于集合的增删方法是不可以使用的。如add,remove,clear。否则会发生UnsupportedOperationException</p>
<p>可以使用contains,indexOf,indexOfLast,set等方法，只要不改变数组的长度即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如果数组中的元素是对象，那么转成集合时，直接将数组中的元素作为集合中的元素进行集合存储。</span></span><br><span class="line"><span class="comment">* 如果数组中的元素是基本数据类型，那么会将该数组作为集合中的元素进行存储。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">31</span>,<span class="number">11</span>,<span class="number">51</span>,<span class="number">61</span>&#125;;</span><br><span class="line">		List&lt;<span class="keyword">int</span>[]&gt; list = Arrays.asList(arr);</span><br><span class="line">	存储的是一个数组，因此list.size()=<span class="number">1</span>。如果想要将数组中的元素存进去，写：</span><br><span class="line">		Integer[] arr2 = &#123;<span class="number">31</span>,<span class="number">11</span>,<span class="number">51</span>,<span class="number">61</span>&#125;;</span><br><span class="line">		List&lt;Integer&gt; list2 = Arrays.asList(arr2);</span><br></pre></td></tr></table></figure>

<h3 id="jdk1-5新特性"><a href="#jdk1-5新特性" class="headerlink" title="jdk1.5新特性"></a>jdk1.5新特性</h3><h4 id="foreach语句"><a href="#foreach语句" class="headerlink" title="foreach语句"></a>foreach语句</h4><p>简化书写，底层利用的迭代器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * foreach语句：</span></span><br><span class="line"><span class="comment"> * 格式</span></span><br><span class="line"><span class="comment"> * for(类型 变量 : Collection集合|数组)</span></span><br><span class="line"><span class="comment"> * &#123;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//迭代器可以对元素迭代时候进行操作</span></span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 只用于遍历或迭代</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span>(String s : list)&#123; <span class="comment">//简化书写</span></span><br><span class="line">	System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i: arr)&#123;</span><br><span class="line">	System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历Map集合，要将map转成单列的Set</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以使用高级for遍历map集合吗？不能直接用，但是可以将map转成单列的set，就可以用了。</span></span><br><span class="line">		Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,String&gt;();</span><br><span class="line">		<span class="keyword">for</span>(Integer key : map.keySet())&#123;</span><br><span class="line">			String value = map.get(key);</span><br><span class="line">			System.out.println(key+<span class="string">"::"</span>+value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(Map.Entry&lt;Integer, String&gt; me : map.entrySet())&#123;</span><br><span class="line">			Integer key = me.getKey();</span><br><span class="line">			String value = me.getValue();</span><br><span class="line">			System.out.println(key+<span class="string">"::"</span>+value);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 函数的可变参数</span></span><br><span class="line"><span class="comment">	 * 其实就是一个数组，但是接受的是数组的元素。</span></span><br><span class="line"><span class="comment">	 * 自动将这些元素封装成数组，简化了调用者的书写。	</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 注意：可变参数类型必须定义在参数列表的结尾处。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">newAdd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span>... arr)</span></span></span><br></pre></td></tr></table></figure>

<p>如果使用普通的数组接收，流程为先创建数组，然后将数组传入要调用的方法，即</p>
<p>​    <strong>int</strong>[] arr = {1,4,2,1};</p>
<p>​    <strong>int</strong> sum3 = <em>add</em>(arr);</p>
<p>而如果使用可变参数，则变成</p>
<p>​    <strong>int</strong> sum4 = <em>newAdd</em>(5,1,3,2,1);</p>
<p>简化了书写，但是可变参数不能放在第一个（有两个以上变量时），而数组可以。</p>
<h4 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h4><p><strong>import</strong> <strong>static</strong> java.util.Collections.<em>sort</em>;//静态导入，其实导入的是类中的静态成员</p>
<p>以前要写Collections.sort();</p>
<p>现在写sort();</p>
<hr>
<h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><p>​    不能被实例化，方法通常为静态的。</p>
<p>out：“标准”输出流</p>
<p>in：“标准”输入流</p>
<p>1、 获取系统时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> l1 = <span class="number">1549696253272l</span>;</span><br><span class="line">System.out.println(l1/<span class="number">1000</span>/<span class="number">60</span>/<span class="number">60</span>/<span class="number">24</span>);<span class="comment">//换算成天</span></span><br><span class="line"><span class="keyword">long</span> l2 = System.currentTimeMillis();</span><br><span class="line">System.out.println(l2-l1);<span class="comment">//计算时间差</span></span><br></pre></td></tr></table></figure>

<p>2、 获取系统信息</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取系统的属性信息，并存储到Properties集合中，键和值都是字符串类型</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * properties集合中存储的都是String类型的键和值。</span></span><br><span class="line"><span class="comment">		 * 最好使用它自己的存储和取出的方法来完成元素的操作。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Properties prop = System.getProperties();<span class="comment">//获取所有的键值对信息，返回Properties对象</span></span><br><span class="line">		Set&lt;String&gt; nameSet = prop.stringPropertyNames();<span class="comment">//返回一组键的集合</span></span><br><span class="line">		<span class="keyword">for</span>(String name : nameSet)&#123;</span><br><span class="line">			String value = prop.getProperty(name);<span class="comment">//由键获取值</span></span><br><span class="line">			System.out.println(name+<span class="string">"::"</span>+value);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h4 id="跨平台使用技巧"><a href="#跨平台使用技巧" class="headerlink" title="跨平台使用技巧"></a>跨平台使用技巧</h4><p>不同平台一些符号不一样，在jvm加载的时候会获取系统信息，因此可以将这些不同平台的符号定义为一个全局常量，然后根据系统信息获取</p>
<p>  //获取换行符号</p>
<p><strong>private</strong> <strong>static</strong> <strong>final</strong> String <strong>LINE_SEPERATOR</strong> = System.<em>getProperty</em>(“line.separator”);</p>
<p>也可以自己给系统设置属性信息。</p>
<h3 id="Runtime类（单例设计）"><a href="#Runtime类（单例设计）" class="headerlink" title="Runtime类（单例设计）"></a>Runtime类（单例设计）</h3><p>​    应用程序不能创建自己的Runtime类实例，可以 通过getRuntime()方法获取当前运行时。单例设计的模式。</p>
<h4 id="开启一个程序进程"><a href="#开启一个程序进程" class="headerlink" title="开启一个程序进程"></a>开启一个程序进程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Runtime:没有构造方法摘要，说明该类不可以创建对象。</span></span><br><span class="line"><span class="comment">		 * 又发现还有非静态的方法，说明该类应该提供静态的返回该类对象的方法。</span></span><br><span class="line"><span class="comment">		 * 而且只有一个，说明Runtime类使用了单例设计模式。 </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Runtime r = Runtime.getRuntime();</span><br><span class="line">		<span class="comment">//execute:执行。xxx.exe</span></span><br><span class="line">		<span class="comment">//可以调用本地程序去执行空格后面的文件，需要格式对应</span></span><br><span class="line">		Process p = r.exec(<span class="string">"D:\\迅雷影音\\XMP\\V5.4.0.6151\\Bin\\XMP.exe c:\\lalaland.rmvb"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="杀死子进程"><a href="#杀死子进程" class="headerlink" title="杀死子进程"></a>杀死子进程</h4><p>只能杀死由Runtime r开启的进程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Process p = r.exec(<span class="string">"notepad.exe"</span>);</span><br><span class="line">p.destroy();</span><br></pre></td></tr></table></figure>

<h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p>PI : double类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Math:提供了操作数学运算的方法。都是静态的。</span></span><br><span class="line"><span class="comment"> * 常用的方法:</span></span><br><span class="line"><span class="comment"> * abs()，求绝对值</span></span><br><span class="line"><span class="comment"> * ceil():返回大于参数的最小整数</span></span><br><span class="line"><span class="comment"> * floor():返回小于参数的最大整数</span></span><br><span class="line"><span class="comment"> * round():返回四舍五入的整数</span></span><br><span class="line"><span class="comment"> * max(int a,int b):求两个数中的大数</span></span><br><span class="line"><span class="comment"> * min(int a,int b):求两个数中的小数</span></span><br><span class="line"><span class="comment"> * pow(double a,double b):返回幂值，即a的b次方</span></span><br><span class="line"><span class="comment"> * random():随机数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="comment">//将随机苏转变为1-10之间的整数，应用：骰子</span></span><br><span class="line">	<span class="keyword">double</span> d = Math.ceil(<span class="number">10</span>*Math.random());</span><br><span class="line">	<span class="keyword">double</span> d = (<span class="keyword">int</span>)(Math.random()*<span class="number">10</span>+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><p>获取随机数还可以使用Random对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">			Random r = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="comment">//			double d = (int)(r.nextDouble()*6+1);</span></span><br><span class="line">			<span class="keyword">int</span> d = r.nextInt(<span class="number">6</span>)+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><p>在类的所有方法Date接受或返回年，月，日，小时，分钟和秒值，以下表述中使用：</p>
<ul>
<li><p>y年代表整数y - 1900 。 </p>
</li>
<li><p>一个月由0到11的整数表示; 0是1月，1是2月，等等; 11月12日。 </p>
</li>
<li><p>日期（月的一天）以通常的方式从1到31的整数表示。 </p>
</li>
<li><p>一小时由0到23之间的整数表示。因此，从午夜到凌晨1点的时间是小时0，从中午到下午1点的小时是12小时。 </p>
</li>
<li><p>分钟一般以0〜59的整数表示。 </p>
</li>
<li><p>秒由0到61的整数表示; 值60和61仅发生在闰秒上，甚至仅在实际上正确跟踪闰秒的Java实现中发生。 由于目前引入闰秒的方式，在同一分钟内不会发生两个闰秒，但是本规范遵循ISO C的日期和时间约定。</p>
</li>
</ul>
<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>Date()</p>
<p>Date(long mills)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();<span class="comment">//将当前日期和时间封装成Date对象</span></span><br><span class="line">System.out.println(date);<span class="comment">//Sat Feb 09 18:46:03 CST 2019	</span></span><br><span class="line">Date date2 = <span class="keyword">new</span> Date(<span class="number">1549709125956l</span>);<span class="comment">////将指定毫秒值封装成Date对象</span></span><br></pre></td></tr></table></figure>

<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>比较两个日期</p>
<p>  <strong>int</strong> compareTo(Date anotherDate) </p>
<p>测试此日期是否在指定日期之后。</p>
<p>  <strong>boolean</strong> after(Date when) </p>
<p>测试此日期是否在指定日期之前。 </p>
<p>  <strong>boolean</strong> before(Date when)</p>
<p><strong>日期与毫秒转换</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 日期对象和毫秒值之间的转换</span></span><br><span class="line"><span class="comment"> * 毫秒值--&gt;日期对象:</span></span><br><span class="line"><span class="comment"> * 1、通过Date对象的构造方法完成 new Date(timeMills);</span></span><br><span class="line"><span class="comment"> * 2、还可以通过setTime(long time)设置。</span></span><br><span class="line"><span class="comment"> * 	 因为可以通过日期对象的方法对该日期中的各个字段（年月日等）进行操作。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 日期对象--&gt;毫秒值</span></span><br><span class="line"><span class="comment"> * 1、getTime()方法	</span></span><br><span class="line"><span class="comment"> * 	因为可以通过具体的数值进行运算。</span></span><br><span class="line"><span class="comment"> * 	</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h3><p>​    对日期进行格式化，不能直接创建对象，需要使用DateFormat.getInstance()，在其中加入其字段，可以使用规定的格式，如默认的，LONG等。如果想要使用自定义的格式，就需要new其子类，SimpleDateFormat。</p>
<h4 id="对日期对象进行格式化"><a href="#对日期对象进行格式化" class="headerlink" title="对日期对象进行格式化"></a>对日期对象进行格式化</h4><p>工厂：生产对象的地方</p>
<p>将日期对象—-&gt;日期格式的字符串</p>
<p>返回String，使用DateFormat方法（或其子类），接收Date对象</p>
<p>使用的是<strong>DateFormat类</strong>中的<strong>format方法</strong></p>
<p>即DateFormat.getDateInstance()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		Date date = <span class="keyword">new</span> Date();</span><br><span class="line">		<span class="comment">//获取日期格式对象，具备着默认的风格。</span></span><br><span class="line"><span class="comment">//		DateFormat dateFormat = DateFormat.getDateInstance();//2019-2-11</span></span><br><span class="line">		<span class="comment">//可以指定风格 FULL LONG SHORT等可以指定风格</span></span><br><span class="line"><span class="comment">//		DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.FULL);//2019年2月11日 星期一</span></span><br><span class="line">		DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.LONG);<span class="comment">//2019年2月11日 </span></span><br><span class="line"><span class="comment">//		DateFormat dateFormat2 = DateFormat.getDateTimeInstance();//2019-2-11 11:11:21</span></span><br><span class="line">		<span class="comment">//指定日期和时间格式。2019年2月11日 上午11时20分04秒</span></span><br><span class="line">		DateFormat dateFormat2 = DateFormat.getDateTimeInstance(DateFormat.LONG,DateFormat.LONG);</span><br><span class="line">		<span class="comment">//结果应该是String格式，格式器最清楚，应该要输入日期对象</span></span><br><span class="line">		String str_data = dateFormat.format(date);</span><br><span class="line">		String str_data_time = dateFormat2.format(date);</span><br><span class="line">		System.out.println(str_data);<span class="comment">//2019-2-11</span></span><br><span class="line">		System.out.println(str_data_time);<span class="comment">//2019-2-11 11:11:21</span></span><br></pre></td></tr></table></figure>

<p>自定义日期时间格式</p>
{% asset_img 第20天1.png This is an example image %}

<p>范例：在指定格式的时候使用字符串，具体的规则见上表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		<span class="comment">//风格是自定义的的解决方式，使用DateFormat的子类</span></span><br><span class="line">		DateFormat dateFormat3 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy--MM--dd"</span>);</span><br><span class="line">		String str_data_own = dateFormat3.format(date);</span><br><span class="line">		System.out.println(str_data_own);</span><br><span class="line">将日期格式的字符串--&gt;日期对象</span><br><span class="line">返回Date对象，使用DateFormat方法（或其子类），接收String</span><br><span class="line">使用的是DateFormat类中的parse方法</span><br><span class="line"><span class="comment">//		String str_date = "2012-4-19";//使用默认格式</span></span><br><span class="line">		String str_date = <span class="string">"2012年4月19日"</span>;</span><br><span class="line">		String str = <span class="string">"2011---8---27"</span>;</span><br><span class="line">		DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.LONG);</span><br><span class="line">		<span class="comment">//如果要使用自定义的风格，则使用DateFormat子类</span></span><br><span class="line">		DateFormat dateFormat2 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy---MM---dd"</span>);</span><br><span class="line">		Date date2 = dateFormat2.parse(str);</span><br><span class="line">		System.out.println(date2);</span><br><span class="line">		Date date = dateFormat.parse(str_date);</span><br><span class="line">		System.out.println(date);</span><br></pre></td></tr></table></figure>

<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p>通过Calendar.getInstance来获取其对象</p>
<p>使用的是键值对</p>
<h4 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h4><p>1、 get()获取时间</p>
<p>2、 add()指定时间的偏移</p>
<p>3、 set()设置时间</p>
<h4 id="日期显示"><a href="#日期显示" class="headerlink" title="日期显示"></a>日期显示</h4><p>使用get方法，其中月份、星期要进行转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Calendar c = Calendar.getInstance();</span><br><span class="line">		showDate(c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showDate</span><span class="params">(Calendar c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> year = c.get(Calendar.YEAR);</span><br><span class="line">		<span class="keyword">int</span> month = c.get(Calendar.MONTH)+<span class="number">1</span>;<span class="comment">//月份从0开始</span></span><br><span class="line">		<span class="keyword">int</span> day = c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">		<span class="keyword">int</span> week = c.get(Calendar.DAY_OF_WEEK);<span class="comment">//星期日是第一天,即1为星期日</span></span><br><span class="line">		System.out.println(year+<span class="string">"年"</span>+month+<span class="string">"月"</span>+day+<span class="string">"日"</span>+getWeek(week));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getWeek</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		String[] weeks =&#123;<span class="string">" "</span>,<span class="string">"星期日"</span>,<span class="string">"星期一"</span>,<span class="string">"星期二"</span>,<span class="string">"星期三"</span>,<span class="string">"星期四"</span>,<span class="string">"星期五"</span>,<span class="string">"星期六"</span>&#125;;</span><br><span class="line">		<span class="keyword">return</span> weeks[i];<span class="comment">//因为是一一对应的角标，所以可以利用数组。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="日期设置"><a href="#日期设置" class="headerlink" title="日期设置"></a>日期设置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置指定日期</span></span><br><span class="line">c.set(<span class="number">2019</span>,<span class="number">10</span>, <span class="number">14</span>);</span><br><span class="line"><span class="comment">//在指定日期上偏移</span></span><br><span class="line">c.add(Calendar.MONTH, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>​    可以先设置时间，然后再利用add进行日期偏移，可以知道每一年哪个月有多少天，即设置那一年，然后将set设置为目标月的下一个月，然后偏移量为日期-1即可，再获取天数即可以。注意月份是从0开始！！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showDays</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">		Calendar c= Calendar.getInstance();</span><br><span class="line">		<span class="comment">//设置指定日期</span></span><br><span class="line">		c.set(year,<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//在指定日期上偏移</span></span><br><span class="line">		c.add(Calendar.DAY_OF_MONTH, -<span class="number">1</span>);</span><br><span class="line">		showDate(c);		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>如果要获取昨天的时分秒，直接将日期偏移量设置为日期偏移-1即可。</p>
<h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><p>​    记得关流，除非是System.in或者System.out</p>
<p>​    IO流用来处理设备之间的数据传输，Java对数据的传输通过流的方式，Java用于操作流的的对象都在IO包中。</p>
<p>流按操作数据分为两种：字节流与字符流。流按流向分为：输入流（将硬盘中的数据读入内存），输出流（将内存中的数据写入硬盘）。</p>
<h4 id="输入流与输出流"><a href="#输入流与输出流" class="headerlink" title="输入流与输出流"></a>输入流与输出流</h4><p>相对于内存设备而言。</p>
<p>将外设中的数据读取到内存中：输入。</p>
<p>将内存中的数据写入到外设中：输出。</p>
<p>构造函数可以接收文件对象，也可以接收字符串，接收文件对象使用更多。</p>
<h4 id="字符流的由来"><a href="#字符流的由来" class="headerlink" title="字符流的由来"></a>字符流的由来</h4><p>其实就是：字节流读取文字字节数据后，不直接操作而是先查指定的编码表。获取对应的文字。再对这个文字进行操作。</p>
<h4 id="IO流基类"><a href="#IO流基类" class="headerlink" title="IO流基类"></a>IO流基类</h4><p>字节流的两个顶层父类：</p>
<p>1，InputStream 2，OutputStream</p>
<p>字符流的两个顶层父类</p>
<p>1，Reader 2,Writer</p>
<p>这些体系的子类都以父类名作为后缀。</p>
<p>而子类名的前缀就是该对象的功能。</p>
<p>从熟悉的文字开始字符流。</p>
<h4 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h4><p>操作文本文件对象</p>
<p>构造函数中加入true表示续写。</p>
<p>//需求：将一些文字存储到硬盘一个文件中。</p>
<p>记住：如果要操作文字数据，建议优先考虑字符流。</p>
<p>而且要将数据从内存写到硬盘上，要使用字符流中的输出流：Writer</p>
<p>硬盘的数据基本体现是文件，希望可以找到一个可以操作文件的Writer</p>
<p>找到了FileWriter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">			<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LINE_SEPARATOR = System.getProperty(<span class="string">"line.separator"</span>);</span><br><span class="line">		<span class="comment">//创建一个可以往文件中写入字符数据的字符输出流对象</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 既然 是往一个文件中写入文件数据，那么在创建对象时，就必须明确该文件（用于存储数据的目的地）</span></span><br><span class="line"><span class="comment">		 * 如果文件不存在，则会自动创建。</span></span><br><span class="line"><span class="comment">		 * 如果文件存在，则会被覆盖。</span></span><br><span class="line"><span class="comment">		 * 如果构造函数中加入true，可以实现对文件进行续写</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"demo.txt"</span>,<span class="keyword">true</span>);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 调用Writer对象中的write(string)方法，写入数据。	</span></span><br><span class="line"><span class="comment">		 * 其实数据写入到临时存储缓冲区。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//调用系统本地的换行</span></span><br><span class="line">		fw.write(<span class="string">"abcde"</span>+LINE_SEPARATOR+<span class="string">"hahaa"</span>);</span><br><span class="line">		fw.write(<span class="string">"xixi"</span>);</span><br><span class="line">		 <span class="comment">//进行刷新，将数据直接写入到目的地中。可以用多次flush</span></span><br><span class="line"><span class="comment">//		fw.flush();</span></span><br><span class="line">		<span class="comment">//关闭流，关闭资源。在关闭前会先调用flush刷新缓冲区中的数据到目的地。</span></span><br><span class="line">		<span class="comment">//关闭后不能够再写入</span></span><br><span class="line">		fw.close(); 	</span><br><span class="line">	<span class="comment">//fw.write("ah");//会报错</span></span><br></pre></td></tr></table></figure>

<h4 id="IO异常处理"><a href="#IO异常处理" class="headerlink" title="IO异常处理"></a>IO异常处理</h4><p>因为流对象一般会抛出异常，因此一般在try外面创建对象，在try里面创建具体的引用。</p>
<p>因为关闭一定要执行，因此close放在finally中，其中close也需要进行处理。为了不出现空指针异常，需要去判断fw，只有在不为空的时候，才进行流关闭操作。</p>
<p>  即变量定外面，new在里面，finally close在里面，不要忘记判断null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileWriter fw = <span class="keyword">null</span>;<span class="comment">// 流对象在try外面进行创建</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	fw = <span class="keyword">new</span> FileWriter(<span class="string">"k:\\demo.txt"</span>);<span class="comment">// 在try里面进行创建引用</span></span><br><span class="line">	fw.write(<span class="string">"abcde"</span> + LINE_SEPARATOR + <span class="string">"hahaa"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	System.out.println(e.toString());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (fw != <span class="keyword">null</span>)<span class="comment">//一定要加入判断，不然会出现空指针异常 </span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			fw.close();<span class="comment">// 需要单独进行处理</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"关闭失败"</span>);</span><br><span class="line">		&#125; <span class="comment">// 没有声明，因此在外面进行声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h4><p><strong>读取方式1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需求：读取一个文本文件，将读取到的字符打印到控制台。</span></span><br><span class="line">		<span class="comment">//1、创建读取字符数据的流对象</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 在创建读取流对象时，必须要明确被读取的文件，一定要确定该文件是存在的。</span></span><br><span class="line"><span class="comment">		 * 用一个读取流关联一个已存在文件</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"demo.txt"</span>);</span><br><span class="line">		<span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((ch=fr.read())!=-<span class="number">1</span>)</span><br><span class="line">			System.out.println((<span class="keyword">char</span>)ch);</span><br></pre></td></tr></table></figure>

{% asset_img 第20天2.png This is an example image %}

<p>读取时候如果读到了末尾，会使用-1标识符，如果继续读则还是-1。</p>
<p><strong>读取方式2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"demo.txt"</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用read(char[])读取文件文本数据</span></span><br><span class="line"><span class="comment"> * 先创建字符数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];<span class="comment">//长度最好是1024的整数倍</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len=fr.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">	System.out.println(<span class="keyword">new</span> String(buf,<span class="number">0</span>,len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

{% asset_img 第20天3.png This is an example image %}

<p>这种读取方式，由于后两次读的数量不一样，因此会对第一次读取的数组进行覆盖。</p>
<h4 id="复制文件一"><a href="#复制文件一" class="headerlink" title="复制文件一"></a>复制文件一</h4><p>读取一个便写一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 需求：将C盘的一个文本文件复制到d盘。</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> * 1，需要读取源</span></span><br><span class="line"><span class="comment"> * 2，将读到的源数据写入目的地</span></span><br><span class="line"><span class="comment"> * 3，既然是操作文本数据，使用字符流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyTextTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//1，读取一个已有的文本文件，使用字符读取流，和文本相关联。</span></span><br><span class="line">		FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"IO流_2.txt"</span>);</span><br><span class="line">		<span class="comment">//2，创建一个目的，用于存储读到的数据。</span></span><br><span class="line">		FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"copytext_1.txt"</span>);</span><br><span class="line">		<span class="comment">//3，频繁的读写操作。</span></span><br><span class="line">		<span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((ch=fr.read())!=-<span class="number">1</span>)&#123;<span class="comment">//只要是读，就使用循环，然后while两层括号，判断是否等于-1</span></span><br><span class="line">			fw.write(ch);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4，关闭流资源。</span></span><br><span class="line">		fw.close();</span><br><span class="line">		fr.close();		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="复制文件二"><a href="#复制文件二" class="headerlink" title="复制文件二"></a>复制文件二</h4><p>使用缓冲来读取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyTextTest_2</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">		FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			fr = <span class="keyword">new</span> FileReader(<span class="string">"IO流_2.txt"</span>);</span><br><span class="line">			fw = <span class="keyword">new</span> FileWriter(<span class="string">"copytest_2.txt"</span>);</span><br><span class="line">			<span class="comment">//创建一个临时容器，用于缓存读取到的字符</span></span><br><span class="line">			<span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[BUFFER_SIZE];</span><br><span class="line">			<span class="comment">//定义一个变量定义读取到的字符数（其实就是往数组里装的字符个数）</span></span><br><span class="line">			<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>((len=fr.read(buf))!=-<span class="number">1</span>)&#123;<span class="comment">//while里面两个括号，判断长度是否为-1即可</span></span><br><span class="line">				fw.write(buf, <span class="number">0</span>, len);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;<span class="comment">//关流前需要判断</span></span><br><span class="line">			<span class="keyword">if</span>(fw!=<span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					fw.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"读写失败"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">if</span>(fr!=<span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					fr.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"读写失败"</span>);</span><br><span class="line">				&#125;		</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="复制文件图解"><a href="#复制文件图解" class="headerlink" title="复制文件图解"></a>复制文件图解</h4>{% asset_img 第21天1.png This is an example image %}

<p>待读取的文件为源，使用流来读取，对应代码为FileReader fr = new FileReader(“demo.txt”)，要写入文件，使用流来写入，对应代码为FileWriter fw = new FileWriter (“test.txt”)。而两个流之间没有直接关系，需要使用缓冲区来作为中转，为了将读入流与缓冲区关联，使用fr.read(buf)；为了将写出流与缓冲区关联，使用fw.write(buf,0,len)。为了将流中的文件写出到输出源中，要使用fw.flush或者fw.close，flush可以多次刷新，而close只能使用一次。</p>
<h4 id="字符流缓冲区"><a href="#字符流缓冲区" class="headerlink" title="字符流缓冲区"></a>字符流缓冲区</h4><p>对应类：</p>
<p>BufferedWriter</p>
<p>BufferedReader</p>
<p>缓冲区的出现提高了对数据的读写效率。缓冲区要结合流才可以使用。在流的基础上对流的功能进行了增强。</p>
<p>进缓冲区写入后一定要刷新！！！</p>
<p>字符流缓冲区</p>
<p>BufferedWriter</p>
<p>特有方法：newLine()换行写入</p>
<p>​    写完记得要刷新flush()</p>
<p>BufferedReader</p>
<p>特有方法：readLine()按行读入</p>
<p>​      判断标志不为-1，而是null。使用String类型接收read。</p>
<p><strong>写入</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LINE_SEPARATOR = System.getProperty(<span class="string">"line.separator"</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"demo.txt"</span>);</span><br><span class="line">		<span class="comment">//为了提高写入的效率。使用了字符流的缓冲区。</span></span><br><span class="line">		<span class="comment">//创建了一个字符写入流的缓冲区对象，并和指定要被缓冲的流对象相关联。</span></span><br><span class="line">		BufferedWriter bufw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line">		<span class="comment">//写入缓冲区的写入方法将数据先写入到缓冲区中</span></span><br><span class="line"><span class="comment">//		bufw.write("abcde"+LINE_SEPARATOR+"dsd");</span></span><br><span class="line"><span class="comment">//		bufw.write("xxixiix");</span></span><br><span class="line"><span class="comment">//		bufw.newLine();</span></span><br><span class="line"><span class="comment">//		bufw.write("heheh");</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=<span class="number">4</span>;x++)&#123;</span><br><span class="line">			bufw.write(<span class="string">"abcde"</span>+x);</span><br><span class="line">			bufw.newLine();<span class="comment">//换行</span></span><br><span class="line">			bufw.flush();<span class="comment">//写一次就刷新一次</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//使用缓冲区的刷新方法将数据刷目的地中</span></span><br><span class="line"><span class="comment">//		bufw.flush();</span></span><br><span class="line">		<span class="comment">//关闭缓冲区。其实关闭的就是被缓冲的流对象</span></span><br><span class="line">		bufw.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>读取</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"buf.txt"</span>);	</span><br><span class="line">		BufferedReader bufr = <span class="keyword">new</span> BufferedReader(fr);<span class="comment">//缓冲区关联流</span></span><br><span class="line">		String line = <span class="keyword">null</span>;<span class="comment">//判断变量</span></span><br><span class="line">		<span class="comment">//按行读取</span></span><br><span class="line">		<span class="keyword">while</span>((line=bufr.readLine())!=<span class="keyword">null</span>)&#123;<span class="comment">//如果读取的不为空，则输出</span></span><br><span class="line">			System.out.println(line);</span><br><span class="line">		&#125;</span><br><span class="line">		bufr.close();</span><br></pre></td></tr></table></figure>

<p>读取中缓冲区的read方法对父类方法进行了覆写</p>
{% asset_img 第21天2.png This is an example image %}

<p>readLine原理：缓冲区从磁盘中使用父类read(buf)方法拿出数据到内存中，从内存中取出字符比较快，使用的是覆盖过的read方法，将取出的数据放在临时容器中，根据文本的行特点，判断是否为换行符，临时容器中存储的是一行的数据，不包含换行符，然后转换成字符串进行输出。</p>
<p>readLine方法使用了读取缓冲区的read方法，将读取到的字符进行缓冲并判断换行标记，将标记前的缓存数据变成字符串返回。</p>
<p>​    <strong>临时容器</strong>可以使用<strong>StringBuilder</strong>。因为最终返回的是字符串。</p>
<p><strong>按行读取</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>((line=bufr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">	bufw.write(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用：可以按行来读取，因为返回的为String类型的变量，就可以使用String中的方法，如判断该行是否包含某一字符串。</p>
<h4 id="复制文件三"><a href="#复制文件三" class="headerlink" title="复制文件三"></a>复制文件三</h4><p>使用缓冲区来实现文件的读写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"buf.txt"</span>);</span><br><span class="line">BufferedReader bufr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"buf_copt.txt"</span>);</span><br><span class="line">BufferedWriter bufw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line"><span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((ch=bufr.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">	bufw.write(ch);</span><br><span class="line">&#125;</span><br><span class="line">bufw.close();</span><br><span class="line">bufr.close();</span><br></pre></td></tr></table></figure>

<h4 id="复制文件四"><a href="#复制文件四" class="headerlink" title="复制文件四"></a>复制文件四</h4><p>使用缓冲区按行读取，为了换行使用newLine，一定要<strong>flush</strong>!!!</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"buf.txt"</span>);</span><br><span class="line">BufferedReader bufr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"buf_copt.txt"</span>);</span><br><span class="line">BufferedWriter bufw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>((line=bufr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">	bufw.write(line);</span><br><span class="line">	bufw.newLine();</span><br><span class="line">	bufw.flush();</span><br><span class="line">&#125;</span><br><span class="line">bufw.close();</span><br><span class="line">bufr.close();</span><br></pre></td></tr></table></figure>

<h4 id="装饰设计模式"><a href="#装饰设计模式" class="headerlink" title="装饰设计模式"></a>装饰设计模式</h4><p>装饰设置模式：</p>
<p>  对一组对象的功能进行增强时，就可以使用该模式进行问题的解决。</p>
<p>装饰和继承都能实现一样的特点，进行功能的拓展增强。</p>
<p>区别：</p>
<p>首先有一个继承体系</p>
<p>Writer</p>
<pre><code>|--TextWriter:用于操作文本

|--MediaWriter:用于操作媒体</code></pre><p>想到对操作的动作进行效率的提高。按照面向对象，可以通过继承对具体的进行功能的拓展。</p>
<p>效率的提高需要加入缓冲技术</p>
<p>Writer</p>
<pre><code>|--TextWriter:用于操作文本</code></pre><p>​            |–BufferTextWriter:加入了缓冲技术的操作文本的对象</p>
<pre><code>|--MediaWriter:用于操作媒体

      |--BufferMediaWriter:加入了缓冲技术的操作媒体的对象</code></pre><p>到这里就可以了，但这样做存在问题。</p>
<p>如果这个体系进行功能拓展，又多了流对象。那么这个流要提高效率是否也要产生子类？</p>
<p>是，会发现只为提高功能进行的继承，导致继承体系越来越臃肿。不够灵活。</p>
<p>重新思考问题</p>
<p>既然加入的都是同一种技术–缓冲。</p>
<p>前一种是让缓冲和具体的对象相结合。可以将缓冲进行单独的封装，哪个对象需要缓冲， 就将哪个对象和缓冲关联。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  Buffer(TextWriter w)</span><br><span class="line"></span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  Buffer(MediaWriter w)</span><br><span class="line"></span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>太麻烦，直接操作父类，利用多态.但是要使用Writer方法，继承即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferWriter</span> <span class="keyword">extends</span> <span class="title">Writer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  Buffer(Writer w)</span><br><span class="line"></span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Writer</p>
<pre><code>|--TextWriter:用于操作文本

|--MediaWriter:用于操作媒体

|--BufferWriter:用于提高效率</code></pre><p>装饰比继承<strong>灵活</strong>。</p>
<p>特点：<strong>装饰类和被装饰类都必须所属同一个接口或者父类</strong>。</p>
<h4 id="LineNumber"><a href="#LineNumber" class="headerlink" title="LineNumber"></a>LineNumber</h4><p>获取行号</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"IO流_2.txt"</span>);</span><br><span class="line">		LineNumberReader lnr = <span class="keyword">new</span> LineNumberReader(fr);</span><br><span class="line">		String line = <span class="keyword">null</span>;</span><br><span class="line">		lnr.setLineNumber(<span class="number">20</span>);</span><br><span class="line">		<span class="keyword">while</span>((line=lnr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			System.out.println(lnr.getLineNumber()+<span class="string">":"</span>+line);</span><br><span class="line">		&#125;</span><br><span class="line">		lnr.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><p>基本操作与字符流相同。但是它不仅可以操作字符，还可以操作其他媒体文件。</p>
<p>字节流一般不用flush，除非用到了缓冲区。</p>
<p>​    不要用字符流操作媒体文件，无法被解析。因为查表查不到。</p>
<p><strong>输出流OutputStream</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo_write</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//1、创建字节输出流对象，用于操作文件</span></span><br><span class="line">		FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"bytedemo.txt"</span>);</span><br><span class="line">		<span class="comment">//2、写数据。直接写入到目的地中。</span></span><br><span class="line">		fos.write(<span class="string">"abcdefg"</span>.getBytes());</span><br><span class="line">		fos.close();<span class="comment">//关闭资源动作要完成。</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输入流InputStream</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo_read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//1、创建一个读取流对象和指定的文件关联</span></span><br><span class="line">		FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"bytedemo.txt"</span>);</span><br><span class="line">		<span class="comment">//创建一个大小刚刚好的缓冲区</span></span><br><span class="line">		<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[fis.available()];<span class="comment">//慎用！！！</span></span><br><span class="line">		fis.read(buf);</span><br><span class="line">		System.out.println(<span class="keyword">new</span> String(buf));</span><br><span class="line">		<span class="comment">//利用缓冲区读取</span></span><br><span class="line">		<span class="comment">//建议使用这种读取数据的方式。</span></span><br><span class="line"><span class="comment">//		byte[] buf = new byte[1024];</span></span><br><span class="line"><span class="comment">//		int len = 0;</span></span><br><span class="line"><span class="comment">//		while((len=fis.read(buf))!=-1)&#123;</span></span><br><span class="line"><span class="comment">//			System.out.println(new String(buf,0,len));</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		<span class="comment">//一次读取一个字节。	</span></span><br><span class="line"><span class="comment">//		int ch = 0;</span></span><br><span class="line"><span class="comment">//		while((ch=fis.read())!=-1)&#123;</span></span><br><span class="line"><span class="comment">//			System.out.println((char)ch);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		fis.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="键盘录入"><a href="#键盘录入" class="headerlink" title="键盘录入"></a>键盘录入</h4><p>Windows中回车是两个字符，’\r’对应数字13，’\n’对应数字10。因此如果读取回车符号会得到13与10。</p>
<p>默认的输入与输出设备均<strong>不用关流</strong>，如果关了则不能再次获取，除非重启设备。</p>
<p>​    将系统输入与字节流进行关流，然后调用字节流的方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream in = System.in;</span><br><span class="line"><span class="keyword">int</span> ch = in.read();<span class="comment">//检测到流末尾或者异常的时候，一直阻塞。一直等待读取到数据。阻塞式方法。</span></span><br><span class="line">System.out.println(<span class="string">"ch:"</span>+ch);</span><br></pre></td></tr></table></figure>

<p>集合的清空为clear，StringBuilder的为delete</p>
<p><strong>获取键盘数据</strong></p>
<p>获取键盘录入数据，转为大写，利用over结束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readKey2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//一直读入键盘输入的值</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 获取用户键盘录入的数据，并将数据变成大写显示在控制台上。</span></span><br><span class="line"><span class="comment">		 * 如果用户输入的是over，结束键盘录入。</span></span><br><span class="line"><span class="comment">		 * 思路：</span></span><br><span class="line"><span class="comment">		 * 1，因为键盘录入只读取一个字节，要判断是否是over，需要将读取到的字节拼成字符串</span></span><br><span class="line"><span class="comment">		 * 2，那就需要一个容器。StrignBuilder。</span></span><br><span class="line"><span class="comment">		 * 3，在用户回车之前，将录入的数据变成字符串判断即可。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//1，创建容器</span></span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//2，获取键盘读取流</span></span><br><span class="line">		InputStream in = System.in;</span><br><span class="line">		<span class="comment">//3，定义变量记录读取到的字节，并循环获取</span></span><br><span class="line">		<span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((ch=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="comment">//在存储之前需要判断是否是换行标记，因为换行标记不存</span></span><br><span class="line">			<span class="keyword">if</span>(ch==<span class="string">'\r'</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(ch==<span class="string">'\n'</span>)&#123;</span><br><span class="line">				<span class="comment">//如果换行，需要判断</span></span><br><span class="line">				String temp = sb.toString();<span class="comment">//将缓冲的字符变成字符串	</span></span><br><span class="line">				<span class="keyword">if</span>(<span class="string">"over"</span>.equals(temp))</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">//不是over就输出</span></span><br><span class="line">				System.out.println(temp.toUpperCase());</span><br><span class="line">				<span class="comment">//输出完以后，将缓冲区清空，不然会将之前的也存进去</span></span><br><span class="line">				<span class="comment">//集合的清空为clear，StringBuilder的为delete。</span></span><br><span class="line">				sb.delete(<span class="number">0</span>, sb.length());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果不加else，那么回车后仍然会添加元素，则将'\n'添加进去了。因为不是回车符才进行添加。一定要加else</span></span><br><span class="line">			<span class="keyword">else</span>	</span><br><span class="line">			<span class="comment">//将读取到的字节存储到StringBuilder中。</span></span><br><span class="line">			sb.append((<span class="keyword">char</span>)ch);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>​    会发现使用到的判断跟BufferedReader中的readLine方法很接近。因此想利用readLine来做。</p>
<h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><p>InputStreamReader ：字节到字符的桥梁。解码。</p>
<p>OutputStreamWriter：字符到字节的桥梁。编码。</p>
<p>​    BufferedReader中有readline方法，如果要使用到BufferedRead方法，需要传入的是字符流对象，但是如果想让字节流也是用其方法，需要将字节流转变为字符流。</p>
<p>​    可以使用<strong>InputSreamReader</strong>。需要考虑编码的问题。在字符流对象中。将字<strong>节流变成字符流</strong></p>
<p>从名字判断。<strong>后缀为父类，前缀为功能</strong>。</p>
<p>因此可以将上面的代码改写，直接获取一行字符串即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字节流</span></span><br><span class="line">		InputStream in = System.in;</span><br><span class="line">		<span class="comment">//将字节转成字符的桥梁，转换流。</span></span><br><span class="line">		InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line">		<span class="comment">//字符流，为字符装饰流。</span></span><br><span class="line">		BufferedReader bufr = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">		String line = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span>((line=bufr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="string">"over"</span>.equals(line))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			System.out.println(line.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符与字节的区别</p>
<p>读取汉字的时候，一个汉字字符为2个字节，如果用字节读就会读2次，然后将2个字节对应成数字单独输出；如果是字符流，那么会一下子读2个，只读1次，然后查表找对应的字符。</p>
<blockquote>
<p>字节-&gt;字符，解码。因为从看不懂的变成看得懂的。使用IuputStreamReader</p>
<p>字符-&gt;字节，编码。因为从看的懂的变成看不懂的。使用OutputStreamWriter</p>
</blockquote>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC22%E5%A4%A91.png" class title="This is an example image">

<p>示意图：从键盘输入到控制台输出</p>
<p>字节流从键盘拿数据，变成字符流使用字符流装饰类来提高效率，因此数据就读取到了缓冲区中，然后从缓冲区中写数据到字符输出流，数据到了字符输出流，目的地是out.控制台，需要将字符流转换成字节流，然后进行输出字节数据。</p>
<h4 id="键盘录入到控制台输出"><a href="#键盘录入到控制台输出" class="headerlink" title="键盘录入到控制台输出"></a>键盘录入到控制台输出</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">键盘录入到控制台输出</span><br><span class="line">		<span class="comment">//键盘录入</span></span><br><span class="line">		<span class="comment">//将键盘字节流转换为字符流装饰类提高效率，背下来！！！</span></span><br><span class="line">		BufferedReader bufr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		<span class="comment">//控制台输出</span></span><br><span class="line">		BufferedWriter bufw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">		String line = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span>((line=bufr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="string">"over"</span>.equals(line))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			bufw.write(line);<span class="comment">//逐行写入</span></span><br><span class="line">			bufw.newLine();<span class="comment">//换行</span></span><br><span class="line">			bufw.flush();<span class="comment">//使用缓冲区记得要刷新</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重点代码"><a href="#重点代码" class="headerlink" title="重点代码"></a>重点代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//键盘录入</span></span><br><span class="line">BufferedReader bufr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">BufferedWriter bufw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br></pre></td></tr></table></figure>

<h4 id="流操作规律"><a href="#流操作规律" class="headerlink" title="流操作规律"></a>流操作规律</h4><p>之所以要弄清楚这个规律，是因为流对象太多，开发时不知道用哪个对象合适。</p>
<p>想要知道开发时用到哪些对象，只要通过四个明确即可。</p>
<p>1， 明确源和目的（汇）</p>
<p>​    源：  InputStream     Reader</p>
<p>​    目的：OutputStream  Writer</p>
<p>2， 明确数据是否是纯文本数据</p>
<p>​    源：是纯文本：Reader</p>
<p>​                       否：InputStream</p>
<p>​    目的：是纯文本：Writer</p>
<p>​                       否：OutputStream</p>
<p>到这里就可以明确需求中具体要用哪个体系。</p>
<p>3， 明确具体的设备。</p>
<p>​    源设备：</p>
<p>​            硬盘：File</p>
<p>​            键盘：System.in</p>
<p>​            内存：数组</p>
<p>​            网络：Socket流</p>
<p>​    目的设备：</p>
<pre><code>硬盘：File</code></pre><p>​            控制台：System.out</p>
<p>​            内存：数组</p>
<p>​            网络：Socket流</p>
<p>4， 是否需要其他额外功能。</p>
<p>​    1， 是否需要高效（缓冲区）？</p>
<p>​        是，就加上buffer。</p>
<p>​    2， 是否需要转换</p>
<p>​        是</p>
<pre><code>源：InputStreamReader 字节流-&gt;字符流

目的：OutputStreamWriter 字符流-&gt;字节流</code></pre><hr>
<p>需求1：复制一个文本文件。</p>
<p>  1，明确源和目的。</p>
<p>​        源：InputStream  Reader</p>
<p>​        目的：OutputStream Writer  </p>
<p>  2，是否是纯文本？</p>
<p>​        是！</p>
<pre><code>源：Reader</code></pre><p>​        目的：Writer</p>
<p>  3，明确具体设备</p>
<p>​        源：</p>
<p>​              硬盘：File</p>
<p>​        目的：</p>
<p>​              硬盘：File</p>
<p>​        FileReader fr = new FileReader(“a.txt”);</p>
<pre><code>FileWriter fw = new FileWriter(&quot;b.txt&quot;);</code></pre><p>  4，需要额外功能吗？</p>
<p>​        需要，需要高效。</p>
<p>​    BufferedReader bufr = new BufferedReader(new FileReader(“a.txt”));</p>
<p>​    BufferedWriter bufw = new BufferedWriter(new FileWriter(“b.txt”));</p>
<hr>
<p>需求2：读取键盘读入信息，并写入到一个文件中。</p>
<p>  1，明确源和目的。</p>
<p>​        源：InputStream  Reader</p>
<p>​        目的：OutputStream Writer </p>
<p>  2，是否是纯文本呢？</p>
<pre><code>是</code></pre><p>​              源：Reader</p>
<p>​          目的 ：Writer</p>
<p>  3，明确设备</p>
<pre><code>源：</code></pre><p>​              键盘：System.in</p>
<p>​        目的</p>
<p>​              硬盘：File</p>
<p>​    InputStream in = System.in;</p>
<p>​    FileWriter fw = new FileWriter(“b.txt”);</p>
<p>​    这样做可以完成，但是麻烦。将读取的字节数据转成字符串，再由字符流操作。</p>
<p>  4，需要额外功能吗？</p>
<p>​    需要，转换。将字节流转换成字符流。因为明确的源是Reader，这样操作文本数据最便捷。</p>
<p>​    所以要将已有的字节流转成字符流。使用字节–&gt;字符。InputStreamReader</p>
<p>​    InputStreamReader isr = new InputStreamReader(System.in);</p>
<p>​    FileWriter fw = new FileWriter(“b.txt”);</p>
<p>​    还需要功能吗？</p>
<p>​    需要：想高效</p>
<p>​    BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));</p>
<p>​    BufferedWriter bufw = new BufferedWriter(new FileWriter(“b.txt”));</p>
<hr>
<p>需求3：将一个文本文件数据显示在控制台上</p>
<p>  1，明确源和目的。</p>
<p>​        源：InputStream  Reader</p>
<p>​        目的：OutputStream Writer </p>
<p>  2，是否是纯文本呢？</p>
<p>​        是</p>
<p>​              源：Reader</p>
<p>​              目的 ：Writer</p>
<p>  3，明确具体设备</p>
<pre><code>源：</code></pre><p>​              硬盘：File</p>
<p>​        目的：</p>
<p>​              控制台：System.out</p>
<p>​    FileReader fr = new FileReader(“a.txt”);</p>
<p>​    OutputStream out = System.out;//对象类型是PrintStream</p>
<p>  4，需要额外功能吗？</p>
<p>​    需要，转换。</p>
<p>​    FileReader fr = new FileReader(“a.txt”);</p>
<p>​    OutputStreamWriter osw = new OutputStreamWriter(System.out);</p>
<p>​    需要，高效。</p>
<p>​    BufferedReader bufr = new BufferedReader(new FileReader(“a.txt”));</p>
<p>​    BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));</p>
<hr>
<p>需求4：读取键盘录入数据，显示在控制台上</p>
<p>  1，明确源和目的。</p>
<p>​        源：InputStream  Reader</p>
<pre><code>目的：OutputStream Writer </code></pre><p>  2，是否是纯文本呢？</p>
<p>​        是</p>
<p>​              源：Reader</p>
<p>​              目的 ：Writer</p>
<p>  3，明确设备</p>
<pre><code>源：</code></pre><p>​              键盘：System.in</p>
<pre><code>目的：</code></pre><p>​              控制台：System.out   </p>
<p>​    InputStream in = System.in;</p>
<p>​    OutputStream out = System.out;</p>
<p>  4，明确额外功能？</p>
<p>​    需要转换，因为都是字节流，但是操作的却是文本数据。</p>
<p>​    所以使用字符流操作起来更方便。</p>
<p>​    InputStreamReader isr = new InputStreamReader(System.in);</p>
<p>​    OutputStreamWriter osw = new OutputStreamWriter(System.out);</p>
<p>​    为了将其高效操作。</p>
<p>​    BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));</p>
<p>   BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));</p>
<h4 id="转换流的编码解码"><a href="#转换流的编码解码" class="headerlink" title="转换流的编码解码"></a>转换流的编码解码</h4><p>GBK中一个中文对应2个字节，在UTF-8编码中，一个中文对应3个字节。</p>
<p>需求5：将一个中文字符串数据按照指定的编码表写入到一个文本文件中</p>
<p>  1，目的。OutputStream Writer</p>
<p>  2，是纯文本，Writer</p>
<p>  3，设备：硬盘File</p>
<p>  FileWriter fw = new FileWriter(“a.txt”);</p>
<p>  fw.write(“你好”);</p>
<p>  注意：既然需求中已经<strong>明确了指定编码表的动作</strong>。</p>
<p>  那就<strong>不可以使用FileWriter</strong>，因为FileWriter内部是使用<strong>默认的本地码表</strong>。</p>
<p>  只能使用其父类，OutputStreamWriter。</p>
<p>  OutputStreamWriter接收一个<strong>字节输出流</strong>对象，既然是操作文件，那么对象应该是FileOutputStream</p>
<p>  OutputStreamWriter = osw = new OutputStreamWriter(new FileOutputStream(“a.txt”),<strong>charsetNam</strong>e);</p>
<p>  需要高效不？</p>
<p>  BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(“a.txt”),charsetName));</p>
<p>什么时候使用转换流呢？</p>
<p>  1，源或者目的对应的<strong>设备是字节流</strong>，但是<strong>操作的却是文本数据</strong>，可以使用转换流作为<strong>桥梁</strong>，提高对文本操作的便捷。</p>
<p>2，一旦操作文本涉及到具体的<strong>指定编码表</strong>，必须使用转换流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字节流加码表变成字符流。</span></span><br><span class="line">		OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"gbk_3.txt"</span>),<span class="string">"GBK"</span>);<span class="comment">//字符转字节，传入字节流</span></span><br><span class="line">		FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"gbk_1.txt"</span>);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 这两句代码的功能是等同的。</span></span><br><span class="line"><span class="comment">		 * FileWriter：其实就是转换流指定了本机默认码表的体现，而且这个转换流的子类对象，可以方便操作文本文件。</span></span><br><span class="line"><span class="comment">		 * 	简单说：操作文件的字节流+本机默认的编码表。</span></span><br><span class="line"><span class="comment">		 * 	这是按照默认码表来操作文件的便捷类。</span></span><br><span class="line"><span class="comment">		 * 如果操作文本文件需要明确具体的编码，FileWriter就不行了。必须用转换流。</span></span><br><span class="line"><span class="comment">		 */</span></span><br></pre></td></tr></table></figure>

<h4 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h4><p>当想把<strong>数据保持原样</strong>，使用打印流最方便。按照需求使用，如果要保证文件的大小，使用之前的输出流，如果要保持数据原样，使用打印流。打印流只负责<strong>目的</strong>。</p>
<p>PrintWriter与PrintStream</p>
<p><strong>PrintStream</strong></p>
<p>System.out类型就为PrintStream类型。PrintStream为其他输出流添加了功能，使他们能够方便的打印各种数据值表现形式。<strong>不抛出IO异常</strong>。在需要写入<strong>字符</strong>而不是写入字节的情况下，应该使用PrintWriter。</p>
<p>1，提供了打印的放法，可以对多种数据类型值打印。并保持数据的表示形式。</p>
<p>2，它不抛IO异常。</p>
<p>构造函数，接收三种类型的值</p>
<p>1， 字符串路径</p>
<p>2， File对象</p>
<p>3， 字节输出流</p>
<p><strong>write</strong>只写<strong>最低8位</strong>，print将值变为字符串再打印，保持<strong>原样</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入int为32位，只保留后8位，将前24位截取，这样在记事本中表现为a</span></span><br><span class="line">		out.write(<span class="number">97</span>);<span class="comment">//记事本中打开为a</span></span><br><span class="line">		<span class="comment">//print原理为将要打印的值变为字符串，保持原样将数据打印到目的地</span></span><br><span class="line">		out.print(<span class="number">97</span>);</span><br></pre></td></tr></table></figure>

<p><strong>PrintWriter</strong></p>
<p>之后用的很多，服务端所用的就为PrintWriter。</p>
<p>构造函数参数：</p>
<p>1， 字符串路径</p>
<p>2， File对象</p>
<p>3， 字节输出流</p>
<p>4， 字符输出流</p>
<p>直接用println方法写入数据</p>
<p><strong>public</strong> PrintWriter(OutputStream out,<strong>boolean</strong> autoFlush)</p>
<p><strong>public</strong> PrintWriter(Writer out, <strong>boolean</strong> autoFlush)</p>
<p>如果传入true，println,printf,format方法将刷新缓冲区。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		<span class="comment">//读键盘</span></span><br><span class="line">		BufferedReader bufr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		<span class="comment">//输出到控制台</span></span><br><span class="line"><span class="comment">//		PrintWriter out = new PrintWriter(System.out,true);</span></span><br><span class="line">		<span class="comment">//如果想要写入到文件中，如果直接使用字符串路径则不能自动刷新，这样使用流对象封装即可。</span></span><br><span class="line">		PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">"out.txt"</span>),<span class="keyword">true</span>);</span><br><span class="line">		String line = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span>((line=bufr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="comment">//如果不定义结束标记，则无法结束。</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="string">"over"</span>.equals(line))</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//自定义结束标记</span></span><br><span class="line">			out.println(line.toUpperCase());</span><br><span class="line">			<span class="comment">//缓冲区记得刷新。</span></span><br><span class="line"><span class="comment">//			out.flush();</span></span><br><span class="line">		&#125;</span><br><span class="line">		out.close();</span><br><span class="line">		bufr.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="序列流"><a href="#序列流" class="headerlink" title="序列流"></a>序列流</h4><p>SequenceInputStream</p>
<p>序列流只负责源。</p>
<p>​    将多个输入流合并为一个流。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC22%E5%A4%A96.png" class title="This is an example image">

<p>将最后一个流的-1作为整个流的-1。</p>
<p>SequenceInputStream(Enumeration&lt;? <strong>extends</strong> InputStream&gt; e) </p>
<p>  初始化新创建 SequenceInputStream通过记住参数，它必须是一个 Enumeration产生对象，它们的运行时类型是 InputStream 。   </p>
<p>  构造器有两种，一种是传入参数为两个字节输入流，一个是字节输入流的枚举。而Vector中有枚举，直接使用Vecor效率太低于是使用ArrayList。但是只能获取迭代器，这样便想到去new一个迭代器，需要去实现其方法，因为与迭代器只有名称不一样，因此可以利用获取的迭代器方法来实现枚举。如果用匿名内部类来实现，而内部类使用临时变量，此临时变量需要被final修饰。但是这样比较麻烦，于是想到去Collections集合工具类中找方法，此方法返回枚举，接收集合对象，可以使用集合对象的方法，于是可以使用</p>
<p>​    Enumeration<FileInputStream> en = Collections.<em>enumeration</em>(集合);</FileInputStream></p>
<p>这样可以有一种思路，即相同功能对象可以利用另一个的方法来实现自身，而不用自己去实现。</p>
<h4 id="文件切割"><a href="#文件切割" class="headerlink" title="文件切割"></a>文件切割</h4><p>​    要切几个文件用几个输出流。</p>
<p>​    如果要将文件存入指定路径，可以将路径与文件后缀名封装成文件对象，因为文件对象的构造器中可以加入文件对象。</p>
<h4 id="文件合并"><a href="#文件合并" class="headerlink" title="文件合并"></a>文件合并</h4><p>​    如果要将多个文件写入同一个文件或者将文件碎片合并到一个文件，要用到序列流。序列流需要用到枚举，而枚举可以通过集合获取到。先将字节输入流存入ArrayList集合，然后用Collections工具类获取集合的枚举。这样从序列流中将数据写入到指定的路径下。如果要指定路径+文件后缀名，可以new File(dir,”1.mp3”);</p>
<h4 id="操作对象（装饰类）"><a href="#操作对象（装饰类）" class="headerlink" title="操作对象（装饰类）"></a>操作对象（装饰类）</h4><p>ObjectInputStream与ObjectOutputStream，操作对象的流。</p>
<p>​    把对象生命周期延迟，存储在硬盘上实现持久化。把对象从堆内存存储在了硬盘上。</p>
<p><strong>ObjectOutputStream</strong></p>
<p>为了实现额外功能，相当于装饰类，将字节流对象关联。要存储的对象必须实现Serializable接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeObj</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//基础的输出流没办法存储对象，因此需要装饰类。将输出流传入对象输出流即可。</span></span><br><span class="line">		<span class="comment">//后缀名使用object</span></span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"obj.object"</span>));</span><br><span class="line">		<span class="comment">//对象序列化。被序列化的对象必须实现Serializable接口</span></span><br><span class="line">		oos.writeObject(<span class="keyword">new</span> Person(<span class="number">30</span>, <span class="string">"小强"</span>));</span><br><span class="line">		<span class="comment">//关流</span></span><br><span class="line">		oos.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ObjectInputStream</strong></p>
<p>​    ObjectInputStream对以前使用ObjectOutputStream写入的基本数据和对象进行<strong>反序列化</strong>。只能读ObjectOutputStream写入的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对象读取流，因为是增强功能因此要传入字节输入流。</span></span><br><span class="line">		ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"obj.object"</span>));</span><br><span class="line">		<span class="comment">//需要有读出对象的class文件才能获得对象。</span></span><br><span class="line">		<span class="comment">//对象的反序列化。</span></span><br><span class="line">		Person p = (Person)ois.readObject();</span><br><span class="line">		System.out.println(p.getName()+<span class="string">":"</span>+p.getAge());</span><br><span class="line">		ois.close();<span class="comment">//关流</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>因为一次只能读一个对象，因此如果想多读几个对象，可使用以下方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">				Person p = (Person) ois.readObject();</span><br><span class="line">				System.out.println(p.getName() + <span class="string">":"</span> + p.getAge());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (EOFException e) &#123;</span><br><span class="line">			</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			ois.close();<span class="comment">// 关流</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h4><p>如果用原来的class文件，用更改后的类来接收，会报错。InvalidClassException。类实现Serializable接口，Serializable为标记接口，序列化运行时使用称为serialVersionUID的版本号与每个可序列化类相关联。该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。如果接收者加载类的ID号与发送者的类的版本号不同，反序列化会导致InvalidClassException。</p>
<p>因此Serializable用于给被序列化的类加入ID号。用于判断类和对象是否是同一个版本。如果可序列化类未显示声明serialVersionUID，则序列化运行时将基于该类的各个方面计算该类的默认serialVersionUID。强烈建议所有可序列化都显示声明serialVersionUID值，因为计算默认ID对类的详细信息有较高的敏感性，根据编译期的不同可能千差万别。</p>
<p>一个可序列化的类可以通过声明一个名为”serialVersionUID”的字段来显式地声明它自己的serialVersionUID，该字段必须是static，final和long类型</p>
<p>  <strong>private</strong> <strong>static</strong> <strong>final</strong> <strong>long</strong> serialVersionUID = 9527L;</p>
<p>  只要ID号一样，就算类文件变化了，那就依然可以读出，在服务器上可能会用到。</p>
<h4 id="无法被写入的属性-static-transient"><a href="#无法被写入的属性-static-transient" class="headerlink" title="无法被写入的属性(static transient)"></a>无法被写入的属性(static transient)</h4><p><strong>静态修饰</strong></p>
<p>如果类中某一属性被静态修饰，则堆内存中没有此属性，因此无法被写入到对象中。对象输出流只能写入非静态的属性和非瞬态的。</p>
<p><strong>transient关键字</strong></p>
<p>​    短暂的，暂时的。如果某一属性不是公用的，不能被static修饰，但是又不想写到对象中，可以使用transien关键字。</p>
<p>非静态数据不想被序列化可以使用这个关键字修饰。</p>
<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p>​    IO流只能操作文件中的数据。</p>
<p>而File类用来将文件或者文件夹封装成对象，方便对文件与文件夹的属性信息进行操作。</p>
<p>File对象可以作为参数传递给流的构造函数。</p>
<h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以将一个已存在的，或者不存在的文件或目录封装成File对象。</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">File file2 = <span class="keyword">new</span> File(<span class="string">"d:\\"</span>,<span class="string">"a.txt"</span>);<span class="comment">//从父路径名字符串和子路径名字符串创建新的 File实例</span></span><br><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"d:\\"</span>);<span class="comment">//加两个反斜杠才能正常读出</span></span><br><span class="line">File f3 = <span class="keyword">new</span> File(f,<span class="string">"a.txt"</span>);<span class="comment">//从父抽象路径名和子路径名字符串创建新的 File实例</span></span><br></pre></td></tr></table></figure>

<p>不同的操作系统分隔符不一样。之前在系统类中使用字段file.separator获取分隔符。现在使用File.separator来获取分隔符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为了系统兼容，使用System.getProperty("file.separator")</span></span><br><span class="line">		String sep = System.getProperty(<span class="string">"file.separator"</span>);<span class="comment">//之前写法</span></span><br><span class="line">		String newsep = File.separator;</span><br><span class="line">		File f4 = <span class="keyword">new</span> File(<span class="string">"d:\\"</span>+newsep+<span class="string">"a.txt"</span>);</span><br><span class="line">		System.out.println(f4);</span><br></pre></td></tr></table></figure>

<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p><strong>获取修改时间</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作用：判断修改时间，加载修改后的新文件</span></span><br><span class="line">		<span class="keyword">long</span> time = file.lastModified();<span class="comment">//最后修改时间</span></span><br><span class="line">		<span class="comment">//将毫秒值转变为Date对象</span></span><br><span class="line">		Date date = <span class="keyword">new</span> Date(time);</span><br><span class="line">		<span class="comment">//日期格式化对象</span></span><br><span class="line">		DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG,DateFormat.LONG);</span><br><span class="line">		<span class="comment">//将日期对象转成String，用format方法。</span></span><br><span class="line">		String str_time = dateFormat.format(date);</span><br></pre></td></tr></table></figure>

<p>File对象的常用方法</p>
<p>1，<strong>获取</strong></p>
<p>  1.1获取文件名称 </p>
<p>​    String getName();</p>
<p>  1.2获取文件路径 </p>
<p>​    String getPath();</p>
<p>String getAbsolutePath();</p>
<p>  1.3获取文件大小 </p>
<p>​     long length();</p>
<p>  1.4获取文件修改时间 </p>
<p>​     long lastModified()得到毫秒值</p>
<p>2，<strong>创建与删除</strong></p>
<p>  如果文件或目录存在就不会创建。</p>
<p>  delete慎用，删除成功无法从回收站中找回。</p>
<p>  delete无法删除原因：</p>
<p>​    文件夹中有目录；正在被流使用</p>
<p>   2.1 文件创建 </p>
<p>​     boolean createNewFile();</p>
<p>​    和输出流不一样，如果文件不存在，则创建；如果文件存在，则不创建。</p>
<p>   2.2 文件删除</p>
<p>​     boolean delete();</p>
<p>   2.3 文件夹创建</p>
<p>​     boolean mkdir();//make directory</p>
<p>​     boolean mkdirs();//创建多级目录文件夹</p>
<p>   2.4 文件夹删除</p>
<p>​     boolean delete();//如果文件夹中有目录无法删除</p>
<p>​    如果是多级目录下的文件，则只删掉最子集的目录，前面的父目录无法删掉。</p>
<p>3，<strong>判断</strong>(很实用)</p>
<p>  在判断是否为文件或者是否是目录之前，要判断其是否存在。</p>
<p>​     boolean exists();//是否存在</p>
<p>​     boolean isFile();//是否是文件</p>
<p>​     boolean isDirectory();//是否是目录</p>
<p>4，<strong>重命名</strong></p>
<p>   需要有2个File，第二个File为命名后的文件位置</p>
<p>​     Boolean renameTo(File file);</p>
<p>   相当于剪切操作，可以从一个盘符移动到另一个。先关联两个文件，然后用文件去调用方法</p>
<p>​     File f1 = new File(“d:\1.jpg”);</p>
<p>​     File f3 = new File(“d:\1\2.jpg”);</p>
<p>​     boolean b2 = f1.renameTo(f3);</p>
<p>​     System.out.println(“文件剪切是否成功”+b2);</p>
<p>5，<strong>系统根目录和容量获取</strong></p>
<p>​     static Files[] listRoots();//获取系统中所有盘符，静态方法</p>
<p>​     long getFreeSpace();//获取可用容量</p>
<p>​     long getTotalSpace();//获取总容量</p>
<p>​     long getUsableSpace();//获取虚拟机可用容量</p>
<p>6，<strong>获取目录内容及文件名过滤器</strong></p>
<p>实现<strong>FilenameFilter</strong>接口。使用<strong>list</strong>方法。</p>
<p>使用list只能获取当前目录下的<strong>名称</strong>。</p>
<p>​     String[] list();</p>
<p>String[] list(FilenameFilter filter) </p>
<blockquote>
<p>获取当前目录下的文件以及文件夹的名称，包含隐藏文件</p>
<p>调用list方法的File对象中封装的必须是目录。否则会发生空指针异常</p>
<p>如果访问的是系统级目录，也会发生空指针异常</p>
<p> 如果目录存在，但是没有内容，会返回一个数组，但是长度为0</p>
</blockquote>
<p>文件名过滤器：过滤文件名</p>
<p>调用list(FilenameFilter)，调用list方法时候需要传入指定的过滤器对象，过滤器需要实现accept方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"d:\\"</span>);</span><br><span class="line">		String[] names = file.list(<span class="keyword">new</span> FilterByName());</span><br><span class="line">过滤器</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterByName</span> <span class="keyword">implements</span> <span class="title">FilenameFilter</span> </span>&#123;</span><br><span class="line">	<span class="comment">//实现FilenameFilter接口</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">		System.out.println(dir+<span class="string">":"</span>+name);</span><br><span class="line">		<span class="keyword">return</span> name.endsWith(<span class="string">".zip"</span>);<span class="comment">//判断以什么结尾。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC22%E5%A4%A92.png" class title="This is an example image">

<p>过滤器原理，先调用list方法获取指定路径下的全部目录，将 其存进数组，遍历数组，只要符合FilenameFilter.accept(dir,name)条件的，就进行存储，如accept方法可使用name.endsWith(指定文件格式)。</p>
<p>​    如果需要对过滤器传入参数，需要对过滤器添加构造函数，过滤器持有一个私有的字符串变量，通过构造函数来获取字符串变量，然后accept方法进行判断。</p>
<p>7，<strong>获取目录下文件对象及过滤</strong></p>
<p>实现FileFilter接口。使用listFiles方法</p>
<p>File[] listFiles() </p>
<p>返回一个抽象路径名数组，表示由该抽象路径名表示的目录中的文件。 </p>
<p>File[] listFiles(FileFilter filter) </p>
<p>返回一个抽象路径名数组，表示由此抽象路径名表示的满足指定过滤器的目录中的文件和目录。 </p>
<p>File[] listFiles(FilenameFilter filter) </p>
<p>返回一个抽象路径名数组，表示由此抽象路径名表示的满足指定过滤器的目录中的文件和目录。</p>
<p>文件类型过滤器</p>
<p>  如可以过滤非隐藏文件</p>
<h4 id="深度遍历文件夹"><a href="#深度遍历文件夹" class="headerlink" title="深度遍历文件夹"></a>深度遍历文件夹</h4><p>思路：</p>
<p>1、 将待深度遍历的目录关联File对象</p>
<p>2、 使用自定义方法来获取其所有子目录及文件</p>
<p>3、 方法怎么弄呢？首先要获取该目录下所有文件数组，遍历此数组，如果是目录则使用自定义功能继续遍历，如果不是目录则将文件名输出。这样便实现了遍历输出。</p>
<p>4、 但是这样不美观，因此需要记录下每个目录的层级信息。不能直接在方法中定义一个数，因为每次调用方法都会将这个数重置，那么需要在递归时传递给下一次递归。则进入下一次递归后将层级++,便实现了层级信息的记录。</p>
<p>5、 那么要如何美观输出呢？每多一个层级，就多一点空格，因为不知有多少字符串，所以使用StringBuilder来实现可变字符串，依靠层级数信息来添加空格信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//1，将File与待深度遍历目录关联</span></span><br><span class="line">		File dir = <span class="keyword">new</span> File(<span class="string">"d:\\test"</span>);</span><br><span class="line">		<span class="comment">//调用自定义方法，获取所有子目录及文件	</span></span><br><span class="line">		listAll(dir,<span class="number">0</span>);<span class="comment">//需要在递归时传入当前层级数。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listAll</span><span class="params">(File dir,<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//输入当前目录的名字，为了层级结构增加level以美观输出。</span></span><br><span class="line">		System.out.println(getSpace(level)+dir.getName());</span><br><span class="line">		level++;<span class="comment">//每次进一次目录，层级加一</span></span><br><span class="line">		<span class="comment">//获取指定目录下当前所有的文件夹或者对象</span></span><br><span class="line">		<span class="comment">//因为需要对数组中文件操作，所以使用listFiles()方法。</span></span><br><span class="line">		File[] files = dir.listFiles();</span><br><span class="line">		<span class="comment">//遍历文件数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;files.length;x++)&#123;</span><br><span class="line">			<span class="comment">//是目录就继续遍历，递归。</span></span><br><span class="line">			<span class="keyword">if</span>(files[x].isDirectory())&#123;</span><br><span class="line">				listAll(files[x],level);<span class="comment">//传入待遍历目录及层数</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果不是目录就进行打印</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="comment">//同样为了美观层级输出使用自定义功能</span></span><br><span class="line">				System.out.println(getSpace(level)+files[x].getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//清晰显示每层的层级结构，因为字符串数组可变，使用StringBuilder。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSpace</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//只有在目录或文件前使用|--</span></span><br><span class="line">		sb.append(<span class="string">"|--"</span>);</span><br><span class="line">		<span class="comment">//每多一层目录加一个|  。</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;level;x++)&#123;</span><br><span class="line">			sb.insert(<span class="number">0</span>,<span class="string">"|  "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归：函数自身直接或间接调用自身。</p>
<p>一个功能在被重复使用并每次使用时参与运算的结果和上一次调用有关。这时可以用递归来解决问题。</p>
<p>注意：</p>
<p>  1，递归一定要明确条件，否则容易栈溢出。即最小收敛情况。</p>
<p>  2，注意一下递归的次数。太多次容易栈溢出。超过栈内存就会报错。</p>
<p>递归中单独定义变量，每次调用方法，各个方法都会持有该变量的引用，如果想让此变量被下一次递归使用，则要作为参数传递给下一次。</p>
<h4 id="二进制转换"><a href="#二进制转换" class="headerlink" title="二进制转换"></a><strong>二进制转换</strong></h4><p>调用时候最先出栈的先输出，因此先输出1%2，然后3%2，最后6%2，因此结果是110.如果toBin()在输出下面，那就是011,因为先输出6%2，3%2，1%2。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toBin</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			toBin(num/<span class="number">2</span>);</span><br><span class="line">			System.out.println(num%<span class="number">2</span>);	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="求和"><a href="#求和" class="headerlink" title="求和"></a><strong>求和</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(num==<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> num+getSum(num-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC22%E5%A4%A93.png" class title="This is an example image">

<p>递归图解：运行sum(5),sum(4),sum(3),sum(2),sum(1)，然后sum(1)出栈，返回1，sum(2)出栈，返回2+1，sum(3)出栈，返回3+3，sum(4)出栈，返回4+6，sum(5)出栈，返回5+10。</p>
<h3 id="Properties集合"><a href="#Properties集合" class="headerlink" title="Properties集合"></a>Properties集合</h3><p>Map</p>
<pre><code>|--Hashtable</code></pre><p>​            |–Properties:</p>
<p>Properties集合：</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>1，该集合中的键和值都是字符串类型。</p>
<p>2，集合中的数据可以保存在流中(store)，或者从流中获取(load)。</p>
<p>通常该集合用于操作以键值对形式存在的配置文件。</p>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><p>1，存储</p>
<p>单个存储</p>
<p>  Object setProperty(String key, String value); </p>
<p>  也可以用来覆盖，键相等，值覆盖 </p>
<p>  使用的是Hashtable的put方法</p>
<p>2，获取</p>
<p>  单个获取</p>
<p>  String getProperty(String key); </p>
<p>  全部获取（转为Set集合）</p>
<p>  Set<String> stringPropertyNames() </String></p>
<p>  返回此属性列表中的一组键，其中键及其对应的值为字符串，包括默认属性列表中的不同键，如果尚未从主属性列表中找到相同名称的键。 </p>
<p>3，与流对象关联</p>
<p>  public void list(PrintStream out);将此属性列表打印到指定的输出流。 此方法对调试非常有用。 </p>
<p>4，持久化存储</p>
<p>  可以关联字节流或字符流，comment为相关注释，不要写中文。</p>
<p>  void store(OutputStream out, String comments);</p>
<p>  void store(Writer writer, String comments)   </p>
<p>5，获取输入流</p>
<p>  <strong>void</strong> load(InputStream inStream) </p>
<p>​    从输入字节流读取属性列表（键和元素对）。</p>
<p>  <strong>void</strong> load(Reader reader) </p>
<p>​    以简单的线性格式从输入字符流读取属性列表（关键字和元素对）。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Properties集合的存和取</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">propertiesDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//创建一个Properties集合</span></span><br><span class="line">		Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">		<span class="comment">//存储元素</span></span><br><span class="line">		prop.setProperty(<span class="string">"zhangsan"</span>, <span class="string">"30"</span>);</span><br><span class="line">		prop.setProperty(<span class="string">"lisi"</span>, <span class="string">"31"</span>);</span><br><span class="line">		prop.setProperty(<span class="string">"zhaoliu"</span>, <span class="string">"28"</span>);</span><br><span class="line">		<span class="comment">//修改元素，键相等，值覆盖</span></span><br><span class="line">		prop.setProperty(<span class="string">"zhangsan"</span>, <span class="string">"26"</span>);</span><br><span class="line">		<span class="comment">//取出所有元素</span></span><br><span class="line">		Set&lt;String&gt; names = prop.stringPropertyNames();<span class="comment">//获取键值集合</span></span><br><span class="line">		<span class="keyword">for</span>(String name:names)&#123;</span><br><span class="line">			String value = prop.getProperty(name);</span><br><span class="line">			System.out.println(name+<span class="string">":"</span>+value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="获取系统信息"><a href="#获取系统信息" class="headerlink" title="获取系统信息"></a>获取系统信息</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取系统的键值信息</span></span><br><span class="line">		Properties prop = System.getProperties();</span><br><span class="line">		<span class="comment">//只能打印，不能获取</span></span><br><span class="line">		prop.list(System.out);</span><br></pre></td></tr></table></figure>

<h5 id="模拟load方法"><a href="#模拟load方法" class="headerlink" title="模拟load方法"></a>模拟load方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 模拟load方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myLoad</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">	Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">	<span class="comment">//字符流装饰类，用以提高效率</span></span><br><span class="line">	BufferedReader bufr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"info.txt"</span>));</span><br><span class="line">	<span class="comment">//按行读取</span></span><br><span class="line">	String line = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">while</span>((line=bufr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="comment">//因为开头包含注释信息，均以#开头，因此不存。</span></span><br><span class="line">		<span class="keyword">if</span>(line.startsWith(<span class="string">"#"</span>))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		String[] arr = line.split(<span class="string">"="</span>);</span><br><span class="line">		prop.setProperty(arr[<span class="number">0</span>], arr[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将集合打印到控制台输出。</span></span><br><span class="line">	prop.list(System.out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="从文件中获取配置信息"><a href="#从文件中获取配置信息" class="headerlink" title="从文件中获取配置信息"></a>从文件中获取配置信息</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">//集合中的数据来自于一个文件</span></span><br><span class="line"><span class="comment">//注意：必须要保证该文件中的数据是键值对</span></span><br><span class="line"><span class="comment">//需要使用到读取流</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"info.txt"</span>);</span><br><span class="line"><span class="comment">//使用load方法</span></span><br><span class="line">prop.load(fis);</span><br><span class="line">prop.list(System.out);<span class="comment">//打印到指定的输出流</span></span><br></pre></td></tr></table></figure>

<h4 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h4><p>简单配置用Properties，复杂配置使用XML。相当于标签。</p>
<p>简单配置</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC22%E5%A4%A94.png" class title="This is an example image">

<p>复杂配置</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC22%E5%A4%A95.png" class title="This is an example image">

<p>XML使用起来更为清晰。</p>
<h3 id="IO流其他类"><a href="#IO流其他类" class="headerlink" title="IO流其他类"></a>IO流其他类</h3><h4 id="RandomAccessFile（多线程写入）"><a href="#RandomAccessFile（多线程写入）" class="headerlink" title="RandomAccessFile（多线程写入）"></a>RandomAccessFile（多线程写入）</h4><p>随机访问文件。看到这个类的名字，纠结。父类为Object。不是IO体系中的子类。此类的实例支持对随机访问文件的读取和写入。随机访问文件的行为类似存储在文件系统中的一个大型byte数组。</p>
<p>​    利用seek方法修改指针位置，即可实现在指定位置的随机读写。一般要求数据有规律。</p>
<p>​    应用：利用多线程，对同一个文件分段同时写入数据。多线程写入。</p>
<p>特点：</p>
<p>1， 该对象既能读，又能写。</p>
<p>2， 该对象内部维护了一个大型byte数组，并通过指针可以操作数组中的元素。</p>
<p>3， 可以通过getFilePointer方法获取指针的位置，和通过seek方法设置指针的位置。</p>
<p>4， 其实该对象就是字节输入流和输出流进行了封装。</p>
<p>5， 该对象的源或者目的只能是文件。通过构造函数就可以看出。</p>
<p>6，如果文件不存在，则创建；如果文件存在，不创建。</p>
<p>构造方法</p>
<p>  RandomAccessFile(File file, String mode) 创建一个随机访问文件流，从File参数指定的文件读取，并可选地写入。 </p>
<p>  RandomAccessFile(String name, String mode) 创建随机访问文件流，以从中指定名称的文件读取，并可选择写入文件。</p>
<p>mode的含义</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC22%E5%A4%A97.png" class title="This is an example image">

<p>局限性：<strong>目的只能是文件</strong>，不能是其他输出流。</p>
<p>write(byte b)，如果传入String类型，需要用getBytes()方法转成字节。</p>
<p>​    按字节写入，如果传入一个比较大的int类型数，会被截断。</p>
<p><strong>读写方法</strong></p>
<p><strong>void</strong> write(<strong>byte</strong>[] b) 从指定的字节数组写入 b.length个字节到该文件，从当前文件指针开始。 </p>
<p><strong>void</strong> writeInt(<strong>int</strong> v) 将 int写入文件为四个字节，高字节为首。 </p>
<p><strong>int</strong> read(<strong>byte</strong>[] b) 从该文件读取最多 b.length个字节的数据到一个字节数组。 </p>
<p><strong>int</strong> readInt() 从该文件读取一个带符号的32位整数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用RandomAccessFile对象写入一些人员信息，比如姓名和年龄。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">		<span class="comment">//可以读也可以写</span></span><br><span class="line">		RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"ranacc.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">		raf.write(<span class="string">"张三"</span>.getBytes());</span><br><span class="line">		raf.writeInt(<span class="number">97</span>);</span><br><span class="line">		raf.write(<span class="string">"小强"</span>.getBytes());</span><br><span class="line">		raf.writeInt(<span class="number">99</span>);</span><br><span class="line">		raf.close();<span class="comment">//关流</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"ranacc.txt"</span>, <span class="string">"r"</span>);<span class="comment">//只读即可</span></span><br><span class="line">		<span class="comment">//通过seek设置指针的位置。</span></span><br><span class="line">		raf.seek(<span class="number">1</span>*<span class="number">8</span>);<span class="comment">//随机的读取，只要指定指针的位置即可</span></span><br><span class="line">		<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">		raf.read(buf);</span><br><span class="line">		<span class="comment">//将字节数组变成字符串</span></span><br><span class="line">		String name = <span class="keyword">new</span> String(buf);</span><br><span class="line">		<span class="keyword">int</span> age = raf.readInt();</span><br><span class="line">		System.out.println(<span class="string">"name:"</span>+name);</span><br><span class="line">		System.out.println(<span class="string">"age:"</span>+age);</span><br><span class="line">		System.out.println(raf.getFilePointer());</span><br><span class="line">		<span class="comment">//关流</span></span><br><span class="line">		raf.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>随机读写</strong></p>
<p>​    通过seek方法可以随时设置指针的位置，可以实现随机的读取，只要指定指针的位置即可。</p>
<p>​    因为数据都在byte数组里面存着，因此如果某位置有数据，因此如果再从0写入，会将原来的数据进行覆盖。因此可以修改数据。</p>
<p>​    再设置seek方法，将数据写在想要的位置即可。</p>
<h4 id="管道流"><a href="#管道流" class="headerlink" title="管道流"></a>管道流</h4><p>​    PipedInputStream和PipedOutputStream。</p>
<p>​    将两个流关流，只读指定流的数据。</p>
<p>​    输入输出可以直接进行连接，通过结合<strong>多线程</strong>使用。</p>
<p>管道输入流应连接到管道输出流; 管道输入流然后提供写入管道输出流的任何数据字节。通常，一个线程从PipedInputStream对象读取数据，并且其他线程将数据写入相应的PipedOutputStream 。 不建议尝试从单个线程使用这两个对象，因为它可能会使线程死锁。 管道输入流包含一个缓冲区，在读取操作中将读取操作与限制内的操作相分离。 如果向连接的管道输出流提供数据字节的线程不再存在， 则称管道为broken 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipedStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//创建管道流。</span></span><br><span class="line">		PipedInputStream input = <span class="keyword">new</span> PipedInputStream();</span><br><span class="line">		PipedOutputStream output = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">		<span class="comment">//管道流连接，使用初始化或者connect</span></span><br><span class="line">		input.connect(output);</span><br><span class="line">		<span class="comment">//不能使用单线程，因为读为阻塞任务，容易死锁。</span></span><br><span class="line">		<span class="comment">//开启线程，将线程任务传入</span></span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Input(input)).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Output(output)).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> PipedInputStream in;</span><br><span class="line">	Input(PipedInputStream in)&#123;</span><br><span class="line">		<span class="keyword">this</span>.in = in;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//异常不能往外抛</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">			<span class="keyword">int</span> len = in.read(buf);</span><br><span class="line">			String s = <span class="keyword">new</span> String(buf,<span class="number">0</span>,len);</span><br><span class="line">			System.out.println(<span class="string">"s="</span>+s);</span><br><span class="line">			in.close();<span class="comment">//关流</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Output</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> PipedOutputStream out;</span><br><span class="line">	Output(PipedOutputStream out)&#123;</span><br><span class="line">		<span class="keyword">this</span>.out = out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">			out.write(<span class="string">"hi，管道来了"</span>.getBytes());</span><br><span class="line">			out.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="操作基本数据类型（装饰类）"><a href="#操作基本数据类型（装饰类）" class="headerlink" title="操作基本数据类型（装饰类）"></a>操作基本数据类型（装饰类）</h4><p>​    DataInputStream与DataOutputStream。</p>
<p>​    用于操作<strong>基本数据类型</strong>。如果使用修改版UTF-8写入，则只有此流对应的方法才为你那个读入。</p>
<p>数据输入流允许应用程序以独立于机器的方式从基础输入流读取原始Java数据类型。 应用程序使用数据输出流来写入稍后可以被数据输入流读取的数据。</p>
<p>普通的write会将整数只保留后8位。</p>
<p>为装饰类，需要传入相应的字节输入流与字节输出流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeDate</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"data.txt"</span>));</span><br><span class="line">		<span class="comment">//UTF-8修改版，用转换流也读不了，只有这个流可以</span></span><br><span class="line">		dos.writeUTF(<span class="string">"你好"</span>);</span><br><span class="line">		dos.close();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readDate</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		DataInputStream dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"data.txt"</span>));</span><br><span class="line">		String str = dis.readUTF();</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="操作字节数组（源、目的为内存）"><a href="#操作字节数组（源、目的为内存）" class="headerlink" title="操作字节数组（源、目的为内存）"></a>操作字节数组（源、目的为内存）</h5><p>​    一般操作的<strong>数据不大</strong>。</p>
<p>​    ByteArrayInputStream与ByteArrayOutputStream</p>
<p>​    源和目的都是<strong>内存</strong>。没有调用底层资源、</p>
<p>ByteArrayOutputStream该类实现了将数据写入字节数组的输出流。 当数据写入缓冲区时，<strong>缓冲区会自动增</strong>长。 可以使用toByteArray()和<strong>toString()</strong>检索数据。 </p>
<p><strong>关闭</strong>ByteArrayOutputStream<strong>没有任何效果</strong>。 在关闭流之后，仍可以调用此类中的方法，而不生成IOException 。 </p>
<p>A ByteArrayInputStream包含一个内部缓冲区，其中包含可以从流中读取的字节。 内部计数器跟踪由read方法提供的下一个字节。</p>
<p>关闭一个ByteArrayInputStream没有任何效果。 该流中的方法可以在流关闭后调用，而不生成IOException 。</p>
<p>输入流<strong>源就是数组</strong>。</p>
<h5 id="操作字符数组"><a href="#操作字符数组" class="headerlink" title="操作字符数组"></a>操作字符数组</h5><p>CharArrayReader与CharArrayWriter</p>
<p>源为字符数组。</p>
<h5 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h5><p>​    StringReader与StringWriter</p>
<p>​    源为字符串。</p>
<h3 id="编码表"><a href="#编码表" class="headerlink" title="编码表"></a>编码表</h3><p>​    编码表：将各个国家的文字用数字表示，并一一对应，形成一张表。</p>
<p>常见的编码表</p>
<p><strong>ASCII</strong>：美国标准信息交换码。</p>
<p>​    用一个字节的7位可以表示</p>
<p><strong>ISO8859-1</strong>：拉丁码表。欧洲码表</p>
<p>​    用一个字节的8位表示，兼容ASCII码表。</p>
<p><strong>GB2312</strong>：中国的中文编码表。</p>
<p><strong>GBK</strong>：中国的中文编码表升级，融合了更多的中文文字符号。</p>
<p><strong>Unicode</strong>：国际标准码，融合了多种文字。</p>
<p>​    所有文字都用两个字节表示，Java语言使用的就是unicode</p>
<p><strong>UTF-8</strong>：最多用三个字节来表示一个字符。Unicode to其他，如果可以用一个字节装下（ASCII码）用一个，两个装的下用两个，三个装的下用三个。</p>
<h4 id="编码解码"><a href="#编码解码" class="headerlink" title="编码解码"></a>编码解码</h4><h5 id="简单编码解码"><a href="#简单编码解码" class="headerlink" title="简单编码解码"></a>简单编码解码</h5><p>利用getBytes(编码名)和new String(byte[] b,编码名)来分别实现编码和解码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 字符串--&gt;字节数组：编码。</span></span><br><span class="line"><span class="comment">		 * 字节数组--&gt;字符串：解码。</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 你好：GBK：-60 -29 -70 -61</span></span><br><span class="line"><span class="comment">		 * 	负数因为一个中文2个字节，而这个字节是很大，以1打头，因此是负数。</span></span><br><span class="line"><span class="comment">		 * 你好：utf-8：-28 -67 -96 -27 -91 -67 </span></span><br><span class="line"><span class="comment">		 * 	六个字节，一个汉字用3个字节表示</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//如果是char类型，使用unicode码完成</span></span><br><span class="line">		<span class="comment">//字符串编码按照本地的编码来</span></span><br><span class="line">		String str = <span class="string">"你好"</span>;</span><br><span class="line">		<span class="comment">//编码</span></span><br><span class="line">		<span class="keyword">byte</span>[] buf = str.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">		<span class="comment">//解码</span></span><br><span class="line">		String s1 = <span class="keyword">new</span> String(buf,<span class="string">"UTF-8"</span>);</span><br><span class="line">		System.out.println(s1);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="编码解码问题"><a href="#编码解码问题" class="headerlink" title="编码解码问题"></a>编码解码问题</h5><p>​    如果编码编错了，解不出来。如果编对了，解错了，有可能有救。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC24%E5%A4%A91.png" class title="This is an example image">

<p>当你好用GBK编码，获得4个数，用iso8859-1解码，获取4个未知字符，再利用iso8859-1对四个未知字符进行编码，获取4位数字，然后利用GBK进行解码，获得你好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串编码按照本地的编码来</span></span><br><span class="line">		String str = <span class="string">"你好"</span>;</span><br><span class="line">		<span class="comment">//编码</span></span><br><span class="line">		<span class="keyword">byte</span>[] buf = str.getBytes(<span class="string">"gbk"</span>);</span><br><span class="line">		<span class="comment">//解码</span></span><br><span class="line">		String s1 = <span class="keyword">new</span> String(buf,<span class="string">"iso8859-1"</span>);</span><br><span class="line">		System.out.println(s1);</span><br><span class="line">		<span class="comment">//获取源字节</span></span><br><span class="line">		<span class="keyword">byte</span>[] buf2 = s1.getBytes(<span class="string">"iso8859-1"</span>);</span><br><span class="line">		String s2 = <span class="keyword">new</span> String(buf2,<span class="string">"GBK"</span>);</span><br><span class="line">		System.out.println(s2);</span><br></pre></td></tr></table></figure>

<p>一种应用</p>
<p>  当数据从本地提交到服务器，在服务器先解码然后以流的形式传回，但是不是中文编码，因此先用服务器自己的编码表再编码一次，然后用GBK解码，就可以得到想要的信息。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC24%E5%A4%A92.png" class title="This is an example image">

<p>如果使用utf-8先解码再编码，很有可能会解码失败，因为使用GBK获取的数字在utf-8中找不到对应的码，因此会变成未知字符，此时码已经发生了变化，因此就无法被还原。而使用iso8859-1可以还原是因为里面没有用到中文而且都是单字节编码。</p>
<h5 id="UTF-8编码"><a href="#UTF-8编码" class="headerlink" title="UTF-8编码"></a>UTF-8编码</h5><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC24%E5%A4%A93.png" class title="This is an example image">

<p>一个字节时，打头位固定为1,2个字节时，前几位也为固定位。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC24%E5%A4%A94.png" class title="This is an example image">

<p>当字节流读数据，读到第一个字节开头为110，然后读第二个字节开头为10，马上去查表。然后读到0，读一个字节就去查表。然后毒药1110，再读10，再读10，然后去查表。</p>
<p>​    一个字节，打头为0；两个字节，打头为2个1，三个字节，打头为3个1。</p>
<h5 id="联通问题"><a href="#联通问题" class="headerlink" title="联通问题"></a>联通问题</h5><p>​    联通在记事本中打开为乱码。解码出了问题。因为联通写入记事本，默认的是使用UTF-8存入，解码的时候也使用UTF-8。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	String str = <span class="string">"联通"</span>;</span><br><span class="line">	<span class="comment">//联通的GBK编码与UTF-8的编码规则相冲突。</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 11000001</span></span><br><span class="line"><span class="comment">	 * 10101010</span></span><br><span class="line"><span class="comment">	 * 11001101</span></span><br><span class="line"><span class="comment">	 * 10101000</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">byte</span>[] buf = str.getBytes();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">byte</span> b:buf)</span><br><span class="line">		System.out.println(Integer.toBinaryString(b&amp;<span class="number">255</span>));<span class="comment">//取单字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="网络模型概述"><a href="#网络模型概述" class="headerlink" title="网络模型概述"></a>网络模型概述</h4><p>OSI（Open System Interconnection开放系统互联）参考模型</p>
<p>TCP/IP模型</p>
<p>七层模型</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC26%E5%A4%A91.png" class title="This is an example image">

<p><strong>1层物理层</strong>：主要定义物理设备标准，如<strong>网线</strong>的接口类型、光纤的接口类型、各种<strong>传输介质</strong>的传输速率等。它的主要作用是<strong>传输比特流</strong>（就是1、0转化为电流强弱来进行传输，到大目的后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做<strong>比特</strong>。</p>
<p><strong>2层数据链路层</strong>：主要将从物理层接收的数据进行<strong>MAC地址</strong>（网卡的地址，每个网卡<strong>唯一</strong>）的封装与解封装。常把这一层的数据叫做<strong>帧</strong>。这一层工作的设备是<strong>交换机</strong>（实现互联），数据通过交换机来传输。</p>
<p><strong>3层网络层</strong>：主要将从下层接收到的数据进行<strong>IP地址</strong>（例192.168.0.1）的封装与解封装。看数据到底发向哪一台主机。在这一层工作的设备是<strong>路由器</strong>（数据包方向的定义），常把这一层的数据叫做<strong>数据包</strong>。</p>
<p><strong>4层传输层</strong>：定义了一些传输数据的<strong>协议</strong>和<strong>端口号</strong>（WWW端口80等），如：<strong>TCP</strong>（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），<strong>UDP</strong>（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做<strong>段</strong>。</p>
<p><strong>5会话层</strong>：通过传输层（端口号：传输端口与接收端口）<strong>建立数据传输的通路</strong>。主要在你的系统之间发起会话或者接收会话请求（设备之间需要互相认识，可以使IP也可以是MAC或者是主机名）</p>
<p><strong>6表示层</strong>：主要是进行对接收的数据进行<strong>解释</strong>、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转成人能识别的东西（如图片、声音等））。</p>
<p><strong>7应用层</strong>：主要是一些<strong>终端的应用</strong>（应用软件），比如FTP（各种文件下载），WEB（IE浏览），QQ之类的（可以把它理解成我们在电脑屏幕上可以看到的东西，就是终端应用）。</p>
<p>对数据加上每一层的标识，便于解析。逐层包装标识（<strong>封包</strong>），逐层解析（<strong>拆包</strong>）。</p>
<p>七层模型过于繁琐，因此有了TCP/IP参考模型。</p>
<p>1主机至网络层：物理层+数据链路层。（交换机为一部分）</p>
<p>2<strong>网际层</strong>：网络层</p>
<p>3<strong>传输层</strong>：原传输层（<strong>重要</strong>）</p>
<p>5   应用层：会话层+表示层+应用层。（Java Web开发）</p>
<h4 id="网络通讯要素"><a href="#网络通讯要素" class="headerlink" title="网络通讯要素"></a>网络通讯要素</h4><p>​    IP地址</p>
<p>​    端口号</p>
<p>​    传输协议</p>
<h5 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h5><p>​    IPV4：有4段，一段的最大值为一个Byte，即2^8，0-255。最大值为255。</p>
<p>​    IPV6：融入了字母。因为地址够用，因此很多设备都可以拥有独立的IP地址，物联网的时代。</p>
<p>IP地址：<strong>InetAddress</strong></p>
<p>​    网络中设备的表示</p>
<p>​    不易记忆，可用主机名</p>
<p>​    本地回环地址：127.0.0.1 主机名：localhost 用于在没有互联网时<strong>本机访问本机</strong>。如果ping本机地址有问题，网卡可能出问题了。<strong>测试网卡</strong>。</p>
<h5 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a><strong>InetAddress</strong></h5><p>​    存在于网际层。</p>
<p>​    可以通过主机名称或者主机地址字符串获得ip对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取本地主机IP地址对象</span></span><br><span class="line">		InetAddress ip = InetAddress.getLocalHost();</span><br><span class="line">		<span class="comment">//获取其他主机的IP地址对象</span></span><br><span class="line">		ip = InetAddress.getByName(<span class="string">"172.21.21.196"</span>);</span><br><span class="line">		ip = InetAddress.getByName(<span class="string">"DESKTOP-L0U8999"</span>);</span><br><span class="line">		ip = InetAddress.getByName(<span class="string">"www.baidu.com"</span>);</span><br><span class="line">		<span class="comment">//获取IP地址更多</span></span><br><span class="line">		System.out.println(ip.getHostAddress());</span><br><span class="line">		System.out.println(ip.getHostName());</span><br></pre></td></tr></table></figure>

<p>IP地址太多记不住，给主机命名，记住名字即可。</p>
<p>com一般属于商业化组织，营利性；org属于非营利性。</p>
<p>cn标识所属国家类别。</p>
<p>IP地址与名字有对应关系，互联网上公共的服务器中存放着IP地址和名称的对应关系。叫做<strong>域名解析DNS</strong>，机器叫域名解析服务器（记住了IP地址）。不指定DNS解析地址，宽带服务商解析，信息发给他，他再发给DNS服务器。</p>
<p>  现在一个IP地址可能分配给多台主机使用。</p>
<p>  如果想提高解析速度，可以在本机中创建域名解析列表。即<strong>host</strong>文件，本地域名解析列表。域名解析最先走的为本地解析列表，如果解析失败再走互联网的解析。自己可以创建对应名称来访问本机，其他人使用此host文件中的域名或地址无法访问到本主机，因为其机器上没有此列表。如果想在局域网中所有人都可以使用此解析列表，可以在某台主机上使用DNS解析软件，然后其他主机的DNS解析地址指向此主机即可。</p>
<p>  如果想屏蔽某些网站，可以将其域名与本地ip地址127.0.0.1关联，这样可以屏蔽公共解析，指向本地解析。</p>
<p>IP地址：192.168.1.1</p>
<p>子网掩码：255.255.255.0</p>
<p>子网掩码前3个均为255，代码IP地址前三位均为网络位，最后一位为IP地址位。从0-255,0代表网络位，不可用，因此1-254可用，255不属于IP地址而是广播地址。如果发到192.168.1.255，代表把消息发到192.168.1.0网络上所有存活的机器上。</p>
<h5 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h5><p>逻辑端口，给应用程序分配数字标识。</p>
<p>​    用于标识进程的逻辑地址，不同进程的标识。</p>
<p>​    有效端口：0<del>65535（2^16），其中0</del>1024系统使用或保留端口。</p>
<p>禁用端口：可以防止某些应用程序禁用互联网。</p>
<h5 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h5><p>​    通讯规则</p>
<p>​    常见协议：TCP，UDP</p>
<p>UDP</p>
<p>数据报文协议</p>
<p>​    将数据及源和目的封装成数据包中，<strong>不需要建立连接</strong></p>
<p>​    每个数据报的大小限制在<strong>64k</strong>内</p>
<p>​    因无连接，是<strong>不可靠</strong>协议</p>
<p>​    不需要建立连接，<strong>速度快</strong></p>
<p>如QQ聊天，视频通讯。</p>
<p>TCP</p>
<p>传输控制协议。</p>
<p>​    建立连接，形成传输数据的通道</p>
<p>​    在连接中进行<strong>大数据量</strong>传输</p>
<p>​    通过<strong>三次握手</strong>完成连接，是可靠协议</p>
<p>​    必须建立连接，<strong>效率会稍低</strong></p>
<p>下载数据</p>
<h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p>插座，套接字</p>
<p>socket就是为网络服务提供的一种机制</p>
<p>通信的两端都有Socket</p>
<p>网络通信其实就是Socket间的通信</p>
<p>数据在两个Socket间通过IO传输。</p>
<h4 id="UDP传输"><a href="#UDP传输" class="headerlink" title="UDP传输"></a>UDP传输</h4><ul>
<li><p>DatagramSocket与DatagramPacket</p>
</li>
<li><p>建立发送端，接收端</p>
</li>
<li><p>建立数据包</p>
</li>
<li><p>调用Socket的发送接收方法</p>
</li>
<li><p>关闭Socket</p>
</li>
</ul>
<p>发送端与接收端是两个独立的运行程序</p>
<p>DtagramSocket：表示用于<strong>发送</strong>和<strong>接收</strong>数据报包的套接字。</p>
<p>​    可以直接new对象，有发送和接收数据包的方法。</p>
<p>DatagramPacket：表示数据报包数据报包实现无连接包投递服务。不对包投递做出保障。</p>
<p>​    构造时有的是发送的，有的是接收的。发送的数据包有目的地址，接收不需要。带有IP对象的均为用来发送的。发送多接收少。</p>
<p>UDP发送端与接收端哪个先连接都可以。</p>
<p>发送端指定的端口为接收端的端口，而接收端获取的端口为发送端的端口。</p>
<p>发送端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 创建UDP传输的发送端</span></span><br><span class="line"><span class="comment">		 * 思路：</span></span><br><span class="line"><span class="comment">		 * 1，建立UDP的Socket服务。</span></span><br><span class="line"><span class="comment">		 * 2，将要发送的数据封装到数据包中。</span></span><br><span class="line"><span class="comment">		 * 3，通过UDP的Socket服务将数据包发送出去</span></span><br><span class="line"><span class="comment">		 * 4，关闭Socket服务。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//1，UDP的Socket服务。使用DatagramSocket对象。</span></span><br><span class="line">		DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">8888</span>);<span class="comment">//明确发送端的端口号</span></span><br><span class="line">		<span class="comment">//2，将要发送的数据封装到数据包中。</span></span><br><span class="line">		String str = <span class="string">"中午吃什么？"</span>;</span><br><span class="line">			<span class="comment">//使用DatagramPacket将数据封装到该对象包中</span></span><br><span class="line">		<span class="keyword">byte</span>[] buf = str.getBytes();</span><br><span class="line">		<span class="comment">//将地址改为接收端的IP地址即可</span></span><br><span class="line">		DatagramPacket dp =</span><br><span class="line">				<span class="keyword">new</span> DatagramPacket(buf, buf.length, InetAddress.getLocalHost(), <span class="number">10000</span>);</span><br><span class="line">		<span class="comment">//3，通过UDP的Socket服务将数据包发送出去，使用send方法。</span></span><br><span class="line">		ds.send(dp);</span><br><span class="line">		<span class="comment">//4，关闭资源</span></span><br><span class="line">		ds.close();</span><br></pre></td></tr></table></figure>

<p>接收端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 建立UDP接收端的思路。</span></span><br><span class="line"><span class="comment">		 * 1，建立UDP的Socket服务，因为是要接收数据，必须要明确一个端口号。</span></span><br><span class="line"><span class="comment">		 * 2，创建数据包，用于存储接收到的数据。方便用数据包对象的方法解析这些数据。</span></span><br><span class="line"><span class="comment">		 * 3，使用Socket服务的receive方法将接收到的数据存储到数据包中。</span></span><br><span class="line"><span class="comment">		 * 4，通过数据包的方法解析数据包中的数据。</span></span><br><span class="line"><span class="comment">		 * 5，关闭资源。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//1，建立UDP的Socket服务</span></span><br><span class="line">		DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">10000</span>);<span class="comment">//明确接收的端口号</span></span><br><span class="line">		<span class="comment">//2，创建数据包</span></span><br><span class="line">		<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line">		<span class="comment">//3，使用接收方法将数据存储到数据包中</span></span><br><span class="line">		ds.receive(dp);<span class="comment">//阻塞式的。</span></span><br><span class="line">		<span class="comment">//4，通过数据包对象的方法，解析其中的数据，比如，地址，端口，数据内容。</span></span><br><span class="line">		String ip = dp.getAddress().getHostAddress();<span class="comment">//IP地址对象的字符串表示</span></span><br><span class="line">		<span class="keyword">int</span> port = dp.getPort();<span class="comment">//获得端口，发送端的端口</span></span><br><span class="line">		String text = <span class="keyword">new</span> String(dp.getData(),<span class="number">0</span>,dp.getLength());<span class="comment">//只取有效数据</span></span><br><span class="line">		System.out.println(ip+<span class="string">":"</span>+port+<span class="string">":"</span>+text);</span><br><span class="line">		<span class="comment">//5，关闭资源</span></span><br><span class="line">		ds.close();</span><br></pre></td></tr></table></figure>

<h4 id="TCP传输"><a href="#TCP传输" class="headerlink" title="TCP传输"></a>TCP传输</h4><ul>
<li><p>Socket和ServerSocket</p>
</li>
<li><p>建立客户端和服务器端</p>
</li>
<li><p>建立连接后，通过Socket中的IO流进行数据的传输</p>
</li>
<li><p>关闭Socket</p>
</li>
</ul>
<p>同样，客户端与服务器端是两个独立的应用程序。</p>
<p>Socket类实现客户端套接字。ServerSocket类实现服务器套接字。</p>
<p>客户端向服务端发送信息建立通道，通道建立后服务器端向客户端发送信息。</p>
<p>客户端一般初始化时要指定对方的IP地址和端口，IP地址可以是IP对象，也可以是IP对象字符串表现形式。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC26%E5%A4%A92.png" class title="This is an example image">

<p>建立通道后，信息传输通过Socket流，为底层建立好的，又有输入和输出，想要获取输入或输出流对象，找Socket来获取。为字节流。getInputStream()和getOutputStream()方法来获取输入流和输出流。</p>
<p>  服务端获取到客户端Socket对象，通过其对象与Cilent进行通讯。</p>
<p>  客户端的输出对应服务端的输入，服务端的输出对应客户端的输入。</p>
<p>  TCP必须<strong>先开服务端</strong>。</p>
<p>  如果名称为out,in的视为Socket流，如果不是就是一般流。</p>
<p>  tcp使用的时候可能会出现两端都在等待的情况，原因可能是数据没有发送出去。最大原因在于有阻塞式方法。</p>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端发数据到服务端</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * TCP传输，客户端建立的过程</span></span><br><span class="line"><span class="comment">		 * 1，创建TCP客户端Socket服务，使用的是Socket对象。</span></span><br><span class="line"><span class="comment">		 * 		建议该对象一创建就明确目的地。要连接的主机。</span></span><br><span class="line"><span class="comment">		 * 2，如果连接建立成功，说明数据传输通道已建立。</span></span><br><span class="line"><span class="comment">		 * 		该通道就是Socket流，是底层建立好的。既然是流，说明这里既有输入，又有输出。</span></span><br><span class="line"><span class="comment">		 * 		想要输入或者输出流对象，可以找Socket来获取。</span></span><br><span class="line"><span class="comment">		 * 		可以通过getInputStream()和getOutputStream()方法来获取两个字节流。</span></span><br><span class="line"><span class="comment">		 * 3，使用输出流，将数据写出。</span></span><br><span class="line"><span class="comment">		 * 4，关闭资源。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//创建客户端Socket服务</span></span><br><span class="line">		Socket socket = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(), <span class="number">10002</span>);</span><br><span class="line">		<span class="comment">//获取Socket流中的输出流</span></span><br><span class="line">		OutputStream out = socket.getOutputStream();</span><br><span class="line">		<span class="comment">//使用输出流，将指定的输出写出去</span></span><br><span class="line">		out.write(<span class="string">"TCP演示，哥们又来了！"</span>.getBytes());</span><br><span class="line">		<span class="comment">//关闭资源</span></span><br><span class="line">		socket.close();</span><br></pre></td></tr></table></figure>

<p><strong>服务端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务端接收客户端发送过来的数据，并打印在控制台上。</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 建立TCP服务端的思路</span></span><br><span class="line"><span class="comment">		 * 1，创建服务端Socket服务，通过ServerSocket对象。</span></span><br><span class="line"><span class="comment">		 * 2，服务端必须对外提供一个端口，否则客户端无法连接。</span></span><br><span class="line"><span class="comment">		 * 3，获取连接过来的客户端对象。</span></span><br><span class="line"><span class="comment">		 * 4，通过客户端对象获取Socket流，读取客户端发来的数据。</span></span><br><span class="line"><span class="comment">		 * 5，关闭资源。关客户端，关服务端。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//1，创建服务端对象</span></span><br><span class="line">		ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">10002</span>);</span><br><span class="line">		<span class="comment">//2，获取连接过来的客户端对象</span></span><br><span class="line">		Socket s = ss.accept();<span class="comment">//阻塞式</span></span><br><span class="line">		String ip = s.getInetAddress().getHostAddress();<span class="comment">//获取IP地址</span></span><br><span class="line">		<span class="comment">//3，通过Socket对象获取输入流，要读取客户端发来的数据</span></span><br><span class="line">		InputStream in = s.getInputStream();</span><br><span class="line">		<span class="comment">//读取数据，自定义缓冲区</span></span><br><span class="line">		<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len = in.read(buf);</span><br><span class="line">		String text = <span class="keyword">new</span> String(buf, <span class="number">0</span>, len);</span><br><span class="line">		System.out.println(ip+<span class="string">":"</span>+text);</span><br><span class="line">		<span class="comment">//关闭客户端</span></span><br><span class="line">		s.close();</span><br><span class="line">		ss.close();<span class="comment">//一般服务器端不关闭</span></span><br></pre></td></tr></table></figure>

<p><strong>服务端与客户端交互</strong></p>
<p>服务器接收到数据后，利用客户端的Socket对象的输出流写入数据，客户端利用Socket流的输入流进行数据接收。</p>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取服务端返回的数据，使用Socket读取流。</span></span><br><span class="line">		InputStream in = socket.getInputStream();</span><br><span class="line">		<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len = in.read(buf);</span><br><span class="line">		String text = <span class="keyword">new</span> String(buf, <span class="number">0</span>, len);</span><br><span class="line">		System.out.println(<span class="string">"客户端收到反馈:"</span>+text);</span><br></pre></td></tr></table></figure>

<p><strong>服务端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用客户端Socket对象的输出流给客户端返回数据</span></span><br><span class="line">		OutputStream out = s.getOutputStream();</span><br><span class="line">		out.write(<span class="string">"收到"</span>.getBytes());</span><br></pre></td></tr></table></figure>

<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC27%E5%A4%A91.png" class title="This is an example image">

<p>服务器端原理，<strong>并发访问</strong>，只有一个端口对外提供，当进来一个客户端Socket，阻塞，新建线程去执行，线程任务就是读写操作。然后再进来一个客户端，再利用新线程去执行，为了避免线程过多，一个线程结束后就结束线程。把连接进来的客户端封装在线程中。</p>
<h4 id="常见客户端与服务端"><a href="#常见客户端与服务端" class="headerlink" title="常见客户端与服务端"></a>常见客户端与服务端</h4><p>最常见客户端：</p>
<p>​    浏览器：IE。</p>
<p>最常见的服务器：</p>
<p>​    服务器：Tomcat。</p>
<p>http：应用层协议，超文本传输控制协议。文字带颜色，大小，图片带声音。使用语言为html。</p>
<p>定义了web浏览器与服务器的通信规则。浏览器中有解析http协议的解析引擎。</p>
<p>FTP：文件传输协议</p>
<p>Web服务器默认端口：80</p>
<p>Tomcat服务器对外提供接口。interface <strong>Servlet</strong>。必须直接或间接实现。Tomcat对外提供Web资源访问。</p>
<p>访问服务器：http://主机名:8080/myweb</p>
<p>​    会自动去webapps下去寻找。</p>
<p>​    服务器必须对外提供可访问资源，即Web应用程序。webapps下存放的为web资源。</p>
<h4 id="客户端和服务端原理"><a href="#客户端和服务端原理" class="headerlink" title="客户端和服务端原理"></a>客户端和服务端原理</h4><p>了解原理：</p>
<p>1， 自定义服务端，使用已有的客户端IE，了解一下客户端给服务器端发了什么请求。</p>
<p>发送的请求是</p>
<p>GET / HTTP/1.1 <strong>请求行</strong> <strong>请求方式 /myweb/1,html 请求的资源路径 http协议版本(1.0或者1.1,1.1更常用)请求方式包括GET,POST</strong></p>
<p><strong>请求消息头</strong> <strong>属性名：属性值（键值对）</strong></p>
<p>Accept: </p>
<p><strong>服务器可以支持的app</strong></p>
<p>text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8</p>
<p><strong>支持的语言</strong></p>
<p>Accept-Language: zh-Hans-CN,zh-Hans;q=0.8,en-US;q=0.5,en;q=0.3</p>
<p>Upgrade-Insecure-Requests: 1</p>
<p><strong>用户信息，系统版本</strong></p>
<p>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36 Edge/18.17763</p>
<p><strong>支持的压缩方式，服务器发送信息时将信息压缩，客户端解压缩</strong></p>
<p>Accept-Encoding: gzip, deflate</p>
<p><strong>访问的主机</strong></p>
<p>Host: 127.0.0.1:9090</p>
<p>Connection: Keep-Alive</p>
<p>请求头和请求体之间有<strong>空行</strong></p>
<p>请求体：可能会有注册信息等。</p>
<p>2， 自定义浏览器</p>
<p>服务端发回应答消息</p>
<p>HTTP/1.1 403 Forbidden <strong>应答行</strong>，http的协议版本 <strong>应答状态码</strong> 应答状态<strong>描述信息</strong></p>
<p><strong>200</strong>代表成功，描述信息OK  <strong>404</strong> not found 找不到页面 </p>
<p><strong>应答消息属性信息</strong>。属性名：属性值</p>
<p>Server: bfe</p>
<p>Date: Tue, 05 Mar 2019 15:26:23 GMT</p>
<p><strong>最后修改时间</strong>，带着信息访问，如果修改日期一致本地缓存界面与服务器端一样，发新的状态码。</p>
<p>Last-Modified:一堆日期</p>
<p><strong>发送字节数</strong></p>
<p>Content-Length: 0</p>
<p><strong>收到数据类型</strong></p>
<p>Content-Type: text/plain; charset=utf-8</p>
<p>Connection: close</p>
<p>//有一行空行</p>
<p><strong>应答体</strong></p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC27%E5%A4%A92.png" class title="This is an example image">

<p>处理请求并给予应答。</p>
<p>可以网页输入http://主机名:指定端口号，即可以访问自定义的服务端。</p>
<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>协议解析对象</p>
<p>​    浏览器向服务器发送<strong>http请求信息</strong>，然后浏览器发送<strong>应答消息头</strong>和应答体。浏览器中只显示应答体，而应答消息头被浏览器解析引擎解析。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC27%E5%A4%A93.png" class title="This is an example image">

<p>可以使用URL对象对应答消息头进行解析。URL底层挂的是URLConnection</p>
<p>​    类URL代表一个<strong>统一资源定位符</strong>，是指向互联网“资源”的<strong>指针</strong>。资源可以是简单的文件或目录，也可以是对更为复杂的对象的引用，例如对数据库或搜索引擎的查询。</p>
<p>​    URI<strong>统一资源标识符引用</strong>。</p>
<p>​    每个URL都是URI，但不一定每个URI都是URL。URI还包括个子类URN，统一资源名称。mailto、news和isbnURI都是URN的示例。</p>
<p>​    URL对象可以直接解析URL地址。getProtocol()，获取协议。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取信息</span></span><br><span class="line">		System.out.println(url.getProtocol());<span class="comment">//协议</span></span><br><span class="line">		System.out.println(url.getHost());<span class="comment">//主机</span></span><br><span class="line">		System.out.println(url.getPort());<span class="comment">//端口</span></span><br><span class="line">		System.out.println(url.getFile());<span class="comment">//文件名，会带有name参数</span></span><br><span class="line">		System.out.println(url.getPath());<span class="comment">//路径，只负责到文件</span></span><br><span class="line">		System.out.println(url.getQuery());<span class="comment">//参数信息，？后的部分</span></span><br></pre></td></tr></table></figure>

<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC27%E5%A4%A94.png" class title="This is an example image">

<p>InputStream openStream()<strong>打开此URL的连接</strong>并返回一个用于从该连接<strong>读入的InputStream</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只输出应答体，不输出应答消息头</span></span><br><span class="line">		InputStream in = url.openStream();</span><br><span class="line">		<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len = in.read(buf);</span><br><span class="line">		String text = <span class="keyword">new</span> String(buf, <span class="number">0</span>, len);</span><br><span class="line">		System.out.println(text);</span><br><span class="line">		in.close();</span><br><span class="line">		<span class="comment">//URL不用关闭</span></span><br></pre></td></tr></table></figure>

<p>其中openStream()底层使用的是openConnection().getInputStream()</p>
<h4 id="URLConnection"><a href="#URLConnection" class="headerlink" title="URLConnection"></a>URLConnection</h4><p>URL连接器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取url对象的URL连接器，将连接封装成了对象：java中内置的可以解析的具体协议的对象+socket</span></span><br><span class="line">		URLConnection conn = url.openConnection();</span><br></pre></td></tr></table></figure>

<p>conn打印结果如下</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC27%E5%A4%A95.png" class title="This is an example image">

<p>​    前面http地址为http底层实现。</p>
<p>String <strong>getHeaderField</strong>(String ) 获取相关属性，</p>
<p>如使用String value = conn. getHeaderField(“Content-Type”)，获取内容类型，然后用相关的解析器去解析。</p>
<p>可以获取输入和输出流，因此相当于使用了Socket，但是加入了协议。</p>
<p>URL中openStream原理为先获取连接，然后获取流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取url对象的URL连接器，将连接封装成了对象</span></span><br><span class="line">		URLConnection conn = url.openConnection();</span><br><span class="line">		InputStream in = conn.getInputStream();</span><br></pre></td></tr></table></figure>

<p>因此以后浏览器就不用使用Socket，而是使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str_url = <span class="keyword">new</span> String(<span class="string">"http://192.168.1.100:8080/myweb/1.html?name=lisi"</span>);</span><br><span class="line">		URL url = <span class="keyword">new</span> URL(str_url);<span class="comment">//抛出无法解析URL</span></span><br><span class="line">		<span class="comment">//只输出应答体，不输出应答消息头</span></span><br><span class="line">		InputStream in = url.openStream();</span><br></pre></td></tr></table></figure>

<h4 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h4><p>1，C/S      Client/Server</p>
<p>​    特点：</p>
<p>该结构的软件，客户端和服务端都需要编写。</p>
<p>​        开发成本较高，维护较为麻烦。</p>
<p>​        可能会出现版本差异</p>
<p>​    好处：</p>
<p>​       客户端在本地可以分担一部分运算。</p>
<p>网络游戏就是客户端，因为很多数据存储在本地，位置坐标实时与主机交换。</p>
<p>2，B/S      Browser/Server</p>
<p>​    特点：</p>
<p>​        该结构的软件，只开发服务器端，不开发客户端，因为客户端直接由浏览器取代。</p>
<p>​        开发成本相对低，维护更为简单。</p>
<p>​    缺点：</p>
<p>​       所有运算都在服务器端完成。</p>
<hr>
<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><h4 id="概述与应用场景"><a href="#概述与应用场景" class="headerlink" title="概述与应用场景"></a>概述与应用场景</h4><p>反射中涉及到的对象均在java.lang.reflect包中。Constructoe,Filed,Method。</p>
<p>​    AccessibleObject类是Field、Method、和Constructor对象的基类。它提供了将反射的对象标记为在使用时取消Java语言访问控制检查的能力。</p>
<p>java反射机制是在运行状态中，对于任意一个类(class文件)，都能够知道这个类的所有属性和方法；</p>
<p>对于任意一个对象，都能够调用它的任意一个方法和属性。</p>
<p>这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p><strong>动态获取类中信息</strong>，就是java的反射机制。</p>
<p>可以理解为对类的解剖。</p>
<p>软件的功能扩展利用对外提供接口实现。</p>
<p>​    一个类实现了软件对外暴露的接口，会在程序的配置文件中写入，程序读取此配置文件，会去寻找接口实现类的class文件。如果找到则加载此文件，并获取该文件里所有内容。拿到字节码文件就可以新建对象，因为其中有构造函数。</p>
<p>​    如果想要对指定名称的字节码文件加载并获取其中的内容并调用。</p>
<p>实现方法：这时使用到了<strong>反射</strong>技术。</p>
<p>优点：极大的提高了程序的扩展性。</p>
<p>Tomcat提供的接口为Servlet，服务器端脚本程序片段。将实现接口的类名称写入配置文件，软件便可以动态加载此类中的内容。利用的是反射技术。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC28%E5%A4%A91.png" class title="This is an example image">

<p>​    需要<strong>接口</strong>+<strong>配置文件</strong>。</p>
<p>​    学习框架：框架作用，配置文件怎么用，常用对象的用法。</p>
<p>​    反射技术提高了扩展技术，用起来简单（用户只面对配置文件）。</p>
<h4 id="细节和Class对象"><a href="#细节和Class对象" class="headerlink" title="细节和Class对象"></a>细节和Class对象</h4><p>​    传参通过配合文件完成。</p>
<p>​    拿到类以后，获取指定类中的信息。</p>
<p>​    反射的过程：由Class类来完成</p>
<p>Class类用来表述二进制字节码文件。可以new对象，提供获取到字节码文件中的内容，如名称、字段、构造函数、一般函数。该类就可以获得字节码文件中的<strong>所有内容</strong>。反射就是依靠该类来完成的。</p>
<p>​    想要对一个类文件进行解剖，只要获取到该类的<strong>字节码文件对象</strong>即可。</p>
<h4 id="获取Class对象的三种方式"><a href="#获取Class对象的三种方式" class="headerlink" title="获取Class对象的三种方式"></a>获取Class对象的三种方式</h4><p>要想对字节码文件进行解剖，必须要有字节码文件对象。如何获取其对象？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 获取字节码对象的方式：</span></span><br><span class="line"><span class="comment">	 * 方式一，Object中的getClass()方法</span></span><br><span class="line"><span class="comment">	 * 想要用这种方式必须要明确具体的类并创建对象。</span></span><br><span class="line"><span class="comment">	 * 麻烦！！！</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">		Person p = <span class="keyword">new</span> Person();</span><br><span class="line">		Class clazz = p.getClass();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 方式二：</span></span><br><span class="line"><span class="comment">	 * 	任何数据类型都具备一个静态的属性.class来获取其对应的Class对象</span></span><br><span class="line"><span class="comment">	 * 相对简单，但是还是要明确用到类中的静态成员</span></span><br><span class="line"><span class="comment">	 * 还是不够扩展</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">		Class clazz = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 方式三：</span></span><br><span class="line"><span class="comment">	 * 只要通过给定的类的字符串名称就可以获取该类，更为扩展</span></span><br><span class="line"><span class="comment">	 * 可以用Class类中的方法完成</span></span><br><span class="line"><span class="comment">	 * 该方法就是forName()</span></span><br><span class="line"><span class="comment">	 * 这种方式只要有名称即可，更为方便，扩展性更强</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">		<span class="comment">//需要带着包名</span></span><br><span class="line">		String className = <span class="string">"cn.zc.bean.Person"</span>;</span><br><span class="line">		Class clazz = Class.forName(className);</span><br></pre></td></tr></table></figure>

<h4 id="获取Class中的构造函数"><a href="#获取Class中的构造函数" class="headerlink" title="获取Class中的构造函数"></a>获取Class中的构造函数</h4><p>获得空参的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//早期：new的时候，先根据被new的类的名称找寻该类的字节码文件，并加载进内存，</span></span><br><span class="line">		<span class="comment">//	  并创建该字节码文件对象，并接着创建该字节文件的对应的Person对象 </span></span><br><span class="line"><span class="comment">//		cn.zc.bean.Person p = new cn.zc.bean.Person();</span></span><br><span class="line">		<span class="comment">//现在：</span></span><br><span class="line">		String name = <span class="string">"cn.zc.bean.Person"</span>;</span><br><span class="line">		<span class="comment">//找寻该名称类文件，并加载进内存，并产生Class对象</span></span><br><span class="line">		Class clazz = Class.forName(name);</span><br><span class="line">		<span class="comment">//如何产生该类的对象呢？</span></span><br><span class="line">		<span class="comment">//如果没有public公共构造函数，会出错。</span></span><br><span class="line">		<span class="comment">//如果是private构造函数，则不能访问，报错。</span></span><br><span class="line">		Object obj = clazz.newInstance();</span><br></pre></td></tr></table></figure>

<p>如果想要获得要输入参数的对象，则要获取构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//		cn.zc.bean.Person p = new cn.zc.bean.Person("小强", 39);</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 当获取指定名称对应的类中所体现的对象时，</span></span><br><span class="line"><span class="comment">		 * 而该对象初始化不使用空参数构造函数该怎么办？</span></span><br><span class="line"><span class="comment">		 * 既然是通过指定的构造函数进行对象的初始化，</span></span><br><span class="line"><span class="comment">		 * 所以应该先获取到该构造函数。通过字节码文件对象即可完成。</span></span><br><span class="line"><span class="comment">		 * 该方法是getConstructor(...parameterTypes)</span></span><br><span class="line"><span class="comment">		 * 获取到所有的公有构造函数</span></span><br><span class="line"><span class="comment">		 * getDeclaredConstructors获取所有权限的构造函数</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		String name = <span class="string">"cn.zc.bean.Person"</span>;</span><br><span class="line">		<span class="comment">//找寻该名称类文件，并加载进内存，并产生Class对象</span></span><br><span class="line">		Class clazz = Class.forName(name);</span><br><span class="line">		<span class="comment">//传进参数类型对应的class</span></span><br><span class="line">		Constructor constructor = clazz.getConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">		<span class="comment">//通过该构造器对象的newInstance方法进行对象的初始化</span></span><br><span class="line">		Object obj = constructor.newInstance(<span class="string">"小明"</span>,<span class="number">38</span>);</span><br></pre></td></tr></table></figure>

<h4 id="获取Class中的字段"><a href="#获取Class中的字段" class="headerlink" title="获取Class中的字段"></a>获取Class中的字段</h4><p>如果字段是私有的，则不能直接访问，需要先取消权限检查，称为暴力访问，不建议使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取字节码文件中的字段</span></span><br><span class="line"><span class="comment"> * 直接get加对应的，获得的均为公共的</span></span><br><span class="line"><span class="comment"> * 如果是所有的则是Declared。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getFieldDemo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Class clazz = Class.forName(<span class="string">"cn.zc.bean.Person"</span>);</span><br><span class="line">	Field field = <span class="keyword">null</span>;<span class="comment">//clazz.getField("age");//只能获取公有的，包含父类</span></span><br><span class="line">	field = clazz.getDeclaredField(<span class="string">"age"</span>);<span class="comment">//只获取本类，但包含私有</span></span><br><span class="line">	<span class="comment">//对私有字段的访问取消权限检查。暴力访问。</span></span><br><span class="line">	field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">	Object obj = clazz.newInstance();</span><br><span class="line">	field.set(obj, <span class="number">89</span>);<span class="comment">//设置字段的值</span></span><br><span class="line">	Object o = field.get(obj);<span class="comment">//属性要被对象调用//如果不改权限，无效访问异常，因为是私有的</span></span><br><span class="line">	System.out.println(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取Class中的方法"><a href="#获取Class中的方法" class="headerlink" title="获取Class中的方法"></a>获取Class中的方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 获取指定Class中的所有公共函数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMethodDemo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class clazz = Class.forName(<span class="string">"cn.zc.bean.Person"</span>);</span><br><span class="line">		Method[] methods = clazz.getMethods();<span class="comment">//获取的都是公有的方法，包含父类</span></span><br><span class="line">		methods = clazz.getDeclaredMethods();<span class="comment">//只获取本类中所有方法，包含私有</span></span><br><span class="line">		<span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">			System.out.println(method);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//获取指定的不带参数方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMethodDemo_2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class clazz = Class.forName(<span class="string">"cn.zc.bean.Person"</span>);</span><br><span class="line">		<span class="comment">//必须指定方法名和列表	</span></span><br><span class="line">		Method method = clazz.getMethod(<span class="string">"show"</span>, <span class="keyword">null</span>);<span class="comment">//获取空参数一般方法</span></span><br><span class="line"><span class="comment">//		Object obj = clazz.newInstance();//获取空参数对象</span></span><br><span class="line">		<span class="comment">//获取有参数的对象</span></span><br><span class="line">		Constructor constructor = clazz.getConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">		Object obj = constructor.newInstance(<span class="string">"小明"</span>,<span class="number">37</span>);</span><br><span class="line">		method.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">		Field field = clazz.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line">		field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">		System.out.println(field.get(obj));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取指定的带参数方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMethodDemo_3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class clazz = Class.forName(<span class="string">"cn.zc.bean.Person"</span>);</span><br><span class="line">		<span class="comment">//必须指定方法名和列表	</span></span><br><span class="line">		Method method = clazz.getMethod(<span class="string">"paraMethod"</span>, String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;<span class="comment">//获取空参数一般方法</span></span><br><span class="line">		Object obj = clazz.newInstance();</span><br><span class="line">		method.invoke(obj, <span class="string">"小强"</span>,<span class="number">89</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="反射演示"><a href="#反射演示" class="headerlink" title="反射演示"></a>反射演示</h4><p>  想要不修改主函数，只通过修改配置文件来让不同的设备运行。程序要对外暴露一个接口PCI，要实现开和关的方法，设备要实现此接口。</p>
<p>  关键：对外暴露接口，加载配置文件，新功能实现此接口，获取到Class对应的对象，将此接口对象传入相应的方法，其他的就很简单了。</p>
<p>思路：</p>
<p>1、 将配置文件关联到文件对象，新建Properties对象，新建流将文件中数据load进Properties中。</p>
<p>2、 遍历键值对，逐个获取到类名。根据类名获取到Class文件</p>
<p>3、 因为所有的设备对象都实现了PCI接口，因此可以利用Class获取到的空参对象强转为PCI类型</p>
<p>4、 将此PCI设备传进主板的使用PCI方法，即可。将流关闭</p>
<p>主函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Mainboard mb = <span class="keyword">new</span> Mainboard();</span><br><span class="line">		mb.run();</span><br><span class="line">		<span class="comment">//每次添加一个设备都需要修改代码传递一个新创建的对象</span></span><br><span class="line"><span class="comment">//		mb.usePCI(new SoundCard());</span></span><br><span class="line">		<span class="comment">//能不能不修改代码就可以完成这个动作</span></span><br><span class="line">		<span class="comment">//不用new来完成，而是直接获取其Class文件，在内部实现创建对象的动作</span></span><br><span class="line">		File configFile = <span class="keyword">new</span> File(<span class="string">"pci.properties"</span>);</span><br><span class="line">		Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">		FileInputStream fis = <span class="keyword">new</span> FileInputStream(configFile);</span><br><span class="line">		prop.load(fis);<span class="comment">//把流中的数据加载到键值对中</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;prop.size();x++)&#123;</span><br><span class="line">			String pciName = prop.getProperty(<span class="string">"pci"</span>+(x+<span class="number">1</span>));</span><br><span class="line">			Class clazz = Class.forName(pciName);<span class="comment">//用Class去加载这个pci子类</span></span><br><span class="line">			PCI p = (PCI)clazz.newInstance();<span class="comment">//要有空参构造参数</span></span><br><span class="line">			mb.usePCI(p);</span><br><span class="line">		&#125;</span><br><span class="line">		fis.close();		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置文件</strong></p>
<p>pci1=cn.zc.reflect.test.SoundCard</p>
<p>pci2=cn.zc.reflect.test.NetCard</p>
<p><strong>接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PCI</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>主板</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mainboard</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"main borad run..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">usePCI</span><span class="params">(PCI p)</span> </span>&#123;<span class="comment">//PCI p = new SoundCard();</span></span><br><span class="line">		<span class="keyword">if</span> (p ! = <span class="keyword">null</span>) &#123;</span><br><span class="line">			p.open();</span><br><span class="line">			p.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>正确表达的字符串。</p>
<p>正则表达式用于操作字符串数据。</p>
<p>通过一些特定的符号来体现的。</p>
<p>  所以为了掌握正则表达式，必须要学习一些符号。</p>
<p>  虽然简化了，但是阅读性差。</p>
<h4 id="常见的规则"><a href="#常见的规则" class="headerlink" title="常见的规则"></a>常见的规则</h4><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC28%E5%A4%A92.png" class title="This is an example image">

<p><strong>字符类</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[abc] 字符串某一位必须是a或b或c，只能是三者中一个</span><br><span class="line">[^abc] 任何字符，除了abc</span><br><span class="line">[a-zA-Z]所有大小写字母</span><br><span class="line">[a-d[m-p]] a到b或m到p: [a-dm-p]并集</span><br><span class="line">[a-z&amp;&amp;[def]]d,e或f，交集</span><br><span class="line">[a-z&amp;&amp;[^bc]]a到z，除了b和c:[ad-z]（减去）</span><br><span class="line">[a-z&amp;&amp;[^m-p]]a到z，而非m到p:[a-lq-z]（减去）</span><br></pre></td></tr></table></figure>

<p><strong>预定义字符类</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.  任何字符（与行结束可能匹配也可能不匹配）</span><br><span class="line">\d 数字：[0-9]</span><br><span class="line">\D 非数字：[^0-9]</span><br><span class="line">\s 空白字符：[ \t\n\x0B\f\r]</span><br><span class="line">\S 非空白字符：[^\s]</span><br><span class="line">\w 单词字符：[a-zA-Z_0-9]大小写字母，数字，下划线</span><br><span class="line">\W 非单词字符：[^\w]</span><br></pre></td></tr></table></figure>

<p><strong>边界匹配器</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^  行的开头</span><br><span class="line">$  行的结尾</span><br><span class="line">\b 单词边界，即两个单词中间的位置</span><br><span class="line">\B 非单词边界</span><br><span class="line">\A 输入的开头</span><br><span class="line">\G 上一个匹配的结尾</span><br><span class="line">\Z 输入的结尾，仅用于最后的结束符（如果有的话）</span><br><span class="line">\z 输入的结尾</span><br></pre></td></tr></table></figure>

<p><strong>Greedy数量词</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X? X,一次或一次也没有，至多一次</span><br><span class="line">X* X，零次或多次，有没有都可</span><br><span class="line">X+ X，一次或多次，不能为0次</span><br><span class="line">X&#123;n&#125;  X,恰好n次</span><br><span class="line">X&#123;n,&#125; X，至少n次</span><br><span class="line">X&#123;n,m&#125; X，至少n次，但不会超过m次</span><br></pre></td></tr></table></figure>

<h4 id="常见的功能"><a href="#常见的功能" class="headerlink" title="常见的功能"></a>常见的功能</h4><p>​    Pattern类指定为字符串的正则表达式必须首先被编译为此类的实例（将正则表达式封装成对象）。然后可将得到的模式（正则规则）用于创建Matcher对象（匹配器），依照正则表达式，该对象可以与任意字符序列匹配。执行匹配所涉及的所有状态都驻留在匹配器中，所以多个匹配器可以共享同一模式。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC28%E5%A4%A93.png" class title="This is an example image">

<p>String类中这些关于正则的方法底层调用的是正则对象的方法，不过String类直接使用比较简单点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 正则表达式对字符串的常见操作：</span></span><br><span class="line"><span class="comment">		 * 1，匹配</span></span><br><span class="line"><span class="comment">		 * 		其实使用的是String类中的matches()方法</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 2，切割</span></span><br><span class="line"><span class="comment">		 * 		其实使用的就是String类中的split()方法</span></span><br><span class="line"><span class="comment">		 * 3，替换</span></span><br><span class="line"><span class="comment">		 * 		其实使用的是String类中的replaceAll()方法</span></span><br><span class="line"><span class="comment">		 * 4，获取</span></span><br><span class="line"><span class="comment">		 * 		只能使用正则对象、匹配器对象来完成</span></span><br><span class="line"><span class="comment">		 * 		包名为java.util.regex</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 匹配</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">functionDemo_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//匹配手机号码是否正确</span></span><br><span class="line">		String tel = <span class="string">"158000o1111"</span>;</span><br><span class="line">		<span class="comment">//首个为1，第二位为固定，其他是0-9</span></span><br><span class="line">		String regex = <span class="string">"1[3589]\\d&#123;9&#125;"</span>;</span><br><span class="line">		<span class="keyword">boolean</span> b = tel.matches(regex);</span><br><span class="line">		System.out.println(tel+<span class="string">":"</span>+b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 切割</span></span><br><span class="line"><span class="comment">	 * 组：((A)(B(C)))，按照左括号数组。组1A(B(c))，组2A，组3B(C),组4C</span></span><br><span class="line"><span class="comment">	 * 组零代表整个表达式</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">functionDemo_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//		String str = "zhangsan         xiaoqiang              zhaoliu";</span></span><br><span class="line"><span class="comment">//		String[] names = str.split(" +");//至少出现一次</span></span><br><span class="line"><span class="comment">//		String str = "zhangsan.xiaoqiang.zhaoliu";</span></span><br><span class="line"><span class="comment">//		String[] names = str.split("\\.");//.是特殊符号，需要加上\\.，将其转义	</span></span><br><span class="line">		String str = <span class="string">"zhangsanttttxiaoqiangmmmmmmmmmmzhaoliu"</span>;</span><br><span class="line">		<span class="comment">//使用叠词来切割，因为叠词的第一个为任意，第二个与第一个一样而且不止一个</span></span><br><span class="line">		<span class="comment">//因此将第一个任意的封装为组，第二个使用此组，使用1，转义变成\\1不止一个用+</span></span><br><span class="line">		String[] names = str.split(<span class="string">"(.)\\1+"</span>);<span class="comment">//正则中用小括号封装，组，从1开始，用编号代表组</span></span><br><span class="line">		<span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">			System.out.println(name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 替换</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">functionDemo_3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String str = <span class="string">"zhangsanttttxiaoqiangmmmmmmmmmmzhaoliu"</span>;</span><br><span class="line">		<span class="comment">//第二个中要使用第一个正则表达式中的内容，使用$加组号</span></span><br><span class="line">		str = str.replaceAll(<span class="string">"(.)\\1+"</span>, <span class="string">"$1"</span>);</span><br><span class="line">		System.out.println(str);</span><br><span class="line">		String tel = <span class="string">"15800001111"</span>;<span class="comment">//158****1111</span></span><br><span class="line">		<span class="comment">//将前三位和后四位进行分组，然后这两个组不变，中间的4位变成****</span></span><br><span class="line">		tel = tel.replaceAll(<span class="string">"(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)"</span>, <span class="string">"$1****$2"</span>);<span class="comment">//将不匹配的替换掉</span></span><br><span class="line">		System.out.println(tel);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 获取</span></span><br><span class="line"><span class="comment">	 * 1，将正则规则进行对象的封装</span></span><br><span class="line"><span class="comment">	 * Pattern p = Pattern.compile("a*b");//规则，a没有或多次+b</span></span><br><span class="line"><span class="comment">	 * 2，通过正则对象的matcher方法与字符串关联。获取要对字符串操作的匹配器对象Matcher。</span></span><br><span class="line"><span class="comment">	 * Matcher m = p.matcher("aaaaab");</span></span><br><span class="line"><span class="comment">	 * 3，通过Matcher匹配器对象的方法对字符串进行操作。</span></span><br><span class="line"><span class="comment">	 * boolean b = m.matches();</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">functionDemo_4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String str = <span class="string">"daa jia hao,ming tian bu fang jia!"</span>;</span><br><span class="line">		String regex = <span class="string">"\\b[a-z]&#123;3&#125;\\b"</span>;<span class="comment">//单词前后需要要有单词边界</span></span><br><span class="line">		<span class="comment">//1，将正则封装成对象</span></span><br><span class="line">		Pattern p = Pattern.compile(regex);</span><br><span class="line">		<span class="comment">//2，通过正则对象获取匹配器对象</span></span><br><span class="line">		Matcher m = p.matcher(str);<span class="comment">//将字符串关联</span></span><br><span class="line">		<span class="comment">//3，使用Matcher对象的方法对字符串进行操作</span></span><br><span class="line">		<span class="comment">//既然要获取三个字母组成的单词</span></span><br><span class="line">		<span class="comment">//查找。find()</span></span><br><span class="line">		System.out.println(str);</span><br><span class="line">		<span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">			<span class="comment">//先找再获取</span></span><br><span class="line">			System.out.println(m.group());<span class="comment">//获取匹配的子序列</span></span><br><span class="line">			System.out.println(m.start()+<span class="string">":"</span>+m.end());<span class="comment">//可以拿到indexOf，即位置</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相关题目整理"><a href="#相关题目整理" class="headerlink" title="相关题目整理"></a>相关题目整理</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="a-与-a区别"><a href="#a-与-a区别" class="headerlink" title="a++与++a区别"></a>a++与++a区别</h3><p>a=3 b = a++ 和b = ++a</p>
<p>若是单个语句，则没有太大区别，若是在运算当中，则</p>
<p>a++，先将a的值用temp存储，然后进行a = a+1，然后存下原来的temp，及若b = a++,</p>
<p>b = 3，a =4；若b = ++a，则b = 4,a = 4</p>
<p>若为i = 3,i = i++，则i= 3，因为存储的是temp的值，+=，-=，*=，/=.为左=左加右，左=左减右，以此类推</p>
<h3 id="short-s-4-，s-4与s-s-4的区别"><a href="#short-s-4-，s-4与s-s-4的区别" class="headerlink" title="short s = 4 ，s += 4与s = s + 4的区别"></a>short s = 4 ，s += 4与s = s + 4的区别</h3><p>s += 4为赋值运算，在底层做了自动的强制转换，编译成功，s = s + 4没有自动转换，精度损失，编译不会通过</p>
<h3 id="两个数互换位置，不使用第三个数"><a href="#两个数互换位置，不使用第三个数" class="headerlink" title="两个数互换位置，不使用第三个数"></a>两个数互换位置，不使用第三个数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = a ^ b  </span><br><span class="line">b = a ^ b  </span><br><span class="line">a = a ^ b</span><br></pre></td></tr></table></figure>

<h3 id="用三元运算符取两个整数中大的"><a href="#用三元运算符取两个整数中大的" class="headerlink" title="用三元运算符取两个整数中大的"></a>用三元运算符取两个整数中大的</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x,y</span><br><span class="line"><span class="keyword">int</span> max = x&gt;y?x:y;</span><br></pre></td></tr></table></figure>

<h3 id="if-与-switch的比较"><a href="#if-与-switch的比较" class="headerlink" title="if 与 switch的比较"></a>if 与 switch的比较</h3><p>if :</p>
<ol>
<li><p>对具体的值进行判断。</p>
</li>
<li><p>对区间判断。</p>
</li>
<li><p>对运算结果是boolean类型的表达式进行判断。</p>
</li>
</ol>
<p>switch</p>
<ol>
<li><p>对具体的值进行判断</p>
</li>
<li><p>值的个数是固定的。</p>
</li>
</ol>
<p>对于几个固定的值判断，建议使用switch进行判断，因为switch语句将具体的答案加载进内存，<strong>效率相对较高</strong></p>
<h3 id="while和for循环区别"><a href="#while和for循环区别" class="headerlink" title="while和for循环区别"></a>while和for循环区别</h3><p>for循环结束后，控制循环变量被释放，无法被再次利用，而while中的变量可以。如果不使用此变量，用for较好，节省内存空间；若要用到变量，则用while较好。</p>
<h3 id="直接打印数组名"><a href="#直接打印数组名" class="headerlink" title="直接打印数组名"></a>直接打印数组名</h3><p>直接打印数组名出来的符号什么意思，如[I@c17164</p>
<p>@分隔符，右边c17164是在当前操作系统下计算出的数组地址，如windows下用哈希算法计算出来的地址位置，左边[表示数组，I表示Int类型</p>
<h3 id="数组异常"><a href="#数组异常" class="headerlink" title="数组异常"></a>数组异常</h3><p>使用数组带来的问题</p>
<p>1、 当访问到数组中不存在的角标，会出现ArrayIndexOutOfBoundsException</p>
<p>2、 当引用型变量没有任何实体指向时，还在用其操作，会出现NullPointerException</p>
<hr>
<h3 id="面对对象-1"><a href="#面对对象-1" class="headerlink" title="面对对象"></a>面对对象</h3><p>如何理解面对对象</p>
<p>（1）   符合现在人们思维的习惯（2）使复杂的事情变得简单化（3）让我们从程序的执行者变成指挥者。面向对象的三个特征：封装，继承，多态</p>
<h3 id="类与对象之间的关系"><a href="#类与对象之间的关系" class="headerlink" title="类与对象之间的关系"></a>类与对象之间的关系</h3><p>类：事物的描述</p>
<p>对象：该类事物的实例，在java中通过new来创建</p>
<h3 id="构造函数与一般函数区别"><a href="#构造函数与一般函数区别" class="headerlink" title="构造函数与一般函数区别"></a>构造函数与一般函数区别</h3><p>构造函数对象创建时就会调用与之对应的构造函数对对象进行初始化，而一般函数对象创建后需要该函数功能时才调用；构造函数对象创建时，会调用只调用一次；一般函数对象创建后可以被调用多次。</p>
<h3 id="什么时候定义构造函数"><a href="#什么时候定义构造函数" class="headerlink" title="什么时候定义构造函数"></a>什么时候定义构造函数</h3><p>在描述事物时，该事物一存在就已具备的一些内容，这些内容定义在构造函数中。可以以重载形式进行运行，定义不同的构造函数</p>
<h3 id="若有静态代码块、构造代码块、构造函数，三个执行顺序"><a href="#若有静态代码块、构造代码块、构造函数，三个执行顺序" class="headerlink" title="若有静态代码块、构造代码块、构造函数，三个执行顺序"></a>若有静态代码块、构造代码块、构造函数，三个执行顺序</h3><p>静态代码块随着类的加载而执行，最先执行。如果有对象，构造代码块执行，然后构造函数执行。如果有继承，先运行父类构造函数。</p>
<h3 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h3><ol>
<li>抽象类中有构造函数吗？</li>
</ol>
<p>有，用于给子类对象进行初始化</p>
<ol start="2">
<li>抽象类可以不定义抽象方法吗？</li>
</ol>
<p>可以，但是很少见，目的是不让该类创建对象。AWT的适配器对象就是这种类</p>
<p>通常这个类中的方法有方法体，但是却没有内容</p>
<ol start="3">
<li>抽象关键字不可以和哪些关键字共存？</li>
</ol>
<p>private不行，抽象类需要被子类覆盖 ; static不行，抽象类本身不需创建对象</p>
<p>final 不行，抽象类需要被子类覆盖</p>
<ol start="4">
<li>抽象类和一般类的异同点</li>
</ol>
<p>相同点：抽象类和一般类都是用来描述事物的，都在内部定义了成员。</p>
<p>不同点：</p>
<ul>
<li><p>一般类有足够的信息描述事物。抽象类描述事物的信息有可能不足。</p>
</li>
<li><p>一般类中不能定义抽象方法，只能定义非抽象方法。抽象类中可以定义抽象方法，同时也可以定义非抽象方法。</p>
</li>
<li><p>一般类可以被实例化。抽象类不可以被实例化。</p>
</li>
</ul>
<ol start="5">
<li><p>抽象类一定是父类吗？</p>
<p>是的，需要子类覆盖方法后才可以对子类实例化。</p>
</li>
</ol>
<h3 id="this关键字含义，final特点"><a href="#this关键字含义，final特点" class="headerlink" title="this关键字含义，final特点"></a>this关键字含义，final特点</h3><p>this关键字：调用本类属性，调用本类方法，使用本类构造器，本类对象的引用</p>
<p>final：final是一个修饰符，可以修饰类，方法，变量；final修饰的类不可以被继承；final修饰的方法不可以被覆盖；final修饰的变量是一个常量，只能赋值一次变量命名与函数一样，常量所有字母都大写</p>
<h3 id="main输出1"><a href="#main输出1" class="headerlink" title="main输出1"></a>main输出1</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%801.png" class title="This is an example image">

<p>如果用单|，要判断左边跟右边，这时候j=0+4，但是如果是||，左边满足，那么右边直接被屏蔽，那么j仍然等于4。输出4.</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String比较"><a href="#String比较" class="headerlink" title="String比较"></a>String比较</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stringDemo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		String s = <span class="string">"abc"</span>;</span><br><span class="line">		<span class="comment">//s = "nba";</span></span><br><span class="line">		String s1 = <span class="string">"abc"</span>;</span><br><span class="line">		System.out.println(s==s1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stringDemo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String s = <span class="string">"abc"</span>;</span><br><span class="line">		String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">		System.out.println(s==s1);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>​    第一个为真，第二个为假。第一种创建String方式为在常量池中创建对象，可以共享，而new在堆内存中进行创建。</p>
<p>​    如果要比较对象的内容，用equals()，而String类将Object中的比较方法进行覆写，普通的equals()比较地址，而字符串比较内容。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/String1.png" class title="This is an example image">

<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/String2.png" class title="This is an example image">

<p>结果一个为5，一个为41，原因下面将4变成了4字符串。第三种方式也可以实现输出41，更简洁。</p>
<h3 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h3><p>{“nba”,abc”,”cba”,”zz”,”qq”,”haha”}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">思路：</span><br><span class="line"><span class="number">1</span>、对数组排序。可以用选择，冒泡都行。</span><br><span class="line"><span class="number">2</span>、<span class="keyword">for</span>嵌套和比较，以及换位</span><br><span class="line"><span class="number">3</span>、问题：以前排的是整数，比较用的是比较运算符，现在是字符串对象</span><br><span class="line">	  字符串对象比较，对象中提供了用于字符串对象比较的功能。</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest_1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String[] arr = &#123; <span class="string">"nba"</span>, <span class="string">"abc"</span>, <span class="string">"cba"</span>, <span class="string">"zz"</span>, <span class="string">"qq"</span>, <span class="string">"haha"</span> &#125;;</span><br><span class="line">		print(arr);</span><br><span class="line">		System.out.println();</span><br><span class="line">		sortString(arr);</span><br><span class="line">		print(arr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			System.out.print(arr[i] + <span class="string">"\t"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String[] sortString(String[] arr) &#123;</span><br><span class="line">		String s;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (arr[i].compareTo(arr[j]) &gt; <span class="number">0</span>) &#123;<span class="comment">//字符串比较用compareTo()方法</span></span><br><span class="line">					swap(arr,i,j);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(String[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		String temp = arr[j];</span><br><span class="line">		arr[j] = arr[i];</span><br><span class="line">		arr[i] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一个子串在整串中出现的次数"><a href="#一个子串在整串中出现的次数" class="headerlink" title="一个子串在整串中出现的次数"></a>一个子串在整串中出现的次数</h3><p>“nbaernbatynbauinbaopnba”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">思路：</span><br><span class="line"><span class="number">1</span>、要找的子串是否存在，如果存在，获取其出现的位置，可以使用indexOf()完成</span><br><span class="line"><span class="number">2</span>、如果找到了，那么记录出现的位置并在剩余的字符串中继续查找该子串，剩余字符串的</span><br><span class="line">起始位是出现位置+子串长度</span><br><span class="line"><span class="number">3</span>、以此类推，通过循环完成查找，如果找不到就是-<span class="number">1</span>，并对每次找到用计数器记录</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest_2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String str = <span class="string">"nbaernbatnbaynbauinbaopnba"</span>;</span><br><span class="line">		String key = <span class="string">"nba"</span>;</span><br><span class="line">		<span class="keyword">int</span> count = getKeyStringCount_2(str,key);</span><br><span class="line">		System.out.println(<span class="string">"count="</span>+count);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getKeyStringCount_2</span><span class="params">(String str, String key)</span> </span>&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 思路：</span></span><br><span class="line"><span class="comment">		 * 不新增字符串，而是改变每次查找的位置，其中起始位为上一次找到的位置加上key的长度</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((index=str.indexOf(key, index))!=-<span class="number">1</span>)&#123;</span><br><span class="line">			index += key.length();</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取子串在整串中出现的次数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getKeyStringCount</span><span class="params">(String str, String key)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//1、定义计数器</span></span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//2、定义变量，记录key出现的位置</span></span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((index = str.indexOf(key))!=-<span class="number">1</span>)&#123;</span><br><span class="line">			str = str.substring(index+key.length());</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两个字符串中最大相同的子串"><a href="#两个字符串中最大相同的子串" class="headerlink" title="两个字符串中最大相同的子串"></a>两个字符串中最大相同的子串</h3><p>“qwerabcdtyuiop”</p>
<p>“xcabcdvbn”</p>
<h2 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h2><h3 id="什么时候定义继承"><a href="#什么时候定义继承" class="headerlink" title="什么时候定义继承"></a>什么时候定义继承</h3><p>当类与类之间存在着所属关系的时候，就定义继承。xxx是yyy的一种，xxx extends yyy</p>
<p>继承就是不断向上抽离的过程，如果A和B部分功能相同，可以将相同功能进行抽离，变成父类。</p>
<h3 id="子类实例化访问父类构造函数原因"><a href="#子类实例化访问父类构造函数原因" class="headerlink" title="子类实例化访问父类构造函数原因"></a>子类实例化访问父类构造函数原因</h3><p>子类继承了父类，获取到了父类中的内容（属性），所以在使用父类内容之前要先看父类是如何对自己的内容进行初始化的，所以子类在构造对象时必须访问父类的构造函数。为了完成这个必须的动作，就在子类的构造函数函数中加入了super();语句.如果父类中没有定义空参数构造函数.那么子类的构造函数必须用super明确要调用父类中哪个构造函数同时子类构造函数中如果使用this()调用了本类构造函数时，super就没有了，因为this和super都只能定义在第一行，所以只能有一个。但是可以保证的是，子类中肯定会有其他的构造函数访问父类的构造函数。</p>
<h3 id="main输出题目1"><a href="#main输出题目1" class="headerlink" title="main输出题目1"></a>main输出题目1</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%A7%E6%89%BF1.png" class title="This is an example image">

<p>A 可以，因为覆盖了 </p>
<p>B不可以，权限不够 </p>
<p>C可以，子类特有方法</p>
<p>D 不可以，调用的不确定项 </p>
<p>E不可以，静态只能覆盖静态</p>
<h2 id="多态-1"><a href="#多态-1" class="headerlink" title="多态"></a>多态</h2><h3 id="main输出题目1-1"><a href="#main输出题目1-1" class="headerlink" title="main输出题目1"></a>main输出题目1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> 讲课()&#123;</span><br><span class="line">        System.out.println(“讲课”);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">void</span> 钓鱼()&#123;</span><br><span class="line">        System.out.println(“钓鱼”);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> 讲课()&#123;</span><br><span class="line">        System.out.println(“Java”);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">void</span> 看电影()&#123;</span><br><span class="line">        System.out.println(“看电影”);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line">main函数中</span><br><span class="line">	Fu a = <span class="keyword">new</span> Zi();</span><br><span class="line">a.讲课()；<span class="comment">//所输出为Java，因为在子类中对父类进行了覆盖</span></span><br><span class="line">a.钓鱼(); <span class="comment">//所输出为钓鱼，因为在子类中对父类进行了继承</span></span><br><span class="line">a.看电影():<span class="comment">//不能调用，需要进行向下转型</span></span><br><span class="line">Zi b = (Zi)a；</span><br><span class="line">b.看电影();<span class="comment">//所输出为看电影</span></span><br></pre></td></tr></table></figure>

<h3 id="main输出题目2"><a href="#main输出题目2" class="headerlink" title="main输出题目2"></a>main输出题目2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">	print(“Fu”);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        print(Fu method)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">4</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">	print(“Zi”);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        print(Zi method)&#125;</span><br><span class="line">&#125;</span><br><span class="line">main函数中</span><br><span class="line">	Fu f = <span class="keyword">new</span> Zi();	</span><br><span class="line">	输出f.num</span><br><span class="line">	f.show()</span><br><span class="line">	f.method()</span><br><span class="line">	结果为<span class="number">3</span>，Zi，Fu method</span><br></pre></td></tr></table></figure>

<h3 id="main输出题目3"><a href="#main输出题目3" class="headerlink" title="main输出题目3"></a>main输出题目3</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%80%813.png" class title="This is an example image">

<p>结果为A B</p>
<p>​    因为f.show()调用父类方法，被子类覆盖，输出A，然后进行for循环判断，输出B，返回false，因为为双与，因此直接短路，循环结束。所以总输出结果为A B。</p>
<h3 id="main输出题目4"><a href="#main输出题目4" class="headerlink" title="main输出题目4"></a>main输出题目4</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%80%814.png" class title="This is an example image">

<p>输出B C 7。使用多态，在子类的构造函数中第一行为super()，因此输出B，此时i=0，然后i+2=2，然后输出C，i+5=7。因此最后结果为B C 7。</p>
<h3 id="main输出题目5"><a href="#main输出题目5" class="headerlink" title="main输出题目5"></a>main输出题目5</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%80%815.png" class title="This is an example image">

<p>输出：4 5 showZi showZi</p>
<h3 id="main输出题目6"><a href="#main输出题目6" class="headerlink" title="main输出题目6"></a>main输出题目6</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%80%816.png" class title="This is an example image">

<p>执行子类构造函数，默认第一行为super()，因为父类中没有空参的构造函数，只有有参的构造函数，因此super()不能被执行，编译失败。</p>
<h3 id="main输出题目7"><a href="#main输出题目7" class="headerlink" title="main输出题目7"></a>main输出题目7</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%80%817.png" class title="This is an example image">

<p>因为父类中方法与此类不一样，覆盖失败，编译报错。调用的不确定性。</p>
<h3 id="多态时成员的特点-1"><a href="#多态时成员的特点-1" class="headerlink" title="多态时成员的特点"></a>多态时成员的特点</h3><p>1.成员变量</p>
<p>编译时：参考引用型变量所属的类中是否有调用的成员变量，有，编译通过；没有，编译失败。</p>
<p>运行时：参考引用型变量所属的类中是否有调用的成员变量，并运行所属类中的成员变量</p>
<p>简单说：<strong>编译和运行都参考等号的左边</strong></p>
<p>2.成员函数（<strong>非静态</strong>，<strong>重点</strong>）</p>
<p>编译时：参考引用型变量所属的类中是否有调用的函数，有，编译通过；没有，编译失败。</p>
<p>运行时：参考的是对象所属的类中是否有调用的函数</p>
<p>简单说：<strong>编译看左边，运行看右边</strong></p>
<p>3.静态函数</p>
<p>编译时：参考引用型变量所属的类中是否有调用的静态方法</p>
<p>运行时：参考引用型变量所属的类中是否有调用的静态方法</p>
<p>简单说：<strong>编译和运行都参考等号的左边</strong></p>
<p>​    其实静态方法是不需要对象的，直接类名调用即可</p>
<h2 id="内部类-1"><a href="#内部类-1" class="headerlink" title="内部类"></a>内部类</h2><h3 id="内部类可以直接访问外部类中成员的原因"><a href="#内部类可以直接访问外部类中成员的原因" class="headerlink" title="内部类可以直接访问外部类中成员的原因"></a>内部类可以直接访问外部类中成员的原因</h3><p>内部类持有外部类的引用，外部类名.this</p>
<p>​    从内部类在局部位置上只能访问局部中被final修饰的局部变量</p>
<h3 id="main输出1-1"><a href="#main输出1-1" class="headerlink" title="main输出1"></a>main输出1</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%85%E9%83%A8%E7%B1%BB1.png" class title="This is an example image">

<p>在主函数中，若直接new Inner()对象会失败，因为<strong>静态方法中不允许有非静态成员</strong>，相当于this.new Inner()，而static中不允许出现this，此时需要将class Inner修改成 static class Inner</p>
<h3 id="main输出2"><a href="#main输出2" class="headerlink" title="main输出2"></a>main输出2</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%85%E9%83%A8%E7%B1%BB2.png" class title="This is an example image">

<p>new Object(){}相当于创立了子类对象，而Object obj=子类对象，匿名内部类这个子类对象被向上转型（多态）为Object类型，隐藏了子类特有属性，这样就不能使用子类特有的方法。编译看左边，Object类中无show方法，因此会编译失败</p>
<h3 id="main输出3"><a href="#main输出3" class="headerlink" title="main输出3"></a>main输出3</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%85%E9%83%A8%E7%B1%BB3.png" class title="This is an example image">

<p>编译失败，因为内部类中如果定义了静态成员，该内部类必须被静态修饰，或者该成员变量被final修饰。因为内部类相当于外部类的成员，必须在外部类的对象创建以后进行，java虚拟机要求所有的静态变量要在对象创建之前完成，因为如果非静态内部类中有静态变量，就要先加载非静态方法，再加载静态成员，与JVM矛盾。</p>
<p>​    但是可以在非静态内部类中定义静态常量（静态常量一定要有一个编译期常量），如果变量被static final修饰，字面常量会在编译阶段确定，称为编译期常量，不需要加载类的字节码文件，即编译期常量不会导致类加载，因此静态常量在非静态内部类中是合法的。（编译期常量折叠：编译期在编译阶段通过语法分析计算出常量表达式的具体值）。但是如果将y改成Math.randm()，会报错，因为这个需要运行确定。</p>
<p>​    总结：<strong>非静态内部类中不能拥有静态成员变量/方法，但是可以有静态的编译期常量，不能使用非编译期常量</strong>。</p>
<h3 id="main输出4"><a href="#main输出4" class="headerlink" title="main输出4"></a>main输出4</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%85%E9%83%A8%E7%B1%BB4.png" class title="This is an example image">

<p>A正确，在外部类访问内部类，必须要建立内部类的对象。</p>
<p>B 错误，因为主函数是静态方法，只能调用静态成员，所以内部类必须是静态的。</p>
<p>C错误，格式错误，应该是new Demo().new Inner();</p>
<p>D 格式正确，但是要求内部类是静态的。</p>
<h3 id="main输出5"><a href="#main输出5" class="headerlink" title="main输出5"></a>main输出5</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%85%E9%83%A8%E7%B1%BB5.png" class title="This is an example image">

<p>调用show()方法，不能直接show()，因为是非静态的，需要对象调用,new Demo().show();</p>
<p>然后传一个匿名对象进去，实现func()方法。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%85%E9%83%A8%E7%B1%BB5-2.png" class title="This is an example image">

<h2 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h2><h3 id="main输出1-2"><a href="#main输出1-2" class="headerlink" title="main输出1"></a>main输出1</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A31.png" class title="This is an example image">

<p>编译失败，因为编译看左边，运行看右边，而因为接口A中没有func方法，所以编译会报错。a所属的A接口中没有func()方法。</p>
<h3 id="main输出2-1"><a href="#main输出2-1" class="headerlink" title="main输出2"></a>main输出2</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A32.png" class title="This is an example image">

<p>编译失败，A a = get()；相当于A a = new B()；相当于把B对象封装，因为A中没有test()方法，因此编译报错。</p>
<h2 id="异常-1"><a href="#异常-1" class="headerlink" title="异常"></a>异常</h2><h3 id="main输出1-3"><a href="#main输出1-3" class="headerlink" title="main输出1"></a>main输出1</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BC%82%E5%B8%B81.png" class title="This is an example image">

<p>找main函数入口，执行show()方法,此方法进栈，抛出异常被catch，因此进入catch，输出B，finally一定会被执行，输出C，问题被解决了，输出D。因此结果为B C D。</p>
<h3 id="main输出2-2"><a href="#main输出2-2" class="headerlink" title="main输出2"></a>main输出2</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BC%82%E5%B8%B82.png" class title="This is an example image">

<p>throw异常下面的语句无法被执行，因为抛出异常就进入catch捕获异常。因此输出A是句废话，编译失败。与main输出1不一样，main输出1<strong>将异常封装</strong>，方法下面的语句还有可能被执行到。</p>
<p>throw 语句下面不要加其他语句，必然要跳转！！！</p>
<h3 id="main输出3-1"><a href="#main输出3-1" class="headerlink" title="main输出3"></a>main输出3</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BC%82%E5%B8%B83.png" class title="This is an example image">

<p>多catch时，父类的catch放在最下面，因此编译会失败。</p>
<h3 id="main输出4-1"><a href="#main输出4-1" class="headerlink" title="main输出4"></a>main输出4</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BC%82%E5%B8%B84.png" class title="This is an example image">

<p>134</p>
<p>13423</p>
<p>​    原因：foo(0)，不等于1，Output=1，然后执行finally，output=13，正常结束，output=134，然后输出134；执行foo(1)，一次是满足条件，丢出异常，output=1342（因为Output为静态变量，一直存在，因此始终操作的是同一变量），然后执行return，但是因为finally一定被执行（除非退出jvm），因此output=13423</p>
<h2 id="多线程-1"><a href="#多线程-1" class="headerlink" title="多线程"></a>多线程</h2><h3 id="实现死锁"><a href="#实现死锁" class="headerlink" title="实现死锁"></a>实现死锁</h3><p>死锁的代码：利用同步的嵌套</p>
<p>run方法中封装线程任务，设置两个同步的嵌套，一个为同步锁a,b；另一个为同步锁b,a；然后设定同步锁对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> flag;</span><br><span class="line">	<span class="comment">//设置构造函数，可以直接初始化参数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.flag = flag;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//设置同步的嵌套</span></span><br><span class="line">		<span class="keyword">if</span>(flag)&#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">				<span class="keyword">synchronized</span>(MyLock.obja)&#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName()+<span class="string">"if的obja"</span>);</span><br><span class="line">						<span class="keyword">synchronized</span>(MyLock.objb)&#123;</span><br><span class="line">							System.out.println(Thread.currentThread().getName()+<span class="string">"if的objb"</span>);</span><br><span class="line">					&#125;	</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">				<span class="keyword">synchronized</span>(MyLock.objb)&#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName()+<span class="string">"else的objb"</span>);</span><br><span class="line">						<span class="keyword">synchronized</span>(MyLock.obja)&#123;</span><br><span class="line">							System.out.println(Thread.currentThread().getName()+<span class="string">"else的obja"</span>);</span><br><span class="line">					&#125;	</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设立同步锁对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object obja = <span class="keyword">new</span> Object();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object objb = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Test a = <span class="keyword">new</span> Test(<span class="keyword">true</span>);</span><br><span class="line">		Test b = <span class="keyword">new</span> Test(<span class="keyword">false</span>);</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(a);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(b);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试题1"><a href="#面试题1" class="headerlink" title="面试题1"></a>面试题1</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B1.png" class title="This is an example image">

<p>错误在第一行，此run()方法为子类特有方法，Test实现了Runnable接口，但是没有覆盖Run()方法，应该被abstract修饰</p>
<h3 id="面试题2"><a href="#面试题2" class="headerlink" title="面试题2"></a>面试题2</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B2.png" class title="This is an example image">

<p>​    判断Thread自身run()和runnable的run方法优先级，应该输出subThread run。</p>
<p>​    Thread实现了自己的run方法，因此直接执行下边的run()方法，只有在下边的run()未实现时，才会寻找到上边的Runnable的run方法，并执行，这就是优先级顺序。</p>
<p>​    因为应该以<strong>子类的任务</strong>为主(new Thread中的run方法)，如果子类没有覆写run方法，那么则以<strong>任务对象</strong>为主，如果没有任务对象，则以<strong>Thread</strong>原有run方法为主</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux使用</title>
    <url>/2020/01/14/Linux%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Linux视频学习笔记"><a href="#Linux视频学习笔记" class="headerlink" title="Linux视频学习笔记"></a>Linux视频学习笔记</h2><blockquote>
<p><a href="https://www.bilibili.com/video/av21303002?p=1" target="_blank" rel="noopener">尚硅谷韩顺平老师视频讲解</a>笔记</p>
<p><a href="https://github.com/Sunxz007/Linux-note-follow-Hanshunping" target="_blank" rel="noopener">Sunxz007Github</a>笔记</p>
</blockquote>
<p>课程内容如下图所示</p>
<img src="/2020/01/14/Linux%E4%BD%BF%E7%94%A8/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9.png" class title="This is an example image">

<a id="more"></a>



<h2 id="Linux下安装jdk8"><a href="#Linux下安装jdk8" class="headerlink" title="Linux下安装jdk8"></a>Linux下安装jdk8</h2><h3 id="卸载Linux自带OpenJDK"><a href="#卸载Linux自带OpenJDK" class="headerlink" title="卸载Linux自带OpenJDK"></a>卸载Linux自带OpenJDK</h3><p>切换到root权限</p>
<blockquote>
<p>su root</p>
</blockquote>
<p> 使用java -version看OpenJDK信息，然后查询系统自带java相关文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep java</span><br></pre></td></tr></table></figure>

<p>命令说明：</p>
<p>rpm 　管理套件</p>
<p>-qa 　使用询问模式，查询所有套件</p>
<p>grep　　查找文件里符合条件的字符串</p>
<p>java 　查找包含java字符串的文件</p>
<p> 除noarch外，删除其他java文件</p>
<blockquote>
<p>rpm -e –nodeps java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64</p>
</blockquote>
<p>命令介绍</p>
<p>rpm 　　　管理套件</p>
<p>-e　　　　　删除指定的套件</p>
<p>–nodeps　　不验证套件档的相互关联性</p>
<p> 当输入java -version，没有找到命令，代表删除成功。</p>
<hr>
<h3 id="下载JDK"><a href="#下载JDK" class="headerlink" title="下载JDK"></a>下载JDK</h3><p>历史版本下载地址：　　<a href="http://www.oracle.com/technetwork/java/javase/archive-139210.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/archive-139210.html</a></p>
<p> 通过浏览器下载会默认下载到当前登陆用户的下载目录，下载位置为“当前用户/下载/jdk-8u211-linux-x64.tar.gz”。</p>
<p> cd 下载，然后使用</p>
<blockquote>
<p>ls -al 展示本目录下所有文件</p>
</blockquote>
<p> 为了查看当前目录路径，可以使用</p>
<blockquote>
<p>pwd 查看当前目录路径</p>
</blockquote>
<hr>
<h3 id="复制JDK"><a href="#复制JDK" class="headerlink" title="复制JDK"></a>复制JDK</h3><h4 id="备份JDK"><a href="#备份JDK" class="headerlink" title="备份JDK"></a>备份JDK</h4><p> 将压缩包复制一份到/usr/local/src/作备份，输入命令</p>
<blockquote>
<p>cp jdk-8u211-linux-x64.tar.gz /usr/local/src</p>
</blockquote>
<p>命令说明：</p>
<p>cp　　　　　　　　　　　　　　 复制文件或目录</p>
<p>jdk-8u211-linux-x64.tar.gz　　　　文件名</p>
<p>/user/local/src　　　　　　　　　 要复制的目标目录</p>
<h4 id="创建java文件夹"><a href="#创建java文件夹" class="headerlink" title="创建java文件夹"></a>创建java文件夹</h4><p> 在usr目录下创建一个文件夹，名为java</p>
<blockquote>
<p>mkdir java</p>
</blockquote>
<p> 然后将文件拷贝至/usr/java</p>
<blockquote>
<p>cp jdk-8u211-linux-x64.tar.gz /usr/java</p>
</blockquote>
<hr>
<h3 id="解压缩JDK"><a href="#解压缩JDK" class="headerlink" title="解压缩JDK"></a>解压缩JDK</h3><h4 id="在java目录下解压JDK压缩文件"><a href="#在java目录下解压JDK压缩文件" class="headerlink" title="在java目录下解压JDK压缩文件"></a>在java目录下解压JDK压缩文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-8u144-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>

<p>命令介绍：</p>
<p>tar　　　　　　备份文件</p>
<p>-zxvf　　　　　</p>
<p>-z　　　　　　 　　　　　　　 通过gzip指令处理备份文件</p>
<p>-x　　　　　　　　　　　　　　 从备份文件中还原文件</p>
<p>-v　　　　　　　　　　　　　　 显示指令执行过程</p>
<p>-f　　　　　　 　　　　　　　　 指定备份文件</p>
<p>jdk-8u211-linux-x64.tar.gz　　　　文件名</p>
<h4 id="删除JDK压缩包"><a href="#删除JDK压缩包" class="headerlink" title="删除JDK压缩包"></a>删除JDK压缩包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -f jdk-8u211-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>

<p>命令解释：</p>
<p>rm　　　　删除文件或目录</p>
<p>-f　　　　 强制删除文件或目录</p>
<hr>
<h3 id="配置JDK环境变量"><a href="#配置JDK环境变量" class="headerlink" title="配置JDK环境变量"></a>配置JDK环境变量</h3><h4 id="编辑全局变量"><a href="#编辑全局变量" class="headerlink" title="编辑全局变量"></a>编辑全局变量</h4><p>命令行键入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<p>命令说明：</p>
<p>vim　　　　　　文本编辑</p>
<p>/etc/profile　　　全局变量文件</p>
<p>进入文本编辑状态下，光标走到文件最后一行，键盘按下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i</span><br></pre></td></tr></table></figure>

<p> 进入插入状态：</p>
<p>在文本的最后一行粘贴如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i</span><br></pre></td></tr></table></figure>

<p>注意JAVA_HOME=/usr/java/jdk1.8.0_211 为你自己的目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#java environment</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_211</span><br><span class="line">export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;jre&#x2F;lib&#x2F;rt.jar:$&#123;JAVA_HOME&#125;&#x2F;lib&#x2F;dt.jar:$&#123;JAVA_HOME&#125;&#x2F;lib&#x2F;tools.jar</span><br><span class="line">export PATH&#x3D;$PATH:$&#123;JAVA_HOME&#125;&#x2F;bin</span><br></pre></td></tr></table></figure>

<p>【注】：CentOS6上面的是JAVAHOME，CentOS7是{JAVA_HOME}</p>
<p> 复制完成后，在键盘敲下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ESC</span><br><span class="line">shift+q</span><br></pre></td></tr></table></figure>

<p> 进入EX模式，敲下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x</span><br></pre></td></tr></table></figure>

<p> 保存并退出。</p>
<hr>
<h3 id="检验环境变量是否生效"><a href="#检验环境变量是否生效" class="headerlink" title="检验环境变量是否生效"></a>检验环境变量是否生效</h3><h4 id="让刚刚设置的环境变量生效"><a href="#让刚刚设置的环境变量生效" class="headerlink" title="让刚刚设置的环境变量生效"></a>让刚刚设置的环境变量生效</h4><p>键入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<p>source /etc/profile或 . /etc/profile</p>
<h4 id="检查是否配置成功"><a href="#检查是否配置成功" class="headerlink" title="检查是否配置成功"></a>检查是否配置成功</h4><p>键入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>pwd 查看当前目录路径</li>
<li>ls -al 展示本目录下所有文件</li>
</ul>
<h3 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h3><ul>
<li>mkdir dir 创建文件夹</li>
</ul>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul>
<li>cp 复制文件</li>
</ul>
<p>cp　　　　　　　　　　　　　　 复制文件或目录</p>
<p>jdk-8u211-linux-x64.tar.gz　　　　完整文件名</p>
<p>/user/local/src　　　　　　　　　 要复制的目标目录</p>
<ul>
<li>rm 删除文件</li>
</ul>
<p>rm　　　　删除文件或目录</p>
<p>-f　　　　 强制删除文件或目录</p>
<ul>
<li>tar 备份，解压缩文件</li>
</ul>
<p>tar　　　　　　备份文件</p>
<p>-zxvf　　　　　</p>
<p>-z　　　　　　 　　　　　　　 通过gzip指令处理备份文件</p>
<p>-x　　　　　　　　　　　　　　 从备份文件中还原文件</p>
<p>-v　　　　　　　　　　　　　　 显示指令执行过程</p>
<p>-f　　　　　　 　　　　　　　　 指定备份文件</p>
<p>jdk-8u211-linux-x64.tar.gz　　　　文件名</p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><h4 id="编辑全局变量-1"><a href="#编辑全局变量-1" class="headerlink" title="编辑全局变量"></a>编辑全局变量</h4><p>vim /etc/profile</p>
<p>i 插入</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown使用</title>
    <url>/2019/12/29/markdown%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="markdown在hexo中使用"><a href="#markdown在hexo中使用" class="headerlink" title="markdown在hexo中使用"></a>markdown在hexo中使用</h1><h2 id="markdown工具"><a href="#markdown工具" class="headerlink" title="markdown工具"></a>markdown工具</h2><h3 id="个人使用工具：Typora"><a href="#个人使用工具：Typora" class="headerlink" title="个人使用工具：Typora"></a>个人使用工具：<strong>Typora</strong></h3><ol>
<li>基于Windows下载</li>
<li>偏好设置 </li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><p>​    博客部署至远端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hexo deploy -g</span><br></pre></td></tr></table></figure>

<p>​    将hexo文件夹源代码（写作所在文件夹）push至github仓库</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m “message”</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h2><p>引用自博客</p>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_30734435/article/details/98497054" target="_blank" rel="noopener">https://blog.csdn.net/weixin_30734435/article/details/98497054</a></p>
</blockquote>
<h4 id="更改配置文件"><a href="#更改配置文件" class="headerlink" title="更改配置文件"></a>更改配置文件</h4><p>​    在根目录下配置文件<code>_config.yml</code> 中有 <code>post_asset_folder:false改为true</code>。这样在建立文件时，<code>Hexo</code>会自动建立一个与文章同名的文件夹，这样就可以把与该文章相关的所有资源（图片）都放到那个文件夹里方便后面引用。</p>
<h4 id="安装git插件"><a href="#安装git插件" class="headerlink" title="安装git插件"></a>安装git插件</h4><blockquote>
<p>npm install <a href="https://github.com/7ym0n/hexo-asset-image" target="_blank" rel="noopener">https://github.com/7ym0n/hexo-asset-image</a> –save</p>
</blockquote>
<h4 id="在插入图片处增加代码"><a href="#在插入图片处增加代码" class="headerlink" title="在插入图片处增加代码"></a>在插入图片处增加代码</h4><p><a href="https://hexo.io/zh-cn/docs/asset-folders" target="_blank" rel="noopener">官方文档</a>给出了解决方式，使用代码为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure>

<p>​    将example.jpg修改为所需要的文件名称和后缀即可，其中<strong>This is an example image</strong>是图片描述。</p>
<h4 id="显示效果"><a href="#显示效果" class="headerlink" title="显示效果"></a>显示效果</h4><img src="/2019/12/29/markdown%E4%BD%BF%E7%94%A8/%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%B9%E6%B3%95.png" class title="This is an example image">

<h3 id="标题前不加数字"><a href="#标题前不加数字" class="headerlink" title="标题前不加数字"></a>标题前不加数字</h3><p>​    在标题前面加数字，hexo使用Next模板后，会自动根据多级标题加上相应数字生成目录，如果人为在多级标题前面加入数字，体验感并不好。</p>
<h1 id="markdown语法记录"><a href="#markdown语法记录" class="headerlink" title="markdown语法记录"></a>markdown语法记录</h1><p>引用自知乎，将一些常用命令进行记录</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/90561228" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/90561228</a></p>
</blockquote>
<h2 id="字体编辑"><a href="#字体编辑" class="headerlink" title="字体编辑"></a>字体编辑</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>​    有6级标题可选，分别为按下Ctrl+1~6。</p>
<h3 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">快捷键：Ctrl+数字  或 Ctrl+加减号  或  ### （几个#表示几级标题，同上）</span><br></pre></td></tr></table></figure>

<h3 id="字体加粗"><a href="#字体加粗" class="headerlink" title="字体加粗"></a>字体加粗</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">快捷键：Ctrl+b</span><br><span class="line">示 例：**加粗内容**</span><br></pre></td></tr></table></figure>

<p>​    加粗前：字体；加粗后<strong>字体</strong></p>
<h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">快捷键：ctrl+i</span><br><span class="line">示 例：*斜体*</span><br></pre></td></tr></table></figure>

<p>​    斜体前：斜体；斜体后<em>斜体</em></p>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">快捷键：alt+shift+5</span><br><span class="line">示 例：~~删除的内容~~</span><br></pre></td></tr></table></figure>

<p>​    删除前：删除；删除后：<del>删除</del></p>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">快捷键：Ctrl+u</span><br><span class="line">示 例：&lt;u&gt;下划线内容&lt;&#x2F;u&gt;</span><br></pre></td></tr></table></figure>

<p>​    下划前：下划；下划后：<u>下划</u></p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：这块有个脚注[^脚注]</span><br><span class="line">     [^脚注]:填写脚注的内容</span><br><span class="line">示例：有一个github网址[^1]</span><br><span class="line">     [^1]:https:&#x2F;&#x2F;github.com&#x2F;</span><br></pre></td></tr></table></figure>

<p>​    无脚注；有脚注<a href="https://github.com/" target="_blank" rel="noopener">^1</a></p>
<h3 id="灰色背景"><a href="#灰色背景" class="headerlink" title="灰色背景"></a>灰色背景</h3><p>加之前：Github，加之后<code>Github</code>，具体为大写锁定后按1左边的键。</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：数字+英文小数点(.)+空格</span><br><span class="line">示例：1. list1</span><br><span class="line">     2. list2</span><br></pre></td></tr></table></figure>

<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：- +空格 或 * + 空格</span><br><span class="line">示例： - list1</span><br><span class="line">      - list2</span><br></pre></td></tr></table></figure>

<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h3 id="插入代码块"><a href="#插入代码块" class="headerlink" title="插入代码块"></a>插入代码块</h3><p>快捷键：shift+3个~</p>
<h3 id="插入数学公式"><a href="#插入数学公式" class="headerlink" title="插入数学公式"></a>插入数学公式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：$$ + enter</span><br><span class="line">示例：$$ + enter后输入11+12，结果如下所示</span><br></pre></td></tr></table></figure>

<p>$$<br>11+12<br>$$</p>
<h3 id="插入引用"><a href="#插入引用" class="headerlink" title="插入引用"></a>插入引用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：&gt; + 空格</span><br><span class="line">示例：&gt; + 空格后，输入 引用的内容，结果如下所示</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是一个引用</p>
</blockquote>
<h3 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操 作:Ctrl+k弹出后，输入 [输入标题名](输入链接地址) 即可</span><br><span class="line">示 例1：[百度一下，你就知道](https:&#x2F;&#x2F;www.baidu.com&#x2F;)</span><br><span class="line">示 例2：这是 [百度一下，你就知道](https:&#x2F;&#x2F;www.baidu.com&#x2F; &quot;百度&quot;) 的链接.  </span><br><span class="line">示 例3：这是 [github][1] 的链接.  </span><br><span class="line">       [1]: https:&#x2F;&#x2F;github.com&#x2F; &quot;github&quot;</span><br><span class="line">ps：按住ctrl点击链接可直接打开</span><br></pre></td></tr></table></figure>

<p><a href="https://www.baidu.com/" target="_blank" rel="noopener">百度一下，你就知道</a></p>
<p>这是<a href="https://www.baidu.com/" target="_blank" rel="noopener" title="百度">百度一下，你就知道</a> 的链接</p>
<h3 id="插入注释"><a href="#插入注释" class="headerlink" title="插入注释"></a>插入注释</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：[^文字]：文字</span><br><span class="line">示例：[^1]：文献1</span><br></pre></td></tr></table></figure>

<p>​    <a href="hughzc.github.io">^2</a> : 个人博客地址</p>
<h3 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">快捷键：ctrl+t</span><br><span class="line">示 例：按完快捷键后，弹出下图，选择对应的行和列，点击确定即可。</span><br></pre></td></tr></table></figure>
<p>弹出下图的选项</p>
<img src="/2019/12/29/markdown%E4%BD%BF%E7%94%A8/%E8%A1%A8%E6%A0%BC.png" class title="This is an example image">



<table>
<thead>
<tr>
<th>1</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="普通markdown插入图片"><a href="#普通markdown插入图片" class="headerlink" title="普通markdown插入图片"></a>普通markdown插入图片</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：直接拖动  或 ctrl+shift+i(相对路径地址)</span><br><span class="line">示例：![](C:\1.jpg)</span><br></pre></td></tr></table></figure>

<p>​    如果是在hexo中插入图片，需要使用代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入分隔符"><a href="#插入分隔符" class="headerlink" title="插入分隔符"></a>插入分隔符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：--- + enter  或者 *** + enter</span><br></pre></td></tr></table></figure>

<p>这是条分割线</p>
<hr>
<h3 id="插入目录"><a href="#插入目录" class="headerlink" title="插入目录"></a>插入目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：[toc]+enter</span><br></pre></td></tr></table></figure>







]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
