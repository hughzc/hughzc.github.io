<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>设计模式</title>
    <url>/2020/04/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>封装变化，需要知道每种模式的典型用法与类图</p>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="单例模式Singleton"><a href="#单例模式Singleton" class="headerlink" title="单例模式Singleton"></a>单例模式Singleton</h3><p>应用于各种Mgr与Factory</p>
<p>单例模式的需求为一个类只允许产生一个对象，实现的方式有饿汉式，懒汉式与嵌套类式。</p>
<p>饿汉式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">singleton1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本思路为直接创建好一个私有的静态的对象，私有构造函数，创建一个public的静态方法去返回此对象（静态方法只能访问静态成员）。这种方法的优点是线程安全，缺点为如果不用到getInstance()方法，仍然会创建一个对象，增加开销。不过一般<strong>推荐使用</strong>。</p>
<p>懒汉式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton1 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">singleton2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton2<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本思路也为创建一个私有静态对象，但一开始不初始，私有构造函数，创建public的静态方法返回此对象，需要加上双重验证，加synchronized是为了保证线程安全，外面加上一层判断是为了提高效率，其中因为new这个语句不是原子性的，为了避免语句重排，出现s没有被初始化就返回的情况，需要让instance被volatile修饰，利用内存屏障保证不重排语句。优点是节约了资源，缺点是写法比较复杂，写错了容易线程不安全。</p>
<p><strong>静态内部类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">singleton3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在饿汉式基础上将对象构造放进内部类中，这样不调用内部类的时候不新建对象。</p>
<p>基本思路为私有构造方法，定义一个私有的静态类，避免其他类访问，直接类名调用，此类中持有外部类的私有静态实例，外部类提供方法，返回内部类中的对象。这样静态类只在被调用时加载一次，因此只有一个对象。优点是不使用getInstance方法不实例化，节约资源。缺点是第一次加载比较慢。</p>
<p><strong>枚举类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton4 &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用时</span></span><br><span class="line">Singleton4 s = Singleton4.INSTANCE;</span><br></pre></td></tr></table></figure>

<p>写法简单，调用方便。</p>
<p>JDK中用到的单例模式为：Runtime类，使用getRuntime()，使用的饿汉式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Runtime</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>策略模式</p>
<p>对于普通的排序，只能排数字，如果想要对多种类型进行排序，方法传入的参数需要为Compareble[]类型，然后比较的时候，调用数组的compareTo[]方法即可。但是这样依旧不够灵活，因为传入的类必须覆写compareTo()方法，更灵活的是让排序的策略可以灵活指定。定义比较器，实现Comparotor接口，实现compare()方法。</p>
<p>一般策略模式，需要有一个策略接口，如Comparator接口，策略接口可以有多个实现，策略模式封装的是<strong>做一件事不同的执行方式</strong>。</p>
<h3 id="工厂模式Factory"><a href="#工厂模式Factory" class="headerlink" title="工厂模式Factory"></a>工厂模式Factory</h3><p>任何可以产生对象的方法或类，都可以称之为工厂，单例也是一种工厂。</p>
<p>应用：Spring IOC</p>
<p>简单工厂</p>
<p>需求：需要使用不同的交通工具，并且调用他们的go方法。</p>
<p>定义一个交通工具的接口Moveable，定义go方法，让所有交通工具都要实现此接口。为了统一生产交通工具，定义一个简单工厂，里面写上不同的get方法来获取不同的交通工具对象，在Main方法中，通过定义接口类型的Module类，指向工厂方法获取的不同对象，以多态来获取不同对象的方法。</p>
<p>Main中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取生产工具</span></span><br><span class="line">    Moveable m = <span class="keyword">new</span> SimpleVehicleFactory().getCar();</span><br><span class="line">    m.go();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单工厂的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleVehicleFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Plane <span class="title">getPlane</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Plane();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象工厂</p>
<p>需求：需要生产一系列产品，如需要生产食品，武器，交通工具。先定义生产的产品的抽象类，然后抽象工厂新建方法返回对应的抽象类。抽象类中只有一个方法，只有一个方法但是用抽象类，是因为食品这些本身是一个具体的概念，是名词。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//产生三个不同的产品</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Food <span class="title">createFood</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Vehicle <span class="title">createVehicle</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Weapon <span class="title">createWeapon</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后如果是工厂1生产自己系列的产品，如面包，手枪，汽车，让产品继承自对应的抽象类，然后工厂1继承抽象工厂，返回自己生产的类即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModernFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Food <span class="title">createFood</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Vehicle <span class="title">createVehicle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Weapon <span class="title">createWeapon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AK47();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Main方法中，持有抽象工厂的引用，具体的对象实例可以是继承了抽象工厂的那些工厂，然后调用工厂的对应方法即可以获取到对应的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取生产工具</span></span><br><span class="line">        AbstractFactory f = <span class="keyword">new</span> ModernFactory();</span><br><span class="line">        Vehicle c = f.createVehicle();</span><br><span class="line">        c.go();</span><br><span class="line">        Food food = f.createFood();</span><br><span class="line">        food.printName();</span><br><span class="line">        Weapon weapon = f.createWeapon();</span><br><span class="line">        weapon.shoot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象工厂方便于产品族的设计。</p>
<h3 id="建造模式Builder"><a href="#建造模式Builder" class="headerlink" title="建造模式Builder"></a>建造模式Builder</h3><p>构建复杂对象</p>
<ul>
<li>分离复杂对象的构建和表示</li>
<li>同样的创建过程可以创建不同的表示</li>
<li>不同记忆，自然使用</li>
</ul>
<p>如果地形类中有墙，暗堡，地雷，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Terrain</span> </span>&#123;</span><br><span class="line">    Wall w;</span><br><span class="line">    Fort f;</span><br><span class="line">    Mine m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想构建不同的地形，可以使用不同的构建器，有一个构建地形的接口，其中有构建墙、暗堡、地雷的方法，当构建完成后，返回一个地形对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TerrainBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function">TerrainBuilder <span class="title">buildWall</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">TerrainBuilder <span class="title">buildFort</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">TerrainBuilder <span class="title">buildMine</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Terrain <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一个具体的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComplexTerrainBuilder</span> <span class="keyword">implements</span> <span class="title">TerrainBuilder</span> </span>&#123;</span><br><span class="line">    Terrain terrain = <span class="keyword">new</span> Terrain();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TerrainBuilder <span class="title">buildWall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        terrain.w = <span class="keyword">new</span> Wall(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TerrainBuilder <span class="title">buildFort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        terrain.f = <span class="keyword">new</span> Fort(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TerrainBuilder <span class="title">buildMine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        terrain.m = <span class="keyword">new</span> Mine(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Terrain <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> terrain;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>聚合一个地形对象，当调用不同的构建方法时对地形对象分批进行构建，返回this即当前构建器对象，最后返回聚合的地形对象。</p>
<p>其中返回一个构建器的接口是因为方便<strong>链式编程</strong>。在main中调用时，使用链式编程调用非常方便</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TerrainBuilder builder = <span class="keyword">new</span> ComplexTerrainBuilder();</span><br><span class="line">   Terrain t = builder.buildFort().buildMine().buildWall().build();</span><br></pre></td></tr></table></figure>

<p>在Java中应用于属性非常多的对象的构建，如果一个对象有些属性是必须的，但一些属性可有可无，如果每次构建对象 都要传入许多参数，则非常麻烦，可以私有类的构造器，在其内部有一个静态内部类，由静态内部类来创建对象，并对外提供对外部类对象构造的方法。</p>
<p>可以看到，下面的类私有了Person对象的构造方法，这样想要新建一个类，只能使用其静态内部类Builder，有基础信息的构建，也有可选信息的构建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonBuilder</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> PersonBuilder <span class="title">basicInfo</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            p.id = id;</span><br><span class="line">            p.name = name;</span><br><span class="line">            p.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> PersonBuilder <span class="title">weight</span><span class="params">(<span class="keyword">double</span> weight)</span> </span>&#123;</span><br><span class="line">            p.weight = weight;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> PersonBuilder <span class="title">score</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">            p.score = score;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main中调用时，如果不想构建哪个属性，直接将其注释掉即可，这样构建非常方便。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person.PersonBuilder()</span><br><span class="line">              .basicInfo(<span class="number">1</span>, <span class="string">"zhangsan"</span>, <span class="number">18</span>)</span><br><span class="line">              <span class="comment">//.score(20)</span></span><br><span class="line">              .weight(<span class="number">200</span>)</span><br><span class="line">              .build();</span><br></pre></td></tr></table></figure>

<p>总结：用于被构建类非常复杂的情况，构建工具类聚合一个被构建类对象，有返回构建工具类的不同构建方法，便于链式编程，最后有一个返回返回被构建类对象的方法。</p>
<h3 id="原型模式Prototype"><a href="#原型模式Prototype" class="headerlink" title="原型模式Prototype"></a>原型模式Prototype</h3><p>又叫克隆模式，Object.clone()</p>
<p>一个类想要被克隆，需要</p>
<ol>
<li><p><strong>实现Cloneable标记型接口</strong>（其中没有方法）</p>
<p>若不实现接口，编译不出错，调用报异常</p>
</li>
<li><p>被克隆的类需要<strong>重写clone方法</strong></p>
<p>因为Object类中的clone方法为native</p>
</li>
</ol>
<p>一般用于一个对象的属性已经确定，需要产生很多相同对象的时候</p>
<p>克隆的只是基本属性，如果被克隆的类中有其他对象的引用，则拷贝的只是此对象的引用。因此是浅克隆。</p>
<p>在main中输出，p与p2的Location对象地址相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">"zhangsan"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> Location location = <span class="keyword">new</span> Location(<span class="string">"nj"</span>,<span class="string">"gulou"</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Person p2 = (Person) p.clone();</span><br><span class="line">        System.out.println(p2.location.city+<span class="string">" "</span>+ p2.location.street);</span><br><span class="line">        System.out.println(p2.location == p.location);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span></span>&#123;</span><br><span class="line">    String city;</span><br><span class="line">    String street;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Location</span><span class="params">(String city, String street)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.city = city;</span><br><span class="line">        <span class="keyword">this</span>.street = street;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了实现深克隆，需要让Location也实现Cloneable接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    String city;</span><br><span class="line">    String street;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Location</span><span class="params">(String city, String street)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.city = city;</span><br><span class="line">        <span class="keyword">this</span>.street = street;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在Person类中，将location单独clone</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    Person p = (Person) <span class="keyword">super</span>.clone();<span class="comment">//用this.clone循环调用，栈溢出</span></span><br><span class="line">    p.location = (Location) <span class="keyword">this</span>.location.clone();</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Location中的String类型的属性不用进行深克隆，因为字符串在常量池中，String类引用不可变。若使用的是StringBuilder，则Location中新老对象使用的同一个StringBuilder引用。那么深克隆时候也需要把StringBuilder进行深克隆。</p>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="装饰模式Decorator"><a href="#装饰模式Decorator" class="headerlink" title="装饰模式Decorator"></a>装饰模式Decorator</h3><p>IO流中的Writer，有人说是装饰。如果要对一个类的功能进行装饰，即增加一些功能，要是使用继承，会产生类爆炸的现象，那么使用一个抽象类继承装饰抽象类，需要持有一个装饰类对象，在装饰类的实现类中，调用被装饰类的自己的方法，然后加入一些字自己的方法。</p>
<h3 id="门面模式Facade"><a href="#门面模式Facade" class="headerlink" title="门面模式Facade"></a>门面模式Facade</h3><img src="/2020/04/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%97%A8%E9%9D%A2.png" class title="This is an example image">

<p>许多类之间有复杂的联系，如果Main类中去跟每个类交互，逻辑非常复杂。而使用一个类，封装所有的类之间的逻辑，对外只暴露一些接口，相当于一个门面。</p>
<h3 id="享元模式Flyweight"><a href="#享元模式Flyweight" class="headerlink" title="享元模式Flyweight"></a>享元模式Flyweight</h3><p>共享元数据，将小对象放入池子中，需要用到的时候，从池子中取即可。    </p>
<h3 id="组合模式Composite"><a href="#组合模式Composite" class="headerlink" title="组合模式Composite"></a>组合模式Composite</h3><p>树状结构专用模式。</p>
<p>将Node组合到Branches类中。</p>
<p>如有节点的抽象类，其中有方法p()，用来打印当前的节点值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">p</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有叶子节点，直接打印值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LeafNode</span> <span class="keyword">extends</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LeafNode</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">p</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是枝干节点，则下面有枝干或者叶子，因此持有一个Node的集合，对外提供将Node加入集合的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Branches</span> <span class="keyword">extends</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="comment">//持有一系列的Node</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; nodes = <span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Branches</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node n)</span></span>&#123;</span><br><span class="line">        nodes.add(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">p</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在遍历树的时候，传入一个节点Node,传入一个当前的高度（便于去打印树的深度）</p>
<p>使用递归的写法，base case为节点为空，直接返回；打印当前高度，打印当前节点。如果当前节点是枝干节点，获取当前枝干节点的节点集合，然后对集合中的所有节点递归调用遍历函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历树</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tree</span><span class="params">(Node n,<span class="keyword">int</span> height)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">           System.out.print(<span class="string">"--"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       n.p();</span><br><span class="line">       <span class="comment">//如果是枝干</span></span><br><span class="line">       <span class="keyword">if</span> (n <span class="keyword">instanceof</span> Branches)&#123;</span><br><span class="line">           <span class="keyword">for</span>(Node node : ((Branches)n).nodes)&#123;</span><br><span class="line">               tree(node,height+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="代理模式Proxy"><a href="#代理模式Proxy" class="headerlink" title="代理模式Proxy"></a>代理模式Proxy</h3><p>代理的含义是比如去买酒，不需要自己去找酒的生产商，而是找到其代理人即可。</p>
<p>静态代理。</p>
<p>有一个可移动的接口，其中有move方法，坦克类实现此接口并覆写方法，为了记录坦克类的运行时间，可以使用继承，但是这样非常臃肿而且不利于功能的复用，比如要记录时间，日志，时间与日志，就需要3个继承类。这时候使用静态的代理，一个时间代理类继承Moveable接口，然后聚合一个Moveable，在其move方法中，增加自己功能，再调用持有的Moveable的move方法。因为此代理也是一个Moveable，因此是可以被其他的代理类所代理的，这样增加功能非常方便，静态代理有点类似于装饰器模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tank</span> <span class="keyword">implements</span> <span class="title">Moveable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Tank wuwuwuu"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MoveableTimeProxy</span> <span class="keyword">implements</span> <span class="title">Moveable</span></span>&#123;</span><br><span class="line">    <span class="comment">//聚合一个引用</span></span><br><span class="line">    Moveable m;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MoveableTimeProxy</span><span class="params">(Moveable m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Long start = System.currentTimeMillis();</span><br><span class="line">        m.move();</span><br><span class="line">        Long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end-start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MoveableLogProxy</span> <span class="keyword">implements</span> <span class="title">Moveable</span></span>&#123;</span><br><span class="line">    <span class="comment">//聚合一个引用</span></span><br><span class="line">    Moveable m;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MoveableLogProxy</span><span class="params">(Moveable m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始移动"</span>);</span><br><span class="line">        m.move();</span><br><span class="line">        System.out.println(<span class="string">"结束移动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态代理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Moveable tank = <span class="keyword">new</span> Tank();</span><br><span class="line">        <span class="comment">//代理嵌套代理</span></span><br><span class="line">        <span class="keyword">new</span> MoveableTimeProxy(<span class="keyword">new</span> MoveableLogProxy(tank)).move();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态代理</p>
<p>想要日志代理不仅可以代理可以移动的，还可以代理任意类型的。本质是分离代理行为与被代理对象。因为不知道被代理的类是什么类型，其中有什么方法，需要使用jdk的动态代理。</p>
<p>动态代理不是改变原来类的代码，而是生成一个新的代理类。</p>
<p>仍然定义一个Moveable接口，坦克类实现此接口。为了获得代理类，使用Proxy的newProxyInstance方法获得，传入3个参数，<strong>类加载器</strong>，<strong>接口的Class数组</strong>及<strong>被调用时的处理器</strong>，即调用被代理对象的方法时该如何做。类加载器写被被代理类的加载器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tank</span> <span class="keyword">implements</span> <span class="title">Moveable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"tank wuwuuw"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tank tank = <span class="keyword">new</span> Tank();</span><br><span class="line">        <span class="comment">//生成一个动态代理类</span></span><br><span class="line">        Moveable m = (Moveable) Proxy.newProxyInstance(Tank<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">                new Class[]&#123;Moveable.class&#125;, new LogProxy(tank));</span><br><span class="line">        m.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    Tank tank;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogProxy</span><span class="params">(Tank tank)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tank = tank;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//写代理部分的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"method "</span>+method.getName()+<span class="string">" start"</span>);</span><br><span class="line">        Object o = method.invoke(tank,args);</span><br><span class="line">        System.out.println(<span class="string">"method "</span>+method.getName()+<span class="string">" end"</span>);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到生成代理对象后，调用其move方法，可以获取如下输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method move start</span><br><span class="line">tank wuwuuw</span><br><span class="line">method move end</span><br></pre></td></tr></table></figure>

<p>但是开始与结束的逻辑写在了InvocationHandler里面的invoke方法，调用move方法时却调用到了invoke方法。原理是生成的动态代理类中，因为其要实现Moveable接口，因此实现了move方法，在此方法中，调用了传入的InvocationHandler的invoke方法。</p>
<p>其中对于invoke方法，通过method可以拿到其方法名，对应不同的方法可以有不同的方法对应。args为往方法里传递的参数，proxy为生成的代理对象m，被代理对象被调用事件是method.invoke，传哪个引用相当于调用哪个引用的方法，method.invoke(tank,args)相当于对坦克对象调用move方法，返回类型与传入引用被调用方法的返回类型相同，此处move返回的是空值，那么这里返回的object也为空。</p>
<p>总的来说，调用的逻辑是，当调用生成的m对象的move方法，其实调用的是传入的InvocationHandler的invoke方法，在其中有自己写的代理的方法，当要使用被代理类的方法时，使用method.invoke，传入被代理对象的引用与参数，返回其原方法的返回值，其实调用的是Tank类的move方法。</p>
<p>而生成动态代理类的过程，底层是使用的asm来实现的，其为二进制字节码操作类库。因此不管用什么语言写，只要能生成二进制字节码文件，就可以在JVM运行，如scala，kotlin等。</p>
<p>JDK反射的动态代理必须<strong>面对接口</strong>。通过接口来指定代理类生成的接口，否则不知道需要生成哪些方法。</p>
<p>而如果使用CGLIB方式（<strong>Code Generation Library</strong>）生成，不要求被代理类实现接口，生成的动态代理类为被代理类的子类，因此如果被代理的类被final修饰，是无法使用这种方式来动态代理的。<strong>cglib底层也用的asm</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(Tank<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//设置父类</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> TimeMethodInterceptor());</span><br><span class="line">        Tank tank = (Tank)enhancer.create();</span><br><span class="line">        tank.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相当于InvocationHandler</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//o为生成的动态代理类对象，其为被代理类的子类</span></span><br><span class="line">        System.out.println(o.getClass().getSuperclass().getName());</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        result = methodProxy.invokeSuper(o,objects);<span class="comment">//调用原来的</span></span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态代理可以对所有类型的对象执行一定的功能。可以在原来的功能上切入自己定义的功能，不用更改原来类的代码，叫做AOP，Aspect Oriented Programming，面向切面编程，使用的CGLIB的方式。</p>
<p>切面是往哪里加代码的集合。</p>
<p>Spring的AOP配置，需要maven导包org.aspectj</p>
<p>方式一：配置文件配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"timeProxy"</span> <span class="attr">class</span>=<span class="string">"com.zc.dp.spring.v1.TimeProxy"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"time"</span> <span class="attr">ref</span>=<span class="string">"timeProxy"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"onmove"</span> <span class="attr">expression</span>=<span class="string">"execution(void com.zc.dp.spring.v1.Tank.move())"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"before"</span> <span class="attr">pointcut-ref</span>=<span class="string">"onmove"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"after"</span> <span class="attr">pointcut-ref</span>=<span class="string">"onmove"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>pointcut代表在哪个点且，此处为执行Tank的move()方法时进行切面，然后指定在此切面前面执行before方法，后面执行after方法，去ref指定的id为timeProxy的类中去寻找这两个方法，如果想执行且多个方法或者多个类，可以使用<code>.*</code>的方式。这样如果想添加新的功能，非常方便。</p>
<p>方式二：注解配置</p>
<p>在要切的类上加入<code>@Aspect</code>注解，在要之前与之后执行的方法前加入<code>@Before</code>与<code>@After</code>注解。比起配置文件实现更方便。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="comment">//表示是一个要往里面切的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeProxy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(void com.zc.dp.spring.v2.Tank.move())"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before "</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"execution(void com.zc.dp.spring.v2.Tank.move())"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after "</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当Tank被final修饰时，报错</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Could not generate CGLIB subclass of class com.zc.dp.spring.v2.Tank: Common causes of this problem include using a final class or a non-visible class;</span><br></pre></td></tr></table></figure>

<h3 id="适配器模式Adapter（Wrapper）"><a href="#适配器模式Adapter（Wrapper）" class="headerlink" title="适配器模式Adapter（Wrapper）"></a>适配器模式Adapter（Wrapper）</h3><p>接口转换器，一个类不能直接访问另外一个类，中间加一个转换。</p>
<ul>
<li><p>电压转接头</p>
</li>
<li><p>java.io</p>
<p>BufferedReader，将字节流转为字符流</p>
</li>
<li><p>JDBC转为ODBC，再访问SQL Server，即JDBC与ODBC的Bridge</p>
</li>
<li><p>ASM Transformer</p>
<p>Reader直接传给Writer，相当于复制，这时候如果多加一层Adapter，可以自定义一些功能，也可以叫做适配器。</p>
</li>
</ul>
<p>误区：常见的Adapter类反而不是Adapter，如WindowAdapter，KeyAdapter</p>
<p>在awt中，如果想要监听窗口，直接new WindowListner接口，需要重写6个方法，但很多时候只关心其中几个方法，这时候，WindowAdapter是一个抽象类，实现WindowListner，将全部方法实现为空，这时候继承WindowAdapter只重写关心的方法即可。</p>
<p>常见的带Adapter的类只是为了方便编程而已。</p>
<h3 id="桥接模式Bridge"><a href="#桥接模式Bridge" class="headerlink" title="桥接模式Bridge"></a>桥接模式Bridge</h3><p>双维度扩展</p>
<ul>
<li>分离抽象与具体</li>
<li>用聚合方式（桥）连接抽象与具体</li>
</ul>
<p>抽象类的树与具体类的树分别发展，但是在抽象类中聚合一个实现类。</p>
<p>需求：礼物Gift有礼物的实现类GiftImlpl，而礼物下有分支温暖的，冷酷的礼物等。而礼物的实现类GiftImlpl下有花，书等。如果子类使用继承，比如一个温暖的花，冷酷的花，可以有多种继承方式，这时候会产生类爆炸。</p>
<p>如Gift抽象类在自己发展，其实现类GiftImlpl也在发展，这时候在Gift类中聚合一个GiftImlpl。就是<strong>用聚合代替继承</strong>。</p>
<p>对于Gift抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Gift</span> </span>&#123;</span><br><span class="line">    GiftImpl impl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于其具体类GiftImlpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiftImpl</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如Gift下有WarmGift，需要传入一个礼物的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WarmGift</span> <span class="keyword">extends</span> <span class="title">Gift</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WarmGift</span><span class="params">(GiftImpl impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.impl = impl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在具体应用时，将具体的实现类传入抽象类即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chase</span><span class="params">(MM mm)</span> </span>&#123;</span><br><span class="line">    Gift g = <span class="keyword">new</span> WarmGift(<span class="keyword">new</span> Flower());</span><br><span class="line">    give(mm, g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="策略模式Strategy"><a href="#策略模式Strategy" class="headerlink" title="策略模式Strategy"></a>策略模式Strategy</h3><p>对做同一件事情，有不同的策略。如坦克的开火，可以有普通的开火，也可以四个方向开火。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Fire&#123;</span><br><span class="line">	void fire();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main中持有Fire，传入不同的Fire实现类，有不同的策略实现。</p>
<h3 id="责任链模式COR"><a href="#责任链模式COR" class="headerlink" title="责任链模式COR"></a>责任链模式COR</h3><p>场景：对字符串进行敏感词过滤操作。如有消息类Msg，其字符串为<code>大家好:)，&lt;script&gt;，欢迎访问 zc.com，大家都是996</code>，其中尖括号中的内容可能会被直接访问，而996算敏感词，网站需要对这两种情况进行过滤。</p>
<p>定义一个Filter接口，定义抽象方法doFilter，需要传入消息类对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Filer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Msg msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为可能有多种敏感词过滤的情况，因此定义多个类，分别实现Filter接口，来覆写自己的doFilter方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTMLFilter</span> <span class="keyword">implements</span> <span class="title">Filer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Msg msg)</span> </span>&#123;</span><br><span class="line">        String r = msg.getMsg();</span><br><span class="line">        r = r.replace(<span class="string">'&lt;'</span>,<span class="string">'['</span>);</span><br><span class="line">        r = r.replace(<span class="string">'&gt;'</span>,<span class="string">']'</span>);</span><br><span class="line">        msg.setMsg(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SensitiveFilter</span> <span class="keyword">implements</span> <span class="title">Filer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Msg msg)</span> </span>&#123;</span><br><span class="line">        String r = msg.getMsg();</span><br><span class="line">        r = r.replace(<span class="string">"996"</span>,<span class="string">"955"</span>);</span><br><span class="line">        msg.setMsg(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了更好封装多个Filter，定义一个FilterChain，可以添加Filter与获取所有的Filter。其中add方法返回的是当前的FilterChain对象，便于链式编程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterChain</span></span>&#123;</span><br><span class="line">    List&lt;Filer&gt; filers = <span class="keyword">new</span> ArrayList&lt;Filer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterChain <span class="title">add</span><span class="params">(Filer f)</span></span>&#123;</span><br><span class="line">        filers.add(f);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Msg msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Filer filer : filers) &#123;</span><br><span class="line">            filer.doFilter(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在主方法中，新建FilterChain对象，添加对应的Filter，调用fc的doFilter方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Msg msg = <span class="keyword">new</span> Msg();</span><br><span class="line">        msg.setMsg(<span class="string">"大家好:)，&lt;script&gt;，欢迎访问 zc.com，大家都是996"</span>);</span><br><span class="line">        <span class="comment">//处理msg</span></span><br><span class="line">        FilterChain fc = <span class="keyword">new</span> FilterChain();</span><br><span class="line">		fc.add(<span class="keyword">new</span> HTMLFilter())</span><br><span class="line">                .add(<span class="keyword">new</span> SensitiveFilter());</span><br><span class="line">        fc.doFilter(msg);</span><br><span class="line">        System.out.println(msg.getMsg());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>整个过滤逻辑如下图所示，每个Filter有自己的责任，串成了链条的样子。</p>
<img src="/2020/04/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE.png" class title="This is an example image">

<p>但是当需要有另外的一个责任链fc2，也需要进行处理，为了让fc1与fc2串在一起，可以让FilterChain本身也实现Filter接口，这样可以让fc1直接add责任链fc2，基本逻辑是因为fc2本身也是一个Filter，这样将不同的责任链都串在了一起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterChain</span> <span class="keyword">implements</span> <span class="title">Filer</span></span>&#123;</span><br><span class="line">    List&lt;Filer&gt; filers = <span class="keyword">new</span> ArrayList&lt;Filer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterChain <span class="title">add</span><span class="params">(Filer f)</span></span>&#123;</span><br><span class="line">        filers.add(f);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Msg msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Filer filer : filers) &#123;</span><br><span class="line">            filer.doFilter(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FilterChain fc = <span class="keyword">new</span> FilterChain();</span><br><span class="line">      fc.add(<span class="keyword">new</span> HTMLFilter())</span><br><span class="line">              .add(<span class="keyword">new</span> SensitiveFilter());</span><br><span class="line">      FilterChain fc2 = <span class="keyword">new</span> FilterChain();</span><br><span class="line">      fc2.add(<span class="keyword">new</span> FaceFilter())</span><br><span class="line">              .add(<span class="keyword">new</span> URLFilter());</span><br><span class="line"><span class="comment">//精髓！！！</span></span><br><span class="line">      fc.add(fc2);</span><br><span class="line">      fc.doFilter(msg);</span><br></pre></td></tr></table></figure>

<p>某个Filter决定是否向下继续走。</p>
<p>做法是让Filter的doFilter方法返回一个布尔类型，返回真表示继续进行，返回假表示终止进行。</p>
<p>在FilterChain中，循环的逻辑中，当一个Filter返回的结果为假，表示不用再继续了，直接返回假；不然等全部结束了返回真。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Filer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Msg msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterChain</span> <span class="keyword">implements</span> <span class="title">Filer</span></span>&#123;</span><br><span class="line">    List&lt;Filer&gt; filers = <span class="keyword">new</span> ArrayList&lt;Filer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterChain <span class="title">add</span><span class="params">(Filer f)</span></span>&#123;</span><br><span class="line">        filers.add(f);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关键</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Msg msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Filer filer : filers) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!filer.doFilter(msg))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Servlet中，有Filter，其功能为可以同时处理request与response，同时处理的顺序为request1,request2,…,requestn，responsen,…,response2,response1。是一个递归的过程，那么需要在执行当前resquest的时候，知道下一个需要执行哪个Filter，那么需要拿到当前的FilterChain，在Filter接口的doFilter方法中，除了需要传入Response与Request，还需要传入FilterChain，以便去调用下一个的Filter。而在FilterChain中，维护有当前执行到的index，当index超出容器范围，直接返回。执行当前index对应的Filter，让index自增，返回当前filter执行执行的结果。在每个Filter中，先执行对Request的操作，然后可以选择是否执行下一个Filter，如果要就调用持有的FilterChain对象的doFilter方法，然后递归执行完毕后，再执行当前的Response。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span></span>&#123;</span><br><span class="line">    String str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Response</span></span>&#123;</span><br><span class="line">    String str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Filer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Request request,Response response,FilterChain fc)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTMLFilter</span> <span class="keyword">implements</span> <span class="title">Filer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request request,Response response,FilterChain chain)</span> </span>&#123;</span><br><span class="line">        String r = request.str;</span><br><span class="line">        r = r.replace(<span class="string">'&lt;'</span>,<span class="string">'['</span>);</span><br><span class="line">        request.str = r.replace(<span class="string">'&gt;'</span>,<span class="string">']'</span>);</span><br><span class="line">        <span class="comment">//执行下一个</span></span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">        response.str += <span class="string">"--HTMLFilter"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SensitiveFilter</span> <span class="keyword">implements</span> <span class="title">Filer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Request request,Response response,FilterChain chain)</span> </span>&#123;</span><br><span class="line">        String r = request.str;</span><br><span class="line">        r = r.replace(<span class="string">":)"</span>,<span class="string">"^v^"</span>);</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">        response.str += <span class="string">"--SensitiveFilter"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterChain</span> </span>&#123;</span><br><span class="line">    List&lt;Filer&gt; filers = <span class="keyword">new</span> ArrayList&lt;Filer&gt;();</span><br><span class="line">    <span class="comment">//持有个位置变量，指向当前执行的Filter位置</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterChain <span class="title">add</span><span class="params">(Filer f)</span></span>&#123;</span><br><span class="line">        filers.add(f);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关键</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Request request,Response response)</span></span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span> (index == filers.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//处理当前的</span></span><br><span class="line">        Filer f = filers.get(index);</span><br><span class="line">        index++;</span><br><span class="line">        <span class="comment">//传给当前Filter的是当前的chain对象</span></span><br><span class="line">        <span class="keyword">return</span> f.doFilter(request,response,<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，如果在实现的Filter中调用了FilterChain，责任链才会继续往下走，否则会处理当前的response并返回，在main方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Request request = <span class="keyword">new</span> Request();</span><br><span class="line">    request.str = <span class="string">"\"大家好:)，&lt;script&gt;，欢迎访问 zc.com，大家都是996\""</span>;</span><br><span class="line">    Response response = <span class="keyword">new</span> Response();</span><br><span class="line">    response.str = <span class="string">"response"</span>;</span><br><span class="line">    FilterChain chain = <span class="keyword">new</span> FilterChain();</span><br><span class="line">    chain.add(<span class="keyword">new</span> HTMLFilter()).add(<span class="keyword">new</span> SensitiveFilter());</span><br><span class="line">    chain.doFilter(request,response);</span><br><span class="line">    System.out.println(request.str);</span><br><span class="line">    System.out.println(response.str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以达到处理的要求了，总结就是思路为递归，需要拿到当前的chain，是否继续往下走的权利在每一个Filter中。</p>
<p>总结：控制责任链是否往下走有两种方式</p>
<ol>
<li>Filter接口的doFilter方法返回布尔类型的值，在FilterChain中对每个Filter的方法返回值判断，有false就停止</li>
<li>Filter接口的doFilter方法传入FilterChain，FilterChain中有指针，指向当前下一个要执行的Filter，当指向末尾返回，不然执行Filter，指针后移，对执行的Filter传入当前FilterChain对象。<strong>控制的权利交给Filter</strong>，如果想要继续执行，则调用FilterChain的doFilter方法，否则不调用就不往下走了</li>
</ol>
<h3 id="观察者模式Observer"><a href="#观察者模式Observer" class="headerlink" title="观察者模式Observer"></a>观察者模式Observer</h3><p>如果有一个小孩，哭了之后需要观察者做出不同的反应。做法是小孩哭了后，产生一个事件，将事件传给所有的观察者，依据不同的事件来做出不同的反应。观察者模式需要具有的3个基本类是Source（被观察类），Observer(观察类)，Event(事件类)，被观察者生产一个事件，传递给观察类接口，接口类方法目的是回调具体实现子类中的方法，当Observer观察到Event的时候，产生具体的反应。</p>
<p>对于事件类，需要知道是哪个被观察者，因为可能监听着多个被观察者。Event类中一般需要有getSource的方法。观察者拿到Event对象后，如果需要知道Source，使用getSource方法就可以，这样可以根据Source来处理相应的处理。这样观察者与被观察者解耦合。</p>
<p>应用：UI界面，很多都是观察者模式。如点击一个Button，产生一个事件Event，调用Observer的方法来处理事件。</p>
<p>很多系统中，Observer与责任链共同负责对事件的处理。其中的一个observer负责是否将事件进一步处理。</p>
<h3 id="调停者模式Mediator"><a href="#调停者模式Mediator" class="headerlink" title="调停者模式Mediator"></a>调停者模式Mediator</h3><img src="/2020/04/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B0%83%E5%81%9C%E8%80%85.png" class title="This is an example image">

<p>许多类之间有许多联系，为了简化类之间的关联，抽出一个类专门与其他类来通信，这个类称为调停者。</p>
<p>门面模式对外，调停者模式对内，可以是同一个。</p>
<p>实际应用：消息中间件MQ（Message Queue）。将消息统一放在MQ中，谁需要消息谁去拿，进行解耦。</p>
<h3 id="迭代器模式Iterator"><a href="#迭代器模式Iterator" class="headerlink" title="迭代器模式Iterator"></a>迭代器模式Iterator</h3><p>用于容器与容器遍历。</p>
<p>集合物理实现只有数组跟链表，为了方便操作不同的集合，让其均继承自一个接口，而为了遍历不同的容器，如何遍历只有容器自己清楚，因此实现的过程封装在不同的容器内部，只对外暴露接口。迭代器接口有hasnext与next方法。在集合接口中，提供获取迭代器的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection_</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator_ <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于具体的实现类，比如LinkedList，提供具体的实现方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList_</span> <span class="keyword">implements</span> <span class="title">Collection_</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Object value;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Node tail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        Node cur = <span class="keyword">new</span> Node(o);</span><br><span class="line">        cur.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            head = cur;</span><br><span class="line">            tail = cur;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            tail.next = cur;</span><br><span class="line">            tail = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator_ <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedListIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator_</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node curIte = head;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (curIte == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Object o = curIte.value;</span><br><span class="line">            curIte = curIte.next;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中LinkedList中的迭代器类为私有的内部类，因为此类只会在当前啊类中使用，而且为了方便访问外部类中的属性与方法，将其进行内部类的封装。而在main方法中，调用的流程如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection_ c = <span class="keyword">new</span> LinkedList_();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">          c.add(i);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(c.getSize());</span><br><span class="line">      Iterator_ it = c.iterator();</span><br><span class="line">      <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">          System.out.print(it.next()+<span class="string">" "</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>如果需要进一步扩展，不指定数据的类型为Object，可以使用泛型。</p>
<h3 id="访问者模式Vistor"><a href="#访问者模式Vistor" class="headerlink" title="访问者模式Vistor"></a>访问者模式Vistor</h3><p>在<strong>结构不变</strong>的情况下动态改变对于内部元素的动作。</p>
<p>具体应用：<strong>编译器</strong>。对抽象语法树的每个节点，传入Vistor，由Vistor来做具体的检查。单一职责原则。</p>
<p>需求：电脑的内部部件是固定的，比如有CPU，内存，主板，如果有不同的人需要去电脑店，电脑店给不同的人有不同组件的优惠，如果是写在每个电脑组件类的内部来判断，则需要有非常多的if else，而且当多一个人以后，就要增加代码，这样将判断的代码封装到一个Vistor中，在每个电脑组件中，需要有接收一个Vistor的方法，还要有调用vistor中优惠价格的方法。</p>
<p>电脑组件定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor v)</span></span>;</span><br><span class="line">    <span class="comment">//可以有其他的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一个电脑，以其只有3个组件为例，对所有的组件都传入同一个vistor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    ComputerPart cpu = <span class="keyword">new</span> CPU();</span><br><span class="line">    ComputerPart memory = <span class="keyword">new</span> Memory();</span><br><span class="line">    ComputerPart board = <span class="keyword">new</span> Board();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acccept</span><span class="params">(Visitor v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cpu.accept(v);</span><br><span class="line">        <span class="keyword">this</span>.memory.accept(v);</span><br><span class="line">        <span class="keyword">this</span>.board.accept(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于电脑组件具体的实现类，是什么部件就调用Vistor的看什么部件的方法。一定会有accpet方法，传入一个Vistor。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPU</span> <span class="keyword">extends</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor v)</span> </span>&#123;</span><br><span class="line">        v.visitCpu(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于Vistor接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitCpu</span><span class="params">(CPU cpu)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitMemory</span><span class="params">(Memory memory)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitBoard</span><span class="params">(Board board)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其具体的实现类，拿到对应组件的价格后，进行优惠即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonelVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> totalPrice = <span class="number">0.0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCpu</span><span class="params">(CPU cpu)</span> </span>&#123;</span><br><span class="line">        totalPrice += cpu.getPrice()*<span class="number">0.9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitMemory</span><span class="params">(Memory memory)</span> </span>&#123;</span><br><span class="line">        totalPrice += memory.getPrice()*<span class="number">0.85</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitBoard</span><span class="params">(Board board)</span> </span>&#123;</span><br><span class="line">        totalPrice += board.getPrice()*<span class="number">0.95</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    PersonelVisitor p = <span class="keyword">new</span> PersonelVisitor();</span><br><span class="line">    <span class="keyword">new</span> Computer().acccept(p);</span><br><span class="line">    System.out.println(p.totalPrice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，其本质是对多个固定组件下，不同组件的if else的封装，适用于组件固定，但每个组件有不同情况的场景下，如果组件频繁增加，则Vistor接口改动也非常频繁，不适用于组件变化多的情况。</p>
<p>ASM框架，相当于使用Java语言来操作字节码文件，可以自己定义Vistor来读字节码文件，也可以来动态写字节码文件。</p>
<p>对于ASM，用Reader去读字节码文件，然后用Writer（一个Visitor）来写字节码文件，如果想要自己定制写的过程，将Reader传给自己定义的Adapter，将Adapter传给Writer，责任链模式。ASM就是用的Visitor，多个Visitor之间形成了链条。利用自己定义的Adapter，可以自己在原来的类字节码文件中的指定方法前后增加内容，这样生成的新的类变为原来类的动态代理类。</p>
<h3 id="命令模式Command"><a href="#命令模式Command" class="headerlink" title="命令模式Command"></a>命令模式Command</h3><p>封装命令，结合责任链实现undo（回滚）</p>
<p>别名：Action / Transaction</p>
<p>Command中封装了多个命令，常见的有执行与回滚，对于每个Command，需要能够将命令回退，在undo命令中记录了与execute中相反的操作。</p>
<p>常见的实现：文本编辑器。这时候相当于实现了一次execute，一次undo，但是为了实现一连串的undo，使用责任链。将所有的Commond放入一个集合，当实现一次回退，执行一个Commond中的undo，再实现一次则继续执行一个。</p>
<ul>
<li><p>多次undo</p>
<p>Command与责任链</p>
<p>将command加入集合，然后逐个取出执行。如果是多次undo，需要倒着过来做</p>
</li>
<li><p>事务回滚</p>
<p>command与记忆</p>
</li>
<li><p>宏命令（多个命令组成）</p>
<p>command与组合Composite，因为宏命令是树状结构</p>
</li>
</ul>
<h3 id="备忘录模式Memento"><a href="#备忘录模式Memento" class="headerlink" title="备忘录模式Memento"></a>备忘录模式Memento</h3><p>记录状态，便于回滚</p>
<p>有一个原对象，使用Memento记录其状态。</p>
<ul>
<li>记录快照（瞬时状态）</li>
<li>存盘</li>
</ul>
<h3 id="模板方法Template-Method"><a href="#模板方法Template-Method" class="headerlink" title="模板方法Template Method"></a>模板方法Template Method</h3><p>模板方法，钩子函数</p>
<p>相当于定好了模板，具体的实现自己来写。</p>
<p>重写一个方法，系统自动调用，如awt中的paint。在父类中有个方法，调用了method1与method2，子类去继承父类的时候，只需要重写method1与2，在父类中被自动调用。</p>
<p>如下，父类中m方法调用了op1与op2，但是是抽象的，子类中继承父类重写此方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">F</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">        op1();</span><br><span class="line">        op2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">op1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">op2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">F</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">op1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"op1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">op2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"op2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主函数中，多态，调用父类的m方法，执行的是子类中重写的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">F f = <span class="keyword">new</span> C();</span><br><span class="line">f.m();</span><br></pre></td></tr></table></figure>

<h3 id="状态模式State"><a href="#状态模式State" class="headerlink" title="状态模式State"></a>状态模式State</h3><p>根据状态决定行为</p>
<p>如果一个类中很多行为都是要根据其状态决定，那么就将state抽象出来，在类中调用state的相应方法即可。类聚合的是state的实现类。</p>
<p>如果在一个类中，固定的几个方法都要根据不同的状态来做出不同的反映，那就把具体的状态给抽象出来，避免自己类的方法过于臃肿。如果自己类的方法会一直扩展，则不适合用State模式。</p>
<p>在设计模式书中的例子是，TCP连接中有open,listen,close等固定几个方法，根据TCP连接状态有不同的反应。</p>
<p>state类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">smile</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其具体的实现类为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonState</span> <span class="keyword">extends</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">smile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"people smile"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"people cry"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Person类中，聚合一个State，调用其相应方法就可以。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    State state = <span class="keyword">new</span> PersonState();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smile</span><span class="params">()</span></span>&#123;</span><br><span class="line">        state.smile();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span></span>&#123;</span><br><span class="line">        state.cry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有限状态机（FSM），就是不同有限的状态之间的迁移。state design pattens 与 state machine不一样。</p>
<p>线程的一个状态迁移就是有限状态机。</p>
<h3 id="解释器模式Intepreter"><a href="#解释器模式Intepreter" class="headerlink" title="解释器模式Intepreter"></a>解释器模式Intepreter</h3><p>动态脚本解析</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm</title>
    <url>/2020/03/21/jvm/</url>
    <content><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="JVM介绍"><a href="#JVM介绍" class="headerlink" title="JVM介绍"></a>JVM介绍</h2><p>Java Virtual Machine，JVM运行在操作系统上，与硬件没有直接的交互。</p>
<h3 id="JVM体系结构概览"><a href="#JVM体系结构概览" class="headerlink" title="JVM体系结构概览"></a>JVM体系结构概览</h3><img src="/2020/03/21/jvm/jvm%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" class title="This is an example image">

<p>JVM包括2个子系统和2个组件，2个子系统为类加载器和执行引擎，2个组件是运行时数据区和本地接口。</p>
<p>整个流程为，编译期将Java代码转为字节码，类加载器将字节码加载进运行数据区中的方法区中，执行引擎来进行解析为系统指令，交由CPU执行，需要调用其他语言的本地接口来实现功能。</p>
<p>亮色：所有线程共享，存在垃圾回收；</p>
<p>灰色：线程私有，不存在垃圾回收。</p>
<p>分为3层来学习。</p>
<p>先是类装载器与执行引擎。</p>
<a id="more"></a>

<h3 id="类装载器ClassLoader"><a href="#类装载器ClassLoader" class="headerlink" title="类装载器ClassLoader"></a>类装载器ClassLoader</h3>

<h4 id="介绍（是什么）"><a href="#介绍（是什么）" class="headerlink" title="介绍（是什么）"></a>介绍（是什么）</h4><p>负责加载class文件，class文件在文件<strong>开头有特定的文件标识</strong>（cafe babe），将class文件字节码内容加载到内存中，并将这些内容转换成<strong>方法区</strong>中的运行时数据结构，且ClassLoader只负责class文件的<strong>加载</strong>，至于其是否可以运行，由Execution Engine决定。</p>
<p>Car.class由ClassLoader装载进内存，Car Class装载进方法区，一个模板Car Class，可以产生多个实例。类装载器有多个，有以下几类</p>
<h4 id="种类（有哪些）"><a href="#种类（有哪些）" class="headerlink" title="种类（有哪些）"></a>种类（有哪些）</h4><p><strong>虚拟机自带的加载器</strong></p>
<ul>
<li><p><strong>启动类</strong>加载器（Boostrap）C++写的</p>
<p>Java的核心类库，提供JVM自身需要的类</p>
<ul>
<li>JAVA_HOME/jre/lib/rt.jar，resources.jar，或sun.boot.class.path</li>
</ul>
</li>
<li><p><strong>扩展类</strong>加载器（Extension）Java写的 </p>
<p>派生于ClassLoader，父类加载器为启动类加载器</p>
<ul>
<li>java.ext.dirs系统属性所指定的目录中加载</li>
<li>JDK安装目录的jre/lib/ext子目录加载，用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</li>
</ul>
</li>
<li><p><strong>应用程序类</strong>加载器（AppClassLoader）Java也叫系统类加载器，加载环境变量classpath的所有类或系统属性java.class.path指定路径下所有类</p>
<p>派生于ClassLoader，父类加载器为扩展类加载器</p>
<p>该类加载是程序中默认的类加载器</p>
</li>
</ul>
<p><strong>用户自定义加载器</strong></p>
<p>Java.lang.ClassLoader的子类，用户可以定义类的加载方式</p>
<p>为了获取到Class文件，有三种方式</p>
<p>1、Object类中的getClass()方法</p>
<p>2、类的class属性，如Object.class</p>
<p>3、Class中的方法，Class.forName(String className)</p>
<p>获取到Class文件后，通过getClassLoader()可以获取到ClassLoader。</p>
<p>如果类是系统自带的，为Boostrap加载器，启动时便加载进了内存，打印出来为null；如果为自定义的类，打印出来为AppClassLoader。lib/ext包下的文件为拓展包。</p>
<p>自定义类为Person，获取到其Class文件，打印其classLoader及父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">System.out.println(clazz.getClassLoader().getParent().getParent());</span><br><span class="line">System.out.println(clazz.getClassLoader().getParent());</span><br><span class="line">System.out.println(clazz.getClassLoader());</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">null</span></span><br><span class="line">sun.misc.Launcher$ExtClassLoader@<span class="number">16</span>d3586</span><br><span class="line">sun.misc.Launcher$AppClassLoader<span class="meta">@dad</span>5dc</span><br></pre></td></tr></table></figure>

<img src="/2020/03/21/jvm/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.png" class title="This is an example image">

<h4 id="双亲委派（怎么用）"><a href="#双亲委派（怎么用）" class="headerlink" title="双亲委派（怎么用）"></a>双亲委派（怎么用）</h4><p>简单来说先从父类寻找，找到了就用，找不到再找子类。类加载从Boostrap至Extension再到AppClassLoader。</p>
<p>如果自定义一个java.lang包下的String类，默认会在Boostrap的ClassLoader中先找这个类，但是在rt.jar包中的String没有自定义写的main方法，因此会报错。</p>
<p>设立目的是不让自己写的类污染Java自带的类，<strong>保障沙箱安全</strong>。</p>
<p>详细介绍为：当一个类收到了<strong>类加载请求</strong>，首先<strong>不会尝试自己去加载此</strong>类，而是将这个请求<strong>委托给父类去完成</strong>，每一个层次类加载器都如此，因此所有的加载请求都应该传送到启动类加载器中，只有当父类加载器反馈自己无法完成这个请求时（在其加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。</p>
<h4 id="沙箱安全（什么用）"><a href="#沙箱安全（什么用）" class="headerlink" title="沙箱安全（什么用）"></a>沙箱安全（什么用）</h4><p>保证了使用不同的类加载器，最终都是委托给<strong>顶层的启动类加载器进行加载</strong>，可以保障得到的类的安全性。</p>
<p>执行引擎负责解释命令，提交给操作系统执行。</p>
<h4 id="类装载的执行过程"><a href="#类装载的执行过程" class="headerlink" title="类装载的执行过程"></a>类装载的执行过程</h4><ol>
<li><p>加载：根据查找路径找到相应的class文件然后导入</p>
<ul>
<li>通过全限定名获取对应的二进制字节流</li>
<li>将此字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>内存中生成一个代表此类的<strong>java.lang.Class对象</strong>，作为方法区的这个类的各种数据访问入口</li>
</ul>
</li>
<li><p>验证：检查加载的class文件的正确性（CafeBaBe）</p>
</li>
<li><p>准备：给类中的<strong>静态变量</strong>分配内存空间并设置默认初始值</p>
<p>不包含用final修饰的static，因为其为常量，在编译阶段就分配了，准备阶段显示初始化</p>
<p>不为实例变量分配初始化，类变量分配在方法区，实例变量随Java对象一起分配到堆中</p>
</li>
<li><p>解析：虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用可理解为一个标识（字符串），在直接引用中直接指向内存的地址。此过程称为静态解析</p>
<p>常量池中的符号引用转为直接引用有类装载时候的静态解析和方法入栈时候的动态链接</p>
</li>
<li><p>初始化：对静态变量和静态代码块执行初始化过程</p>
<p>执行类构造器方法<code>&lt;clinit&gt;</code>()的过程，此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</p>
<p>构造器方法中的指令按语句在源文件中出现的顺序执行</p>
<p>若该类有父类，JVM会保证子类的<code>&lt;clinit&gt;</code>()执行前，父类的<code>&lt;clinit&gt;</code>()已经执行完毕</p>
<p>虚拟机需要保证一个类的<code>&lt;clinit&gt;</code>()方法在多线程下被<strong>同步加锁</strong></p>
</li>
</ol>
<p>其中验证、准备、解析属于链接阶段。</p>
<h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><p>自定义类加载器的目的</p>
<ul>
<li><p>隔离修改类</p>
<p>中间件的使用</p>
</li>
<li><p>修改类加载的方式</p>
</li>
<li><p>扩展加载源</p>
</li>
<li><p>防止源码泄漏</p>
</li>
</ul>
<p>步骤</p>
<ol>
<li>继承抽象类java.lang.ClassLoader，实现自己的类加载器</li>
<li>JDK1.2前重写loadClass()方法，之后不建议覆盖loadClass()方法，而是把自定义类的加载逻辑写在findClass()方法中</li>
<li>若没有太复杂的需求，可以直接继承URLClassLoader类，避免自己编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</li>
</ol>
<h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><ul>
<li>执行方法区</li>
<li>读取程序计数器中行号对应的指令</li>
<li>开辟线程执行GC</li>
</ul>
<h3 id="本地接口"><a href="#本地接口" class="headerlink" title="本地接口"></a>本地接口</h3><p>Java底层调用的方法为native方法，由<strong>本地方法接口</strong>提供，为了将其装载进内存并与普通方法区别，装载进特殊的栈中，即<strong>本地方法栈</strong>中（Native Method Stack）。方法具体的实现交给本地方法库。native是关键字，有声明，无实现。</p>
<p>本地接口的作用是融合不同编程语言为Java调用，在内存中专门开辟了区域处理标记为native方法，具体做法为Native Method Stack栈中登记native方法，在Execution Engine执行时加载<strong>本地方法库</strong>。目前该方法使用越来越少。</p>
<h3 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h3><p>记录了方法之间的调用与执行情况。该程序接下来要去哪。</p>
<p>每个线程都有程序计数器，是线程私有的，指向方法区中的方法字节码（<strong>正在执行的代码行号</strong>），此值被<strong>执行引擎</strong>赋值。内存空间很小，几乎可忽略（不存在GC），<strong>是当前线程所执行的字节码的行号指示器</strong>。若执行的为Native方法，计数器是空。不会发生内存溢出（OutOfMemory=OOM）错误。</p>
<p>便于执行<strong>线程的上下文切换</strong>，如果没有程序计数器，当切换到这个线程的时候，便不知道该执行哪行代码。</p>
<p>若执行的是native方法，则计数器为空。因为native方法通过其他语言来实现，没有通过Java自然也就没有对应的字节码行号。</p>
<p>CPU时间切片，线程去争抢时间片来执行，经常会出现线程的中断和恢复，如果不是线程私有而是共享，则没法保存当前线程执行的行号，不方便上下文切换，设置成线程私有，不会出现干扰的情况。 </p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>供线程共享的运行时内存区域，<strong>存储每一个类的结构信息</strong>（模板）。如运行时常量池（Runtime Constant Pool），字段和方法数据，构造函数和普通方法的字节码内容。</p>
<p>常量+静态变量+类信息。方法区中静态变量存储的是堆中对象的地址。</p>
<p>上面讲的是<strong>规范</strong>，不同虚拟机中实现不一样，最典型的为永久代（PermGen Space）和元空间（Metaspace）。</p>
<p>实例变量存在堆中，与方法区无关。</p>
<p>由字节码执行引擎去执行。</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈管运行，堆管存储。</p>
<p>栈（先进后出），队列（先进先出）。</p>
<p>当执行一个方法时，进行压栈；当方法结束后，执行出栈。</p>
<p>栈也叫栈内存，主管Java程序的运行，栈在线程创建时创建，栈的生命周期跟随线程，对于栈不存在垃圾回收问题。是线程私有的。<strong>8种基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存中分配</strong>。</p>
<p>栈帧：当一个方法入栈时，在栈中为其单独开辟一个空间，叫做栈帧，存放方法中的局部变量等。栈的数据结构为先进后出，结构与程序运行特点相符，先执行的方法后结束。</p>
<img src="/2020/03/21/jvm/%E6%A0%88%E5%B8%A7.png" class title="This is an example image">

<p>栈帧中有4部分</p>
<ul>
<li><p><strong>局部变量表</strong>：为局部变量开辟地址存储；对象地址（引用）</p>
<p>定义为<strong>数字数组</strong>，主要为存储<strong>方法参数</strong>和定义在方法体内的<strong>局部变量</strong></p>
<p>数据类型包括：基本数据类型，对象引用，及returnAddress类型</p>
<p>容量大小在编译期间确定</p>
</li>
<li><p><strong>操作数栈</strong>：存储操作数运算时需要的临时变量</p>
<p>常量的计算，给局部变量赋值，从局部变量表中取值运算</p>
</li>
<li><p><strong>动态链接</strong>：符号引用转为直接引用</p>
<p>这一步与类装载时均可以将符号引用转为直接引用，类装载时候的解析为静态加载，入栈时候为动态链接 ，也有说这一步实现了多态</p>
</li>
<li><p><strong>方法出口</strong>：指向此方法结束后应该跳转的方法出口</p>
</li>
</ul>
<h4 id="栈的存储"><a href="#栈的存储" class="headerlink" title="栈的存储"></a>栈的存储</h4><p>栈帧中主要存储3类数据</p>
<ul>
<li><strong>本地变量</strong>（Local Varibles）：输入参数和输出参数及方法内的变量</li>
<li>栈操作（Operand Stack）：记录出栈、入栈的操作</li>
<li>栈帧数据（Frame Data）：包括类文件、方法等等</li>
</ul>
<h4 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h4><p>每个<strong>方法</strong>执行的同时都会创建一个一个<strong>栈帧</strong>，先进后出，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。方法从调用到执行完毕的过程就对应着一个栈帧在虚拟机中入栈到出栈的过程。</p>
<p>栈的大小和具体的jvm实现相关，通常在256k-756k之间，<strong>约等于1Mb左右</strong>。</p>
<p>可以通过-Xss:设定每个线程虚拟机栈的大小，一般256k足够，会影响并发线程数的大小</p>
<p>Exception in Thread “main” java.lang.StackOverflowError</p>
<p>是Error错误，</p>
<p>Error与Exception父类为Throwable。</p>
<ul>
<li>如果线程请求栈的深度超过了虚拟机所允许的深度，报StackOverflowError</li>
<li>虚拟机栈可以动态扩展，如果扩展到无法申请足够的内存，会报OOM</li>
</ul>
<h4 id="栈-堆-方法区的交互"><a href="#栈-堆-方法区的交互" class="headerlink" title="栈+堆+方法区的交互"></a>栈+堆+方法区的交互</h4><p>HotSpot使用指针的方式来访问对象，栈中存放引用变量reference，存储对象的地址，Java堆中存放访问类元数据的地址（对象实例数据），方法区中存放对象类型数据。</p>
<h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><p>浅拷贝：增加一个指针指向已经存在的内存地址</p>
<p>深拷贝：增加一个指针且申请一个新的内存，使这个指针指向新的内存</p>
<h4 id="堆与栈的区别"><a href="#堆与栈的区别" class="headerlink" title="堆与栈的区别"></a>堆与栈的区别</h4><ul>
<li>物理地址：<strong>堆的物理地址分配不连续</strong>，<strong>栈的物理地址分配连续</strong></li>
<li>内存：堆因为不连续，分配内存在运行期间确定，大小不固定，一般远大于栈；栈为连续，分配内存在编译时确定，大小固定</li>
<li>存放内容：堆中存放对象的<strong>实例</strong>和<strong>数组</strong>，更关注数据的存储；栈中存放<strong>局部变量</strong>，<strong>对象引用</strong>，更关注方法运行</li>
<li>可见度：堆是所有线程共享的，栈是线程私有的，生命周期与线程相同</li>
</ul>
<p>静态变量放在方法区，静态对象放在堆中</p>
<h4 id="new对象发生的事情"><a href="#new对象发生的事情" class="headerlink" title="new对象发生的事情"></a>new对象发生的事情</h4><p>Student s = new Student()；</p>
<ol>
<li>加载Student.class进内存</li>
<li>在栈空间为s开辟空间</li>
<li>在堆空间为学生对象开辟空间</li>
<li>学生对象初始化</li>
<li>将对象地址赋值给s</li>
</ol>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>逻辑上三部分：新生+老年+元空间（7为永久代），物理上为新生+养老</p>
<ol>
<li>新生代（New）<ul>
<li>伊甸园区（Eden Space）</li>
<li>幸存者零区(Servivor 0 space)</li>
<li>幸存者一区(Servivor 1 space)</li>
</ul>
</li>
<li>老年代(Old，Tenure)</li>
<li><strong>元空间</strong>(Perm)</li>
</ol>
<p>一个jvm实例只存在一个堆内存，大小可调。类加载读取了类文件后，需要把类、方法 、常变量放到堆内存中。</p>
<p>Java7之前为<strong>永久代</strong>，Java8后为<strong>元空间</strong>。</p>
<h4 id="堆new对象流程"><a href="#堆new对象流程" class="headerlink" title="堆new对象流程"></a>堆new对象流程</h4><p>新建对象在Eden区，当一直new对象，<strong>Eden区达到阈值</strong>，进行<strong>MinorGC</strong>=轻GC，Eden区基本清空，第一次幸存后的对象移动到<strong>幸存者0区</strong>，也叫S0=from区。当S0满了再进行垃圾回收，从S0到S1=to区，S0与S1进行一次交换（<strong>from和to区，名称不是固定的，每次GC后会交换，谁空谁是to</strong>）。<strong>养老区满了</strong>，开启Major GC（Full GC），Major GC多次，老年代空间执行了Major GC后仍无法新建对象，报OOM异常。</p>
<p>如果出现java.lang.OutOfMemoryError:Java heap space异常，说明Java虚拟机堆内存不够，原因有</p>
<ol>
<li><strong>Java虚拟机的堆内存设置不够，可以通过参数-Xms，-Xmx调整</strong></li>
<li><strong>代码中创建了大量大对象，并且长时间不能被垃圾收集器手机（存在引用）</strong></li>
</ol>
<img src="/2020/03/21/jvm/%E6%96%B0%E7%94%9F%E5%85%BB%E8%80%81.png" class title="This is an example image">

<p><strong>新生代1/3</strong>堆空间，<strong>老年代2/3堆</strong>空间。新生代中，Eden8/10空间，From和To各1/10（<strong>8:1:1</strong>）。</p>
<h4 id="MinorGC（复制-gt-清空-gt-互换）"><a href="#MinorGC（复制-gt-清空-gt-互换）" class="headerlink" title="MinorGC（复制-&gt;清空-&gt;互换）"></a>MinorGC（复制-&gt;清空-&gt;互换）</h4><ol>
<li>eden、From复制到To，年龄+1</li>
</ol>
<p>当Eden区满的时候触发第一次GC，将活着的对象拷贝进From区，当Eden区再次触发GC的时候，扫描Eden区和From区，将这两个区域进行垃圾回收，经过这次回收后还存活的对象，直接复制到To区，（若有对象达到老年的标准，则复制到老年区），将这些对象的年龄+1。<strong>分代年龄</strong>记录在<strong>对象头</strong>的MarkWord中。</p>
<ol start="2">
<li>清空eden、from</li>
</ol>
<p>清空eden和from中的对象</p>
<ol start="3">
<li>from和to互换</li>
</ol>
<p>from和to互换，原to成为下一次的from，部分对象来from与to区域间来回复制，若交换15次（由JVM参数MaxTenuringThreashold决定，默认15）还活着进入老年代。</p>
<h4 id="永久代（jdk7前）"><a href="#永久代（jdk7前）" class="headerlink" title="永久代（jdk7前）"></a>永久代（jdk7前）</h4><p>方法区和堆一样，是线程共享的内存区域，虽然JVM规范将方法区描述为堆的一个逻辑部分，但其有别名为Non-Heap（非堆），目的是和堆分开。</p>
<p>堆HotSpot，很多开发者习惯将方法区称之为永久代，但严格本质上说二者不同，或者说使用永久代来实现方法区而已，永久代是方法区（相当于一个接口）的实现。jdk1.7中将原本在永久代的字符串常量池移走。</p>
<img src="/2020/03/21/jvm/%E6%B0%B8%E4%B9%85%E5%8C%BA.png" class title="This is an example image">

<p>永久存储区是一个常驻内存区域，用于存放jdk自身携带的Class，Interface的元数据，存储的是运行环境必须的信息，被装载进此区域的数据不会被GC，关闭JVM才会释放此空间的内存。</p>
<h4 id="堆参数调整"><a href="#堆参数调整" class="headerlink" title="堆参数调整"></a>堆参数调整</h4><img src="/2020/03/21/jvm/%E5%A0%86%E5%8F%82%E6%95%B0.png" class title="This is an example image">

<p>上面为jdk7的堆的图，逻辑上分为3块，但物理上堆只包括新生与老年。</p>
<p>调整物理上堆的参数</p>
<ul>
<li>-Xms：初始大小start</li>
<li>-Xmx：最大大小max</li>
</ul>
<p>调整新生代的参数</p>
<ul>
<li>-Xmn：new区，一般不调</li>
</ul>
<img src="/2020/03/21/jvm/%E5%A0%86%E5%8F%82%E6%95%B02.png" class title="This is an example image">

<p>Minor GC针对年轻代，Major GC针对老年代。</p>
<p>JDK8将永久代取消，改为<strong>元空间</strong>。</p>
<p>永久代与元空间区别在于：</p>
<ul>
<li>永久代使用JVM的堆内存</li>
<li><strong>元空间不在虚拟机中而是使用本机物理内存</strong></li>
</ul>
<p>默认情况下元空间大小仅受<strong>本地内存</strong>限制。类的元数据放入native memory，字符串池和类的静态变量放入java堆中，这样可以加载多少类的元数据不再由MaxPermSize控制，而是由系统的实际可用空间来控制。</p>
<table>
<thead>
<tr>
<th>-Xms</th>
<th>设置初始分配大小，默认为物理内存的“1/64”</th>
</tr>
</thead>
<tbody><tr>
<td>-Xmx</td>
<td>最大分配内存，默认为物理内存的“1/4”</td>
</tr>
<tr>
<td>-XX:+PrintGCDetails</td>
<td>输出详细的GC处理日志</td>
</tr>
<tr>
<td>-XX:NewRatio=4</td>
<td>设置年轻代与老年代的比例为1:4</td>
</tr>
<tr>
<td>-XX:SurvivorRatio=8</td>
<td>设置新生代Eden和Survivor区比例为8:2</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold</td>
<td>从年代到到老年代经过GC次数阈值，默认15</td>
</tr>
</tbody></table>
<p>将运行时数据区区（方法区、堆、栈、计数器、本地方法栈）抽象为Runtime类，其实例通过getRun()方法获取。</p>
<p>其设计为单例设计模式中的<strong>饿汉式</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Runtime</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数阅览为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取CPU核数</span></span><br><span class="line">      System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">      <span class="comment">//返回Java虚拟机试图使用的最大内存量</span></span><br><span class="line">      <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory();</span><br><span class="line">      <span class="comment">//返回Java虚拟机中的内存总量</span></span><br><span class="line">      <span class="keyword">long</span> totalMemory = Runtime.getRuntime().totalMemory();</span><br><span class="line">      System.out.println(<span class="string">"MAX_MEMORY="</span>+maxMemory+<span class="string">"字节、"</span>+(maxMemory/(<span class="keyword">double</span>)<span class="number">1024</span>/<span class="number">1024</span>)+<span class="string">"MB"</span>);</span><br><span class="line">      System.out.println(<span class="string">"TOTAL_MEMORY="</span>+totalMemory+<span class="string">"字节、"</span>+(totalMemory/(<span class="keyword">double</span>)<span class="number">1024</span>/<span class="number">1024</span>)+<span class="string">"MB"</span>);</span><br></pre></td></tr></table></figure>

<p>实际中需要将<strong>初始内存和最大内存设置为相同</strong>，避免内存不稳定产生停顿。</p>
<h4 id="OOM异常"><a href="#OOM异常" class="headerlink" title="OOM异常"></a>OOM异常</h4><p>当一个线程发生了OOM异常后，另一个线程是可以正常执行的，因为发生OOM异常的线程会清空其堆内存，不影响其他线程的使用。</p>
<h3 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h3><p>调优的目的：减少full gc，减少stop-the-world时间。</p>
<p>让朝生夕死的对象，尽量在年轻代被minor gc，而少在老年代被full gc。方法之一为调整年轻代与老年代的内存分配比例。</p>
<h4 id="常见jvm参数"><a href="#常见jvm参数" class="headerlink" title="常见jvm参数"></a>常见jvm参数</h4><blockquote>
<p>来源于马士兵老师课程笔记</p>
</blockquote>
<p>JVM的命令行参数参考：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p>
<p>HotSpot参数分类</p>
<blockquote>
<p>标准： - 开头，所有的HotSpot都支持</p>
<p>非标准：-X 开头，特定版本HotSpot支持特定命令</p>
<p>不稳定：-XX 开头，下个版本可能取消</p>
</blockquote>
<p>为了在发生OOM异常时，将堆信息dump出来，使用如下命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:\dump</span><br></pre></td></tr></table></figure>

<h4 id="调优前概念"><a href="#调优前概念" class="headerlink" title="调优前概念"></a>调优前概念</h4><ul>
<li>吞吐量：用户代码时间/（用户代码执行时间+垃圾回收时间）</li>
<li>响应时间：Stop-the-World时间越短，响应时间越好</li>
</ul>
<p>需要确定是吞吐量优先还是响应时间优先。</p>
<p>吞吐量优先的一般为：Pareller Scanvenge + Pareller Old</p>
<ul>
<li>科学计算</li>
<li>吞吐量</li>
<li>数据挖掘</li>
</ul>
<p>响应时间优先：1.8后为G1</p>
<ul>
<li>网站GUI API</li>
</ul>
<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><h2 id="Java内存泄漏"><a href="#Java内存泄漏" class="headerlink" title="Java内存泄漏"></a>Java内存泄漏</h2><p>内存泄漏指的是不被使用的对象或内存一直占据着内存，理论上来说Java有GC垃圾回收，即不再被使用的对象会被垃圾回收，从内存中清除。</p>
<p>但即使这样也会存在内存泄漏，长生命周期的对象持有者短生命周期对象的引用，虽然短生命周期的对象不再需要，但因为场面生命周期的对象持有着他的引用而导致不能被回收。</p>
<h2 id="GC收集日志信息"><a href="#GC收集日志信息" class="headerlink" title="GC收集日志信息"></a>GC收集日志信息</h2><p>在IDEA中，使用Configuration中的VM options来配置</p>
<p>注意：-Xms与数字1024m中间没有空格，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xms:<span class="number">1024</span>m -Xmx:<span class="number">1024</span>m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>

<img src="/2020/03/21/jvm/%E5%A0%86%E4%BF%A1%E6%81%AF.png" class title="This is an example image">

<p>可以看到堆由年轻代，老年代与MetaSpace（元空间）组成。</p>
<h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"java"</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    str += str + <span class="keyword">new</span> Random().nextInt(<span class="number">88888888</span>) + <span class="keyword">new</span> Random().nextInt(<span class="number">999999999</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后设置-Xms10m -Xmx10m，得到如下结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>

<img src="/2020/03/21/jvm/OOM.png" class title="This is an example image">

<p>可以看到先GC，后Full GC。</p>
<p>XX:+PrintGCDatails</p>
<h3 id="日志解读"><a href="#日志解读" class="headerlink" title="日志解读"></a>日志解读</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: <span class="number">2595</span>K-&gt;<span class="number">320</span>K(<span class="number">3072</span>K), <span class="number">0.0023459</span> secs] <span class="number">2595</span>K-&gt;<span class="number">743</span>K(<span class="number">9920</span>K), <span class="number">0.0024277</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br></pre></td></tr></table></figure>

<p>具体意思是：这次GC因为分配失败，发生在新生代，GC前内新生代内存占用2595k，GC后内存占用320k，新生代总共大小3072k（设置的10M的1/3），GC前堆内存占用2595k，GC后堆内存占用743k，JVM堆内存共有9920k，共耗时0.0024277秒，后面为用户、系统、实际耗时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [Tenured: 4684K-&gt;4580<span class="title">K</span><span class="params">(<span class="number">6848</span>K)</span>, 0.0037896 secs] 4684K-&gt;4580<span class="title">K</span><span class="params">(<span class="number">9920</span>K)</span>, [Metaspace: 2106K-&gt;2106<span class="title">K</span><span class="params">(<span class="number">4480</span>K)</span>], 0.0038318 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br></pre></td></tr></table></figure>

<p>具体意思是：回收前老年代4684k，回收后4580k，老年代总内存大小为6848k。 JVM堆内存公有9920k。</p>
<p>规律：【名称：GC前内存大小-&gt;GC后内存占用（该区总内存大小）</p>
<p>System.gc()显式调用系统的GC，并不是马上回收。一般不要用！</p>
<h2 id="GC介绍"><a href="#GC介绍" class="headerlink" title="GC介绍"></a>GC介绍</h2><p>GC为垃圾回收机制（分代收集算法）</p>
<ul>
<li>次数上频繁收集年轻代</li>
<li>次数上较少收集老年代</li>
<li>基本不动元空间</li>
</ul>
<p>JVM在GC时，大部分回收的是年轻代，GC按照回收的区域分为普通GC（minor GC）和全局GC（major GC or Full GC）。</p>
<h3 id="Minor-GC和Full-GC区别"><a href="#Minor-GC和Full-GC区别" class="headerlink" title="Minor GC和Full GC区别"></a>Minor GC和Full GC区别</h3><ul>
<li>普通GC（Minor GC）：只针对年轻代区域，因为大多数Java对象存活率不高，因此Minor GC非常频繁，一般回收速度也较快</li>
<li>全局GC（Full GC）：发生在老年代的垃圾回收机制，出现了Major GC，经常会伴随至少一次的Minor GC（不绝对）。<strong>Major GC的速度一般比Minor GC慢10倍以上</strong>。</li>
</ul>
<h3 id="对象可达性分析"><a href="#对象可达性分析" class="headerlink" title="对象可达性分析"></a>对象可达性分析</h3><h4 id="引用计数法（ReferenceCount）"><a href="#引用计数法（ReferenceCount）" class="headerlink" title="引用计数法（ReferenceCount）"></a>引用计数法（ReferenceCount）</h4><ul>
<li>判断对象的引用数量</li>
<li>每个对象实例有引用计数器，被引用+1，完成引用-1</li>
<li>任何引用为0的对象实例可被垃圾回收</li>
<li>优点：效率高</li>
<li>缺点：维护引用计数器，无法解决相互引用，主流JM并未使用</li>
</ul>
<h4 id="根可达算法（Rootearching）"><a href="#根可达算法（Rootearching）" class="headerlink" title="根可达算法（Rootearching）"></a>根可达算法（Rootearching）</h4><p>判断对象的引用链是否可达来决定对象是否被回收，从图论引入。从名为GC Roots的对象作为起始点，从这些节点向下搜索，搜素走过的路径就是引用链，若一个节点与GC Roots间没有引用链，则被判断为不可达的。</p>
<p>从Root开始，将所有可达的对象进行标记，标记完后不可达的对象就是垃圾。</p>
<p>可以用作GC Root的对象</p>
<ul>
<li><p>虚拟机栈中引用的对象</p>
<p>如方法中引用到的对象</p>
</li>
<li><p>方法区中的常量引用的对象</p>
<p>方法区中定义的常量为对象地址，被保存的对象可以是root</p>
</li>
<li><p>方法区中类静态属性引用的对象</p>
</li>
<li><p>本地方法栈中Native方法引用的对象</p>
</li>
<li><p>活跃现成的引用对象</p>
</li>
</ul>
<h2 id="4大算法"><a href="#4大算法" class="headerlink" title="4大算法"></a>4大算法</h2><ol>
<li><p>引用计数法（微软的COM/ActionScript3/Python）</p>
<p>对象的引用为0时回收</p>
<ul>
<li>需要维护引用计数器，且计数器本身有一定消耗；</li>
<li>较难处理循环引用。</li>
<li>JVM实现一般不采用这种方式</li>
</ul>
</li>
<li><p>复制算法（Copying）</p>
<p>用在<strong>年轻代</strong>中，Minor GC，复制-交换-清除，前提是大部分对象可以被清除</p>
<p>-XX:MaxTenuringThreshold-设置对象在新生代中存活次数，默认15</p>
<p>优点：<strong>不会产生内存碎片</strong>，速度快</p>
<p>缺点：</p>
<ul>
<li><strong>浪费一半空间</strong></li>
<li>若对象存活率很高，复制非常花时间（老年代对象存活率高，不适合用）</li>
</ul>
</li>
<li><p>标记清除（Mark-Sweep）</p>
<p><strong>老年代</strong>一般是标记清除或标记清除与与标记整理（压缩）的混合实现</p>
<p>分为标记和清除两个阶段，先标记出要回收的对象，然后统一回收这些对象</p>
<p>优点：不需要额外空间</p>
<p>缺点：</p>
<ul>
<li>两次扫描，<strong>耗时严重</strong></li>
<li>会产生<strong>内存碎片</strong></li>
</ul>
</li>
<li><p>标记压缩（Mark-Compact）</p>
<p><strong>老年代</strong>一般是标记清除或标记清除与与标记整理（压缩）的混合实现</p>
<p>也叫标记清除压缩</p>
<p>标记和标记清除一样，压缩，再次扫描，往一段滑动存活对象</p>
<p>优点：没有内存碎片</p>
<p>缺点：需要移动对象的成本，效率不高</p>
<p>可以结合标记清除与标记压缩，进行多次标记清除GC后，再进行标记压缩</p>
</li>
</ol>
<p>没有最好的算法，根据不同代的特点用不同的垃圾收集算法。即<strong>分代收集算法</strong>。</p>
<p>内存效率：复制算法&gt;标记清除算法&gt;标记压缩算法（简单比较时间复杂度，实际不一定）</p>
<p>内存整齐度：复制算法=标记压缩算法&gt;标记清除算法</p>
<p>内存利用率：标记压缩算法=标记清除算法&gt;复制算法</p>
<h2 id="常见垃圾收集器"><a href="#常见垃圾收集器" class="headerlink" title="常见垃圾收集器"></a>常见垃圾收集器</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>介绍垃圾收集器前需要介绍两个常见概念，stop the world和Safepoint，与垃圾收集器的工作过程相关</p>
<h4 id="Stop-the-World"><a href="#Stop-the-World" class="headerlink" title="Stop-the-World"></a>Stop-the-World</h4><ul>
<li>JVM由于要执行GC，需要将应用程序停止</li>
<li>所有的GC算法中都会发生</li>
<li>多数GC优化通过减少stop-the-world时间来提升性能，达到高吞吐量、少停顿的特点</li>
</ul>
<p>为什么要stop the world？</p>
<p>若没有stop-the-world，可能之前可达的对象因为应用程序的继续进行而变成浮动的不可达对象，这样需要重新进行标记，增加了GC算法的难度，降低程序性能，因此使用stop-the-point，可以减少GC算法复杂度。</p>
<h4 id="Safepoint"><a href="#Safepoint" class="headerlink" title="Safepoint"></a>Safepoint</h4><p>在GC时，程序不是随便停止，而是在Safepoint停止</p>
<ul>
<li><p>分析过程中对象引用关系不发生变化的点</p>
</li>
<li><p>产生的地方：方法调用，循环跳转，异常跳转等</p>
</li>
<li><p>安全点数量得适中</p>
<p>太少会让GC等太久，太多会增加程序运行的负担</p>
</li>
</ul>
<h3 id="常见收集器"><a href="#常见收集器" class="headerlink" title="常见收集器"></a>常见收集器</h3><img src="/2020/03/21/jvm/%E6%94%B6%E9%9B%86%E5%99%A8.png" class title="This is an example image">

<p>图中为常见的JVM收集器，用实线相连代表可以搭配使用</p>
<p><strong>1.8默认是Paraller Scavenge+ParallerOld</strong></p>
<h3 id="年轻代常见收集器"><a href="#年轻代常见收集器" class="headerlink" title="年轻代常见收集器"></a>年轻代常见收集器</h3><h4 id="Serial收集器（-XX-UseSerialGC，复制算法）"><a href="#Serial收集器（-XX-UseSerialGC，复制算法）" class="headerlink" title="Serial收集器（-XX:+UseSerialGC，复制算法）"></a>Serial收集器（-XX:+UseSerialGC，复制算法）</h4><p>最基本也最悠久的，单线程，进行垃圾收集时<strong>停止所有工作线程</strong></p>
<p>Client模式下年轻代默认的</p>
<p><strong>Serial + Serial Old的组合</strong>，用于<strong>小型</strong>程序，<strong>几十兆</strong>内存</p>
<img src="/2020/03/21/jvm/%E5%B9%B4%E8%BD%BB1.png" class title="This is an example image">

<h4 id="ParNew收集器（-XX-UseParNewGC，复制算法）"><a href="#ParNew收集器（-XX-UseParNewGC，复制算法）" class="headerlink" title="ParNew收集器（-XX:+UseParNewGC，复制算法）"></a>ParNew收集器（-XX:+UseParNewGC，复制算法）</h4><p>多线程收集，多核下比Serial有优势</p>
<p>在Server模式下非常重要，与Serial一样均可配合CMS使用</p>
<p>PerNew + SerialOld组合，很少使用</p>
<img src="/2020/03/21/jvm/%E5%B9%B4%E8%BD%BB2.png" class title="This is an example image">

<h4 id="Paraller-Scavenge-XX-UseParallelGC，复制算法"><a href="#Paraller-Scavenge-XX-UseParallelGC，复制算法" class="headerlink" title="Paraller Scavenge(-XX:+UseParallelGC，复制算法)"></a>Paraller Scavenge(-XX:+UseParallelGC，复制算法)</h4><p>ParellerOld + Pareller Scanvenge，1.8默认</p>
<p>前面两个更关注系统的停顿时间，此收集器更关注系统的吞吐量（执行用户线程时间/CPU总执行时间），适合后台运算不需要太多交互的情况</p>
<p>多核下执行有优势，Server下默认的年轻代收集器</p>
<p>不能与CMS搭配使用，因为框架不兼容</p>


<h3 id="老年代常见收集器"><a href="#老年代常见收集器" class="headerlink" title="老年代常见收集器"></a>老年代常见收集器</h3><h4 id="SerialOld（-XX-UseSerialOldGC，标记整理算法）"><a href="#SerialOld（-XX-UseSerialOldGC，标记整理算法）" class="headerlink" title="SerialOld（-XX:+UseSerialOldGC，标记整理算法）"></a>SerialOld（-XX:+UseSerialOldGC，标记整理算法）</h4><p>Serial GC的老年代版本，单线程收集</p>
<p><strong>Client</strong>模式下默认的老年代收集器 </p>
<img src="/2020/03/21/jvm/%E8%80%81%E5%B9%B41.png" class title="This is an example image">

<h4 id="ParellerOld（-XX-UseParellerOldGC，标记整理算法）"><a href="#ParellerOld（-XX-UseParellerOldGC，标记整理算法）" class="headerlink" title="ParellerOld（-XX:+UseParellerOldGC，标记整理算法）"></a>ParellerOld（-XX:+UseParellerOldGC，标记整理算法）</h4><p>ParellerOld + Pareller Scanvenge，1.8默认【PS + SerialOld】</p>
<p>多线程，吞吐量优先，配合ParallerScavenge使用</p>
<h4 id="CMS（-XX-UseConcMarkSweepGC，标记清除算法）"><a href="#CMS（-XX-UseConcMarkSweepGC，标记清除算法）" class="headerlink" title="CMS（-XX:+UseConcMarkSweepGC，标记清除算法）"></a>CMS（-XX:+UseConcMarkSweepGC，标记清除算法）</h4><p><strong>Parnew + CMS + SerialOld</strong></p>
<p>Concurrent Mark Sweep收集器，适用于程序对停顿比较敏感的情况，号称“<strong>最短用户停顿时间</strong>”，适合用在互联网站或者B/S系统服务器上。</p>
<img src="/2020/03/21/jvm/cms.png" class title="This is an example image">

<ul>
<li><strong>初始标记</strong>：标记处GC Roots直接关联到的对象，速度较快，<strong>需要停顿</strong></li>
<li>并发标记：进行GC Roots Tracing，标记出全部的垃圾对象，与应用线程一起</li>
<li>并发预清理：查找执行并发标记阶段从年轻代晋升至老年代对象，减少重新标记工作</li>
<li><strong>重新标记</strong>：修正并发标记期间对象变化情况，<strong>需要停顿</strong>，较慢</li>
<li>并发清除：标记清除算法清除标记</li>
<li>并发重置：重置CMS收集器的数据结构</li>
</ul>
<p>问题是不压缩存活对象，有碎片化问题。当碎片达到一定程度，CMS老年代分配对象分配不下时，使用SerialOld进行老年代回收。问题较多，没有一个版本默认，需要手工指定。</p>
<h4 id="堆内存垃圾收集G1（-XX-UseG1GC，复制-标记整理算法）"><a href="#堆内存垃圾收集G1（-XX-UseG1GC，复制-标记整理算法）" class="headerlink" title="堆内存垃圾收集G1（-XX:+UseG1GC，复制+标记整理算法）"></a>堆内存垃圾收集G1（-XX:+UseG1GC，复制+标记整理算法）</h4><p>用于年轻代与老年代，为了替代CMS。JDK9默认。</p>
<ul>
<li>并行和并发的：采用多个CPU缩短stop-the-world停顿时间，与用户线程并发执行</li>
<li>分代收集：采用不同方式处理新建对象和存活一段时间对象收集</li>
<li>空间整合：基于标记整理，解决了碎片化问题</li>
<li>可预测的停顿：让使用者指定停顿时间</li>
</ul>
<p>将整个Java堆内存划分为多个region，年轻代与老年代不再物理隔离。</p>
<h2 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h2><h3 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a>VisualVM</h3><p>在IDEA的插件中安装VisualVM，在VisualVM中依照官网给的插件网址更新插件下载url，安装Visual GC插件。</p>
<p>可以看到具体的GC情况。</p>
<img src="/2020/03/21/jvm/gc.png" class title="This is an example image">

<p>可以看到具体的GC次数，每个区域剩余的空间。</p>
<img src="/2020/03/21/jvm/vmoom.png" class title="This is an example image">

<p>可以具体看到，在Eden区发生了20次GC，在Old区发生了11次GC，老年代Full GC次数更少，但是消耗的时间更长，老年代内存占用达到了73%，然后发生了OOM</p>
<p>为了具体分析OOM异常，可以在run，VM设置中加上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:\dump</span><br></pre></td></tr></table></figure>

<p>这样会在指定的路径生成OOM异常后的dump文件，文件名为</p>
<p>java_pid12332.hprof</p>
<p>指明了是java的12332进程出现的。</p>
<p>然后在VisualVM中，装载此文件，打开如下</p>
<img src="/2020/03/21/jvm/mainoom.png" class title="This is an example image">

<p>可以看到是主线程中发生了OOM异常，点进去看到</p>
<img src="/2020/03/21/jvm/sboom.png" class title="This is an example image">

<p>发现是StringBuilder中的添加方法出现了问题，进一步点进去分析</p>
<img src="/2020/03/21/jvm/%E5%80%BCoom.png" class title="This is an example image">

<p>可以看到具体的出问题的变量值，这样便可以找到相应的位置，去进行修改。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="强引用、软引用、弱引用、虚引用"><a href="#强引用、软引用、弱引用、虚引用" class="headerlink" title="强引用、软引用、弱引用、虚引用"></a>强引用、软引用、弱引用、虚引用</h3><p>不同的引用下GC不同</p>
<p>设置：-Xms:10m -Xmx:10m -XX:+PrintGCDetails</p>
<h4 id="强引用（Strong-Reference）"><a href="#强引用（Strong-Reference）" class="headerlink" title="强引用（Strong Reference）"></a>强引用（Strong Reference）</h4><ul>
<li>最普遍的引用：Object o = new Object();</li>
<li>只有对象不被引用时才被回收</li>
<li>若仍被引用，抛出OOM异常程序也不会回收具有强引用的对象</li>
<li>将对象设置为null来弱化引用，使其被回收，或等待其生命周期结束</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"java"</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">   str += str + <span class="keyword">new</span> Random().nextInt(<span class="number">88888888</span>) + <span class="keyword">new</span> Random().nextInt(<span class="number">999999999</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: <span class="number">2669</span>K-&gt;<span class="number">0</span>K(<span class="number">3072</span>K), <span class="number">0.0007536</span> secs][Tenured: <span class="number">5998</span>K-&gt;<span class="number">4663</span>K(<span class="number">6848</span>K), <span class="number">0.0019593</span> secs] <span class="number">5998</span>K-&gt;<span class="number">4663</span>K(<span class="number">9920</span>K), [Metaspace: <span class="number">2106</span>K-&gt;<span class="number">2106</span>K(<span class="number">4480</span>K)], <span class="number">0.0027569</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"></span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [Tenured: 4663K-&gt;4559<span class="title">K</span><span class="params">(<span class="number">6848</span>K)</span>, 0.0024536 secs] 4663K-&gt;4559<span class="title">K</span><span class="params">(<span class="number">9920</span>K)</span>, [Metaspace: 2106K-&gt;2106<span class="title">K</span><span class="params">(<span class="number">4480</span>K)</span>], 0.0024861 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>

<p>会报OOM异常，先GC，最后Full GC，不能将强引用的对象强制回收</p>
<h4 id="软引用（Soft-Reference）"><a href="#软引用（Soft-Reference）" class="headerlink" title="软引用（Soft Reference）"></a>软引用（Soft Reference）</h4><ul>
<li><p>对象处在有用但非必须的状态</p>
</li>
<li><p>当<strong>内存空间不足</strong>，GC会回收该引用的对象的内存</p>
</li>
<li><p>可以用来实现内存敏感的高速<strong>缓存</strong></p>
<p>将经常用到的内容放在缓存中，提高效率，但如果空间不足，GC时可以将此软引用指向的对象进行回收，节省空间。兼顾时间与空间的效率。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SoftReference&lt;byte[]&gt; m &#x3D;  new SoftReference&lt;&gt;(new byte[1024*1024*10]);</span><br><span class="line">m.get();</span><br></pre></td></tr></table></figure>

<p>m与SoftRefence（sr）对象强引用，sr与定义的字符数组虚引用，通过m.get()方法可以获得其引用。</p>
<p>下面看其被GC情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"java"</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    SoftReference&lt;String&gt; str2 = <span class="keyword">new</span> SoftReference&lt;String&gt;(str + <span class="keyword">new</span> Random().nextInt(<span class="number">88888888</span>) + <span class="keyword">new</span> Random().nextInt(<span class="number">999999999</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: <span class="number">2752</span>K-&gt;<span class="number">0</span>K(<span class="number">3072</span>K), <span class="number">0.0002984</span> secs] <span class="number">3327</span>K-&gt;<span class="number">575</span>K(<span class="number">9920</span>K), <span class="number">0.0003464</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br></pre></td></tr></table></figure>

<p>可以看到，没有老年代的GC信息。</p>
<p>不会报OOM异常，会一直GC，没有Full GC。</p>
<h4 id="弱引用（Weak-Reference）"><a href="#弱引用（Weak-Reference）" class="headerlink" title="弱引用（Weak Reference）"></a>弱引用（Weak Reference）</h4><ul>
<li>非必须引用的对象，比软引用更弱</li>
<li>GC时会被回收（无论当前线程是否紧缺）</li>
<li>被回收的概率也不大，因为GC线程优先级较低</li>
<li>适用于偶尔被使用且不影响垃圾回收的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WeakRference&lt;M&gt; m =  <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> M());</span><br><span class="line">m.get();</span><br></pre></td></tr></table></figure>

<p>使用m.get()方法可以得到其引用。</p>
<p>在ThreadLocal中的Entry里，key对ThreadLocal对象为弱引用，可以防止内存泄漏。</p>
<h4 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h4><p>Phantom虚幻的，使用get()方法得不到。</p>
<ul>
<li>不会决定对象的生命周期</li>
<li>任何时候都可能被垃圾收集器回收</li>
<li>跟踪对象被垃圾收集器回收的活动，起哨兵作用</li>
<li>必须和引用队列ReferenceQueue联合使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"java"</span>;</span><br><span class="line">ReferenceQueue&lt;String&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">PhantomReference&lt;String&gt; pr = <span class="keyword">new</span> PhantomReference&lt;&gt;(str,queue);</span><br></pre></td></tr></table></figure>

<p>通过判断队列中是否加入了虚引用来了解被引用的对象是否被GC。</p>
<p>作用是<strong>管理堆外内存</strong>，在传统的网络通信中，网卡数据写给OS，OS写入Buffer中，再复制给JVM，JVM要向网络传输数据，先 复制到OS的Buffer中，再写给网卡。这个Buffer复制到JVM的过程是不必要的，在NIO中，提供了直接内存管理或堆外内存管理。利用JVM管理操作系统中的堆外内存，不用再次拷贝，称为zerocopy，提高效率。有对象DirectByteBuffer来指向堆外内存，为了方便回收堆外内存的垃圾回收，给DirectByteBuffer加上虚引用，配合队列使用，当队列中有内容，说明DirectByteBuffer有对象被回收，需要相应清理堆外内存。</p>
<h3 id="对象何时进入老年代"><a href="#对象何时进入老年代" class="headerlink" title="对象何时进入老年代"></a>对象何时进入老年代</h3><p>一般新建对象时发生在Eden区，但是某些情况对象会进入到老年代</p>
<ol>
<li><p>新建大对象（需要大量连续内存空间的对象，如很长的字符串或数组）直接进入老年代</p>
</li>
<li><p>长期存活对象进入老年代（默认对象年龄为15进入,如静态常量）</p>
</li>
<li><p>survivor区空间不足（相同年龄的所有对象大小总和大于Survivor空间<strong>一半</strong>)</p>
<p>这个比例可以通过-XX:TargetSurvivorRatio指定</p>
<p>这一步称为对象动态年龄判断，规则是希望可能长期存活的对象今早进入老年代。此机制一般在minor gc后触发。</p>
<p>一些朝生夕死对象，因为survivor区域设置不足，而直接放入老年代，而频繁进行full gc，这种情况可以调大年轻代空间，改变年轻代与老年代比例。-XX:NewRatio，调小。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>哈夫曼树</title>
    <url>/2020/03/06/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
    <content><![CDATA[<p>写这篇博客源自于之前做了一道哈夫曼编码的题，但是当时哈夫曼树的知识已经遗忘了，因此没有做出来。后来在学习左神的算法的时候，复习到了切金条的问题，其中用到了哈夫曼树，因此趁此机会在网上学习了哈夫曼树的相关知识并自己动手用Java实现了相关操作，记录在博客中，方便日后查阅。</p>
<blockquote>
<p>参考博客：<code>https://www.cnblogs.com/kubixuesheng/p/4397798.html</code></p>
</blockquote>
<a id="more"></a>

<h1 id="什么是哈夫曼树"><a href="#什么是哈夫曼树" class="headerlink" title="什么是哈夫曼树"></a>什么是哈夫曼树</h1><p>要学习哈夫曼树，首先要知道哈夫曼树是什么，为什么要用哈夫曼树。</p>
<h2 id="问题场景：判断结构"><a href="#问题场景：判断结构" class="headerlink" title="问题场景：判断结构"></a>问题场景：判断结构</h2><p>如果要使用条件判断将百分制成绩转换为等级输出，可以写多个if else语句，将其判断逻辑用一个树来表示，其中越接近树顶层的结果越容易获取到，假如有如下的分数段分布情况</p>
<table>
<thead>
<tr>
<th>分数</th>
<th>0-59</th>
<th>60-69</th>
<th>70-79</th>
<th>80-89</th>
<th>90-100</th>
</tr>
</thead>
<tbody><tr>
<td>比例</td>
<td>0.05</td>
<td>0.15</td>
<td>0.40</td>
<td>0.30</td>
<td>0.10</td>
</tr>
</tbody></table>
<p>为了写出判断每个学生分数区间的代码，可以有如下两种构造方式</p>
<p>构造方式1</p>
<img src="/2020/03/06/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/%E6%9E%84%E9%80%A01.png" class title="This is an example image">

<p>构造方式2</p>
<img src="/2020/03/06/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/%E6%9E%84%E9%80%A02.png" class title="This is an example image">

<p>这样第一种方式的判断次数要多余第二种方式，原因是假设头节点高度为0，越往下高度越高，节点所在的高度越高，则找到此节点所需要的工作量越大。这时候为了找到一种效率最高的判别树，便找到了哈夫曼树。</p>
<h2 id="哈夫曼树有关概念"><a href="#哈夫曼树有关概念" class="headerlink" title="哈夫曼树有关概念"></a>哈夫曼树有关概念</h2><p>路径：在一棵树中，从一个结点到另一个结点的通路。</p>
<p>路径长度：路径上的结点个数-1。</p>
<p>结点的权：路径上的值，可以理解为节点的距离，通常指字符对应的二进制编码出现的概率。</p>
<p>树的路径长度：从树根节点到每一个叶结点的路径长度之和。</p>
<p>结点的带权路径长度：该结点到树根的路径长度与该结点上权的乘积</p>
<p>树的带权路径长度：所有的结点带权路径长度之和。</p>
<p>哈夫曼树就是树的带权路径长度最短的二叉树。</p>
<h1 id="如何得到一棵哈夫曼树"><a href="#如何得到一棵哈夫曼树" class="headerlink" title="如何得到一棵哈夫曼树"></a>如何得到一棵哈夫曼树</h1><h2 id="哈夫曼树构造算法"><a href="#哈夫曼树构造算法" class="headerlink" title="哈夫曼树构造算法"></a>哈夫曼树构造算法</h2><ol>
<li>根据给定的带权值的结点构成二叉树集合，每个二叉树只有一个带权值的结点，左右子树为空</li>
<li>在集合中选取权值最小的两个二叉树重新构造一个二叉树，新的二叉树的权值为两个二叉树权值之和</li>
<li>在集合中删除取出的两个二叉树，将新的二叉树放入</li>
<li>重复步骤2,3直到只有一棵二叉树</li>
</ol>
<p>这样便得到了一棵哈夫曼树。</p>
<p>要注意的是，具有相同带权结点的哈夫曼树不唯一。</p>
<h1 id="哈夫曼树的应用"><a href="#哈夫曼树的应用" class="headerlink" title="哈夫曼树的应用"></a>哈夫曼树的应用</h1><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p>哈夫曼编码为哈夫曼树在通讯领域的应用，可以有效压缩数据，在编码时候需要考虑两个问题：数据的最小冗余编码（频率大的字符编码短），译码唯一性（一个译码对应唯一编码），利用哈夫曼树可以很好解决以上问题。</p>
<p>在之前介绍的哈夫曼树构造基础之上，在两个子树合并为一个新的二叉树时，选择权值较小的二叉树为左子树，然后从树的根结点出发，其左子树的分支标‘0’，右子树的分支标’1’，这样便可以得到每个字符的编码，如下图所示</p>
<img src="/2020/03/06/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81.png" class title="This is an example image">

<p>这样得到的编码即为二进制前缀编码。</p>
<p>总算将其基本概念大致介绍了一遍，那么开始从最初的起点（做错的题）开始，自己设计一个用于26个英文字符编码的哈夫曼树吧！</p>
<h1 id="”我的”哈夫曼树"><a href="#”我的”哈夫曼树" class="headerlink" title="”我的”哈夫曼树"></a>”我的”哈夫曼树</h1><h2 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h2><p>假设某段通信电文仅由 6 个字母 ABCDEF 组成，字母在电文中出现的频率分别为2，3，7，15，4，6。根据这些频率作为权值构造哈夫曼编码，最终构造出的哈夫曼树带权路径长度与字母 B 的哈夫曼编码分别为<strong>__</strong>。(这里假定左节点的值小于右节点的值)</p>
<p>因此接下来的内容为致力于构造自己的哈夫曼树，来解决此类问题。</p>
<h2 id="需求介绍"><a href="#需求介绍" class="headerlink" title="需求介绍"></a>需求介绍</h2><p>在明确了问题后，需要进一步分析需求。</p>
<p>输入：目前看到关于哈夫曼树的题目有两种输入方式，一种是直接输入一串字符串，另一种是逐个输入字符，频率。</p>
<p>输出：希望最后输出有哈夫曼树的路径长度，带权路径长度与每个字母对应的哈夫曼编码。</p>
<p>因此便得到了基础需求，即输入字符串或者字符+频率，得到其对应的哈夫曼树路径长度、带权路径长度与哈夫曼编码，下面将逐步实现这些需求，并在此基础之上，增加一些自定义的需求。说明：下面定义的哈夫曼树基于大写英文字母进行统计，只进行A-Z的字符统计。</p>
<h2 id="树结点的结构"><a href="#树结点的结构" class="headerlink" title="树结点的结构"></a>树结点的结构</h2><p>树由结点构成，基本的树结点中有值，左结点，右结点，而为了实现需求，需要在此之上加入每个节点的字符，结点的值为每个字符的频率，而当集合中有多个子树权值相等时，为了让树显得更加饱满（高度更低），选择优先让子结点数更少的二叉树进行合并，因此需要加上当前结点下所有结点的个数（包括自己），因此树结点的定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HaffNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Character c;<span class="comment">//字符</span></span><br><span class="line">    <span class="keyword">public</span> Integer fre;<span class="comment">//频数</span></span><br><span class="line">    <span class="keyword">public</span> Integer count;<span class="comment">//子结点个数</span></span><br><span class="line">    <span class="comment">//两个结点</span></span><br><span class="line">    <span class="keyword">public</span> HaffNode left;</span><br><span class="line">    <span class="keyword">public</span> HaffNode right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HaffNode</span><span class="params">(Character c, Integer fre, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">        <span class="keyword">this</span>.fre = fre;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈夫曼树的结构"><a href="#哈夫曼树的结构" class="headerlink" title="哈夫曼树的结构"></a>哈夫曼树的结构</h2><p>在前面所介绍的哈夫曼树的生成算法中，每次需要弹出两个权值最小的两个子树，最后直到只有一个子树，因此可以利用小根堆来实现，在Java中的实现为优先级队列PriorityQueue，为了保证让子结点树更小的二叉树优先被弹出，定义相应的比较器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HaffmanCompare</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">HaffNode</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//让树更均衡</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(HaffNode o1, HaffNode o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.fre != o2.fre ? o1.fre - o2.fre : o1.count - o2.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心思想为如果两个二叉树权值不同，则优先比较权值；若权值相同，则优先弹出子树个数更少的二叉树。</p>
<p>然后将此比较器传入哈夫曼树中维护的优先级队列中，因为在需求中介绍了有两种输入方式，一种为直接传入字符串，一种为逐个传入字符和频数，因此相应的定义了两种构造函数，一种有参数的对应传入字符串，一种无参数的对应逐个传入字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHaffman</span> </span>&#123;</span><br><span class="line">    <span class="comment">//持有小根堆，用来统计每个字符的个数</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;HaffNode&gt; numHeap = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String str = <span class="keyword">null</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHaffman</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        numHeap = <span class="keyword">new</span> PriorityQueue&lt;HaffNode&gt;(<span class="keyword">new</span> HaffmanCompare());</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHaffman</span><span class="params">()</span></span>&#123;</span><br><span class="line">        numHeap = <span class="keyword">new</span> PriorityQueue&lt;HaffNode&gt;(<span class="keyword">new</span> HaffmanCompare());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在完成了树的初始化后，需要将每个字符与其频率封装成为结点对象，传入维护的优先级队列中。因此首先需要统计每个字符与其频率</p>
<h2 id="统计每个字符与其频率"><a href="#统计每个字符与其频率" class="headerlink" title="统计每个字符与其频率"></a>统计每个字符与其频率</h2><h3 id="传入字符串"><a href="#传入字符串" class="headerlink" title="传入字符串"></a>传入字符串</h3><p>首先介绍传入参数为一个字符串的形式，假设传入字符串为“ABACCDA”，为了统计每个字符串个数，可以利用桶排序，即维护一个长度为26的数组作为桶，若为A在0号桶，为B在1号桶，以此类推。这样便可以将每个桶位置处的字符个数统计出来。然后遍历桶的26个位置，如果当前桶中有数，就将此位置对应的字符与其频率封装成结点对象，并放入堆中。</p>
<p>其中封装的时候，传入当前字符，频率，所有结点个数（1）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入字符串，统计频率，并加到大根堆中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFre</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//桶排序，将每个字符放入桶中</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];<span class="comment">//统计频率</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        arr[str.charAt(i)-<span class="string">'A'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从桶中取出来数，统计每个字母的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] != <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)(<span class="string">'A'</span>+i)+<span class="string">" "</span>+arr[i]+<span class="string">" "</span>);</span><br><span class="line">            numHeap.add(<span class="keyword">new</span> HaffNode((<span class="keyword">char</span>)(<span class="string">'A'</span>+i),arr[i],<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="传入数组"><a href="#传入数组" class="headerlink" title="传入数组"></a>传入数组</h3><p>而如果是以A 3，换行，B 4,…，这样的形式输入，则在输入的函数处维护一个数组，数组的index为0的地方表示A，值为3，表示A的频率为3，以此类推，便得到了一个字符的频率数组，完成此过程的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入字符和频数来构造数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCharAndFre</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">char</span> c, <span class="keyword">int</span> fre)</span></span>&#123;</span><br><span class="line">    <span class="comment">//新建桶，放入桶中</span></span><br><span class="line">    <span class="keyword">if</span> (c &lt; <span class="string">'A'</span> || c &gt; <span class="string">'Z'</span> || fre &lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"输入的字符不为A-Z之间或者频数不为正数"</span>);</span><br><span class="line">    arr[c-<span class="string">'A'</span>] = fre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将所有的输入都存到了上述数组中后，便可以遍历桶，将不为0处对应的字符与频率封装为结点对象并放入堆中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFre</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="comment">//从桶中取出来数，统计每个字母的个数</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (arr[i] != <span class="number">0</span>)&#123;</span><br><span class="line">               System.out.print((<span class="keyword">char</span>)(<span class="string">'A'</span>+i)+<span class="string">" "</span>+arr[i]+<span class="string">" "</span>);</span><br><span class="line">               numHeap.add(<span class="keyword">new</span> HaffNode((<span class="keyword">char</span>)(<span class="string">'A'</span>+i),arr[i],<span class="number">1</span>));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>接下来便可以开始构造哈夫曼树</p>
<h2 id="树的构造"><a href="#树的构造" class="headerlink" title="树的构造"></a>树的构造</h2><p>这方法需要返回树的根结点，其思路为</p>
<ol>
<li>如果堆为空，返回空</li>
<li>如果堆中元素比1大，则弹出2个结点</li>
<li>新建一个结点，字符为A-Z之外的（此处选#），权值为两个子树之和，左子树为权值较小的，总结点树为两子树结点树之和+1</li>
<li>将此结点重新放入堆中，继续步骤2,3，直到只有1个结点</li>
<li>返回此结点，即为哈夫曼树的头结点</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构建哈夫曼树</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> HaffNode <span class="title">getHaffTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果堆为空，返回空</span></span><br><span class="line">    <span class="keyword">if</span> (numHeap.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//从numHeap中弹出两个，构建新的节点，再丢进去</span></span><br><span class="line">    <span class="keyword">while</span> (numHeap.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        HaffNode cf1 = numHeap.poll();</span><br><span class="line">        HaffNode cf2 = numHeap.poll();</span><br><span class="line">        <span class="comment">//字符用单引号</span></span><br><span class="line">        HaffNode res = <span class="keyword">new</span> HaffNode(<span class="string">'#'</span>,cf1.fre+cf2.fre,cf1.count+cf2.count+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//构建左右子树</span></span><br><span class="line">        res.left = cf1.fre &lt;= cf2.fre ? cf1 : cf2;</span><br><span class="line">        res.right = cf1.fre &lt;= cf2.fre ? cf2 : cf1;</span><br><span class="line">        numHeap.offer(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只剩一个的时候弹出</span></span><br><span class="line">    <span class="keyword">return</span> numHeap.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树的打印"><a href="#树的打印" class="headerlink" title="树的打印"></a>树的打印</h2><p>为了直观显示树的结构和方便验证程序的正确性，此处<strong>直接使用左神的打印树的函数</strong>，其核心思路为递归方式的中序遍历，每一层树占据的长度为len，因此需要计算得到每个结点所在树的高度，如果为右子树，用<code>V</code>标识；如果为左子树，用<code>^</code>标识。递归的中序遍历为递归左子树，打印当前结点，递归右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(HaffNode head)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Binary Tree:"</span>);</span><br><span class="line">        printInOrder(head, <span class="number">0</span>, <span class="string">"H"</span>, <span class="number">17</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printInOrder</span><span class="params">(HaffNode head, <span class="keyword">int</span> height, String to, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        printInOrder(head.right, height + <span class="number">1</span>, <span class="string">"v"</span>, len);</span><br><span class="line">        String val = to + head.c + head.fre + to;</span><br><span class="line">        <span class="keyword">int</span> lenM = val.length();</span><br><span class="line">        <span class="keyword">int</span> lenL = (len - lenM) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> lenR = len - lenM - lenL;</span><br><span class="line">        val = getSpace(lenL) + val + getSpace(lenR);</span><br><span class="line">        System.out.println(getSpace(height * len) + val);</span><br><span class="line">        printInOrder(head.left, height + <span class="number">1</span>, <span class="string">"^"</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSpace</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String space = <span class="string">" "</span>;</span><br><span class="line">        StringBuffer buf = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            buf.append(space);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buf.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="树的编码"><a href="#树的编码" class="headerlink" title="树的编码"></a>树的编码</h2><p>在构建好树以后，需要得到每个叶子结点的编码。思路为递归实现，需要传入的参数是统计结果的Map，用来表示当前路径长度的String，用来表示总的带权路径长度的StringBuilder，以及当前树的高度和当前结点。</p>
<p>采用先序遍历，base case为结点为空，当结点不为空的时候：</p>
<ol>
<li>如果当前结点为叶子结点，将其字符编码加入，将其带权路径加入到结果中（如果StringBuilder长度为0，直接将当前高度*频率加入；若已经有数，将之前的数取出，累加上当前结点的带权路径长度，替换到StirngBuilder中原来的值）</li>
<li>如果当前结点不为叶子结点，递归遍历其左子树，其中string加上0，高度加一</li>
<li>递归遍历其右子树，string加上1，高度加一</li>
</ol>
<p>在此过程中遇到的坑有，之前为了获得结点的字符使用的是StringBuilder类型，但是因为StringBuilder的值在堆中而不是在当前递归栈中，在返回到上一级时需要将当前步骤的影响消除，使用此方法效果有问题。后在leetcode上找到了相似的题目，使用String类型来保存当前栈的状态，这样不用自己去手动消除这一步状态 ，更为简单。而计算带权路径又需要一个堆内存中的变量，此处使用比较笨的方法，利用StringBuilder，每次取出之前的值，加上当前值再进行替换。其中使用的replace函数来替换，起始位置为0，终止位置要是其长度。</p>
<p>得到的启示：要是遇到要获取每个结点的路径的题目，可以使用String类型来保存其路径，这样可以自动随栈变化，使用比较方便。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编码，使用StringBuilder有问题，现在改成String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encodingHaff</span><span class="params">(Map&lt;Character,String&gt; map, String sb, StringBuilder num, <span class="keyword">int</span> height, HaffNode cf)</span></span>&#123;</span><br><span class="line">    <span class="comment">//basecase</span></span><br><span class="line">    <span class="keyword">if</span> (cf != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//当前节点为叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (cf.left == <span class="keyword">null</span> &amp;&amp; cf.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//将答案加入</span></span><br><span class="line">            map.put(cf.c,sb);</span><br><span class="line">            <span class="keyword">if</span> (num.length() == <span class="number">0</span>)&#123;</span><br><span class="line">                num.append(height*cf.fre);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = Integer.valueOf(num.toString())+height*cf.fre;</span><br><span class="line">                num.replace(<span class="number">0</span>,num.length(),String.valueOf(temp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果不为叶子节点，遍历左右两边</span></span><br><span class="line">            encodingHaff(map,sb+<span class="number">0</span>, num, height+<span class="number">1</span>, cf.left);</span><br><span class="line">            encodingHaff(map,sb+<span class="number">1</span>,num, height+<span class="number">1</span>, cf.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时需要实现给一个字符串，输出其编码后的二进制码，思路为字符串每一位在Map中进行寻找，最后输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入字符串，给编码后的二进制码结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">codeHaff</span><span class="params">(String str, Map&lt;Character,String&gt; map)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        res.append(map.get(str.charAt(i)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树编码结果的输出"><a href="#树编码结果的输出" class="headerlink" title="树编码结果的输出"></a>树编码结果的输出</h2><p>在上一步中，树所有的编码结果放在了一个Map中，因此需要获取Map中的所有数，比较old school的方式是先获取Map的EntrySet类型的Set，再获取Set的EntrySet类型迭代器，利用迭代器来遍历Map，获取其每一个Key与Value，为了让程序更有拓展性，此处使用了泛型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历map</span></span><br><span class="line">   <span class="keyword">public</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">itraMap</span><span class="params">(Map&lt;K,V&gt; map)</span></span>&#123;</span><br><span class="line">       <span class="comment">//得到entey</span></span><br><span class="line">       Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">       <span class="comment">//遍历enterset</span></span><br><span class="line">       Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it = entrySet.iterator();</span><br><span class="line">       <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">           Map.Entry&lt;K,V&gt; me = it.next();</span><br><span class="line">           K key = me.getKey();</span><br><span class="line">           V value = me.getValue();</span><br><span class="line">           System.out.println(key+<span class="string">":"</span>+value+<span class="string">" "</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用更加简洁的写法，用 foreach语句遍历map的keySet，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历map的较方便写法</span></span><br><span class="line"><span class="keyword">public</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">itraMap2</span><span class="params">(Map&lt;K,V&gt; map)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (K key : map.keySet())&#123;</span><br><span class="line">        V value = map.get(key);</span><br><span class="line">        System.out.println(key+<span class="string">":"</span>+value+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候基本需求便实现了，但是获取了编码，如果给出了一串编码后的结果，该如何得到其解码呢？</p>
<p>因为哈夫曼树为二进制前缀编码，当编码规则确定后，解码结果应该唯一。因此，如果给定了一个字符串输入，从第一个字符开始看，在根结点开始遍历，如果是0，去左子树；如果是1，去右子树；如果都不是，抛出异常。当遍历结点走到了叶子节点时，将当前字符添加至结果，并从树的根结点开始遍历，直到将输入的字符串遍历完。</p>
<p>其中，遇到的坑是判断的逻辑，应该是先往左或右去走，再判断是不是叶子结点，而不是先判断再走。原因是在此处，默认至少树中是有2个以上的结点的，因为如果只有头结点一个叶子结点，是无法编码的，也就无法解码。因此头结点是不用判断的，当到了头结点，至少要<strong>先走出一步再进行判断</strong>，不然会少判断一个字符，造成解码错误。基本原理是<code>1</code>或者<code>0</code>的状态，是在在路径上的结点才有的，也就是要先走一步才有1或者0的状态，因此要先走一步，再进行判断。</p>
<p>第二个坑是char字符的判断，字符用单引号，字符串用双引号，因为刚开始的时候比较的为(0or1)，比较的不是0与1字符，因此一直判断不对 。总的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//译码</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">decodeHaff</span><span class="params">(String str, HaffNode head)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;                                                                               </span><br><span class="line">       <span class="comment">//返回结果</span></span><br><span class="line">       StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       HaffNode cur = head;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">           <span class="comment">//如果当前为0，往左走，如果为1，往右走</span></span><br><span class="line">           Character nowChar = str.charAt(i);</span><br><span class="line">           <span class="comment">//字符使用单引号，字符串使用双引号</span></span><br><span class="line">           <span class="comment">//是0往左走，是1往右走</span></span><br><span class="line">           <span class="keyword">if</span> (nowChar.equals(<span class="string">'0'</span>)) &#123;</span><br><span class="line">               cur = cur.left;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nowChar.equals(<span class="string">'1'</span>)) &#123;</span><br><span class="line">               cur = cur.right;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"译码错误"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果当前节点为叶节点，添加至结果，再从头开始找</span></span><br><span class="line">           <span class="keyword">if</span> (cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">               res.append(cur.c);</span><br><span class="line">               cur = head;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造总方法"><a href="#构造总方法" class="headerlink" title="构造总方法"></a>构造总方法</h2><p>因此总的方法为：如果传入的是字符串，使用无参的得到频率方法；若传入的是数组，使用有参的得到频率方法，然后后面的均为构造树，返回类型为得到的字符与二进制编码的Map，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//主方法，对应输入string的构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;Character,String&gt; <span class="title">mainHaff</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"所有字母及频数如下"</span>);</span><br><span class="line">      <span class="comment">//1、得到每个字符的频率并放入堆中</span></span><br><span class="line">      getFre();</span><br><span class="line">      <span class="keyword">return</span> getTree();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//主方法，对应输入字母，频数的输入方式</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;Character,String&gt; <span class="title">mainHaff</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">      <span class="comment">//从桶中取出来数，统计每个字母的个数</span></span><br><span class="line">      getFre(arr);</span><br><span class="line">      <span class="keyword">return</span> getTree();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//已经得到了堆，用堆得到哈夫曼树</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;Character,String&gt; <span class="title">getTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//1、构建哈夫曼树</span></span><br><span class="line">      HaffNode head = getHaffTree();</span><br><span class="line">      <span class="comment">//2、看哈夫曼树的遍历</span></span><br><span class="line">      printTree(head);</span><br><span class="line">      <span class="comment">//3、得到 每个字符的编码map</span></span><br><span class="line">      Map&lt;Character,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      String sb = <span class="keyword">new</span> String();</span><br><span class="line">      StringBuilder sum = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      encodingHaff(map,sb,sum, <span class="number">0</span>, head);</span><br><span class="line">      <span class="comment">//4、遍历map看结果</span></span><br><span class="line">      itraMap2(map);</span><br><span class="line">      <span class="comment">//5、输出路径长度与带权值路径长度</span></span><br><span class="line">      System.out.println(<span class="string">"哈夫曼带权路径长度为："</span>+sum);</span><br><span class="line">      System.out.println(<span class="string">"哈夫曼总路径长度为："</span>+head.fre);</span><br><span class="line">      <span class="keyword">return</span> map;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造输入"><a href="#构造输入" class="headerlink" title="构造输入"></a>构造输入</h2><p>输入的逻辑为：如果输入1，输入一串字符串，然后构建哈夫曼树；如果输入2，循环输入字符与频率，如果输出end表示结束，将获得的频率数组传入用于构建哈夫曼树。这样便得到了编码信息。这时候用户可以选择是否继续，如果输入1便继续，输入当前规则下得到的编码字符串，则输出为译码后的字符信息。输入代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">    <span class="comment">//提示以字符串输入还是每个字母频率</span></span><br><span class="line">    System.out.println(<span class="string">"请输入数字1或者2"</span>);</span><br><span class="line">    System.out.println(<span class="string">"输入1：将整个字符串输入"</span>);</span><br><span class="line">    System.out.println(<span class="string">"输入2：将字符对应的频数输入"</span>);</span><br><span class="line">    <span class="keyword">int</span> n = Integer.valueOf(bf.readLine());</span><br><span class="line">    MyHaffman mf = <span class="keyword">null</span>;</span><br><span class="line">    Map&lt;Character,String&gt; map = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//处理输入</span></span><br><span class="line">    <span class="keyword">switch</span> (n)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">"请输入完整字符串"</span>);</span><br><span class="line">            String str = bf.readLine().toUpperCase();</span><br><span class="line">            mf = <span class="keyword">new</span> MyHaffman(str);</span><br><span class="line">            map = mf.mainHaff();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">"请输入字母和频数，中间用空格隔开"</span>);</span><br><span class="line">            System.out.println(<span class="string">"以end作为结束"</span>);</span><br><span class="line">            String s;</span><br><span class="line">            mf = <span class="keyword">new</span> MyHaffman();</span><br><span class="line">            <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">while</span> (!(s=bf.readLine()).equals(<span class="string">"end"</span>))&#123;</span><br><span class="line">                String[] strArr = s.split(<span class="string">" "</span>);</span><br><span class="line">                <span class="keyword">char</span> c = strArr[<span class="number">0</span>].toUpperCase().charAt(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">int</span> fre = Integer.valueOf(strArr[<span class="number">1</span>]);</span><br><span class="line">                mf.addCharAndFre(arr,c,fre);</span><br><span class="line">            &#125;</span><br><span class="line">            map = mf.mainHaff(arr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"是否要继续：如果要编码，输入1；如果要译码，输入2，否则输入3"</span>);</span><br><span class="line">    <span class="keyword">int</span> opt;</span><br><span class="line">    <span class="keyword">while</span> ((opt = Integer.valueOf(bf.readLine())) != <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"输入要编码的字符串，如ABSFSDF"</span>);</span><br><span class="line">            String str = bf.readLine().toUpperCase();</span><br><span class="line">            System.out.println(<span class="string">"编码后的二进制码为："</span>+mf.codeHaff(str,map));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"输入要译码的二进制码，由0或者1组成"</span>);</span><br><span class="line">            String str = bf.readLine();</span><br><span class="line">            System.out.println(str);</span><br><span class="line">            System.out.println(<span class="string">"解码后的字符串为："</span>+mf.decodeHaff(str,mf.getHaffTree()));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"是否要继续：如果要编码，输入1；如果要译码，输入2，否则输入3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><h3 id="输入字符串"><a href="#输入字符串" class="headerlink" title="输入字符串"></a>输入字符串</h3><p>输入字符串ABCACCDAEAE，交互过程如下</p>
<img src="/2020/03/06/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/%E5%AD%97%E7%AC%A6%E4%B8%B21.png" class title="This is an example image">

<p>得到的所有字母及频数如下</p>
<img src="/2020/03/06/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/%E5%AD%97%E7%AC%A6%E4%B8%B22.png" class title="This is an example image">

<p>得到的每个字符的编码规则及带权路径等如下</p>
<img src="/2020/03/06/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/%E5%AD%97%E7%AC%A6%E4%B8%B23.png" class title="This is an example image">

<p>接着编码、解码及退出如下</p>
<p>可以看到正常的完成了需要的功能。</p>
<h3 id="输入字符及频数"><a href="#输入字符及频数" class="headerlink" title="输入字符及频数"></a>输入字符及频数</h3><p>不忘初心，牢记使命。</p>
<p>这个博客开始的地方就是这道错题，请这位选手回到讲台。</p>
<img src="/2020/03/06/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/%E7%89%9B%E5%AE%A2%E9%A2%98%E7%9B%AE.png" class title="This is an example image">

<p>我们开始用程序来做这一道题</p>
<p>交互方式如下</p>
<img src="/2020/03/06/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/%E5%AD%97%E7%AC%A6%E9%A2%91%E6%95%B01.png" class title="This is an example image">

<p>那么结果应该为！</p>
<img src="/2020/03/06/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/%E5%AD%97%E7%AC%A6%E9%A2%91%E6%95%B02.png" class title="This is an example image">

<p>所以答案选A！</p>
<img src="/2020/03/06/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/%E5%AD%97%E7%AC%A6%E9%A2%91%E6%95%B03.png" class title="This is an example image">

<h3 id="小彩蛋"><a href="#小彩蛋" class="headerlink" title="小彩蛋"></a>小彩蛋</h3><p>输入字符及频数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a <span class="number">1</span></span><br><span class="line">b <span class="number">1</span></span><br><span class="line">h <span class="number">1</span></span><br><span class="line">e <span class="number">1</span></span><br><span class="line">i <span class="number">2</span></span><br><span class="line">j <span class="number">1</span></span><br><span class="line">o <span class="number">1</span></span><br><span class="line">u <span class="number">2</span></span><br><span class="line">y <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>二进制码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">01110101011111101001100000011110101</span></span><br></pre></td></tr></table></figure>

<p>答案在文章最后</p>
<p>输入字符及频数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a <span class="number">1</span></span><br><span class="line">e <span class="number">2</span></span><br><span class="line">f <span class="number">3</span></span><br><span class="line">h <span class="number">2</span></span><br><span class="line">i <span class="number">1</span></span><br><span class="line">j <span class="number">1</span></span><br><span class="line">n <span class="number">2</span></span><br><span class="line">p <span class="number">2</span></span><br><span class="line">s <span class="number">1</span></span><br><span class="line">v <span class="number">1</span></span><br><span class="line">y <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>二进制码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">111111111011101010010010100111011100001000111000000001101</span></span><br></pre></td></tr></table></figure>

<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>从不太了解哈夫曼树，到查阅博客，自己编写哈夫曼树的类，遇到问题，在leetcode和左神算法笔记中寻找方法，不断调试，踩坑，添加功能，到最后马马虎虎完成了自己要求的功能，也许其中还有很多考虑的不够周到的地方，但因为自己的好奇心去实现一个功能，确实是一件很有意思的事情。</p>
<h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>彩蛋1：</p>
<p>字符编码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A:<span class="number">000</span> </span><br><span class="line">B:<span class="number">010</span> </span><br><span class="line">U:<span class="number">101</span> </span><br><span class="line">E:<span class="number">1111</span> </span><br><span class="line">H:<span class="number">011</span> </span><br><span class="line">Y:<span class="number">001</span> </span><br><span class="line">I:<span class="number">110</span> </span><br><span class="line">J:<span class="number">100</span> </span><br><span class="line">O:<span class="number">1110</span></span><br></pre></td></tr></table></figure>

<p>二进制码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">01110101011111101001100000011110101</span></span><br></pre></td></tr></table></figure>

<p>答案：</p>
<p>HUBEIJIAYOU</p>
<p>彩蛋2：</p>
<p>字符编码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">P:<span class="number">000</span> </span><br><span class="line">A:<span class="number">1100</span> </span><br><span class="line">S:<span class="number">1001</span> </span><br><span class="line">E:<span class="number">010</span> </span><br><span class="line">V:<span class="number">1010</span> </span><br><span class="line">F:<span class="number">111</span> </span><br><span class="line">H:<span class="number">001</span> </span><br><span class="line">I:<span class="number">1000</span> </span><br><span class="line">Y:<span class="number">1101</span> </span><br><span class="line">J:<span class="number">1011</span> </span><br><span class="line">N:<span class="number">011</span></span><br></pre></td></tr></table></figure>

<p>对应的二进制码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">111111111011101010010010100111011100001000111000000001101</span></span><br></pre></td></tr></table></figure>

<p>答案：</p>
<p>FFFNVSHENJIEHAPPY</p>
]]></content>
      <categories>
        <category>哈夫曼树</category>
      </categories>
      <tags>
        <tag>哈夫曼树</tag>
        <tag>哈夫曼编码</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE知识整理</title>
    <url>/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><p>根据网上博客和黑马的一些资料，整理了下面的JavaSE的知识点</p>
<blockquote>
<p><a href="https://blog.csdn.net/ThinkWon/article/details/104390612" target="_blank" rel="noopener">https://blog.csdn.net/ThinkWon/article/details/104390612</a></p>
<p>《黑马程序员Java学习》</p>
</blockquote>
<a id="more"></a>

<h2 id="Java基本语法、特性"><a href="#Java基本语法、特性" class="headerlink" title="Java基本语法、特性"></a>Java基本语法、特性</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="Java有哪些数据类型"><a href="#Java有哪些数据类型" class="headerlink" title="Java有哪些数据类型"></a>Java有哪些数据类型</h4><p>Java中数据类型分为基础数据类型与引用数据类型</p>
<ul>
<li>基础数据类型<ul>
<li>数值型<ul>
<li>整数类型，<strong>默认int</strong><ul>
<li>byte：1字节</li>
<li>short：2字节</li>
<li>int：4字节</li>
<li>long：8字节</li>
</ul>
</li>
<li>浮点数类型，<strong>默认double</strong><ul>
<li>float：4字节</li>
<li>double：8字节</li>
</ul>
</li>
</ul>
</li>
<li>字符型<ul>
<li>char：2字节，用单引号括</li>
</ul>
</li>
<li>布尔型<ul>
<li>boolean：1字节，只有2个值</li>
</ul>
</li>
</ul>
</li>
<li>引用数据类型<ul>
<li>类(class)</li>
<li>接口(interface)</li>
<li>数组([])</li>
</ul>
</li>
</ul>
<h4 id="float与double"><a href="#float与double" class="headerlink" title="float与double"></a>float与double</h4><p>float f = 1.1;会报错吗？</p>
<p>会，1.1默认为double，这里相当于向下转型，造成精度损失，需要更改为float f = 1.1f或者float f = (float)1.1</p>
<h4 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗"></a>short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗</h4><p>s1 = s1+1有错，因为1为int类型，不能将int隐式的转换为低精度的short，所以需要类型转换。</p>
<p>s1 += 1，这里相当于强制类型转换，s1 = (short)(s1 + 1)，使用 ++ 或者 += 相当于执行了类型转换</p>
<h4 id="Math-round-11-5-等于多少？Math-round-11-5-等于多少"><a href="#Math-round-11-5-等于多少？Math-round-11-5-等于多少" class="headerlink" title="Math.round(11.5) 等于多少？Math.round(-11.5)等于多少"></a>Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</h4><p>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加 0.5 然后进行下取整。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="最有效率的方式计算2乘以8"><a href="#最有效率的方式计算2乘以8" class="headerlink" title="最有效率的方式计算2乘以8"></a>最有效率的方式计算2乘以8</h4><p>2 &lt;&lt; 3，左移几位相当于2乘以几次方，位运算效率最高。</p>
<p>而<code>&gt;&gt;</code>表示右移，右移几位就是除以2的几次幂，高位保持原来的数字，而对于<code>&gt;&gt;&gt;</code>，无论高位是什么，用<code>0</code>来补齐，因此是无符号位右移。</p>
<h4 id="计算-6"><a href="#计算-6" class="headerlink" title="计算~6"></a>计算~6</h4><p><code>~6</code>相当于对6逐位取反，6全部取反+1得到-6，<code>~6=-7</code></p>
<h4 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h4><p>&amp;运算符的作用是</p>
<ol>
<li>按位与 ，num1&amp;num2相当于将每个数的二进制位相与</li>
<li>逻辑与运算，boolean f1 &amp; f2，两个同时为真返回真</li>
</ol>
<p>而&amp;&amp;是短路的与运算，boolean f1 &amp; f2，如果左边的f1为假，则直接返回假，屏蔽了f2，逻辑或（|）与短路运算符（||）作用也类似。</p>
<h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="switch的作用类型"><a href="#switch的作用类型" class="headerlink" title="switch的作用类型"></a>switch的作用类型</h4><p>在JDK5之前，switch(expr)中的expr只能是基础数据类型中的byte、short、int、char，在JDK5引入了枚举类型enum，在JDK7后，可以为字符串String，但长整形long不可以。因此总的为byte、short、int、char、enum、String。</p>
<h4 id="break-continue-return-的区别及作用"><a href="#break-continue-return-的区别及作用" class="headerlink" title="break ,continue ,return 的区别及作用"></a>break ,continue ,return 的区别及作用</h4><p>break：结束当前的循环体，不再执行此循环</p>
<p>continue：跳出本次循环，继续执行下一个循环</p>
<p>return：结束当前的方法，直接返回</p>
<h4 id="在-Java-中，如何跳出当前的多重嵌套循环"><a href="#在-Java-中，如何跳出当前的多重嵌套循环" class="headerlink" title="在 Java 中，如何跳出当前的多重嵌套循环"></a>在 Java 中，如何跳出当前的多重嵌套循环</h4><p>给外面的循环定义一个标签，在需要跳出的地方使用break 循环名即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">loop1:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">break</span> loop1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><h4 id="四种访问修饰符及区别"><a href="#四种访问修饰符及区别" class="headerlink" title="四种访问修饰符及区别"></a>四种访问修饰符及区别</h4><p>用访问修饰符来保护对类、变量、方法和构造方法的访问，支持四种访问权限。</p>
<ul>
<li>public：对所有类可见，使用对象为类、接口、变量、方法</li>
<li>default：默认的，在一个包中可见，使用对象为类、接口、变量、方法</li>
<li>protected：对同一个包内和子类可见。使用对象为内部类，变量，方法，不能修饰外部类</li>
<li>private：在同一个类内可见。使用对象为变量，方法，不能修饰外部类</li>
</ul>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">同一类中</th>
<th align="center">同一包中</th>
<th align="center">子类中</th>
<th align="center">不同包中</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">default</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="static作用"><a href="#static作用" class="headerlink" title="static作用"></a>static作用</h4><ol>
<li>创建独立于具体对象的域变量或者方法，随类而加载，可以直接用类名调用</li>
<li>形成静态代码块优化程序性能。在类被加载时，按照static块出现顺序执行，只加载一次，可以将只需要进行一次的初始化操作放在static中</li>
</ol>
<h4 id="static特点"><a href="#static特点" class="headerlink" title="static特点"></a>static特点</h4><ol>
<li>static是一个修饰符，修饰成员（成员变量和成员函数）</li>
<li>static修饰的成员被所有对象共享</li>
<li>static优先于对象存在，随类的第一次使用而加载，且只加载一次</li>
<li>static修饰的成员多了一种调用方式，即直接被类名调用</li>
<li>static变量值在类加载时分配空间，以后创建类对象时不会重新分配，可以对其任意赋值</li>
</ol>
<h4 id="static应用场景"><a href="#static应用场景" class="headerlink" title="static应用场景"></a>static应用场景</h4><ol>
<li>修饰成员变量</li>
<li>修饰成员方法</li>
<li>静态代码块</li>
<li>修饰类（只能修饰内部类即静态内部类）</li>
<li>静态导包</li>
</ol>
<h4 id="static注意事项"><a href="#static注意事项" class="headerlink" title="static注意事项"></a>static注意事项</h4><ol>
<li>静态方法只能访问静态成员，静态方法可直接被类名调用，非静态既可以访问静态，又可以访问非静态</li>
<li>静态 方法中不能出现this与static</li>
<li>主函数是静态的，不要在主函数中创建其他函数</li>
</ol>
<h4 id="方法调用顺序"><a href="#方法调用顺序" class="headerlink" title="方法调用顺序"></a>方法调用顺序</h4><p>父类静态代码块-&gt;子类静态代码块-&gt;子类静态方法-&gt;父类非静态代码块-&gt;父类构造方法-&gt;子类非静态代码块-&gt;子类构造方法</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="final作用"><a href="#final作用" class="headerlink" title="final作用"></a>final作用</h4><p>用于修饰类、属性和方法</p>
<ul>
<li><p>被final修饰的<strong>类不可以被继承</strong></p>
<p>关键字final置于定义前</p>
</li>
<li><p>被final修饰的<strong>方法不可以被重写</strong></p>
<p>防止任何继承类修改其定义，处于设计的考虑</p>
</li>
<li><p>被final修饰的变量不可以被改变，<strong>不可变的是变量的引用</strong>，而不是引用指向的内容（针对对象）</p>
<p>一般会加静态，全局变量。固定常量一律用final修饰。<strong>不能改变的数据类型需要是基本数据类型</strong>，对常量定义时需要对其赋值。对对象的引用表明此引用不能指向另一个对象，但对象本身可以被修改。</p>
</li>
</ul>
<p>允许在参数列表中以声明的方式将参数指定为final，意味着无法在方法中更改参数引用所指向的对象。可以读参数，无法改参数，主要用来<strong>向匿名内部类传递数据</strong>。</p>
<h4 id="final-finally-finalize区别"><a href="#final-finally-finalize区别" class="headerlink" title="final finally finalize区别"></a>final finally finalize区别</h4><ul>
<li>final可以修饰类、方法、变量，修饰类表明该类不能被继承，修饰方法表明该方法不能被重写，修饰变量表明该变量为常量不能重新被赋值，但若修饰的是对象的引用，不可变的是引用。</li>
<li>finally一般作用在try-catch代码块中，处理异常时将一定要执行的方法放在finally中，表示不管是否出现异常，该代码块都一定会执行（存在try语句，在try语句中没有执行System.exist(0)），一般放关闭资源的代码。</li>
<li>finalize是Object类的方法，一般由垃圾回收器调用，当调用Syetem.gc()的时候，由垃圾回收器调用finalize()，回收垃圾，是一个对象是否可回收的最后判断，最后的自救机会，但只有一次。</li>
</ul>
<h3 id="this与super"><a href="#this与super" class="headerlink" title="this与super"></a>this与super</h3><h4 id="this关键字使用"><a href="#this关键字使用" class="headerlink" title="this关键字使用"></a>this关键字使用</h4><p>this的含义：代表本类对象引用，可以理解成<strong>指向对象本身的一个指针</strong>。</p>
<p>this的用法</p>
<ol>
<li><p>普通的直接引用，this相当于当前对象本身</p>
</li>
<li><p>构造函数中，形参与成员变量重名，用this区分</p>
</li>
<li><p>在构造函数中引用本类的其他构造函数</p>
<p>this(待传入参数，可为空)，只能放在构造函数的第一行，不可与super()同时出现</p>
</li>
</ol>
<h4 id="super关键字使用"><a href="#super关键字使用" class="headerlink" title="super关键字使用"></a>super关键字使用</h4><p>super为指向超（父）类对象的指针，此超类为离当前类最近的一个父类。</p>
<p>super的用法与this类似</p>
<ol>
<li><p>普通的直接引用，使用super.xxx来引用父类成员</p>
</li>
<li><p>子类中的成员变量与父类中成员变量重名时，用super()区分</p>
</li>
<li><p>引用父类构造函数</p>
<p>super(参数)，调用父类中构造函数，在子类的构造函数第一行默认为super()，如果有this()，则没有super()，因为二者均需要出现在构造函数第一行</p>
</li>
</ol>
<h4 id="this与super-1"><a href="#this与super-1" class="headerlink" title="this与super"></a>this与super</h4><ol>
<li>this指当前对象，super指父类对象</li>
<li>this在本类中调用本来方法，super在子类中调用父类方法</li>
<li>this与super均要放在构造函数的第一行</li>
<li>this与super不能出现在一个构造函数中，因为this()中调用其他构造函数，其他构造函数中有super()</li>
<li>二者均不可在static环境中使用，如static变量，static方法，static代码块</li>
</ol>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h3><h4 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h4><p>面向过程：具体化的，流程化的，为了解决问题，需要一步步分析和实现</p>
<p>面向对象：模型化的，将过程的实现抽象为多个类，直接去调用类的属性和方法，不用去一步步实现，面向对象的底层是面向过程，将面向过程抽象成类并进行封装，就是面向对象了</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>优点</th>
<th>缺点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>面向过程</td>
<td>性能更高，没有调用类的资源消耗。</td>
<td>没有面向对象易维护、复用、扩展</td>
<td>单片机，嵌入式开发，Linux/Unix</td>
</tr>
<tr>
<td>面向对象</td>
<td>易维护、易复用、易扩展，系统耦合性更低</td>
<td>性能比面向过程低</td>
<td>需求变化多，互联网应用</td>
</tr>
</tbody></table>
<h4 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h4><p>面向对象的特征主要有4个方面，抽象，封装，继承和多态</p>
<p>抽象：将一类对象的<strong>共同特征</strong>总结出来构造类的过程，包括<strong>数据抽象</strong>和<strong>行为抽象</strong>两方面，抽象只关注对象的属性和行为，并不关心其实现细节。</p>
<p>封装：将一个对象的<strong>属性私有化</strong>，同时对外提供可以<strong>访问属性的方法</strong>。在类中编写方法对实现细节进行封装，隐藏一切可隐藏的，只对外暴露最简单的编程<strong>接口</strong>。</p>
<p>继承：从父类继承属性与方法到子类，子类可以增加新的数据和功能，方便复用，继承会增加类之间的耦合性。（里氏替换原则）</p>
<p>多态：某一种事物具有多种形态，用父类类型指向子类对象，一个对象对应着不同类型。</p>
<h4 id="面向对象的基本原则"><a href="#面向对象的基本原则" class="headerlink" title="面向对象的基本原则"></a>面向对象的基本原则</h4><ol>
<li><p>单一职责原则</p>
<p>一个类只有一个职责，内部高内聚</p>
</li>
<li><p>接口隔离原则</p>
<p>一个类对另一个类的依赖建立在最小的接口上</p>
</li>
<li><p>依赖倒转原则</p>
<p>抽象不应该依赖细节，细节应该依赖抽象，<strong>面向接口编程</strong>。依赖关系的三种传递：接口传递、构造方法传递、setter方法传递</p>
</li>
<li><p>里氏替换原则</p>
<p>与继承相关，任何时候子类都能替换父类</p>
</li>
<li><p>开放封闭原则</p>
<p>模块和函数应该对<strong>扩展开放</strong>（对提供方），对<strong>修改关闭</strong>（对使用方），<strong>用抽象构建框架，用实现扩展细节</strong></p>
</li>
<li><p>迪米特法则（最少知道原则）</p>
<p>一个类对自己依赖的类知道越少越好，陌生的类最好不要以局部变量形式出现在类的内部</p>
</li>
<li><p>合成复用原则</p>
<p>尽量使用合成/聚合的方式，而不是继承</p>
</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="继承的好处"><a href="#继承的好处" class="headerlink" title="继承的好处"></a>继承的好处</h4><ol>
<li>提高了代码的复用性</li>
<li>让类与类之间有了联系，为多态提供了前提</li>
</ol>
<h4 id="继承的注意事项"><a href="#继承的注意事项" class="headerlink" title="继承的注意事项"></a>继承的注意事项</h4><ol>
<li><p>Java中支持单继承，不直接支持多继承</p>
<p>多继承会出现父类成员变量调用的不确定性，可以多实现</p>
</li>
<li><p>子类中有父类非private的属性和方法</p>
</li>
<li><p>子类可以对父类的属性和功能进行扩展</p>
</li>
<li><p>子类可以对父类方法进行覆盖</p>
</li>
</ol>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="多态的特点与实现方式"><a href="#多态的特点与实现方式" class="headerlink" title="多态的特点与实现方式"></a>多态的特点与实现方式</h4><p>程序中的引用变量所指向的具体类型和调用方法只有在程序运行时才能确定，这样可以实现引用变量绑定到不同的类上，让程序可以选择多个运行状态。</p>
<p>利用父类或接口引用变量指向子类或具体实现类的对象，提高程序的扩展性。</p>
<p>方法<strong>重载</strong>（overload）实现的是<strong>编译</strong>时的多态性（也称<strong>前绑定</strong>），根据参数列表的不同来区分不同的函数；方法<strong>覆盖</strong>（override）实现的是<strong>运行</strong>时的多态性（也称<strong>后绑定</strong>），运行时的多态是面向对象最精髓的（引用变量调用的方法只有在运行时才能确定）。</p>
<p>实现多态需要做到</p>
<ul>
<li><p>继承（子类继承父类）</p>
</li>
<li><p>方法重写（子类重写父类中的<strong>已有</strong>或抽象方法）</p>
</li>
<li><p>向上转型（父类型引用子类对象，接口类型引用实现类的对象，相同的调用会根据子类对象不同而表现不同的行为）</p>
</li>
</ul>
<h3 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h3><h4 id="抽象类和接口的对比"><a href="#抽象类和接口的对比" class="headerlink" title="抽象类和接口的对比"></a>抽象类和接口的对比</h4><p>从设计层面来说，抽象类是对<strong>类的抽象</strong>，是一种模板设计；接口是<strong>行为的抽象</strong>，是一种行为的规范</p>
<p>相同点</p>
<ul>
<li>接口和抽象类<strong>不能直接实例化</strong></li>
<li>位于继承的顶端，用于被其他类实现或继承</li>
<li>都包含抽象方法，其子类必须覆写这些抽象方法</li>
</ul>
<p>不同点</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>声明</td>
<td>abstract关键字</td>
<td>interface关键字</td>
</tr>
<tr>
<td>实现</td>
<td>子类使用extends继承</td>
<td>子类使用implements实现</td>
</tr>
<tr>
<td>构造器</td>
<td>可以有</td>
<td>没有</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>方法可以为任意访问修饰符</td>
<td>接口方法默认为public，不允许定义为private或protected</td>
</tr>
<tr>
<td>多继承</td>
<td>只能继承一个类</td>
<td>可以多实现</td>
</tr>
<tr>
<td>抽象方法</td>
<td>可以有非抽象方法</td>
<td>全为抽象方法</td>
</tr>
</tbody></table>
<p>选择抽象类或者接口，遵循如下原则</p>
<ul>
<li>行为模型总是通过接口而不是抽象类定义，通常<strong>优先使用接口</strong>，少使用抽象类</li>
<li>选择抽象类的情况：需要定义子类的行为，又要为子类提供通用的功能</li>
</ul>
<h4 id="普通类与抽象类区别"><a href="#普通类与抽象类区别" class="headerlink" title="普通类与抽象类区别"></a>普通类与抽象类区别</h4><ul>
<li>普通类中不能有抽象方法，抽象类中可以包含抽象方法</li>
<li>普通类可以直接实例化，抽象类不能直接实例化</li>
</ul>
<h4 id="抽象类能用final修饰吗"><a href="#抽象类能用final修饰吗" class="headerlink" title="抽象类能用final修饰吗"></a>抽象类能用final修饰吗</h4><p>不能，定义抽象类的目的是让其他类继承，而final关键字修饰的类不能被继承，二者相违背，因此抽象类不能被final修饰</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="创建一个对象用什么关键字？对象实例与对象引用有何不同？"><a href="#创建一个对象用什么关键字？对象实例与对象引用有何不同？" class="headerlink" title="创建一个对象用什么关键字？对象实例与对象引用有何不同？"></a>创建一个对象用什么关键字？对象实例与对象引用有何不同？</h4><p>创建类使用关键字new，对象实例存在于堆内存中，而对象引用指向对象实例，对象引用可以指向一个对象实例或者指向空，而一个对象实例可以有多个对象引用指向它。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="成员变量与局部变量区别"><a href="#成员变量与局部变量区别" class="headerlink" title="成员变量与局部变量区别"></a>成员变量与局部变量区别</h4><p>成员变量定义在方法外部，局部变量定义在类的方法或代码块中。</p>
<ul>
<li>作用域：成员变量针对整个类有效，局部变量只在方法或代码块中有效</li>
<li>存储位置：成员变量存储在堆内存中，局部变量存储在栈中</li>
<li>生命周期：成员变量周期与对象一样，局部变量周期与方法一样</li>
<li>初始值：成员变量默认有初始值，局部变量没有默认初始值，使用前需要赋值</li>
<li>使用原则：就近原则，先在局部范围找，接着在成员中找</li>
</ul>
<h4 id="静态变量和实例变量区别"><a href="#静态变量和实例变量区别" class="headerlink" title="静态变量和实例变量区别"></a>静态变量和实例变量区别</h4><p>静态变量，随类的加载而加载，被当前类所有对象共享，内存中只有一份。</p>
<p>实例变量：随每次创建对象而创建，有几个对象就有几个实例变量。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h4><p>public static void main(String[] args)</p>
<p>main方法是Java程序的入口，public表示任何类和对象可以访问，static表示方法随类而加载，可使用类名来调用，void表明没有返回值，main为JVM识别的特殊方法名，不是关键字。字符串数组args可以用来输入参数。main为最先加载的方法（不一定最先执行），因此需要被静态调用。</p>
<p>是否有其他写法？</p>
<p>public与static可以交换顺序，也可以定义为final，也可以用synchronized来修饰main方法。</p>
<h4 id="在main方法执行前输出"><a href="#在main方法执行前输出" class="headerlink" title="在main方法执行前输出"></a>在main方法执行前输出</h4><p>可以使用静态代码块，静态代码块在类加载时被调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		Sout(<span class="string">"Hello1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	main()&#123;</span><br><span class="line">		Sout(<span class="string">"Hello2"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数的重载与覆盖"><a href="#函数的重载与覆盖" class="headerlink" title="函数的重载与覆盖"></a>函数的重载与覆盖</h4><p>都是实现多态的方式。</p>
<ul>
<li>重载：重载发生于<strong>一个类</strong>中，若同名的方法有不同的输入参数列表（参数类型不同，参数个数不同或均不同）视为重载，编译时的多态性，前绑定</li>
<li>覆盖：也称为覆写，重写，override，发生在<strong>子类和父类</strong>之间，要求子类重写方法与父类有相同的参数列表和返回类型，子类方法权限大于等于父类方法（父类方法不能被private修饰），子类方法声明异常不能多于父类异常（其子类或子集）。运行时的多态性，后绑定，精髓。</li>
</ul>
<h4 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h4><ol>
<li>调用方式不同，实例方法只能通过对象.方法调用，而静态方法多了类名.方法，无需创建对象。</li>
<li>访问成员变量限制，在静态方法中只能访问静态成员（静态成员变量和静态方法），不能访问实例成员，而实例方法没有此限制。</li>
</ol>
<h4 id="和-equals-的区别是什么"><a href="#和-equals-的区别是什么" class="headerlink" title="== 和 equals 的区别是什么"></a>== 和 equals 的区别是什么</h4><p>==比较的是地址，equals分两种情况</p>
<ul>
<li>该类覆写了equals方法，比较的是值或内容</li>
<li>该类没有覆写equals方法，比较的仍然为地址</li>
</ul>
<h4 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode 与 equals"></a>hashCode 与 equals</h4><p>将对象加入Set或Map集合中，必须要覆写hashCode或equals方法。通过hashCode计算哈希散列值，寻找在桶中的位置，然后在该桶处的链表或树上通过equals方法来寻找是否有相同的节点，如果有就进行替换（HashMap的put方法逻辑）。覆写hashCode与equals需要确保</p>
<ul>
<li>两个相等对象的哈希值相同</li>
<li>两个相等对象返回equals返回true</li>
<li>哈希值相等的对象不一定相等</li>
</ul>
<p>这样在重写equals时必须重写hashCode，哈希值不等的对象即使有相同的数据也不等。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在Java中定义一个不做事且没有参数的构造方法的作用"></a>在Java中定义一个不做事且没有参数的构造方法的作用</h4><p>在执行子类的构造方法前，默认执行super()，若父类中只有有参数的构造方法，则编译会报错，因为程序在父类中找不到相应方法来执行，因此需要在父类中加上一个不做事的空参的构造方法</p>
<h4 id="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"><a href="#在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？" class="headerlink" title="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"></a>在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</h4><p>子类与父类有较强的耦合性，在初始化子类前，需要相应对父类进行初始化，此函数可以帮助子类做初始化工作</p>
<h4 id="一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？"><a href="#一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？" class="headerlink" title="一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？"></a>一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？</h4><p>构造方法的主要作用是完成对类对象的<strong>初始化</strong>工作。若没有显式声明构造方法，程序也能正确执行，因为每个类中有一个默认的空参的构造方法，但当自己定义了构造方法后，就没有该默认构造方法了。</p>
<h4 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="构造方法有哪些特性？"></a>构造方法有哪些特性？</h4><ul>
<li>名字与类相同</li>
<li>没有返回值，不能用void声明函数</li>
<li>在new对象时自动调用该方法</li>
</ul>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="内部类定义"><a href="#内部类定义" class="headerlink" title="内部类定义"></a>内部类定义</h4><p>将类定义在内的内部，方便访问外部类中成员。外部类要访问内部类中成员，必须新建外部类对象。内部类可以访问外部类中数据的原理是持有外部类的this引用。</p>
<h4 id="内部类种类"><a href="#内部类种类" class="headerlink" title="内部类种类"></a>内部类种类</h4><ul>
<li><p>成员内部类（成员位置上非静态类）</p>
<p>需要先创建外部类对象，再创建内部类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.Inner in = <span class="keyword">new</span> Outer().<span class="keyword">new</span> Inner();</span><br></pre></td></tr></table></figure>
</li>
<li><p>局部内部类（定义在方法中的内部类）</p>
<p>可访问外部类中所有方法</p>
</li>
<li><p>匿名内部类（没有名字的内部类，开发较多）</p>
</li>
<li><p>静态内部类（static修饰）</p>
<p>不可以访问外部类中的非静态变量，外部类可通过外部类的对象调用，不用新建内部类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.StaticInner inner = <span class="keyword">new</span> Outer.StaticInner();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><ul>
<li>必须继承一个抽象类或接口</li>
<li>不能定义任何静态成员与静态方法</li>
<li>所在方法的形参被匿名内部类使用，需要用final修饰</li>
<li>匿名内部类不能是抽象的，必须实现继承的类或实现的接口所有的抽象方法</li>
</ul>
<p>创建方式如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类/接口&#123; </span><br><span class="line">  <span class="comment">//匿名内部类实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内部类优点"><a href="#内部类优点" class="headerlink" title="内部类优点"></a>内部类优点</h4><ul>
<li>方便访问其外部类中所有数据</li>
<li>不被其他包中的类所见，封装性较好</li>
</ul>
<h4 id="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"><a href="#局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？" class="headerlink" title="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"></a>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</h4><p>因为生命周期不同，局部变量存储在栈中，在方法执行结束后，非final的局部变量被销毁，但局部内部类对此变量引用仍然存在，这样当要调用的时候就会出错，增加final可以延长局部变量的生命周期。</p>
<h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><p>值传递指在方法调用时，传递的是参数列表值的拷贝</p>
<p>引用传递指方法调用时，传递的是引用的地址</p>
<h4 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</h4><p>值传递，Java语言的传递只支持值传递，当对象实例被传入方法，方法得到的只是参数的拷贝，因此方法中参数的值为此对象实例的一个引用，对象的属性可以在被调用时改变，但对对象引用的改变无法传递给调用者。</p>
<ul>
<li>方法不能修改一个<strong>基本数据类型</strong>的参数（即数值型或布尔型》</li>
<li>方法可以改变一个对象参数的状态（存储在堆内存中）</li>
<li>方法不能让对象参数的引用</li>
</ul>
<h3 id="常见类"><a href="#常见类" class="headerlink" title="常见类"></a>常见类</h3><h4 id="String的equals、-与intern"><a href="#String的equals、-与intern" class="headerlink" title="String的equals、==与intern"></a>String的equals、==与intern</h4><p>==的作用</p>
<ol>
<li>判断基础数据类型的</li>
<li>判断引用是否指向堆内存的同一地址</li>
</ol>
<p>equals方法在Object类中，String类中对其进行重写，判断两个String对象内容是否相同。先比较地址，再每个字符进行比较。</p>
<p>String类中有对应的String池即String pool，每个内容相同的字符串对应一个pool中的对象。</p>
<p>String的三种比较</p>
<p>比较1：值相同，对象不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1==s2);            <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>当使用new，就是新建对象，s1与s2指向堆中的不同空间，因此使用==判断为false。</p>
<p>比较2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String s2 = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>s1新建时，在pool和堆内存中都新建了对象，而s1指向堆内存中的对象，由于“abc”已经存在于常量池，因此s2指向的是常量池中的对象，一个指向堆，一个指向常量值，因此地址不同。</p>
<p>比较3：均不使用new</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(s1==s2);            <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>s1新建时，常量池中没有“abc”，会在常量池中新建，s1指向常量池中对象，而s2也指向常量池中对象，因此二者地址相同。</p>
<p>而String中的intern方法，返回字符串对象的规范化表示形式，即此字符串对应常量池中的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">System.out.println(s == s1.intern());<span class="comment">//false</span></span><br><span class="line">System.out.println(s == s2.intern());<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s2.intern());<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>intern的具体步骤是，当字符串s在常量池中不存在对应对象，创建并返回常量池对象；若常量池中存在对应对象，则返回常量池中的对象。</p>
<p>s指向堆内存，s1.intern指向常量池，二者不相同；s指向堆内存，s2.intern指向常量池，二者不相同；s1指向常量池，s2.intern指向常量池，二者相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String hello = <span class="string">"hello"</span>;</span><br><span class="line">String hel = <span class="string">"hel"</span>;</span><br><span class="line">String lo = <span class="string">"lo"</span>;</span><br><span class="line">System.out.println(hello == <span class="string">"hel"</span> + <span class="string">"lo"</span>);<span class="comment">//true</span></span><br><span class="line">System.out.println(hello == <span class="string">"hel"</span> + lo);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>hello指向的是常量池中的徐爱那个，而“hel”+“lo”也指向常量池中对象，而lo+“hel”，相当于调用StringBuilder的append方法，重新在堆中生成了一个对象，因此地址不同。</p>
<h4 id="String不变性的理解"><a href="#String不变性的理解" class="headerlink" title="String不变性的理解"></a>String不变性的理解</h4><ul>
<li>String类被final修饰，不能被继承</li>
<li>用+号拼接字符串后，会创建新的字符串</li>
<li>String s = new String(“hello”)可能创建一个或两个对象。若静态区中有“hello”字符串常量对象，仅在堆中创建一个对象。若静态区中没有“hello”对象，堆上和静态区中都需要创建对象</li>
<li>在Java中，通过+拼接字符串，底层会转为StringBuilder实例的append()方法来实现</li>
</ul>
<h4 id="String重写equals而不重写hashCode的问题"><a href="#String重写equals而不重写hashCode的问题" class="headerlink" title="String重写equals而不重写hashCode的问题"></a>String重写equals而不重写hashCode的问题</h4><p>在equals()被重写时，通常有必要重写hashCode()方法，以维护hashCode()方法的约定，即相对等的两个对象要有相同的hashCode，若只重写equals而不重写hashCode，在将String类对象加入Set或Map集合时，会先判断hashCode，再判断equals，但因为没有重写hashCode，会在集合中存储两个值相同的对象，导致混淆。</p>
<h4 id="String、StringBuffer、StringBuilder区别"><a href="#String、StringBuffer、StringBuilder区别" class="headerlink" title="String、StringBuffer、StringBuilder区别"></a>String、StringBuffer、StringBuilder区别</h4><ul>
<li>String、StringBuffer与StringBuilder均为final类，不允许被继承</li>
<li>字符串拼接时，String类可使用+号，而另外两个类需要使用append()方法</li>
<li>String长度不可变，而StringBuffer与StringBuilder长度可变</li>
<li>StringBuffer是线程安全的，而StringBuilder不是，StringBuffer在StringBuilder方法上加入了synchronized修饰，因此StringBuffer性能更低。多线程时使用StringBuffer，单线程下使用StringBuilder。</li>
<li>若String类型的字符串，在编译时就可以确定为字符串常量，在编译完成后，字符串会自动拼接为一个常量，此时String性能会更好</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Java中的内存泄漏多与集合容器相关。当集合中持有生命周期较短的对象，当对象作用已经结束，需要被销毁时，因为有长生命周期的集合持有，如果不进行手动销毁，会存在内存泄漏。</p>
<h3 id="List与Set"><a href="#List与Set" class="headerlink" title="List与Set"></a>List与Set</h3><p>Collection下有List、Set和Queue，重点说明List与Set的区别。</p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/list%E4%B8%8Eset.png" class title="This is an example image">

<p>一、特点</p>
<p>按照特点来看</p>
<ul>
<li>List：元素有序（存入和取出顺序一致），可以索引（角标）操作元素，元素可以重复</li>
<li>Set：元素不能重复，无序</li>
</ul>
<p>二、种类</p>
<ul>
<li><p>List</p>
<ul>
<li>底层是数组，查询快，增删慢<ul>
<li>Vector，线程安全，效率低</li>
<li>ArrayList，线程不安全，效率高</li>
</ul>
</li>
<li>底层是链表，查询慢，增删快<ul>
<li>LinkedList，线程不安全，效率高</li>
</ul>
</li>
</ul>
</li>
<li><p>Set</p>
<ul>
<li><p>底层是哈希表</p>
<p>HashSet，保证元素唯一性，存入的类需要覆写hashcode()和equals()方法</p>
<p>先判断hashcode()，再判断equals()</p>
</li>
<li><p>底层是二叉树</p>
<p>TreeSet，保证元素排序，两种排序方式，比较器优先使用</p>
<ul>
<li>自然顺序，让对象所属的类实现Compareble接口，覆盖compareTo()方法，无参构造</li>
<li>让集合自身具备比较功能，比较器实现Comparator接口，覆盖compare()方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>其中，Vector虽安全，但不适用于高并发。HashSet底层为HashMap，在add元素时，以键的形式放入，值为PRESENT。TreeSet的核心在排序，不排序用HashSet。TreeSet有两种排序方式，方式一是被排序类实现Compareble接口（实现equals()、hashcode()、compareTo()方法），方式二为传入比较器，比较器需要实现Comparator接口（实现compare()方法）。TreeSet底层为TreeMap，两种排序方式比较器优先级较高。</p>
<h4 id="ArrayList-和-LinkedList-的区别"><a href="#ArrayList-和-LinkedList-的区别" class="headerlink" title="ArrayList 和 LinkedList 的区别"></a>ArrayList 和 LinkedList 的区别</h4><ol>
<li>数据结构实现：ArrayList底层为动态数组（可动态扩容），LinkedList底层为双向链表</li>
<li>随机查询效率：ArrayList随机查询效率更高，而LinkedList只能依靠遍历，因此ArrayList查询效率更高</li>
<li>增加和删除效率：在增加和删除非首尾元素时，LinkedList效率更高，因为ArrayList的增加和删除操作会影响到其他位置的元素，涉及元素的移动</li>
<li>内存空间占用：LinkedList比ArrayList更占内存，因为LinkedList中除了存放数据，还有指向前后的引用</li>
<li>线程安全方面：二者都是不安全的</li>
</ol>
<p>因此，如果涉及频繁的查询操作，ArrayList更合适；涉及频繁的增删操作，LinkedList更合适</p>
<h4 id="ArrayList-和Vector-的区别"><a href="#ArrayList-和Vector-的区别" class="headerlink" title="ArrayList 和Vector 的区别"></a>ArrayList 和Vector 的区别</h4><ol>
<li>线程安全：Vector使用synchronized保障线程安全，ArrayList不是</li>
<li>性能：因为Vector存在锁，因此性能不如ArrayList</li>
<li>扩容：ArrayList和Vector均可以动态扩容，Vector新容量为原来的2倍，而ArrayList新容量为原来的1.5倍</li>
</ol>
<p>在不需要线程安全时，建议使用ArrayList。</p>
<p>如果想在多线程下使用ArrayList，可以使用Collections.synchronizedList(list)方法</p>
<h4 id="List遍历时删除问题"><a href="#List遍历时删除问题" class="headerlink" title="List遍历时删除问题"></a>List遍历时删除问题</h4><p>如果直接for循环遍历List，再进行remove操作，会报ConcurrentModificationException，因为使用了foreach语句时，会自动生成一个Iterator来遍历list，但同时该list又在被iterator.remove()方法修改，不允许在其他地方进行删除，因此这样会出问题。</p>
<p>解决办法1：使用迭代器来获取List中全部元素，再调用iterator的remove方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">   *<span class="comment">// do something*</span></span><br><span class="line">   it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法2：利用下标来获取元素，再使用删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">          list.remove(list.get(i));</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="HashSet实现原理"><a href="#HashSet实现原理" class="headerlink" title="HashSet实现原理"></a>HashSet实现原理</h4><p>HashSet基于HashMap而实现，HashSet中的值存放于HashMap的key上，HashMap的value全部为PRESENT，HashSet底层方面基本是调用HashMap来实现的。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap为Java中非常重要和常用的一种数据结构，下面将重点介绍HashMap的底层原理及方法实现。</p>
<p>Java8以前：数组+链表</p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/%E9%93%BE%E8%A1%A8hash.png" class title="This is an example image">

<p>操作为非同步，效率较高。<strong>数组默认16</strong>，存储链表头节点，数组位置的获得方式是hash(key.hashCode())%len，计算键的哈希值再算出%数组长度的值。实际中通过位运算来实现。其中数组的类型为Entry&lt;K,V&gt;，当发生哈希冲突时，则将数组中的Entry设置为新值的next，新值放在数组中，旧值在新值的链表上。</p>
<p>最坏的情况下，链表会集中在一个数组，这样查找的时间复杂度从O(1)变为O(n)。</p>
<p>Java8及以后：链表+数组+红黑树</p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/%E7%BA%A2%E9%BB%91%E6%A0%91hash.png" class title="This is an example image">

<p>当数组中某个位置链表长度大于TREEIFY_THRESHOLD常量时，链表转换为红黑树，最坏情况下的性能从O(n)提高到O(logn)。数组类型变为Node，当链表大小<strong>超过</strong>TREEIFY_THRESHOLD（<strong>默认是8</strong>）时，链表被改造成红黑树。当红黑树元素被删除<strong>低于</strong>UNTREEIFY_THRESHOLD（<strong>默认是6</strong>）时，红黑树被转成链表。HashMap在首次使用时才被初始化，可以扩容，当插入一个元素，若对应位置数组没有元素，则新建；如果有，则判断是树还是链表，按照相应方式插入。若链表元素超过阈值，则树化；若插入值的键重复，就更新值。</p>
<h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><p>HashMap的put方法逻辑是：</p>
<ol>
<li>若HashMap未被初始化 ，进行初始化</li>
<li>对key求hash值，计算下标</li>
<li>如果没有碰撞，直接放入桶中</li>
<li>如果碰撞了，以链表的方式链接到后面</li>
<li>如果链表长度超过阈值（8），把链表转成红黑树</li>
<li>如果链表的长度低于6，把红黑树转成链表</li>
<li>如果key对应节点存在，替换旧值</li>
<li>如果桶满了（容量16*负载因子0.75），需要resize（扩容2倍重排）</li>
</ol>
<h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><p>先计算hash值找到对应的桶，然后在链表或者红黑树中通过equals方法找到对应的节点，找到值并返回。</p>
<h4 id="扩容resize-方法"><a href="#扩容resize-方法" class="headerlink" title="扩容resize()方法"></a>扩容resize()方法</h4><p>在构造哈希表时，若不指明初始大小，默认为16，若大小达到了容量16*负载因子0.75，用大数组去替代小数组，重新调整hashmap大小为原来2倍，比较耗时。</p>
<p>具体逻辑为创建一个大小为原数组大小2倍的新数组，要原数组中的元素重新计算在新数组中的索引，然后添加至新数组中。</p>
<ul>
<li>在多线程环境下，调整大小会存在条件竞争，容易造成<strong>死锁</strong></li>
<li>rehashing是一个比较耗时的过程</li>
</ul>
<p>在JDK7前，哈希表扩容，需要重新计算每个元素在新的数组中的位置，然后进行移动。在JDK8中进行了优化，通过位运算来判断元素是否需要移动，如果位置不变可直接放入对应的位置；如果出现了变化，新的位置是原来的下标位置+原数组长度。</p>
<p>可以这么做是因为计算hash的时候，采用的是散列后的哈希值与上数组长度减一。初始为16，二进制的长度减一为1111，当扩容后，数组新长度为11111，如果一个key倒数第5位本来计算就是0，这样当扩容后计算的位置还是不变的，如果倒数第5位是1，相当于要加上10000，即老数组长度16，因此若有变化将原来老数组下标加上老数组长度就是在新数组中的位置。</p>
<h4 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h4><p>为何负载因子要选为0.75，而不是更高的1，或者更小的0.5呢。如果负载因子选为1，则resize()的阈值会变得比较高，更不容易扩容，减少了rehash的成本，但是这样桶中元素更密集，哈希碰撞更严重，降低了查询效率。如果选为0.5，则resize()的阈值变得很低，扩容频繁，虽然桶中元素分布更散列，但扩容成本变高。因此为了权衡扩容成本与查询效率，选了折中的数字0.75。</p>
<h4 id="cpu占用100-的问题"><a href="#cpu占用100-的问题" class="headerlink" title="cpu占用100%的问题"></a>cpu占用100%的问题</h4><p>出现在JDK7，因为在JDK7中链表元素的插入采用的是头插法，即如果插入元素的顺序为1,2,3，链表的顺序是3-&gt;2-&gt;1，然后在扩容的时候，当两个线程均新建了一个新的数组，一个数组将链表元素放入到新数组中，由于从头节点开始放，因此此时的顺序是1-&gt;2-&gt;3，而对于第二个链表，其当前记录指针e若指向3，e的next指向2，此时会让3再指向2，这样相当于形成了一个循环链表，这样当使用get()方法的时候，就会死循环。</p>
<p>JDK8后，链表插入采用尾插入的方法，这样便解决了死循环问题，但在多线程下HashMap仍然会存在节点丢失等问题，因此不能在单线程下使用。</p>
<h4 id="如何减少碰撞"><a href="#如何减少碰撞" class="headerlink" title="如何减少碰撞"></a>如何减少碰撞</h4><ul>
<li><p>使用扰动函数：促使元素位置分布均匀，减少碰撞几率</p>
</li>
<li><p>使用final对象，并采用合适的equals()和hashCode()方法</p>
<p>使用String、Integer等类作为键很好，防止键值改变，放入和获取到的键不一样，就不能获取到</p>
</li>
</ul>
<p>哈希散列的过程：可以看到<strong>hashmap允许键为null</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> h;</span><br><span class="line">	<span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h=key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将hashCode右移16位，去除低位，与原数据异或，混合原始哈希码的高位和低位，加大低位随机性，散列更均匀，计算下标使用(数组长度-1)&amp;hash，数组长度总为2^n（传入值时替换为最接近2的n次方的值），等价于对长度取模，效率更高。    </p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/hash%E6%95%A3%E5%88%97.png" class title="This is an example image">

<h4 id="Dos攻击"><a href="#Dos攻击" class="headerlink" title="Dos攻击"></a>Dos攻击</h4><p>在JDK7以前，如果对方知道我方使用哈希算法，可以发送大量哈希值相同的请求来导致严重的哈希碰撞，然后不停访问这些key就可以显著影响服务器的性能（大量占用CPU），这样形成了一次拒绝服务供给（DoS）。这样将最坏性能从O（N）优化至O（logN），有较大的改善。</p>
<p>那么怎么进一步处理呢？</p>
<ol>
<li>限制POST和GET请求参数个数</li>
<li>限制POST请求的请求体大小</li>
<li>Web Application FireWall（WAF）</li>
</ol>
<p>对于JDK7，HashMap会动态的使用一个专门的TreeMap实现来替换掉它。</p>
<h4 id="多线程下的HashMap"><a href="#多线程下的HashMap" class="headerlink" title="多线程下的HashMap"></a>多线程下的HashMap</h4><p>由于HashMap不是线程安全的，在多线程下会出现问题，有</p>
<ul>
<li><p>多线程put操作后，get操作导致死循环</p>
<p>rehash时容易出现环状链表</p>
</li>
<li><p>多线程put非null元素后，get操作得到null值</p>
</li>
<li><p>多线程put操作，导致元素丢失</p>
</li>
</ul>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><blockquote>
<p>引用自博客<code>https://my.oschina.net/hosee/blog/618828</code></p>
</blockquote>
<p>要了解红黑树是什么，为什么要有红黑树。</p>
<p>红黑树是<strong>相对平衡</strong>的<strong>二叉查找树</strong>，不同的是在每个结点上增加一个存储位来表示颜色，Red或Black。而红黑树的特点是通过对任何一条从根到叶子的路径上各个结点的着色方式的限制，<strong>红黑树确保没有一条路径比其他路径长出两倍</strong>，树是接近平衡的。没有AVL树那么平衡。</p>
<p>二叉查找树简单理解是：</p>
<ul>
<li>若有左子树，则左子树上所有结点的值均小于根节点值 </li>
<li>若有右子树，则右子树上所有结点的值均大于根节点值</li>
<li>任意节点的左、右子树分别为二叉查找树</li>
<li>没有键值相等的节点</li>
</ul>
<p>一般普通的二叉查找树高度为log(N)，但如果二叉查找树退化为一个链表，最坏时间会变成O（N）,那么红黑树如何保证树相对平衡呢？介绍其5个性质：</p>
<ol>
<li>每个节点要么红、要么黑</li>
<li>根节点是黑</li>
<li>叶节点是黑的空节点</li>
<li>若一个节点是红，两个儿子都是黑的（不存在两个连续的红色节点）</li>
<li>对任意节点，其到叶节点尾端指针的每条路径都包含相同数目的黑节点</li>
</ol>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%9B%BE.png" class title="This is an example image">

<p>数学证明红黑树的操作时间复杂度最差为O(logN)。</p>
<h4 id="HashMap与HashTable"><a href="#HashMap与HashTable" class="headerlink" title="HashMap与HashTable"></a>HashMap与HashTable</h4><p>因为HashMap在多线程下不安全，而线程安全的类有HashTable，其线程安全原因是使用了synchronized修饰符，锁为调用者的this，与Collections.synchronizedMap(hashMap)几乎无区别，只是锁不一样，synchronizedMap锁为Object类的mutex，hashMap方法均用synchronized(mutex)加锁。</p>
<p>而HashTable初始容量为11，与HashMap不同。扩容时，计算容量为2倍原来容量+1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但HashTable在多线程下效率较低，因此又引入了ConcurrentHashMap。</p>
<p>二者的区别概括为</p>
<ul>
<li><p>线程安全</p>
<p>HashMap不安全，HashTable安全</p>
</li>
<li><p>能否存空键</p>
<p>HashMap可以，计算散列值时null的hash为0，HashTable不可以</p>
</li>
<li><p>初始容量与扩容</p>
<p>HashMap默认初始16，HashTable为11；</p>
<p>扩容时，HashMap为原来2倍，HashTable为原来2倍+1；</p>
<p>指定容量，HashMap会计算与指定的最接近的2的整数次幂作为初始容量，HashTable按照指定的</p>
</li>
<li><p>效率</p>
<p>HashMap效率更高，HashTable因为有synchronized，效率更低</p>
</li>
<li><p>底层结构</p>
<p>HashMap1.8后底层为数组+链表+红黑树，HashTable没有树化的机制</p>
</li>
</ul>
<h4 id="HashMap与ConcurrentHashMap"><a href="#HashMap与ConcurrentHashMap" class="headerlink" title="HashMap与ConcurrentHashMap"></a>HashMap与ConcurrentHashMap</h4><p>那么该如何优化HashTable呢？</p>
<p><strong>通过锁细粒度化，将整锁拆解成多个锁进行优化</strong>。</p>
<p>早期的ConcurrentHashMap通过<strong>分段锁Segment</strong>实现</p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/segment.png" class title="This is an example image">

<p>在HashMap的基础上，外面多了一层数组结构，有多个Segment（一种可重入锁），Segment继承自ReentrantLock，每个Segment中有多段数据（HashEntry），当一个线程占用一个锁时，位于此Segment上的其他数据也可以被访问到。默认分配<strong>16</strong>个Segment，理论上比HashTable效率高16倍。将HashMap的table数组逻辑上拆分为多个子数组，每个子数组配置一个Segment，线程只有在获取到某把分段锁后，才能获取到其中的子数组，其他没有该Segment的线程访问其中数据被阻塞，而访问没有被Segment锁住的数据不会被阻塞。</p>
<p>而当前的ConcurrentHashMap，使用<strong>CAS+Synchronized使锁更细化</strong></p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/%E6%96%B0con.png" class title="This is an example image">

<p>使用CAS+synchronized为保证并发安全，数据结构使用数组+链表/红黑树，synchronized锁定的是当前链表或树的首节点，只要没有哈希冲突，效率就可以被进一步提高。许多参数与HashMap类似，如树化和反树化参数。也有一些特有的参数，如sizeCtl，是大小控制的标识符，-1表示正在初始化，-n表示有n-1个线程在执行扩容操作，正数或零表示还没有初始化，数值表示下一次初始化或扩容大小，此参数有volatile修饰，在多线程间可见。</p>
<p>相比于HashMap可以添加null键，ConcurrentHashMap不允许添加null键和null值，其对数组元素的更新使用CAS操作。</p>
<p>ConcurrentHashMap的put方法</p>
<ol>
<li>判断Node[]数组是否初始化，没有则进行初始化操作</li>
<li>通过hash值定位数组的索引坐标，看是否有Node节点，如果没有则使用<strong>CAS添加</strong>（链表的头节点f），添加失败进入下次循环</li>
<li>若检查到内部在扩容，<strong>协助扩容</strong></li>
<li>判断链表/红黑树头节点f是否为空，若不为空则<strong>用synchronized锁住</strong><ul>
<li>若为链表结构，执行链表的添加操作</li>
<li>若为树结构，执行树的添加操作</li>
</ul>
</li>
<li>如果链表长度到达临界值（默认为8），将链表转换为树结构</li>
</ol>
<p>比起Segment，锁更细化，只要没有哈希冲突就不会有并发获得锁的情况，因为其锁的是每一个桶。在put方法操作时，比较关键的是若当前没有Node节点，先使用<strong>CAS操作插入头节点</strong>，失败则循环重试；若已经有头节点，则<strong>获取头节点的锁</strong>后再进行相关操作。</p>
<p>此外，计算map的大小时，有size()和mappingCount()方法，从源码可以看出，size()返回的为int类型，有大小限制，而mappingCount()方法返回long类型，JDK更推荐使用mappingCount()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">mappingCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0L</span>) ? <span class="number">0L</span> : n; <span class="comment">// ignore transient negative values</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三者的比较"><a href="#三者的比较" class="headerlink" title="三者的比较"></a>三者的比较</h4><ul>
<li>HashMap线程不安全，数组+链表+红黑树</li>
<li>HashTable线程安全，锁住整个对象，数组+链表</li>
<li>ConcurrentHashMap线程安全，CAS+synchronized，数组+链表+红黑树</li>
<li>HashMap的key、value均可为null，而其他两个类不支持</li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>框架：最早是BIO，后来有NIO，再后来有AIO，但这些API都不好用，于是Netty基于NIO进行了封装。</p>
<h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>Blocking IO(Input-Output)</p>
<p>IO速度相比CPU速度非常慢</p>
<p>半双工，读的时候不能同时写。</p>
<p>阻塞IO，有个client连接，服务端就新建一个线程进行连接。</p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/BIO.png" class title="This is an example image">

<p>服务端：服务端等待客户端建立连接，通过accept方法获取Socket，此方法会阻塞直到客户端连接，服务端获取到socket后，新建一个线程处理socket的数据读写。socket的读与写不是双向的，单独拿出socket的InputStream来读，拿出OutputStream来写。</p>
<p>客户端：建立一个Socket，向输出流写信息，从服务端读信息，关闭socket连接。</p>
<p>Blocking在于：建立连接阻塞，读写阻塞</p>
<ul>
<li>Server端accpet方法阻塞，没有客户端连接就wait</li>
<li>在处理socket流的读与写方法也是阻塞的</li>
</ul>
<p>需要是多线程，因为accept为阻塞的，一个连接一个线程，只有一个线程其他客户端会被阻塞，一次只能处理一个客户端。可以使用线程池。</p>
<p>BIO效率低，并发量不好。BIO很少用，代码简单，适合建立连接少的情况。</p>
<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>Non-Blocking IO </p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/NIO.png" class title="This is an example image">

<p>上面为NIO的<strong>单线程模型</strong>，用一个线程处理客户端的连接，selector轮询客户端是否有连接与读写，门面模式？selector负责client的连接与读写。并不是只能一个连接，而是selector一次处理一次请求。</p>
<p>NIO服务端对socket封装为ServerSocketChannel，此通道为<strong>双向</strong>，可同时读写，设置非阻塞，打开并注册selector，此时关心的只是建立连接，selector进行select，此<strong>方法</strong>也是<strong>阻塞</strong>，获取到key并进行处理。</p>
<p>为了处理客户端的连接，需要将selector注册到客户端的channel中，因此selector处理的是服务端的channel+客户端的channel，不同的channel上的时间在一个set中，selector从set中获取事件并处理，每次处理事件后要将其移除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();<span class="comment">//服务端的socket</span></span><br><span class="line">      ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">8888</span>));<span class="comment">//绑定地址</span></span><br><span class="line">      ssc.configureBlocking(<span class="keyword">false</span>);<span class="comment">//设置非阻塞</span></span><br><span class="line">      System.out.println(<span class="string">"server started, listening on :"</span> + ssc.getLocalAddress());</span><br><span class="line">      <span class="comment">//要有selector</span></span><br><span class="line">      Selector seletor = Selector.open();</span><br><span class="line">      ssc.register(seletor, SelectionKey.OP_ACCEPT);<span class="comment">//将selector注册</span></span><br><span class="line">      <span class="comment">//轮训</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">          seletor.select();<span class="comment">//看是否有连接，阻塞</span></span><br><span class="line">          Set&lt;SelectionKey&gt; keys = seletor.selectedKeys();<span class="comment">//获取所有的keys</span></span><br><span class="line">          <span class="comment">//迭代keys</span></span><br><span class="line">          Iterator&lt;SelectionKey&gt; it = keys.iterator();</span><br><span class="line">          <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">              SelectionKey key = it.next();</span><br><span class="line">              <span class="comment">//获取后移除，不移除会重复处理</span></span><br><span class="line">              it.remove();</span><br><span class="line">              handle(key);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>此时Selector负责客户端连接与读写，干的太负责，于是有了reactor模式</p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/NIO2.png" class title="This is an example image">

<p>NIO的多线程模型</p>
<p>Observer模式，响应式编程。selector只负责与客户端建立连接，然后又客户端要进行读写后，selector交给线程池进行处理。selector+worker。</p>
<p>如果客户端消息来不及处理，可以放入消息队列。NIO的ByteBuffer比较难用，读与写只用一个指针，较少直接用NIO，多用Netty。</p>
<p>NIO相比BIO，不用一个客户端连接建立一个线程，客户端连接只需要一个线程来管理。但NIO需要一直轮询。</p>
<h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><p>Asynchronous-IO</p>
<p>客户端要建立连接时，操作系统通知selector，selector连接通道，再交给工人去执行读写操作。</p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/AIO.png" class title="This is an example image">

<p>AIO的accpet不是阻塞的，当执行accpet后会<strong>继续往下</strong>，因此要在accept后设置循环等待避免main方法结束。当有客户端连接，交给CompletionHandler来处理，本质是模板方法模式，只重写关心的方法。方法写好了，当有客户端连接时自动调用completed方法执行。</p>
<p>总的来说，当操作系统发现有客户端连接请求，调用写好的建立连接的方法，建立连接的方法再调用写的方法，使用观察者模式来实现异步操作。</p>
<p>现在读也可以是非阻塞的，读了就执行其他，当读完后再执行一个CompletionHandler。</p>
<p>AIO与NIO在Linux下都是基于epoll实现的，epoll也是轮询，因此底层实现一样，<strong>AIO多了层封装</strong>，在Linux下使用AIO效率并一定高，Netty对NIO进行封装，使得API更像AIO，更好用。Windows下的AIO单独实现，使用Completion Port，但大多数Server都是基于Linux实现的，因此Netty还是基于NIO封装。</p>
<h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><p>实现对NIO，BIO的封装，封装成AIO的样子。建立两个group，一个负责建立连接，一个负责读写，将这两个group交给Server启动的封装类，指定连接后者两个group的类型，对每个客户端连接增加监听器，进行处理，一旦通道被初始化，在此通道添加对此通道的监听器，这样将连接与业务处理代码解耦。对于读写的处理过程，重写channelRead方法等。对于异常处理，将相应的通道关闭。</p>
<h4 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h4><p>客户端的写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//事件处理线程池，可处理连接或读写事件</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);<span class="comment">//1个线程</span></span><br><span class="line">        <span class="comment">//辅助启动类</span></span><br><span class="line">        Bootstrap b = <span class="keyword">new</span> Bootstrap();<span class="comment">//启动</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//连接server</span></span><br><span class="line">            b.group(group)<span class="comment">//传入group</span></span><br><span class="line">                    <span class="comment">//指定channel类型为nio</span></span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)//指定<span class="title">channel</span>类型</span></span><br><span class="line"><span class="class">                    //当<span class="title">channel</span>有事件，指定处理的<span class="title">handler</span></span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ClientChannelInitializer</span>())</span></span><br><span class="line">                    .connect("localhost",8888)//连接远程，异步方法，无法知道是否成功</span><br><span class="line">                    .sync();<span class="comment">//必须等其结束，不让继续进行</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();<span class="comment">//正常结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、定义事件处理的线程池</p>
<p>2、定义辅助启动类</p>
<p>3、链式编程</p>
<ul>
<li>将辅助类中传入线程池</li>
<li>指定channel的类型为bio还是nio</li>
<li>增加连接后的处理handler</li>
<li>进行连接，返回的是ChannelFuture，为了知道是否连接成功<ul>
<li>再加入sync方法</li>
<li>或自定义监听器</li>
</ul>
</li>
</ul>
<p>Netty中方法均是异步的。</p>
<p>connet为异步，返回ChannelFuture，使用sync才知道是否有成功执行，如果不用sync的写法，需要在Future中增加监听器。因为ChannelFuture得到的是异步的结果，当其中有结果后，会调用监听器中的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//连接server</span></span><br><span class="line">         ChannelFuture f = b.group(group)<span class="comment">//传入group</span></span><br><span class="line">                 <span class="comment">//指定channel类型为nio</span></span><br><span class="line">                 .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)//指定<span class="title">channel</span>类型</span></span><br><span class="line"><span class="class">                 //当<span class="title">channel</span>有事件，指定处理的<span class="title">handler</span></span></span><br><span class="line"><span class="class">                 .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ClientChannelInitializer</span>())</span></span><br><span class="line">                 .connect("localhost", 8888);//连接远程，异步方法，无法知道是否成功</span><br><span class="line">         f.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                 <span class="keyword">if</span> (!future.isSuccess())&#123;</span><br><span class="line">                     System.out.println(<span class="string">"not connected!"</span>);</span><br><span class="line">                 &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                     System.out.println(<span class="string">"connected!"</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">         f.sync();</span><br></pre></td></tr></table></figure>

<p>因为Future异步，加入监听器后也会继续往下 ，为了阻塞住它，加上sync，在结束后才继续进行，加sync是为了防止客户端还没有建立好连接则main线程直接结束。</p>
<p>其中打印的顺序是，channel初始化的时候，客户端打印SocketChannel，服务端连接上客户端后，服务端打印信息，然后客户端的监听器打印。</p>
<h4 id="服务端连接"><a href="#服务端连接" class="headerlink" title="服务端连接"></a>服务端连接</h4><p>对于服务端的写法</p>
<p>1、指定负责连接与读写的线程池</p>
<p>2、服务端的启动类</p>
<p>3、链式编程</p>
<ul>
<li>启动类绑定两个线程池</li>
<li>指定channel类型为NIO</li>
<li>为客户端的通道增加监听器</li>
<li>绑定监听端口</li>
<li>等待future返回</li>
</ul>
<p>4、让服务器等待被关闭</p>
<ul>
<li>获取到future对应的服务端的channel，再调用closeFuture，不调用close就被阻塞，调用sync等待此future结束</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);<span class="comment">//负责连接</span></span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>);<span class="comment">//负责读写</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            ChannelFuture f = b.group(bossGroup, workerGroup)<span class="comment">//指定线程池类型，一个连接，一个读写</span></span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)//指定<span class="title">channel</span>类型</span></span><br><span class="line"><span class="class">                    //加在客户端上</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            System.out.println(ch);<span class="comment">//打印客户端端口</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .bind(<span class="number">8888</span>)<span class="comment">//监听端口</span></span><br><span class="line">                    .sync();<span class="comment">//等待future执行完毕</span></span><br><span class="line">            System.out.println(<span class="string">"server started!"</span>);</span><br><span class="line">            <span class="comment">//等着服务器关闭</span></span><br><span class="line">            f.channel().closeFuture().sync();<span class="comment">//阻塞，拿到server的channel，没有调用close，closeFuture会被一直阻塞</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭</span></span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很多情况下都使用到了sync的写法，因为Netty中方法为异步，为了知道执行结果必须加入sync，只有有返回值后才继续进行。</p>
<h4 id="客户端与服务端读写数据"><a href="#客户端与服务端读写数据" class="headerlink" title="客户端与服务端读写数据"></a>客户端与服务端读写数据</h4><p>客户端如果需要向服务端写数据，需要在其被初始化完成后，调用的initChannel方法中，在此channel的责任链上加上一个监听器，继承自<code>ChannelInboundHandlerAdapter</code>，就是Channel的Handler，其中Adapter表示实现了其骨架，只需要重写部分方法即可。当此channel被激活后，就可以写数据，Netty写数据通过Bytebuf，此为直接内存，为操作系统管理，读写更高效，将要写的消息转为字节再写入。其中需要释放Bytebuf的内存，当使用writeAndFlush后，自动释放 。为了读取服务端数据，重写channelRead方法。</p>
<p>其中ChannelHandlerContext是通道上下文信息，聚合了Channel。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> ClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//channel第一次连上可用，写出一个字符串</span></span><br><span class="line">        <span class="comment">//写数据依靠ByteBuf，堆外内存Direct Memory</span></span><br><span class="line">        <span class="comment">//需要释放buf</span></span><br><span class="line">        ByteBuf buf = Unpooled.copiedBuffer(<span class="string">"hello"</span>.getBytes());</span><br><span class="line">        ctx.writeAndFlush(buf);<span class="comment">//自动释放</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//数据存在msg中</span></span><br><span class="line">        ByteBuf buf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            buf = (ByteBuf)msg;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.readableBytes()];</span><br><span class="line">            buf.getBytes(buf.readerIndex(),bytes);<span class="comment">//读到字节数组中</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//手动释放内存</span></span><br><span class="line">            <span class="keyword">if</span> (buf != <span class="keyword">null</span>) ReferenceCountUtil.release(buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在服务端中，也是类似，当channel初始化后，加上一个服务端channel的监听器</p>
<p>将对应客户端的流的责任链上加上一个监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ChannelFuture f = b.group(bossGroup, workerGroup)<span class="comment">//指定线程池类型，一个连接，一个读写</span></span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)//指定<span class="title">channel</span>类型</span></span><br><span class="line"><span class="class">                    //加在客户端上，每个客户端通道初始化完成后调用</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="comment">//相当于客户端进来了</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//负责客户端连接后的事宜</span></span><br><span class="line">                            <span class="comment">//责任链模式</span></span><br><span class="line">                            ChannelPipeline pl = ch.pipeline();<span class="comment">//在每个责任链上加入一个handler</span></span><br><span class="line">                            pl.addLast(<span class="keyword">new</span> ServerChildHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .bind(<span class="number">8888</span>)<span class="comment">//监听端口</span></span><br><span class="line">                    .sync();<span class="comment">//等待future执行完毕</span></span><br></pre></td></tr></table></figure>

<p>然后读的handler如下，使用的是channelRead，在有数据读入的时候被调用，将 msg转为Bytebuf，然后获取此Bytebuf中可读数据长度，构建字节数组，通过buf的得到字节方法，指定可读的初始位置与要存入的位置，将数据读取到数组中，转为String即可输出。因为此buf需要被手动释放，因此在finally中释放。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerChildHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span></span>&#123;</span><br><span class="line">    <span class="comment">//接收数据</span></span><br><span class="line">    <span class="comment">//当此管道有数据读入，将数据保存到这里</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//数据存在msg中</span></span><br><span class="line">        ByteBuf buf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            buf = (ByteBuf)msg;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.readableBytes()];</span><br><span class="line">            buf.getBytes(buf.readerIndex(),bytes);<span class="comment">//读到字节数组中</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line"><span class="comment">//            System.out.println(buf);</span></span><br><span class="line"><span class="comment">//            System.out.println(buf.refCnt());</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//手动释放内存</span></span><br><span class="line">            <span class="keyword">if</span> (buf != <span class="keyword">null</span>) ReferenceCountUtil.release(buf);</span><br><span class="line"><span class="comment">//            System.out.println(buf.refCnt());</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是当服务端读到数据后，立刻向客户端写数据，此时就不用自己关闭了，再次关闭会出错。通过ctx来写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//数据存在msg中</span></span><br><span class="line">    ByteBuf buf = <span class="keyword">null</span>;</span><br><span class="line">    buf = (ByteBuf)msg;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.readableBytes()];</span><br><span class="line">    buf.getBytes(buf.readerIndex(),bytes);<span class="comment">//读到字节数组中</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line">    <span class="comment">//写回数据</span></span><br><span class="line">    ctx.writeAndFlush(buf);<span class="comment">//不能再自己释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遇到了服务端写数据，服务端出错的异常，后来检查发现是因为客户端建立连接后，异步方法继续向下走，导致main方法结束，客户端关闭了，因此异步的方法一定要注意加sync来手动阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">f.sync();</span><br><span class="line"><span class="comment">//客户端中也要加上sync，避免客户端自己关闭</span></span><br><span class="line">f.channel().closeFuture().sync();</span><br></pre></td></tr></table></figure>

<h4 id="服务器分发数据"><a href="#服务器分发数据" class="headerlink" title="服务器分发数据"></a>服务器分发数据</h4><p>服务端为了向客户端分发数据，需要有channelGroup，传入相应的处理线程。然后在客户端通道被激活时，将其加入到通道组中，在写数据的时候，写到通道组中。</p>
<p>服务端属性：通道组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ChannelGroup clients = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br></pre></td></tr></table></figure>

<p>客户端通道激活时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">//通道可用时，将其放入通道</span></span><br><span class="line">      Server.clients.add(ctx.channel());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在写数据的时候</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写到每一个通道组中</span></span><br><span class="line">   Server.clients.writeAndFlush(buf);<span class="comment">//不能再自己释放</span></span><br></pre></td></tr></table></figure>

<p>这样就将一个客户端写入的数据分发到了所有的客户端。这种方法核心为通道组。</p>
<h4 id="客户端与服务端图形化界面"><a href="#客户端与服务端图形化界面" class="headerlink" title="客户端与服务端图形化界面"></a>客户端与服务端图形化界面</h4><p>客户端：</p>
<p>新建客户端窗口类，可以输入字符串，显示在窗口上。</p>
<p>新建客户端类，将之前写在main中的连接服务器的方法封装在connect方法中，在其main方法中，新建一个客户端对象，调用其connect方法就可以与服务端建立连接。客户端窗口类持有一个客户端对象，在图形化界面初始化后，新建一个客户端对象，调用其connect方法即可连接服务器。</p>
<blockquote>
<p>设计思路：将客户端与图形化界面解耦合，单一职责原则。</p>
</blockquote>
<p>为了之后方便去给服务端写数据，客户端对象持有一个Channel对象，在成功连接服务器后，初始化channel</p>
<p>channel为客户端与服务端之间的通道，pipeline为此通道上的责任链</p>
<p>客户端类提供send(String msg)方法，当调用时，使用持有的channel写信息。</p>
<p>在客户端界面类，当界面初始化后，调用自身的连接至服务器方法，新建一个客户端类，并调用其connect方法，然后在文本框中增加监听器，当按下回车时，读取到文本框中的信息，并调用客户端的send方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientFrame</span> <span class="keyword">extends</span> <span class="title">Frame</span> </span>&#123;</span><br><span class="line">    TextArea ta = <span class="keyword">new</span> TextArea();<span class="comment">//多行</span></span><br><span class="line">    TextField tf = <span class="keyword">new</span> TextField();<span class="comment">//单行</span></span><br><span class="line">    Client c = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientFrame</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setSize(<span class="number">600</span>,<span class="number">400</span>);</span><br><span class="line">        <span class="keyword">this</span>.setLocation(<span class="number">100</span>,<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">this</span>.add(ta,BorderLayout.CENTER);</span><br><span class="line">        <span class="keyword">this</span>.add(tf,BorderLayout.SOUTH);</span><br><span class="line">        tf.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//把字符串发送到服务器</span></span><br><span class="line">                ta.setText(ta.getText()+tf.getText());</span><br><span class="line">                c.send(tf.getText());</span><br><span class="line">                <span class="comment">//写发送消息的逻辑</span></span><br><span class="line">                tf.setText(<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        connectToServer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectToServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化client,调用connect</span></span><br><span class="line">        c = <span class="keyword">new</span> Client();</span><br><span class="line">        c.connect();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClientFrame cf = <span class="keyword">new</span> ClientFrame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于客户端类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture f = b.group(group)</span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> ClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .connect(<span class="string">"localhost"</span>, <span class="number">8888</span>)</span><br><span class="line">                    .addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="keyword">if</span> (future.isSuccess())&#123;</span><br><span class="line">                                System.out.println(<span class="string">"connected"</span>);</span><br><span class="line">                                channel = future.channel();<span class="comment">//初始化</span></span><br><span class="line">                            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                                System.out.println(<span class="string">"not connected"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="comment">//调用时，将msg通过channel写出去</span></span><br><span class="line">        ByteBuf buf = Unpooled.copiedBuffer(msg.getBytes());</span><br><span class="line">        channel.writeAndFlush(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//数据存在msg中</span></span><br><span class="line">        ByteBuf buf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            buf = (ByteBuf)msg;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.readableBytes()];</span><br><span class="line">            buf.getBytes(buf.readerIndex(),bytes);<span class="comment">//读到字节数组中</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//手动释放内存</span></span><br><span class="line">            <span class="keyword">if</span> (buf != <span class="keyword">null</span>) ReferenceCountUtil.release(buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心为：调用客户端类，建立与服务端的连接，为了在另一个类中实现写消息，让客户端传给服务端，那么客户端中需要提供此方法，而写消息要通过channel，因此客户端需要有个channel的属性，在第一次初始化后初始channel，在发送消息的方法中，直接在channel中写入信息即可，重点为持有channel。</p>
<p>现在需要将服务端发送来的信息显示在客户端界面类中，那么接收消息是在客户端类中，那么客户端必须要跟客户端界面类耦合才能将信息显示在客户端界面类中，一种做法是客户端类中持有客户端界面类的引用，另一种做法是将客户端界面类做成单例。对于更新方法，拿到一个字符串后，加入换行符显示在界面上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端界面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ClientFrame INSTANCE = <span class="keyword">new</span> ClientFrame();</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateText</span><span class="params">(String msgAccepted)</span></span>&#123;</span><br><span class="line">       ta.setText(ta.getText()+System.getProperty(<span class="string">"line.separator"</span>)+msgAccepted);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ClientFrame cf = ClientFrame.INSTANCE;</span><br><span class="line">       cf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">       cf.connectToServer();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在客户端，因为客户端对象是单例的，直接通过类名就可以获取，不需要传入对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//数据存在msg中</span></span><br><span class="line">       ByteBuf buf = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           buf = (ByteBuf)msg;</span><br><span class="line">           <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.readableBytes()];</span><br><span class="line">           buf.getBytes(buf.readerIndex(),bytes);<span class="comment">//读到字节数组中</span></span><br><span class="line">           <span class="comment">//写在clientFrame中</span></span><br><span class="line">           String msgAccepted = <span class="keyword">new</span> String(bytes);</span><br><span class="line">           ClientFrame.INSTANCE.updateText(msgAccepted);</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//手动释放内存</span></span><br><span class="line">           <span class="keyword">if</span> (buf != <span class="keyword">null</span>) ReferenceCountUtil.release(buf);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>因为服务端是将所有客户端的channel都写入了信息，有信息的分发，客户端接收到信息后显示在窗口上，而多个客户端界面是运行在各自的JVM上，因此单个JVM上的客户端界面是单例，但不同的JVM上客户端界面是不同的，这样可以实现不同客户端之间的聊天。</p>
<p>但当关闭一个客户端后，服务端会报错，因为没有将此客户端从服务端的ChannelGroup中删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       cause.printStackTrace();</span><br><span class="line">       <span class="comment">//从clients删除</span></span><br><span class="line">       Server.clients.remove(ctx.channel());</span><br><span class="line">       ctx.close();<span class="comment">//关闭此流</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>接下来客户端需要优雅的关闭，给客户端界面类添加窗口监听器，当关闭窗口时，调用客户端的关闭方法，再推出页面。客户端向服务端发送一个<code>_bye_</code>字符串，服务端接收消息进行判断，如果客户端发送的是bye，将此channel从组中移除，关闭此channel，如果不是，分发给channel组。</p>
<p>客户端界面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.addWindowListener(<span class="keyword">new</span> WindowAdapter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">        c.closeConnect();</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>客户端类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeConnect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.send(<span class="string">"_bye_"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//数据存在msg中</span></span><br><span class="line">        ByteBuf buf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            buf = (ByteBuf)msg;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.readableBytes()];</span><br><span class="line">            buf.getBytes(buf.readerIndex(),bytes);<span class="comment">//读到字节数组中</span></span><br><span class="line">            String s = <span class="keyword">new</span> String(bytes);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"_bye_"</span>.equals(s))&#123;</span><br><span class="line">                System.out.println(<span class="string">"客户端要退出"</span>);</span><br><span class="line">                Server.clients.remove(ctx.channel());</span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//写到每一个通道组中</span></span><br><span class="line">                Server.clients.writeAndFlush(buf);<span class="comment">//不能再自己释放</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//手动释放内存</span></span><br><span class="line"><span class="comment">//            if (buf != null) ReferenceCountUtil.release(buf);</span></span><br><span class="line"><span class="comment">//            System.out.println(buf.refCnt());</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>增加服务端的窗口，同样将服务器类的信息封装到serverConnect方法，同时当有信息的时候直接写入到服务器窗口类即可。其中要注意的是，因为服务器类会阻塞，因此为了避免UI线程被阻塞，起服务器的线程最好放在main线程中。同样为了方便服务器类与服务器窗口类通信，将服务器窗口类做成单例。</p>
<p>这时候完成了客户端与服务端字符串的通信。</p>
<h4 id="Netty-Codec"><a href="#Netty-Codec" class="headerlink" title="Netty Codec"></a>Netty Codec</h4><p>1、定义TankMsg x,y</p>
<p>2、TankMsgEncoder负责编码，继承自MessageToByteEncoder<code>&lt;TankMsg&gt;</code></p>
<ul>
<li>负责将TankMsg转为字节</li>
</ul>
<p>3、TankMsgDecoder负责解码</p>
<ul>
<li>将字节转为坦克消息类</li>
</ul>
<p>4、在客户端加上编码的Handler</p>
<ul>
<li>写消息的时候，直接写TankMsg即可</li>
</ul>
<p>5、在服务端加上解码的Handler</p>
<ul>
<li>读消息的时候，读出来的就是TankMsg</li>
</ul>
<p>定义自己要处理的消息类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankMsg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TankMsg</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"TankMsg&#123;"</span> +</span><br><span class="line">                <span class="string">"x="</span> + x +</span><br><span class="line">                <span class="string">", y="</span> + y +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后定义此类的加码类，将其转为字节，继承MessageToByteEncoder，指定要加码的类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将TankMsg转换为字节</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankMsgEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">TankMsg</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, TankMsg msg, ByteBuf buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        buf.writeInt(msg.x);</span><br><span class="line">        buf.writeInt(msg.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此加码类也是一个Handler，在客户端将其加入到pipeLine责任链上，先加解码，再加InBound</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ch.pipeline()</span><br><span class="line">                .addLast(<span class="keyword">new</span> TankMsgEncoder())</span><br><span class="line">                .addLast(<span class="keyword">new</span> ClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在初始化的Handler中，写消息的时候直接写TankMsg即可，因为责任链上加了加码的责任链，因此在Channel中传输的时候自己被转为字节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ctx.writeAndFlush(<span class="keyword">new</span> TankMsg(<span class="number">5</span>,<span class="number">8</span>));<span class="comment">//自动由handler转为二进制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解码，需要定义解码类，将字节转为自定义的消息，为了解决TCP的拆包与黏包的问题，即将一个消息分成多个包，在字节数不够的时候直接返回，按照编码的顺序进行解码，并加入到out这个集合中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankMsgDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//没有读取完，返回，TCP拆包与黏包问题</span></span><br><span class="line">        <span class="comment">//字节数不够，就等着</span></span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes()&lt;<span class="number">8</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//in.markReaderIndex();</span></span><br><span class="line">        <span class="keyword">int</span> x = in.readInt();</span><br><span class="line">        <span class="keyword">int</span> y = in.readInt();</span><br><span class="line">        <span class="comment">//将解析出来的消息放在List中</span></span><br><span class="line">        out.add(<span class="keyword">new</span> TankMsg(x,y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了在服务端读取此消息，需要将此Handle加入到服务端的pipeLine上，先加解码的责任，这样在读取的时候，直接读取到的就是对应的TankMsg类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//在每个责任链上加入一个handler</span></span><br><span class="line">        ch.pipeline()</span><br><span class="line">                .addLast(<span class="keyword">new</span> TankMsgDecoder())</span><br><span class="line">                .addLast(<span class="keyword">new</span> ServerChildHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在读取的时候，直接将msg转为TankMsg读取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//数据存在msg中</span></span><br><span class="line">       System.out.println(<span class="string">"channelRead "</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           TankMsg tm = (TankMsg)msg;</span><br><span class="line">           System.out.println(tm);</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//手动释放内存</span></span><br><span class="line">           ReferenceCountUtil.release(msg);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Codec单元测试"><a href="#Codec单元测试" class="headerlink" title="Codec单元测试"></a>Codec单元测试</h4><p>采用Junit单元测试的好处是，不用一个个去比对结果，避免人眼观察出错。复用测试，不用重新写测试。</p>
<p>在写自己定义的二进制加码解码时，先用Junit测试通过后，再组装。</p>
<p>EmbeddedChannel只用于单元测试上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankMsgEncoderTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTankMsgEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//往外写的测试</span></span><br><span class="line">        TankMsg msg = <span class="keyword">new</span> TankMsg(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//使用Embedded嵌入的Channel，不是连接到网上</span></span><br><span class="line">        <span class="comment">//加入自己的Encoder</span></span><br><span class="line">        EmbeddedChannel ch = <span class="keyword">new</span> EmbeddedChannel(<span class="keyword">new</span> TankMsgEncoder());</span><br><span class="line">        <span class="comment">//往外写消息</span></span><br><span class="line">        ch.writeOutbound(msg);</span><br><span class="line">        <span class="comment">//将输出的消息读出来</span></span><br><span class="line">        ByteBuf buf = (ByteBuf) ch.readOutbound();</span><br><span class="line">        <span class="keyword">int</span> x = buf.readInt();</span><br><span class="line">        <span class="keyword">int</span> y = buf.readInt();</span><br><span class="line">        Assert.assertTrue(x == <span class="number">10</span> &amp;&amp; y == <span class="number">10</span>);</span><br><span class="line">        buf.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTankMsgEncoder2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//往里写的测试，先经过Decoder，再经过Encoder</span></span><br><span class="line">        ByteBuf buf = Unpooled.buffer();</span><br><span class="line">        TankMsg msg = <span class="keyword">new</span> TankMsg(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">        buf.writeInt(msg.x);</span><br><span class="line">        buf.writeInt(msg.y);</span><br><span class="line">        <span class="comment">//加两个</span></span><br><span class="line">        <span class="comment">//写的是ByteBuf，先经过Decoder被转为msg，不符合Encoder的要求</span></span><br><span class="line">        EmbeddedChannel ch = <span class="keyword">new</span> EmbeddedChannel(<span class="keyword">new</span> TankMsgEncoder(),<span class="keyword">new</span> TankMsgDecoder());</span><br><span class="line">        ch.writeInbound(buf.duplicate());</span><br><span class="line">        TankMsg tm = (TankMsg)ch.readInbound();</span><br><span class="line">        Assert.assertTrue(tm.x == <span class="number">10</span> &amp;&amp; tm.y == <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="同步异步阻塞非阻塞"><a href="#同步异步阻塞非阻塞" class="headerlink" title="同步异步阻塞非阻塞"></a>同步异步阻塞非阻塞</h3><p>同步异步关注的是<strong>消息通信机制</strong></p>
<ul>
<li>同步：烧水时，自己开开关，自己关。消息回来仍需要自己处理</li>
<li>异步：烧水时，自己打开，水开了后调用写好的代码去关。消息回来后其他人去处理。</li>
</ul>
<p>阻塞非阻塞关注的是<strong>等待消息时的状态</strong></p>
<ul>
<li>阻塞：等烧水时，不做别的，盯着水</li>
<li>非阻塞：等烧水时，干点其他事</li>
</ul>
<p>同步阻塞：自己开火后，等水开，水不开不做别的，自己关火。</p>
<p>同步非阻塞：自己开火，等水时去看电视，做点别的，自己关火。</p>
<p>异步阻塞：自己开火，自己盯着水看，水开后铃铛响，让其他工具关火。很少发生。</p>
<p>异步非阻塞：自己开火，做好火开的处理，自己去做别的事，让其他工具关火。</p>
<p>程序相当于人，操作系统相当于水。对accept于读写的处理要分开说明。</p>
<h3 id="select，poll与epoll"><a href="#select，poll与epoll" class="headerlink" title="select，poll与epoll"></a>select，poll与epoll</h3><p>每个网络连接以文件描述符Fd的方式存在于内核中。</p>
<p>在单线程处理网络连接时，可以用如下这种简单的方式进行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span>(fd1 ~ fdn)&#123;</span><br><span class="line">		<span class="keyword">if</span>(fd有数据)</span><br><span class="line">			读fd，处理</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>而select，判断fd中有数据，从用户态拷贝rset(一个bitmap，存了fds信息)至内核态来判断，如果没有数据，select会阻塞，当有数据的时候，内核将rset对应的fd置位（表示有数据），select返回，程序继续运行，遍历全部fd（可能多个fd中有数据），判断哪个fd中有数据，将对应数据读取并处理。</p>
<p>select缺点</p>
<ul>
<li>bitmap默认大小为1024，大小有限</li>
<li>内核修改rset，FD_SET不可重用，需要重新创建bitmap</li>
<li>从用户态拷贝至内核态存在一定开销</li>
<li>select后判断哪个fd中有数据，需要有O(n)的复杂度</li>
</ul>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/poll.png" class title="This is an example image">

<p>poll原理与select相似，poll的改进围绕传入的结构体，poll没有用bitmap，而是pollfd，其中fd为传入的fd，events在意的事件（读还是写），revents是对events的回馈。poll函数仍为阻塞，内核置位的时候，置的是revents字段，不像select修改bitmap会导致bitmap不可重用，poll返回。判断如果revents被置位，需要读取，将revents重置。</p>
<p>poll解决了select大小默认1024的问题，传入的结构体可以重用。但poll仍然存在select中剩下两个缺点</p>
<ul>
<li>从用户态拷贝至内核态存在一定开销</li>
<li>poll后判断哪个fd中有数据，需要有O(n)的复杂度</li>
</ul>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/epoll.png" class title="This is an example image">

<p>epoll的epoll_event中有fd跟event两个字段，epfd暂且理解为容器，其中有5个epoll_event，既有fd，又有event。epfd是直接内存，省去了拷贝的过程，内核判断是否有数据到来，在没有数据的时候，也会阻塞，在有数据的时候，select与poll是置位+函数返回，在epoll中通过重排来置位，将有数据的fd放到最前面，然后返回fd触发事件的个数，这样只需要遍历触发时间个数的数据就可以处理完毕，时间复杂度从O(n)变为O(1)。</p>
<p>因此epoll解决了从用户态拷贝数据到内核态的过程，且轮询时间复杂度从O(n)减少至O(1)。</p>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>并发与锁总结</title>
    <url>/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>要学习一个知识点，可以采取的思路是了解为什么要用它，怎么用它，有什么缺点，如何去改进。</p>
<p>对于并发 ，也将从这四个方面进行介绍。</p>
<a id="more"></a>

<h2 id="并发应用场景"><a href="#并发应用场景" class="headerlink" title="并发应用场景"></a>并发应用场景</h2><p>利用多线程去替代单线程，主要有两个应用场景。</p>
<ol>
<li><p>获得更好的性能</p>
<p>单线程执行速度有限，为了获得更好的性能需要使用多线程</p>
</li>
<li><p>由于业务模型的需要</p>
<p>确实需要多个执行实体</p>
</li>
</ol>
<p>需要分清进程与线程的区别</p>
<h3 id="为什么要有进程与线程"><a href="#为什么要有进程与线程" class="headerlink" title="为什么要有进程与线程"></a>为什么要有进程与线程</h3><p>进程为了解决<strong>并发操作</strong>问题，保存了当前线程的状态，由于分配时间短，会有不同进程并行执行的感觉（实际为并发）。但一个进程只能一次执行一个任务，若子任务不存在顺序的区别，可以并发执行。让CPU切给子任务更细的时间片去执行。这样一个进程包括多个线程。</p>
<p><strong>进程让操作系统的并发成为可能，线程让进程的内部并发成为可能</strong>。</p>
<h3 id="进程与线程区别"><a href="#进程与线程区别" class="headerlink" title="进程与线程区别"></a>进程与线程区别</h3><ul>
<li><p>进程可以看作是独立应用，线程不可以</p>
</li>
<li><p>进程有独立的地址空间，相互不影响，线程只是进程的不同执行路径，线程没有独立的地址空间</p>
</li>
<li><p>多进程程序比多线程程序健壮</p>
</li>
<li><p>进程的切换比线程的切换开销大</p>
</li>
</ul>
<h2 id="多线程怎么用"><a href="#多线程怎么用" class="headerlink" title="多线程怎么用"></a>多线程怎么用</h2><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><ol>
<li>新建（New）：创建后尚未启动的线程的状态（还未调用start方法）</li>
<li>就绪（Ready）：等待CPU为其分配时间</li>
<li>运行（Running）：正在执行</li>
<li>无限期等待（Waiting）：不会被分配CPU执行时间，需要显式被唤醒。wait方法不指定时间</li>
<li>限期等待（Timed Waiting）：在一定时间后会由系统自动唤醒（sleep方法）</li>
<li>阻塞（Blocked）：等待获取排它锁（Synchronized）</li>
<li>结束（Terminated）：已终止线程的状态，线程已经结束执行（run或main方法结束）</li>
</ol>
<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" class title="This is an example image">

<h4 id="阻塞和等待区别"><a href="#阻塞和等待区别" class="headerlink" title="阻塞和等待区别"></a>阻塞和等待区别</h4><p>阻塞可理解为当前线程仍处于活跃状态，只是在阻塞等待其他线程使用完某个锁资源。在等待是因为自身调用了wait()方法，join()方法或其他进入等待状态，只能等待其他线程执行某个特定动作才能继续唤醒。</p>
<h3 id="Java使用多线程的四种方式"><a href="#Java使用多线程的四种方式" class="headerlink" title="Java使用多线程的四种方式"></a>Java使用多线程的四种方式</h3><h4 id="方式一：继承Thread类"><a href="#方式一：继承Thread类" class="headerlink" title="方式一：继承Thread类"></a>方式一：继承Thread类</h4><p>1、 定义一个类继承Thread类</p>
<p>2、 覆盖Thread类中的run()方法。Thread类用于描述线程，因此Thread类也有对任务的描述，这个任务就是通过Thread类中的run()方法来体现，因此 run()方法就是封装自定义线程运行任务的函数。run方法中定义的是线程要运行的任务代码。</p>
<p>3、 直接创建Thread的子类对象创建线程</p>
<p>4、 调用start()方法，作用为启动线程，调用run()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(MyThread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用的时候</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">MyThread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<p>原理：Thread本身实现了Runnable接口，通过start()方法启动线程，native方法start()启动新线程并执行run()方法，实现方式较为简单，但继承有局限性。</p>
<p>注意：Thread类的start()方法最多只能调用一次，运行后会将started的状态改变，再次调用会报不合法线程状态异常。</p>
<h4 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口"></a>方式二：实现Runnable接口</h4><p>1、 定义类实现Runnable接口</p>
<p>2、 覆盖接口中的run()方法，将线程的任务代码封装到run()方法中</p>
<p>3、 通过Thread类创建对象，并将Runnable接口的子类对象作为Thread类构造函数的参数进行传递</p>
<p>原因：因为线程的任务都封装在Runnable子类对象run()方法中，所以要在线程对象创建时明确要运行的任务。</p>
<p>4、 调用线程对象的start()方法启动线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RunTest r = <span class="keyword">new</span> RunTest();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<p>原理：当传入一个Runnable类型的任务参数target给Thread后，Thread的run()方法就会调用target.run()</p>
<h4 id="方式三：实现Callable接口"><a href="#方式三：实现Callable接口" class="headerlink" title="方式三：实现Callable接口"></a>方式三：实现Callable接口</h4><p>1、创建Callable接口的实现类，并实现call()方法，并创建该实现类的实例</p>
<p>2、使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值</p>
<p>3、使用FutureTask对象作为Thread对象的target创建并启动线程</p>
<p>4、调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String value = <span class="string">"test"</span>;</span><br><span class="line">        System.out.println(<span class="string">"Ready to work"</span>);</span><br><span class="line">        Thread.currentThread().sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">"task done"</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> MyCallable());</span><br><span class="line">    <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">    <span class="keyword">if</span> (!task.isDone())&#123;</span><br><span class="line">        System.out.println(<span class="string">"task has not finished, please wait"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"task return : "</span> + task.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get方法会被阻塞直到子线程结束。</p>
<h4 id="方式四：使用Executors工具类来使用"><a href="#方式四：使用Executors工具类来使用" class="headerlink" title="方式四：使用Executors工具类来使用"></a>方式四：使用Executors工具类来使用</h4><p>使用Executors中的方法来获取不同种类的线程池，一般不建议直接这样使用。</p>
<p>详情见后面的线程池部分，此处主要讨论前三种方法</p>
<h4 id="三种方法的比较"><a href="#三种方法的比较" class="headerlink" title="三种方法的比较"></a>三种方法的比较</h4><p>实现Runnable和实现Callable接口的方式大致相同，基本思路均为将任务进行分装再传递给Thread对象，但后者执行call()方法有返回值且get()方法可以获取异常，且Callable接口可以搭配线程池使用，进行统一管理。二者和Thread的比较为：</p>
<p>1、Thread是一个类，Runnable是一个接口；</p>
<p>2、继承Thread类后不能继承其他类，而实现Runnable接口后仍可继承其他类，更为灵活，避免了单继承的局限性；</p>
<p>3、Thread类中的资源不能共享（多个任务对象），而实现Runnable接口可以实现资源共享（只有一个任务对象）；</p>
<p>4、Runnable将任务记性封装，更体现了面向对象的编程思想。</p>
<p>因此相比于继承Thread，更推荐使用Runnable接口来实现多线程。</p>
<h4 id="Thread中run-方法执行顺序"><a href="#Thread中run-方法执行顺序" class="headerlink" title="Thread中run()方法执行顺序"></a>Thread中run()方法执行顺序</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println("R run");</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">)&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        System.out.println("T run");</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure>

<p>输出为T run，看Thread中run()方法的源码</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/* What will be run. */</span></span><br><span class="line">   private Runnable target;</span><br><span class="line">   </span><br><span class="line">@Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">       if (target != null) &#123;</span><br><span class="line">           target.run();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​    其会对target进行判断，当target不为空的时候，执行Runnable的run方法，但由于多态，当子类方法覆写了父类方法时，会优先执行子类方法。因此执行顺序为Thread子类&gt;Runnable方法&gt;Thread类</p>
<h4 id="start与run"><a href="#start与run" class="headerlink" title="start与run"></a>start与run</h4><p>run()方法只是一个普通方法，而start方法可以让线程从新建状态转为执行状态，并调用run()方法。</p>
<p>start方法只能被调用一次，而run方法可以被多次调用。</p>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>可以使用Thread类中的setPriority方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span></span></span><br></pre></td></tr></table></figure>

<p>其中优先级为1-10</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>优先级越高的线程越有可能抢到CPU时间片，但不一定先执行。</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h4><p>线程间进行协作的时候，一个线程可能会比较依赖于另一个线程的执行结果，为了实现这个效果，可以使用线程的等待join()方法，在Thread类中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>提供了无限期等待的无参方法和选择最长等待时间的有参方法，验证如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskJoin</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TaskJoin tj = <span class="keyword">new</span> TaskJoin();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(tj);</span><br><span class="line">        t.start();</span><br><span class="line">        t.join();</span><br><span class="line">        System.out.println(tj.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有join方法，输出的i的值会很小，而使用了join方法后，主线程会wait，直到线程任务执行完毕，join的本质是让调用线程（此处为主线程）<strong>wait</strong>在当前线程对象实例上，因此每次输出的值都是设定的100000，可以用于线程的顺序执行。</p>
<h4 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h4><p>yield为本地方法，表示告知线程调度器当前线程愿意让出CPU使用权，但可能会被线程调度器忽略，不稳定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>当线程调用了yield方法后，会回到就绪状态，与其他线程一起争抢CPU资源。</p>
<p>yield方法与sleep方法均为静态的是因为，需要使用在当前运行的线程上，其他等待线程使用没有意义。</p>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>使用Tread类的setDaemon(true)方法，在<strong>start()方法前</strong>调用，守护线程在后台执行系统性服务，如垃圾回收线程等可以理解为守护的。当一个Java应用内，只有守护线程时，Java虚拟机就会退出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">(<span class="keyword">boolean</span> on)</span> </span>&#123;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (isAlive()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    &#125;</span><br><span class="line">    daemon = on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h4><ol>
<li><p>自定义停止条件，在代码中进行判断</p>
</li>
<li><p>使用interruped方法，在异常捕捉的catch中进行处理</p>
<p>使用中断，只是设置线程状态，不会让线程停止，需要自己去监视线程状态并做判断</p>
</li>
<li><p>已经作废的stop方法</p>
</li>
</ol>
<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>上文中介绍了为什么要用多线程及如何使用，但当多个线程操作一个资源时，会带来安全问题。如两个线程都在卖票，剩最后一张票的时候，会出现票数量&lt;0的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+num--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当开启多个线程卖票的时候，会出现如下的结果</p>
<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/%E5%8D%96%E7%A5%A8.png" class title="This is an example image">

<p>已经限制了票数要&gt;0，为什么会出现票数=-1的情况呢？</p>
<h3 id="线程安全产生原因"><a href="#线程安全产生原因" class="headerlink" title="线程安全产生原因"></a>线程安全产生原因</h3><ol>
<li><p>多个线程在操作共享的数据。</p>
</li>
<li><p>操作共享数据的线程代码有多条。（操作共享数据代码在2行以上容易出事）</p>
</li>
</ol>
<p>当一个线程在执行操作共享数据的多条代码中，其他线程参与了运算，就会导致线程安全问题的产生。</p>
<p>那么该如何解决呢？</p>
<p>解决思路：将多条操作共享数据的线程代码封装起来；当有线程在执行这些代码的时候，其他线程是不可以参与运算的。必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算，类似于上锁，当一群人要去上厕所，谁进去了将门锁住，其他人（线程）也就进不来了。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><p>为了解决线程安全问题，有的锁比较悲观，认为其他线程一定会修改数据，因此在拿数据的时候会上锁，若其他线程访问会被阻塞，Java中关键字synchronized的实现为悲观锁；而乐观锁，在拿数据时，认为别人不会修改，不会上锁，但在更新时会判断其他线程有没有更新数据。乐观锁适用于多读的场景，可以提高吞吐量。CAS就是比较常见的乐观锁的实现方式。</p>
<p>下面将主要将介绍比较常见的synchronized，RenentrantLock与JMM的内存可见性（volatile）与CAS。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronized为互斥锁，具有的特性为</p>
<ol>
<li><p>互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程的协调机制，这样在同一时间只有一个线程对需要同步的代码块（复合操作）进行访问。互斥性也称为操作的<strong>原子性</strong>。</p>
</li>
<li><p>可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（<strong>即在获得锁时应获得最新共享变量的值</strong>），否则另一个线程可能是在本地缓存的某个副本上继续操作，从而引起不一致。</p>
</li>
</ol>
<p>synchronized锁的不是代码，锁的都是对象。</p>
<h4 id="synchronized使用"><a href="#synchronized使用" class="headerlink" title="synchronized使用"></a>synchronized使用</h4><p>可以分为对象锁和类锁，均加在同步代码块上或同步方法上。同步代码块的使用如下</p>
<p>对象锁：</p>
<p>1、 同步代码块（synchronized(this)）, synchronized(类实例对象))，锁是小括号()中的实例对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">synchrnozed(<span class="keyword">this</span>或类实例对象)&#123;</span><br><span class="line">	<span class="comment">//要同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、 同步非静态方法（synchronized method），锁是当前对象的实例对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> 返回值 method()&#123;</span><br><span class="line">	<span class="comment">//要同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类锁：</p>
<p>1、 同步代码块（synchronized(类.class)），锁时小括号()中的类的对象（Class对象）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">synchrnozed(类<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//要同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、 同步静态方法（synchronized static method），锁是当前对象的类对象（Class对象）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> 返回值 method()&#123;</span><br><span class="line">	<span class="comment">//要同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>当出现锁的嵌套时，容易出现死锁。即线程1先获取锁A，再获取锁B；而线程2先获取锁B，再获取锁A。这时候两个线程均不能请求 到另一个锁，就会出现死锁，进程卡死。</p>
<p>要注意的是，这里的两个锁对象一定要用static修饰，因为要保证这两个对象随类加载保证唯一性，如果不加static，就会每次new DeadLockSyn的时候，产生各自的两个o1，o2，则不能出现死锁现象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadLockSyn</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//要加static是因为随类的创建而产生</span></span><br><span class="line">    <span class="comment">//如果不加static，那么产生的是各自的object对象，不是同一个锁了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeadLockSyn</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"完成任务"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DeadLockSyn d1 = <span class="keyword">new</span> DeadLockSyn(<span class="keyword">true</span>);</span><br><span class="line">DeadLockSyn d2 = <span class="keyword">new</span> DeadLockSyn(<span class="keyword">false</span>);</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(d1);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(d2);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<p>简单实现死锁程序的关键</p>
<ul>
<li>两个锁对象保证唯一性：static修饰</li>
<li>两个锁的嵌套调用</li>
</ul>
<p>死锁的调试</p>
<p>当发现死锁的时候，如何知道是哪里发生了死锁呢？</p>
<p>可以通过jps命令，查看java进程的进程ID，然后使用jstack得到线程的线程堆栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-&gt;jps</span><br><span class="line"><span class="number">11088</span></span><br><span class="line"><span class="number">8356</span> Jps</span><br><span class="line"><span class="number">11576</span> Launcher</span><br><span class="line"><span class="number">5292</span> ThreadTest</span><br></pre></td></tr></table></figure>

<p>然后看ThreadTest的线程堆栈情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">"Thread-1"</span>:</span><br><span class="line">        at test.DeadLockSyn.run(ThreadTest.java:<span class="number">141</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0x0499e890</span>&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0x0499e898</span>&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line"><span class="string">"Thread-0"</span>:</span><br><span class="line">        at test.DeadLockSyn.run(ThreadTest.java:<span class="number">132</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0x0499e898</span>&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0x0499e890</span>&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line"></span><br><span class="line">Found <span class="number">1</span> deadlock.</span><br></pre></td></tr></table></figure>

<p>这样便可以看到具体的死锁信息。</p>
<p>形成死锁的条件</p>
<ol>
<li>互斥条件：资源具有排他性，只能被一个线程占有</li>
<li>请求与保持条件：线程因请求资源被阻塞时，对已获取的资源保持不放</li>
<li>不剥夺条件：线程已获得的资源在未使用完前不能被其他线程剥夺</li>
<li>循环等待条件：发生死锁时，所等待的线程形成循环等待</li>
</ol>
<h4 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h4><p>当每个线程可以独立安全的完成自己的任务了，但如果A线程的任务涉及到了B线程，如A线程是生产烤鸭的，B线程是吃烤鸭的，只有生产出来的烤鸭被吃掉了A才会继续生产，那要如何实现呢？</p>
<p>这时候需要用到线程间的通信，即A线程刚来做烤鸭，发现B线程还没吃，就跟B线程交流下，让他快点吃，自己先睡个觉，等烤鸭被吃了再起来吃。主要用到的方法是wait、notify()与notifyAll()。</p>
<p><strong>生产者与消费者</strong></p>
<p>基本的实现思路是：封装一个烤鸭资源对象，实现Runnable接口，有一个标识变量，代表烤鸭有没有被吃。生产烤鸭的方法需要加锁，首先判断烤鸭有没有被吃，如果没被吃，生产任务停止，唤醒吃烤鸭任务。如果烤鸭被吃了，进行生产。吃烤鸭的方法与生产类似。</p>
<p>需要持有一个资源，其属性有资源名称name，当前资源数量和标志变量（用来判断消费还是生产）。对同步的生产方法，当还没有消费的时候，让当前线程wait，释放锁；当已经消费了，进行生产，反转标志变量，数量自增，唤醒其他线程。对同步的消费方法，当还没有生产的时候，让当前线程wait，释放锁；当已经生产了，进行消费，反转标志变量，唤醒其他线程。生产者和消费者类持有资源类对象，实现Runnable接口，并分别在run()方法中调用其生产和消费方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//生产的物品名称</span></span><br><span class="line">    <span class="comment">//同步的生产方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当还没有消费，生产线程等待</span></span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始生产</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        count++;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"生产"</span>+name+count);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同步的消费方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//当还没有生产，消费线程等待</span></span><br><span class="line">        <span class="keyword">while</span> (!flag)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始生产</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"消费"</span>+<span class="keyword">this</span>.name+count);</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Resource r;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Resource r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            r.set(<span class="string">"烤鸭"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Resource r;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Resource r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            r.out();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Resource r = <span class="keyword">new</span> Resource();</span><br><span class="line">        Producer p = <span class="keyword">new</span> Producer(r);</span><br><span class="line">        Consumer c = <span class="keyword">new</span> Consumer(r);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(p);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(p);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(c);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(c);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，在同步方法中判断标记要使用while而不能使用if，因为if只进行一次判断，不安全。唤醒线程的时候要使用notifyAll()而不能使用notify()，不然容易造成死锁。notify是唤醒线程池中的一个线程，而notifyAll是唤醒线程池中的所有线程。</p>
<p>可见在synchronized中，线程间通信主要依靠wait()、notify()和notifyAll()方法，这三个方法均在Object类中，那么既然wait()和sleep()都能让线程休眠，二者有什么区别呢？</p>
<p><strong>wait和sleep</strong>差别</p>
<p><strong>基本差别</strong></p>
<ol>
<li><p>sleep是<strong>Thread</strong>类的方法，wait是<strong>Object</strong>类中定义的方法</p>
</li>
<li><p>sleep()方法可以在任何地方使用， wait()方法只能在synchronized方法或synchronized块中使用</p>
</li>
<li><p>sleep在设置时间结束后自动唤醒，而wait需要使用notify或者notifyAll方法唤醒</p>
</li>
</ol>
<p><strong>本质差别</strong></p>
<p>​    Thread.sleep只会让出CPU，不会导致锁行为的改变；Object.wait不仅会让出CPU，还是释放已经占有的同步资源锁</p>
<p>二者相比，sleep类似于线程在厕所中睡着了，wait类似于从厕所中让出来睡着了。</p>
<p>介绍了synchronized后，需要了解为什么每个对象都可以作为锁，即需要了解synchronized的底层原理</p>
<h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p>首先必须要明确的是synchronized锁的是对象，而不是代码。然后宏观上来看有以下级别的实现：</p>
<ol>
<li><p>源码级别</p>
<p>同步代码块或同步方法</p>
</li>
<li><p>字节码级别</p>
<p>moniterenter moniterexist 或 SYN_SYNCHRONIZED标识</p>
</li>
<li><p>JVM级别（Hotspot）</p>
<p>锁升级的过程，依靠对象头中的Markword</p>
</li>
</ol>
<h4 id="实现基础"><a href="#实现基础" class="headerlink" title="实现基础"></a>实现基础</h4><p>实现synchronized的基础是以下两点</p>
<ul>
<li>Java对象头</li>
<li>Monitor</li>
</ul>
<h4 id="对象头结构"><a href="#对象头结构" class="headerlink" title="对象头结构"></a>对象头结构</h4><p>​    在JVM中，对象在内存中的布局有对象头、实例数据（存放类的属性数据信息）和对齐填充（虚拟机要求对象起始地址必须是8字节的整数倍）。</p>
<p>一般synchronized使用的<strong>锁对象</strong>是存储在<strong>Java对象头</strong>里的，头结构由<strong>Mark Word</strong> ，<strong>CLass Pointer</strong>指针组成，如果为数组，还有数组长度。其中CLass Pointer用于<strong>确定该对象是哪个类的实例</strong>；而<strong>Mark Word</strong>用于存储对象自身的运行时数据，是实现轻量级锁和偏向锁的<strong>关键</strong>，默认存储着对象的<strong>identity hashCode</strong>（即用内存地址计算出的哈希值），<strong>分代年龄</strong>（4字节最大15），<strong>锁标志位</strong>，<strong>GC</strong>等信息。</p>
<p>对于Object o = new Object()；Object对象的对象头，在64位的机器下，Markword是 8字节，一般默认压缩了ClassPointer指针跟栈中的对象引用指针，在不压缩下是8字节，压缩后变为4字节。因此Mardword+Class Pointer长度为8+4=12，而Object类中没有实例变量，为了对齐，需要有4字节的对其数据，因此Object对象在堆中占据空间为16字节。</p>
<h4 id="Markword"><a href="#Markword" class="headerlink" title="Markword"></a>Markword</h4><img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/markword.png" class title="This is an example image">

<p>MarkWord被设计为一个<strong>非固定</strong>的数据结构，以便存储更多有效数据，会根据对象本身的状态，复用存储空间，轻量级锁和偏向锁是JDK6后新增。</p>
<p>用后两位来区分不同的锁，01为偏向锁，00为轻量级锁，10为重量级锁，用倒数第三位来区分无锁和偏向锁。</p>
<h4 id="identity-hashcode"><a href="#identity-hashcode" class="headerlink" title="identity hashcode"></a>identity hashcode</h4><p>有关identity hashcode的问题，可以看到，只有在无锁状态下才有hashcode，如果一个对象计算了identity hashcode，则对象<strong>无法进入偏向</strong>状态。</p>
<p>若是轻量级锁，在线程的栈帧中保存了无锁状态下的Markword，即Lock Record记录。</p>
<p>若是重量级锁，在ObjectMonitor中有相应的成员变量。</p>
<h4 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h4><p>对于重量级锁，锁标志位是10，指针指向的是monitor对象的起始地址，<strong>每个对象都有Monitor与之关联</strong>，monitor被线程持有后就处于锁定状态。在Java虚拟机中，monitor是由ObjectMonitor实现。monitor底层由C++实现，里面有两个队列，WaitSet（等待池）和EntryList（锁池），而owner指向持有ObjectMonitor对象的线程。</p>
<p>具体过程为：当有多个线程同步访问同步代码时，进入锁池集合，当线程获取到锁对象的monitor以后，进入_Owner 区域并将owner变量设置为当前线程，Monitor中的计数器count+1，如果当前线程调用了wait()方法，会释放当前的Monitor，将owner变量设置为null，count减一，该线程进入等待池来等待被唤醒。若当前变量执行完毕，也会释放Monitor锁，并将对应的变量值复位。</p>
<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/monitor.png" class title="This is an example image">

<p>monitor对象存在于每个Java对象的对象头中，synchronized锁通过这种方式获取锁，这也是为什么所有Java对象均可以作为锁的原因，也是wait,notify,notifyAll等方法存在于对象Object中的原因。而wait,notify,notifyAll方法需要在synchronized中使用是因为调用这几个方法前必须拿到当前对象的监视器monitor对象，而synchronized关键字可以获取 monitor，因此若不在synchronized中使用会报IllegalMonitorStateException异常。</p>
<p>接下来反编译synchronized应用于同步代码块和同步方法中的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synBlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"synchronized in code block"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"synchronized in method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体操作为先javac生成对应class文件，然后执行javap -v Sync，首先看应用于同步代码块中的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>: monitorenter</span><br><span class="line">  4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">  7: ldc           #3                  // String synchronized in code block</span><br><span class="line">  9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line"> <span class="number">12</span>: aload_1</span><br><span class="line"> <span class="number">13</span>: monitorexit</span><br><span class="line"> <span class="number">14</span>: goto          <span class="number">22</span></span><br><span class="line"> <span class="number">17</span>: astore_2</span><br><span class="line"> <span class="number">18</span>: aload_1</span><br><span class="line"> <span class="number">19</span>: monitorexit</span><br></pre></td></tr></table></figure>

<p>截取了最重要的输出，可看到同步代码块实现的方式为monitorenter和monitorexit，分别是同步 开始和结束的位置。当执行monitorenter，当前线程会尝试获取对象锁，当计数器为0时，可以成功获取monitor并将计数器置为1，表示持有锁，当已经拥有此锁的时候，可以重入（再次遇到有相同对象锁时，可以获取）；若其他线程持有了锁，便会在monitorenter处阻塞，直到其他线程释放锁并将计数器置为0。为了保证monitorenter和monitorexit可以正常配对执行，编译期产生处理器声明可以处理任何异常，目的是为了处理monitorexit指令，正常释放锁，因此多了一个monitorexist。</p>
<p>而对于同步方法，并没有显式的monitorenter等，而是用ACC_SYNCHRONIZED访问标志来区分此方法是否是同步方法，当方法调用时，检查方法此标识是否被设置，如果设置则持有monitor，无论方法是否正常完成，释放monitor。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synMethod</span><span class="params">()</span></span>;</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">        0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        3: ldc           #5                  // String synchronized in method</span><br><span class="line">        5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">8</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>在早期，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的<strong>Mutex</strong> Lock来实现的，而操作系统实现线程之间的切换时需要从<strong>用户态转换到内核态(kernel)</strong>，这个状态之间的转换需要相对比较长的时间（时间成本相对较高），是相对于重量级的。而从JDK6以后，其性能有了较大提升。</p>
<h3 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h3><h4 id="锁的膨胀"><a href="#锁的膨胀" class="headerlink" title="锁的膨胀"></a><strong>锁的膨胀</strong></h4><img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/%E9%94%81%E5%8D%87%E7%BA%A7.png" class title="This is an example image">

<p>锁并不会一开始就进入到重量级锁，在JDK6对锁优化后，锁的状态有四种，并且会根据实际情况膨胀升级，膨胀方向为无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁。</p>
<p>锁只有在GC时才会降级。</p>
<p><strong>偏向锁</strong></p>
<p>在很多情况下，锁不存在多线程竞争，总是由一个线程多次获得。其核心的思想是：当一个线程获得了锁，锁就进入偏向模式，Markword的结构调整为偏向锁模式，当该线程再次请求锁的时候，获取锁的过程只要检查Markword的<strong>锁标记位</strong>是偏向锁且当前线程id与Markword中<strong>ThreadID</strong>相等即可，这样便可以省去很多锁申请的操作。</p>
<p>​    适用条件：无锁竞争的场合，但不适用于比较激烈的多线程场合。偏向锁失败后，在safe point撤销，升级为轻量级锁。</p>
<p>偏向锁默认4s后会开启，没有直接打开是因为程序刚启动的时候，竞争会比较激烈，直接开启偏向锁，影响性能。可以设置偏向锁没有时延，-XX:BiasedLockingStartupDelay=0，设置0延迟。立刻上偏向锁。此时对象是偏向锁，但没有被任何线程占有，称为<strong>匿名偏向锁</strong>。</p>
<p><strong>轻量级锁</strong></p>
<p>​    轻量级锁适用于线程交替执行同步代码，其依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，只允许顺序拿锁，但如果有竞争操作，轻量级锁会先尝试自旋，尝试失败后会膨胀为重量级锁。</p>
<p>轻量级锁的加锁过程</p>
<ol>
<li>在代码进入到同步代码块的时候，如果同步对象锁是<strong>无锁</strong>状态（锁标志位是‘01’），虚拟机首先在当前线程的栈帧中建立叫锁空间（Lock Record）的空间用于存储锁对象目前的Mark Word拷贝，官方称为Displaced Mark Word，此时线程堆栈和对象头状态如下</li>
</ol>
<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/%E8%BD%BB%E9%87%8F%E7%BA%A71.png" class title="This is an example image">

<ol start="2">
<li><p>拷贝对象头中的Mark Word复制到锁记录中</p>
<p>需要保存轻量级锁之前的Markword原因是，当上偏向锁后，对象的很多信息在Markword中会被丢失，因此需要被记录下来。</p>
</li>
<li><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record中owner指针指向object mark word。如果更新成功，执行步骤4，否则执行步骤5</p>
</li>
<li><p>如果更新成功，当前线程就拥有了该对象的锁，并且对象mark word锁标志设置成‘00’，表示此对象处于轻量级锁状态，此时线程堆栈与对象头的状态如下</p>
</li>
</ol>
<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/%E8%BD%BB%E9%87%8F%E7%BA%A72.png" class title="This is an example image">

<ol start="5">
<li>如果更新失败了，虚拟机首先将检查对象的mark word是否指向当前线程的栈帧，是说明当前线程已经拥有了锁，可以直接进入同步块继续执行。否则说明有多个线程竞争锁，先进行一段时间的自旋，如果自旋期间成功获得锁，则执行同步代码。若自旋结束后也没有获得锁，则将膨胀为重量级锁，将锁标志位变成‘10’，此时mark word中存储的就是指向重量级锁的指针，后面等待锁的线程进入阻塞状态。</li>
</ol>
<p>执行完毕解锁</p>
<ol>
<li>通过CAS操作尝试把线程栈帧中复制的Displaced Mark Word对象替换当前的Mark Word</li>
<li>若替换成功，整个同步过程就完成了</li>
<li>若替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），则要在释放锁的同时，唤醒被挂起的线程</li>
</ol>
<p><strong>自旋锁</strong></p>
<p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。依赖的思想是也许几个CPU周期后就可以获得锁，虚拟机会让当前等待锁的线程做几个空循环（称为自旋的原因），经过固定的若干次循环后，如果得到锁，就进入临界区。反之，就会将线程真实地在操作系统层面挂起。</p>
<p>自旋锁的缺点是：若锁被其他线程长时间占用，会带来许多性能上的开销，因为要一直消耗CPU资源</p>
<p>因此自旋<strong>需要有一定的限度</strong>，默认是自旋等待<strong>10次</strong>（-XX:PreBlockSpin）或自旋的线程数超过<strong>CPU核数的一半</strong>，如果超出限度还没有获取到锁，就要用传统的方法去挂起线程。</p>
<p>对自旋锁有优化，为<strong>自适应自旋锁</strong>，自旋的次数不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，这样JVM依据之前自旋成功率在增加或减少自旋次数，<strong>更加精确</strong>。</p>
<p><strong>重量级锁</strong></p>
<p>如果轻量级锁升级为重量级锁，那么Markword锁标志位从00改为10，Markword中指针指向重量级锁（互斥锁）。依靠的monitor，而monitor在操作系统层面依靠的是mutex，涉及到从用户态到内核态的切换，比较耗时。</p>
<p>比较三种锁如下</p>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距</td>
<td>若线程存在锁竞争，会带来额外的锁撤销的消耗</td>
<td>只有<strong>一个线程</strong>访问同步块或同步方法</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>若线程长时间抢不到锁，自旋会消耗CPU性能</td>
<td><strong>线程交替执行</strong>同步方法块或同步方法的场景</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU</td>
<td>线程<strong>阻塞</strong>，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗</td>
<td>追求吞吐量，同步块或者同步方法<strong>执行时间较长的场景</strong></td>
</tr>
</tbody></table>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>上面介绍了第一种优化方式是使用锁膨胀来代替单纯的重量级锁，而第二种方式为使用锁消除。</p>
<p>在JIT（Just-In-Time Compiler）编译时，对运行上下文进行扫描，去除不可能存在竞争的锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">        System.out.println(<span class="string">"method1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    System.out.println(<span class="string">"method2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中，method1中方法虽然被同步修饰，但锁变量为方法内的私有变量，不会被其他线程获取到，因此在编译阶段会被优化掉，反编译得到结果如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PUBLIC</span><br><span class="line">   Code:</span><br></pre></td></tr></table></figure>

<p>可以看到并没有ACC_SYNCHRONIZED标志。</p>
<p>在动态编译同步块的时候，JIT编译器借助逃逸分析（Escape Analysis）技术来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。</p>
<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>锁粗化是虚拟机对另一种极端情况的优化处理，通过扩大锁的范围，避免反复加锁和释放锁。</p>
<p>一般设置同步时尽量限制在小的范围，只在共享数据的实际作用域中，减少等待时间。但如果有一连串操作对一个对象<strong>反复加锁解锁</strong>，甚至加锁操作出现在<strong>循环体</strong>中，即使没有线程竞争，频繁进行互斥同步锁操作，会降低性能。当JIT此时会将加锁同步的范围扩散（粗化）到整个<strong>操作序列的外部</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面操作中，在循环体中进行了加锁，如果没有锁粗化，那么方法一应该会比方法二慢很多，但测试了两端代码运行时间后，结果为下图</p>
<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/%E9%94%81%E7%B2%97%E5%8C%96.png" class title="This is an example image">

<p>说明方法一种锁范围被扩大至循环体外，验证了锁粗化的效果。</p>
<p>上文中介绍了Java中使用synchrnonized上锁的方式，那么按照面向对象的思想，能否将锁及线程间的通信业对象化 呢？下面将介绍将介绍其增强版-重入锁。</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentranlLock位于java.util.concurrent.locks包，基于AQS（AbstractQueuedSynchronizer队列同步器）实现，AQS是Java并发构建锁或其他同步组件的基础，是JUC包的核心，一般使用AQS的方式为继承，而利用AQS实现同步结构，必须要实现同步结构，至少要实现acquire（实现资源的独占权）和release（释放对资源的独占）。</p>
<h4 id="ReentranlLock特点"><a href="#ReentranlLock特点" class="headerlink" title="ReentranlLock特点"></a>ReentranlLock特点</h4><p>ReentrantLock的特点有：</p>
<ul>
<li><p>重入锁有着显式的操作过程，必须手动指定何时加锁、释放锁，在逻辑控制的灵活性上好于synchronized。</p>
</li>
<li><p>在退出临界区时必须释放锁。</p>
</li>
<li><p>可以实现比synchronized更细粒度的控制，如控制锁的公平性</p>
<p>在公平时，倾向于将锁赋予等待时间最长的线程</p>
</li>
<li><p>性能不一定比synchronized高，也是可重入（已持有锁的线程可以再次访问需要同一个锁的代码）的</p>
<p>在低竞争场合，synchronized性能可能会优于ReentrantLock</p>
</li>
</ul>
<h4 id="ReentrantLock使用"><a href="#ReentrantLock使用" class="headerlink" title="ReentrantLock使用"></a>ReentrantLock使用</h4><p>使用可重入锁的流程分为三步：</p>
<ol>
<li>上锁</li>
<li>try中写同步执行代码</li>
<li>finally中解锁</li>
</ol>
<h4 id="处理死锁"><a href="#处理死锁" class="headerlink" title="处理死锁"></a>处理死锁</h4><p>之前演示过了synchronized的死锁情况，使用ReentrantLock也可以达到相同的效果，那么有没有方法可以处理死锁呢？</p>
<p><strong>中断响应</strong></p>
<p>对于synchronized，线程等待锁，结果是要么获取锁执行，要么继续等待，而RenentranlLock提供了线程可以被中断的情况，在等待锁的过程中，程序可以根据需要取消对锁的请求，对处理死锁有一定的帮助。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> lockStatus;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntLock</span><span class="params">(<span class="keyword">int</span> lockStatus)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockStatus = lockStatus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lockStatus == <span class="number">1</span>)&#123;</span><br><span class="line">                lock1.lockInterruptibly();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;&#125;</span><br><span class="line">                lock2.lockInterruptibly();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lock2.lockInterruptibly();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;&#125;</span><br><span class="line">                lock1.lockInterruptibly();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"线程完成任务"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock1.isHeldByCurrentThread())</span><br><span class="line">                lock1.unlock();</span><br><span class="line">            <span class="keyword">if</span> (lock2.isHeldByCurrentThread())</span><br><span class="line">                lock2.unlock();</span><br><span class="line">            System.out.println(Thread.currentThread().getId()+<span class="string">"线程退出"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">		<span class="comment">//main函数中</span></span><br><span class="line">        IntLock lock1 = <span class="keyword">new</span> IntLock(<span class="number">1</span>);</span><br><span class="line">        IntLock lock2 = <span class="keyword">new</span> IntLock(<span class="number">2</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(lock1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(lock2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t2.interrupt();</span><br></pre></td></tr></table></figure>

<p>lock1与lock2容易形成死锁，lockInterruptibly方法可以对中断进行相应的锁申请动作，在等待锁的过程中可以响应中断。当t2被中断的时候，t2会放弃对锁lock1的申请，同时释放已经获得的lock2，这样t1线程就可以顺序获取lock2而执行下去。</p>
<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/%E5%93%8D%E5%BA%94%E4%B8%AD%E6%96%AD.png" class title="This is an example image">

<p><strong>锁申请等待限时</strong></p>
<p>除了等待外部通知将线程中断外，避免死锁还可以使用限时等待。给定等待时间，让线程自动放弃，    使用tryLock()方法进行限时的等待，tryLock()方法接收两个参数，等待时长和计时单位。在请求等待时间之内，如果请求成功，返回true，否则返回false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TryLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">                Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"完成任务"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"任务失败"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock.isHeldByCurrentThread())</span><br><span class="line">                lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当创建两个线程去执行此任务时，会发现线程2执行失败，线程1执行成功。因为先持有锁的线程会持有锁6秒，而另一个线程等待锁只有5秒钟（5,TimeUnit.SECONDS），因此后请求锁的线程请求失败。</p>
<p>此方法也可以空参数运行，表示当前线程尝试获取锁，如果锁未被其他线程占用，申请锁成功，并立刻返回true；若锁被其他线程占用，当前线程不会等待，立刻返回false。这种模式不会引起线程等待，也不会引起死锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TryLockDeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">int</span> lock;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TryLockDeadLock</span><span class="params">(<span class="keyword">int</span> lock)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lock == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//上锁1</span></span><br><span class="line">                <span class="keyword">if</span> (lock1.tryLock())&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">                        <span class="comment">//上锁2</span></span><br><span class="line">                        <span class="keyword">if</span> (lock2.tryLock())&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                System.out.println(Thread.currentThread().getName()+<span class="string">"job done"</span>);</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                                lock2.unlock();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                        lock1.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//上锁2</span></span><br><span class="line">                <span class="keyword">if</span> (lock2.tryLock())&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">                        <span class="comment">//上锁1</span></span><br><span class="line">                        <span class="keyword">if</span> (lock1.tryLock())&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                System.out.println(Thread.currentThread().getName()+<span class="string">"job done"</span>);</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                                lock1.unlock();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                        lock2.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>死锁代码：利用条件判断，第一个线程先用锁1，再用锁2；第二个线程先用锁2，再用锁1。使用tryLock()后，线程不会一直处于阻塞状态，会不停尝试，只要执行足够长的时间，线程会得到需要的资源（同时获得两个所），从而正常执行。但结果不总是会正常完成，有时还是会出现死锁。</p>
<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>在大多数情况下，锁的申请都是非公平的，即不会根据等待时间来挑选执行线程。而公平锁的特点是：不会产生饥饿现象，不会出现一线程长时间等待获取不到CPU分配时间的情况。</p>
<p>synchronized是非公平锁，而ReentrantLock可以设置为公平锁，将fair设置为true即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(Boolean fair)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FairLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock fair = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//1、上锁</span></span><br><span class="line">            fair.lock();</span><br><span class="line">            <span class="comment">//2、try中运行代码</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"工作"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3、finally中释放锁</span></span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                fair.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，当开启两个线程时，两个线程轮流输出，几乎不会发生同一个线程多次获得锁的可能，而如果使用非公平锁会出现一个线程多次获得锁进行输出。实现公平锁要维护一个有序队列，实现成本比较高，性能比较低下，默认可重入锁是非公平的，若无特殊需求不使用公平锁。</p>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>在synchrnozied中，有wait、notify和notifyAll搭配使用进行线程间的通信，而ReentrantLock中也有，那就是Condition，Condition与重入锁相关联，通过newCondition()方法可获取Condition对象，一个锁可以获得多个Condition，类似的，Condition中提供了await()、signal()、signalAll()方法。</p>
<p>下面将基于重入锁和Condition来实现多生产多消费者模式。核心是一个锁，两个监视器，在要同步的方法中，先上锁，然后在try中写同步代码，最后在finally中解锁。其中利用标志变量来判断当前线程是否休眠。生产者和消费者类实现Runnable接口，在run()方法中调用资源类的方法即可。要注意的是，生产完后，要唤醒消费线程；消费完后，要唤醒生产线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockResource</span></span>&#123;</span><br><span class="line">    <span class="comment">//一个锁，两个监视器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition proCondition = lock.newCondition();</span><br><span class="line">    Condition conCondition = lock.newCondition();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LockResource</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同步set方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//2、在try中写同步代码</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    proCondition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进行生产</span></span><br><span class="line">            count++;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"生产"</span>+name+count);</span><br><span class="line">            <span class="comment">//唤醒消费线程</span></span><br><span class="line">            conCondition.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、在finally中解锁</span></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同步消费方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//2、在try中写同步代码</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!flag)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conCondition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进行消费</span></span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"消费"</span>+name+count);</span><br><span class="line">            <span class="comment">//唤醒生产线程</span></span><br><span class="line">            proCondition.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、在finally中解锁</span></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerRe</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LockResource r;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProducerRe</span><span class="params">(LockResource r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            r.set();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerRe</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LockResource r;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsumerRe</span><span class="params">(LockResource r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            r.out();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="synchronized和ReentrantLock区别"><a href="#synchronized和ReentrantLock区别" class="headerlink" title="synchronized和ReentrantLock区别"></a>synchronized和ReentrantLock区别</h4><ol>
<li>synchronized是关键字，ReentrantLock是类</li>
<li>synchronized的加锁解锁是隐式的，而重入锁的显式的</li>
<li>ReentrantLock可以设置为公平锁，synchronized不行</li>
<li>ReentrantLock可以设置锁的等待时间，避免死锁</li>
<li>底层机制：sync操作对象头中Mark Word，lock调用Unsafe类中方法</li>
</ol>
<h3 id="JMM内存可见性"><a href="#JMM内存可见性" class="headerlink" title="JMM内存可见性"></a>JMM内存可见性</h3><p>Java内存模型（Java Memory Model，简称JMM）是抽象概念，描述一组规范，围绕原子性、有序性和可见性展开。通过此规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。</p>
<p><strong>原子性</strong></p>
<p>原子性指一个操作不可中断，即使是多个线程一起执行的时候，一个操作一旦开始就不会被其他线程干扰。</p>
<p><strong>可见性</strong></p>
<p>可见性指当一个线程修改了某个共享变量的值，其他线程能够立刻知道这个修改。以下情况会导致可见性问题</p>
<ul>
<li><p>缓存优化</p>
<p>CPU改动后的值被缓存在cache或寄存器中，另一个CPU读到值没有更新</p>
</li>
<li><p>硬件优化</p>
<p>一些内存读写不会立即触发，而会先进入一个硬件队列等待</p>
</li>
<li><p>指令重排及编辑器优化</p>
</li>
</ul>
<p><strong>有序性</strong></p>
<p>在并发时，程序的执行可能会出现乱序，原因是程序在执行时可能会进行指令重排，重排后的指令与原指令未必一致。</p>
<p>线程将变量从主内存中拷贝至线程自己的本地内存进行操作，操作完成后再放回主内存。主内存和工作内存的关系是，工作内存是主内存的备份，工作内存是线程的私有区域。因此线程间的传值必须依靠主内存来完成。</p>
<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/%E4%B8%BB%E5%86%85%E5%AD%98.png" class title="This is an example image">

<h4 id="JMM中主内存和工作内存"><a href="#JMM中主内存和工作内存" class="headerlink" title="JMM中主内存和工作内存"></a>JMM中主内存和工作内存</h4><p>JMM中的主内存</p>
<ul>
<li>存储Java实例对象</li>
<li>包括成员变量、类信息、常量、静态变量等</li>
<li>属于数据共享的区域，多线程并发操作会引发线程安全问题</li>
</ul>
<p>JMM中的工作内存</p>
<ul>
<li>存储当前方法的所有本地变量信息，本地变量对其他线程不可见</li>
<li>字节码行号指示器，Native方法信息</li>
<li>属于线程私有区域，不存在线程安全问题</li>
</ul>
<p>主内存与工作内存的数据类型及操作方式</p>
<ul>
<li>方法里的基本数据类型本地变量将直接存储在工作内存的栈帧结构中</li>
<li>引用类型的本地变量：引用存储在工作内存中，实例存储在主内存中</li>
<li>成员变量、static信息、类信息均存储在主内存中</li>
<li>主内存共享的方式是线程各拷贝一份数据到工作内存，操作完成后刷新回主内存</li>
</ul>
<p>前面提到指令重排会影响可见性和有序性，但指令重排对提高CPU性能非常重要，那什么时候不能够指令重排呢？答案是无法通过happens-before原则推导出来的，才能进行指令重排。在JVM内部的实现，通常依赖于<strong>内存屏障</strong>，通过禁止某些重排序的方式，提供内存可见性保证，即实现了各种happens-before的规则。下面将简单介绍下happens-before原则。</p>
<h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><ol>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；（先来后到）</li>
<li>锁定规则：一个unlock操作先行于后面对同一个锁的lock操作；（解锁后才能上锁）</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；（写好才给看）</li>
<li>传递规则：A先于B，B先于C，则A先于C；（排队）</li>
<li>线程启动规则：线程的start()方法先于它的每一个动作；（不开始不许动）</li>
<li>线程中断规则：线程的中断（interrupt()）先于被中断的代码检测到中断的发生；</li>
<li>线程终结规则：线程的操作先于线程的终结（Thread.join()）；</li>
<li>对象终结规则：对象的初始化先于finalized。</li>
</ol>
<p>值得注意的是，第1条的次序规则只在单线程下有效，多线程中不一定保证。第3条volatitle保证了线程的可见性，写一定先于读。第6条线程A若对线程B设置中断，线程B马上可以知道。第8个要保证对象的字段要在初始化后可见。</p>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>为了在适当的场合保证线程间的原子性、有序性和可见性，volatile关键字是JVM提供的轻量级同步机制，对于保证操作的原子性有很大的帮助，但其<strong>不能替代锁</strong>，也无法保证一些复合操作的原子性。</p>
<ul>
<li>保证被volatile修饰的共享变量对所有线程总是<strong>可见</strong>的</li>
<li>禁止指令重排序优化</li>
</ul>
<p>如果操作volatile修饰的变量是复合的（多条操作），如value++这种（先读，后自增），即使value被volatile修饰也会引发线程安全问题。synchronized会创建内存屏障，保证所有CPU结果刷到主内存中，可以保证操作的内存可见性，因此在synchronized代码块或方法中操作的变量可以省略volatile修饰。而如果对一个变量的操作是原子性的，如操作布尔类型的变量，加上volatile就可以实现可见性，实现线程安全的目的，此时可以省略synchronized。</p>
<h5 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h5><p>当写一个volatile变量时，JMM把该线程对应的工作内存中的共享变量刷新到主内存中；当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效，只能从主线程中重新读取。</p>
<p>涉及到CPU的结构，CPU一般有3级缓存，每个CPU内有2级缓存，多核CPU共享3级缓存，而3级缓存共享主内存。CPU在读取数据是，从1级缓存，2级，3级，主内存这样的顺序读取，写入顺序是主内存，3级，2级，1级。在读取数据的时候，根据局部性原理会多读取一些数据，按照一块64字节的cache line即<strong>缓存行</strong>来读取。CPU级别的内存可见性是以缓存行为单位的。在常用的Intel CPU内，是依靠<strong>MESI缓存行一致性协议</strong>来保证内存可见性的。MESI是CPU缓存的4种状态：</p>
<ul>
<li>Modified</li>
<li>Exclusive</li>
<li>Shared</li>
<li>Invalid</li>
</ul>
<p>而使用了缓存行一致性后，会存在一个问题，如果线程1要修改x变量，线程2要修改y变量，若x与y变量在一个缓存行中，线程1修改了x变量后要通知线程2，线程2修改了y变量后要通知线程1，这时候就比较浪费效率。解决办法是缓存行对齐，即故意添加一些无用数据，使得x与y不在一个缓存行中，如Disruptor，使用了缓存行对齐来提高运行效率。下图为其源码中使用到了缓存行对齐的部分：</p>
<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/%E7%BC%93%E5%AD%98%E8%A1%8C%E5%AF%B9%E9%BD%90.png" class title="This is an example image">

<p>总的来说，对于实现可见性方面，系统底层的实现为：</p>
<ul>
<li>使用MESI缓存一致性</li>
<li>锁总线（数据量超过缓存行）</li>
</ul>
<h5 id="如何禁止重排序"><a href="#如何禁止重排序" class="headerlink" title="如何禁止重排序"></a>如何禁止重排序</h5><p>内存屏障（Memory Barrier）</p>
<ol>
<li>保证特性操作的执行顺序</li>
<li>保证某些变量的内存可见性</li>
</ol>
<p>通过插入内存屏障禁止指令在<strong>内存屏障前后的指令执行重排序优化</strong>；强制刷出各种CPU的缓存数据，因此任何CPU上的线程能够读取到这些数据的最新版本。</p>
<ol>
<li><p>源码层面 volatile</p>
</li>
<li><p>字节码层面 ACC_VOLATILE标记</p>
</li>
<li><p>jvm层面，jvm规范要求加内存屏障</p>
<p>sfence(写屏障) mfence(全屏障) lfence(读屏障)等系统原语</p>
<ul>
<li>写操作前加屏障，写完才能读</li>
<li>读操作前加屏障，读完才能写</li>
</ul>
</li>
<li><p>hot spot层面</p>
<p>没有使用fence，使用lock addl指令</p>
</li>
</ol>
<h5 id="单例双重检测"><a href="#单例双重检测" class="headerlink" title="单例双重检测"></a>单例双重检测</h5><p>广为人知的单例模式懒汉式在多线程下是不安全的，因此有如下的双重检测</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中要点是，此类中持有的instance是私有静态的，因为不能被其他类直接获取而且不能通过对象获得。构造函数要私有。获取实例的对象要公共静态，为了直接通过类名调用。锁对象为单例类的class对象而双重检测，同步是为了线程安全，外层判断是为了提高效率。但是这样依然会存在风险。</p>
<p>原因 ：instance = new Singleton();可以分为三步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memory = allocate();<span class="comment">//1、分配对象内存空间</span></span><br><span class="line">instance(memory); <span class="comment">//2、初始化对象</span></span><br><span class="line">instance = memory <span class="comment">//3、设置instance指向刚分配的内存地址，此时instance=null</span></span><br></pre></td></tr></table></figure>

<p>而因为步骤2和步骤3之间没有happens-before关系，因此是可以被重排序的，这样排序后的顺序为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memory = allocate();<span class="comment">//1、分配对象内存空间</span></span><br><span class="line">instance = memory <span class="comment">//3、设置instance指向刚分配的内存地址，此时instance！=null</span></span><br><span class="line">instance(memory); <span class="comment">//2、初始化对象</span></span><br></pre></td></tr></table></figure>

<p>这时候，会出现instance指向了分配的空间已经不为null，执行了默认初始化，但还没有显式初始化对象，如果此时线程被切走，再次进来的线程判断instance不为空，直接将instance返回，出现问题。</p>
<p>因此解决办法是不让这部分指令重排，即<strong>让instance被volatile修饰</strong>。因此完整的线程安全的单例双重检测如下，其中volatile与static顺序没有要求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Singleton&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="volatile与synchronized"><a href="#volatile与synchronized" class="headerlink" title="volatile与synchronized"></a>volatile与synchronized</h4><ol>
<li>二者本质不同。volatile为告诉JVM当前变量在寄存器（工作内存）中的值是不确定的，需要<strong>从主存中读取</strong>；synchronized则是<strong>锁定当前变量</strong>，只有当前线程可以访问该变量，其他线程被阻塞住直到该线程完成变量操作为止。</li>
<li><strong>使用级别</strong>不同。volatile仅能使用在变量级别，而synchronized可以使用在变量、方法和类级别<ul>
<li>synchronized(A.class) //修饰类</li>
<li>synchronized void get() //修饰方法</li>
<li>synchronized(o) //修饰变量</li>
</ul>
</li>
<li>volatile仅能实现变量的修改可见性，<strong>不确保原子性</strong>；而synchronized可以保证变量修改的可见性和原子性</li>
<li>volatile不会造成线程阻塞，而synchronized会</li>
<li>volatile标记的变量不会被编译器优化，synchronized标记的变量可以被编译器优化</li>
</ol>
<h4 id="无法禁止指令重排的synchronized如何保证有序性"><a href="#无法禁止指令重排的synchronized如何保证有序性" class="headerlink" title="无法禁止指令重排的synchronized如何保证有序性"></a>无法禁止指令重排的synchronized如何保证有序性</h4><ol>
<li>有序性是什么</li>
</ol>
<p>对于有序性的理解为，本线程内观察，所有操作都是天然有序的；若在另一个线程中观察此线程，所有操作都是无序的。在本线程中有序是因为根据as-if-serial语义，不管怎么重排序，单线程程序执行的结构都不能被改变，因此可以认为重排序在单线程内部可忽略。</p>
<ol start="2">
<li>synchronized如何保障有序</li>
</ol>
<p>而synchronized虽然不禁止指令重排，但是其为排他的可重入锁，一个线程持有了锁后，其他线程是不能访问到临界区资源的，这样被synchronized修饰的方法相当于单线程执行，因此符合as-id-serial语义下的有序性。</p>
<ol start="3">
<li>指令重排的原因与影响</li>
</ol>
<p>更具体来讲，synchronized虽然保证了单线程内的有序性，但因为指令的重排序，一个线程操作的结果对另一个线程会影响。那么为什么要指令重排序呢？</p>
<ul>
<li>指令重排存在的原因是计算机为了提升一些语句的处理效率，会将不满足happens-before的语句进行重排序，提高了处理效率（在一些语句停顿的时候先加载其他语句）。heppens-before保证的是可见性。</li>
</ul>
<p>在多线程环境中，由于有多个线程的并发操作，可能会导致线程安全问题，这样在多线程下，语句的重排序可能会造成线程安全问题，如懒汉式instance不被volatile修饰的问题。</p>
<ol start="4">
<li>如何解决</li>
</ol>
<p>为了不让某些语句进行重排序，使用volatile关键字，利用内存屏障禁止相关语句重排序，这样就保证了语句的有序性。</p>
<p>因此从宏观上，synchronized通过排它锁保证了单线程下的有序性，但因为此线程的结果会对其他线程造成影响，有时候synchronized需要配合volatile一起使用。这样才能更好的达到有序性。</p>
<p>而CAS操作，其为轻量级的锁，一般需要让临界区资源变量被volatile修饰，保证其可见性，然后通过compare and set的方式对其进行操作。</p>
<h3 id="CAS-Compare-and-Swap"><a href="#CAS-Compare-and-Swap" class="headerlink" title="CAS(Compare and Swap)"></a>CAS(Compare and Swap)</h3><p>​    CAS叫做自旋锁或无锁（无重量级锁），是乐观锁最常见的实现方式，默认没有数据冲突，如果有就回滚数据并重新提交。</p>
<p>CAS是一种高效实现数据安全性的方法</p>
<ul>
<li>支持原子更新操作，适用于计数器，序列发生器（给变量自增的工具）等场景</li>
<li>属于乐观锁机制，号称lock-free（底层仍有加锁行为）</li>
<li>CAS操作失败时由开发者决定是否继续尝试，还是执行其他操作</li>
</ul>
<h4 id="CAS思想及原理"><a href="#CAS思想及原理" class="headerlink" title="CAS思想及原理"></a>CAS思想及原理</h4><img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/CAS.png" class title="This is an example image">

<p>包含有三个操作数——内存位置（V），预期原值（A）和新值（B）</p>
<p>将内存位置（主内存）的值与预期原值比较，如果匹配则自动将该位置值更新为新值；否则进行自旋，重新获取值再进行操作。</p>
<p>对于volatile修饰的变量，虽然保证了内存可见性，但不能保证操作原子性，反编译如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译结果部分展示如下</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">2: getfield      #2                  // Field value:I</span><br><span class="line">     <span class="number">5</span>: iconst_1</span><br><span class="line">     <span class="number">6</span>: iadd</span><br><span class="line">     7: putfield      #2                  // Field value:I</span><br></pre></td></tr></table></figure>

<p>可以看到自增这个操作是分为先取值，再自增，再将值放回去的，因此这种非原子性的操作容易引发线程安全问题。而之前介绍的将add方法加上synchronized关键字实现悲观锁可以解决，但是效率相对较低，此时也可以使用CAS这种乐观锁来实现。Java中的AtomicInteger类便可以在不使用悲观锁的情况下保证线程安全，引用其实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">            <span class="keyword">int</span> current = get();  </span><br><span class="line">            <span class="keyword">int</span> next = current + <span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))  </span><br><span class="line">                <span class="keyword">return</span> current;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//存在自旋</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> var5;</span><br><span class="line">    	<span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    	&#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"> </span><br><span class="line">    	<span class="keyword">return</span> var5;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中getAndIncrement相当于自增操作，那么来看CAS操作是如何实现操作的安全性的。首先value被volatile修饰，这样保证了内存的可见性，因此当前数current为从主内存中刷出来的数据(CAS中的A)，next为其操作后变成的数据(CAS中的B)，然后调用了unsafe类的compareAndSwapInt方法，其中unsafe类为底层实现，其中为native方法，其实现逻辑类似于如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == expect) &#123;</span><br><span class="line">	<span class="keyword">this</span> = update</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即如果期望值A与主内存处为同一地址，那么就将主内存中的地址修改为更新后的值位置；否则不做修改。因此CAS的关键在于将期望值与主内存中值进行比较，确保值没有变动才进行修改。</p>
<p>而unsafe类中，看其C++源码，发现更底层使用的汇编指令cmpxchg1，是非原子的，存在问题是如果有线程比较完后来写入数据的时候，又有线程进行了数据写入，则仍然不安全，因此会有指令LOCK_IF_MP，multi processor如果是多核处理器，会在这条指令前加上lock指令。因此<strong>CAS最底层</strong>的指令为<code>lock cmpxchg</code>，锁定的是北桥信号，没有锁总线。</p>
<p>在J.U.C包中的atomic包中提供了常用的原子性数据以及引用、数组等相关原子类型和更新操作工具，是很多线程安全服务的首选。那么CAS这么好用，有没有什么缺点呢？</p>
<h4 id="CAS缺点及解决方式"><a href="#CAS缺点及解决方式" class="headerlink" title="CAS缺点及解决方式"></a>CAS缺点及解决方式</h4><ul>
<li>CAS中存在自旋等待，若循环时间长，开销很大，浪费CPU资源</li>
<li>由于CAS比较的为this对象，因此只能保证一个共享变量的原子操作</li>
<li>ABA问题</li>
</ul>
<p>下面将详细介绍ABA问题。ABA问题描述为如果内存地址V初次读取到为A，在赋值检查时仍为A，不能保证此值没有被其他线程修改过，如果曾经被改为B再改回来，CAS操作会误认为此值没有被改变过，此漏洞就是CAS的ABA问题。</p>
<p>那么该如何解决呢？</p>
<p>1、ABA问题</p>
<p>对于解决ABA问题，JDK1.5后后atomic包中提供了类AtomicStampedReference类，增加了<strong>版本号的比较</strong>，在比较值的同时，再进行版本号的比较。若存在ABA问题的应用场景，使用传统的互斥同步会更高效点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                             V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> newStamp)</span></span></span><br></pre></td></tr></table></figure>

<p>版本号的使用如下(使用lambda表达式，()-&gt;{方法代码})</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//新建类，初始化值</span></span><br><span class="line">        AtomicStampedReference&lt;Integer&gt; at = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//新建两个任务，执行方法</span></span><br><span class="line">        <span class="comment">//任务1，执行ABA操作</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = at.getStamp();</span><br><span class="line">            System.out.println(<span class="string">"线程1第一次拿到的版本号"</span>+stamp);</span><br><span class="line">            <span class="comment">//暂停一段时间，让线程2拿到相同的版本号</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">            <span class="comment">//进行A-&gt;B操作</span></span><br><span class="line">            at.compareAndSet(<span class="number">2</span>,<span class="number">5</span>,at.getStamp(),at.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"线程1第一次操作后的版本号"</span>+at.getStamp());</span><br><span class="line">            <span class="comment">//进行B-&gt;A操作</span></span><br><span class="line">            at.compareAndSet(<span class="number">5</span>,<span class="number">2</span>,at.getStamp(),at.getStamp()+<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"线程1第二次操作后的版本号"</span>+at.getStamp());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = at.getStamp();</span><br><span class="line">            System.out.println(<span class="string">"线程2第一次拿到的版本号"</span>+stamp);</span><br><span class="line">            <span class="comment">//暂停，让线程一完成ABA操作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进行A-&gt;C操作，看能否操作成功</span></span><br><span class="line">            <span class="keyword">boolean</span> b = at.compareAndSet(<span class="number">2</span>,<span class="number">10</span>,stamp,stamp+<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"当前内存中最新值为"</span>+at.getReference());</span><br><span class="line">            System.out.println(<span class="string">"线程2处理完ABA问题后的结果为："</span>+b);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这样当线程1执行完ABA操作后，虽然期待值与主内存中值相等，但是版本号变化了，因此当线程2用旧的版本号进行操作的时候，无法成功执行CAS操作，执行结果为</p>
<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/CAS%E7%BB%93%E6%9E%9C.png" class title="This is an example image">

<p>2、循环时间长</p>
<blockquote>
<p>以下解释引用自<a href="https://blog.csdn.net/qq_37113604/article/details/81582784?depth_1-utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">博客</a></p>
<p>若JVM可以支持处理器提供的pause指令效率会有一定提升。pause指令的作用是：1、延迟流水线执行指令，使CPU不消耗过多的执行资源；2、避免在退出循环时因内存顺序冲突而引起CPU流水线被清空，提高CPU执行效率。</p>
</blockquote>
<p>3、只能保证一个共享变量的原子操作</p>
<p>可以将多个变量合并为一个共享变量进行操作，JDK1.5后提供了AtomicReference类，可以保证引用对象之间的原子性，因此可以将多个变量放在一个对象中进行CAS操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect, V update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CAS与synchronized"><a href="#CAS与synchronized" class="headerlink" title="CAS与synchronized"></a>CAS与synchronized</h4><p>在synchronized未被改进前，synchronized在资源竞争较少时，线程被阻塞在操作系统层面被挂起开销较大，因此CAS更适用于竞争较少的场合；而竞争较多的场合，CAS资源几率大，效率低于synchronized。</p>
<p>而synchronized在JDK1.6后被改进，有了前面介绍过的锁的膨胀机制，在竞争资源较少时也能获得与CAS类似的性能。</p>
<h4 id="concurrent包的实现"><a href="#concurrent包的实现" class="headerlink" title="concurrent包的实现"></a>concurrent包的实现</h4><p>concurrent包有通用化的实现模式</p>
<blockquote>
<ol>
<li>声明共享变量为volatile（保证内存可见性）</li>
<li>使用CAS的原子条件更新实现线程间的同步</li>
<li>配合以volatile的读/写和CAS所具有的读和写的内存语义来实现线程间的通信</li>
</ol>
</blockquote>
<p>关于锁的实现先说到这里，接下来说下多线程非常常用的线程池。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>在之前使用多线程时，依赖的是新建多个Thread对象，然后传递任务对象，再开启线程。</p>
<p>但是线程的创建与销毁开销是比较大的，为了重复利用线程，提高效率，便有了线程池。为了了解线程池，从为什么要用线程池（优势），怎么用线程池（方式与种类），重要参数来说明。</p>
<h4 id="线程池优势"><a href="#线程池优势" class="headerlink" title="线程池优势"></a>线程池优势</h4><ul>
<li><p><strong>降低资源消耗</strong></p>
<p>重复利用已创建的线程来降低线程创建和销毁造成的消耗</p>
</li>
<li><p><strong>提高线程的可管理性</strong></p>
<p>线程是稀缺资源，无限制的创建会消耗系统资源，降低稳定性，使用线程池可以统一的分配、调优和监控</p>
</li>
</ul>
<p>使用线程池后，创建线程变成从线程池中获得空闲线程，关闭线程变成向线程池归还线程。</p>
<h4 id="常见线程池种类"><a href="#常见线程池种类" class="headerlink" title="常见线程池种类"></a>常见线程池种类</h4><p>JDK提供了Executor框架来更好的控制线程池，下面先介绍5种常用的线程池工作方法。</p>
<p>1、指定工作数量的线程池</p>
<p>newFixedThreadPool(int nThreads)</p>
<p>每当一个任务去创建一个线程，如果工作线程数量达到线程池的初始最大数，将提交的任务存储池队列中；如果工作线程退出，将会有新的工作线程被创建，补足nThread的数目。</p>
<p>适用于可以<strong>预测线程数量</strong>的任务中，或者服务器<strong>负载较重</strong>，对当前线程数量进行限制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、处理大量短时间工作任务的线程池</p>
<p>newCachedThreadPool()</p>
<p>（1）试图缓存线程并重用，当无缓存线程可用时，就创建新的线程</p>
<p>（2）如果线程闲置的时间超过阈值（一般60s），则会被终止并移出缓存</p>
<p>（3）系统长时间闲置的时候，不会占用什么资源</p>
<p>适用于服务器<strong>负载较轻</strong>，执行很多短期异步任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、唯一的工作线程池</p>
<p>newSingleThreadExecutor()</p>
<p>创建唯一的工作线程来执行任务，如果线程异常结束，会有另一个线程取代它。可保证顺序的去执行各个任务，且在给定的时间内不会有多个线程是活动的。</p>
<p>适用于需要保证<strong>顺序执行</strong>各个任务，并且在任意时间点，<strong>不会有多个线程是活动的</strong>场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、定时或者周期性的工作调度</p>
<p>newSingleThreadScheduledExecutor()与newScheduledThreadPool(int corePoolSize)</p>
<p>二者区别在于单一工作线程还是多个线程，前者与newSingleThreadExecutor()一样，若线程异常结束，会有另一个线程来取代它确保顺序执行。</p>
<p>适用于需要后台线程<strong>执行周期任务</strong>的场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、拥有多个任务队列的线程池</p>
<p>newWorkStealingPool()</p>
<p>内部创建ForkJoinPool，利用work-stealing算法，并行地执行任务，不保证处理顺序，JDK8引入。</p>
<p>可以减少连接数，创建当前可用CPU数量的线程来并行执行，适用于大耗时的操作，可以并行来执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ForkJoin框架</p>
<p>将大任务切割成若干个小任务并发执行，最终汇总每个小任务的结果后得到大任务结果的框架。</p>
<p>是Executor接口的一种具体实现，更好利用多处理带来的好处，使用分治法解决问题。使用的是work-stealing算法，具体是从其他任务队列中窃取任务来执行。将任务分别放在不同的队列中，为每个队列来创建一个线程执行任务。会出现某些队列任务已经完成而其他队列任务还没有完成的情况，这时候为了提高效率，完成任务的处于空闲状态的线程会从其他处于busy状态的线程处窃取等待执行的任务。为了减少窃取和被窃取任务的竞争，使用双端队列，<strong>被窃取任务</strong>线程从双端队列<strong>头部</strong>拿任务执行，而<strong>窃取任务</strong>线程从双端队列<strong>尾部</strong>拿任务。</p>
<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/%E7%AA%83%E5%8F%96%E4%BB%BB%E5%8A%A1.png" class title="This is an example image">

<p>下面将介绍JDK中的Executor框架</p>
<h4 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h4><img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/%E6%A1%86%E6%9E%B6.png" class title="This is an example image">

<p>Executor框架将任务的提交与运行进行分离，在Java标准库中提供了Executor、ExecutorService和ScheduledExecutorService三个接口和基础实现。如Executors类扮演<strong>线程池工厂</strong>的角色，通过Executors可以获得拥有特定功能的线程池。ThreadPoolExecutor类实现Executor接口，表示一个<strong>线程池</strong>，通过此接口，任何Runnable的对象均可以被ThreadPoolExecutor线程池调度。以上成员均在J.U.C包中。</p>
<h4 id="J-U-C的三个Executor接口"><a href="#J-U-C的三个Executor接口" class="headerlink" title="J.U.C的三个Executor接口"></a>J.U.C的三个Executor接口</h4><h5 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h5><p>运行新任务的简单接口，将任务<strong>提交</strong>与任务<strong>执行</strong>细节<strong>解耦</strong>。下面只有一个execute(Runnable command)方法，线程执行有多种可能</p>
<ul>
<li>可能为创建一个新线程并立即启动</li>
<li>可能是用已有的工作线程来运行传入的任务</li>
<li>可能是根据设置线程池的容量或阻塞队列的容量来决定将线程放入阻塞队列或接收传入的线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br></pre></td></tr></table></figure>

<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/%E6%8E%A5%E5%8F%A31.png" class title="This is an example image">

<h5 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h5><p>具备管理执行器和任务声明周期的方法，提交任务机制更完善。扩展了Executor接口，如可以返回Future的submit方法，Callable弥补了Runnale没有返回值的短板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h5><p>扩展了ExecutorService，支持<strong>定期执行</strong>任务。</p>
<h4 id="线程池使用"><a href="#线程池使用" class="headerlink" title="线程池使用"></a>线程池使用</h4><p>展示固定大小的线程池的使用为例子，基本思路仍为创建任务类实现Runnable接口，实现run()方法，然后利用Executors线程工厂来获取线程池，利用线程池的submit(task)方法来执行任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis()+<span class="string">": Thread ID"</span>+Thread.currentThread().getId());</span><br><span class="line">        <span class="comment">//休息一秒钟</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、新建线程池</span></span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//将任务放入线程池，并执行10次</span></span><br><span class="line">        MyTask task = <span class="keyword">new</span> MyTask();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            es.submit(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中这里让一个线程执行后休眠1秒钟，然后线程池大小设置为5，让线程池执行10次任务，可以看到任务5个5个分批次执行，而且每一批都为相同的几个线程，结果如下所示。</p>
<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BC%94%E7%A4%BA1.png" class title="This is an example image">

<p>但是如果使用的是newCachedThreadPool()，则可以10个线程一批执行完。</p>
<p>但是有些时候，Executors工厂类中提供的线程池不能满足需求，这时候可以通过ThreadPoolExecutor构造函数去创建线程池。</p>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4>

<p>线程池整个的应用逻辑为：线程池由工作队列WorkQueue来存储各个队列提交的工作任务。工作队列可以是容量为0的SynchronizedQueue，主要用于newCachedThreadPool；也可以是newFixedThreadPool中的LinkedBlockingQueue。队列接到任务后，排队提交给线程池，即工作队列的集合，该集合负责在运行的过程中管理线程的创建和销毁。线程池的<strong>工作线程</strong>被抽象为静态内部类WorkerThread，线程池维护的其实是一组<strong>Worker对象</strong>。</p>
<p>Worker类是ThreadPoolExecutor类中的内部类，继承自AQS，实现了Runnable，由firstTast保存传入的任务，thread保存创建出来的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">            <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当Worker启动的时候，调用run()方法来启动里面的逻辑。</p>
<p>ThreadPoolExecutor构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                             TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                             RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<p>5个参数比较关键</p>
<ul>
<li><p>corePoolSize：核心线程数量（长期驻留的线程数，不同实现差别很大）</p>
<p>太小，频繁创建销毁线程；太大，浪费系统资源</p>
</li>
<li><p>maximumPoolSize：线程不够用时能够创建的最大线程数（有的固定于核心线程一样，有的可以创建更多）</p>
<p>必须大于等于corePoolSize</p>
</li>
<li><p>keepAliveTime：线程存活时间（线程池维护线程允许的空闲时间，当线程池中线程数量大于corePoolSize的时候，若没有新任务提交，核心线程外的线程不会立即被销毁，而是等待时间超过keepAliveTime）</p>
</li>
<li><p>workQueue：任务等待队列（当任务提交时，若线程池中线程数量大于等于PoolSize，将任务封装为Worker对象放入等待队列中）</p>
<ul>
<li>直接提交的队列：SynchronousQueue<strong>没有容量</strong>，是<strong>无缓冲等待队列</strong>，是一个不存储元素的<strong>阻塞</strong>队列，一个插入操作要等待一个删除操作。提交的任务不会被真实保存，总是将新任务给线程执行，若没有空闲的线程，尝试创建新的线程。一般要求maximumPoolSizes设置很大，避免线程拒绝执行操作。</li>
<li>有界的任务队列：ArrayBlockingQueue，构造函数必须传入其最大容量，当有新任务执行，线程数小于核心线程数，优先创建线程，若大于，将新任务加进等待队列。若队列满了，无法加入，在总线程数不大于最大线程数时，创建新线程执行任务；否则执行拒绝策略。因此有界队列仅在任务队列装满时才可能将线程数扩充到核心线程数之上。</li>
<li>无界的任务队列：LinkedBlockingQueue，当有新任务执行，线程数小于设定核心线程数，生成新线程执行任务，当线程数达到核心线程数后，线程不会增加，若有任务没有被消费，放进队列等待，队列可以一直增长直到耗尽系统资源。每个线程完全独立于其他线程。生产者和消费者使用<strong>独立的锁</strong>来控制数据的同步，即在高并发的情况下可以并行操作队列中的数据。</li>
<li>优先任务队列：PriorityBlockingQueue，可控制任务先后执行顺序，特殊的无界队列，ArrayBlockingQueue与LinkedBlockingQueue按照先进先出顺序执行，而此队列确保高优先级的任务先执行。</li>
</ul>
</li>
<li><p>threadFactory：创建新线程，Executors.defaultThreadFactory()（使用这个创建，新线程有一样的优先级，且是非守护线程，同时设置了线程的名称）</p>
</li>
</ul>
<p>而其中的handle，是线程池的饱和策略</p>
<p><strong>若阻塞队列满且没有空闲线程，若继续提交任务，需要策略去处理</strong></p>
<ul>
<li>AbortPolicy：直接抛出异常，默认策略</li>
<li>CallerRunsPolicy：由调用者的线程来执行任务</li>
<li>DiscardOldestPolicy：丢弃队列中最靠前的任务，并执行当前任务</li>
<li>DiscardPolicy：直接丢弃任务</li>
<li>或自己定义，<strong>实现RejectExecutionHandler接口</strong></li>
</ul>
<p>自定义类，实现RejectExecutionHandler接口，并实现如下方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="新任务提交执行后线程池判断"><a href="#新任务提交执行后线程池判断" class="headerlink" title="新任务提交执行后线程池判断"></a>新任务提交执行后线程池判断</h4><ul>
<li>若运行中线程数少于核心线程数，创建新线程处理任务</li>
<li>若线程池数量大于等于核心线程数且小于最大线程数，将其放入等待队列，当等待队列满了再新建线程去执行任务</li>
<li>若运行线程数量大于最大线程数，若等待队列已满，通过handler所指定策略执行任务</li>
</ul>
<h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><ul>
<li><p>RUNNING：可以接受新提交的任务，也能处理阻塞队列中的任务</p>
</li>
<li><p>SHUTDOWN：不再接受新任务，可以处理存量任务</p>
<p>在处于RUNNING状态时调用shutdown()方法</p>
</li>
<li><p>STOP：不再接受新的任务，也不处理存量任务（线程被中断）</p>
<p>处于RUNNING或SHUNDOWN状态调用shutdownnow()方法</p>
</li>
<li><p>TIDYING：所有任务终止</p>
<p>进行最后清理工作，有效线程数为0，进入此状态后调用terminated方法进入下一状态</p>
</li>
<li><p>TERMINATED：默认什么也不做，只作为一个标识</p>
</li>
</ul>
<p>处于SHUTDOWN和STOP状态的线程，当线程池中工作线程数量为0时，进入TIDYING状态。</p>
<h4 id="线程池大小"><a href="#线程池大小" class="headerlink" title="线程池大小"></a>线程池大小</h4><ul>
<li><p>CPU密集型：线程数=核数或核数+1设定</p>
<p>大幅增加线程导致许多不必要的开销</p>
</li>
<li><p>I/O密集型：线程数=CPU核数*（1+平均等待时间/平均工作时间）</p>
</li>
</ul>
<h4 id="线程池创建规则"><a href="#线程池创建规则" class="headerlink" title="线程池创建规则"></a>线程池创建规则</h4><p>在阿里巴巴《Java开发手册》中规定，线程池不允许使用Executors创建，而是通过ThreadPoolExecutor的方式，目的是更加明确线程池的使用规则，避免资源耗尽的风险。</p>
<p>使用Executors创建线程池弊端有</p>
<ul>
<li>FixedThreadPool和SingleThreadPool，使用的LinkdedBlockingQueue，任务队列最大长度为Integer.MAX_VALUE，可能堆积大量请求，导致OOM</li>
<li>CachedThreadPool和ScheduledThreadPool，允许创建的最大此案城数量为Integer.MAX_VALUE，可能创建大量的线程，导致OOM</li>
</ul>
<h4 id="线程池执行方法"><a href="#线程池执行方法" class="headerlink" title="线程池执行方法"></a>线程池执行方法</h4><p>有submit()和execute()</p>
<ul>
<li>execute()属于Executor接口，submit()属于ExecutorService接口</li>
<li>execute()不能接收返回值，submit()可以配合Future来接收返回值</li>
</ul>
<h4 id="ThreadPoolExecutor扩展"><a href="#ThreadPoolExecutor扩展" class="headerlink" title="ThreadPoolExecutor扩展"></a>ThreadPoolExecutor扩展</h4><p>让自定义类继承ThreadPoolExecutor，然后重写其beforeExecute和afterExecute方法，然后添加自定义方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="并发工具包"><a href="#并发工具包" class="headerlink" title="并发工具包"></a>并发工具包</h3><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><h5 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h5><p>Semaphore信号量是对锁的拓展，synchronized或ReentrantLock都只允许一个线程访问一个资源，而信号量可以指定多个线程，其构造方法有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即在新建其对象时，必须指定信号的准入数，即同时可以申请多少个许可。其主要方法有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">tryAcquire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>acquire方法尝试去获得准入许可，若无法获得会等待，直到有线程释放许可或被中断。acquireUninterruptibly不响应中断。这两个方法类似于locks.interruptedLock和lock.lock。tryAcquire()尝试获得许可，成功返回true，失败返回false，不会等待，而tryAcquire()会尝试等待，类似于locks.tryLock()方法。release()用于线程在访问资源结束后，释放一个许可。</p>
<h5 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h5><p>下面演示Semaphore的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskSem</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Semaphore sem = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1、获取semaphore</span></span><br><span class="line">            sem.acquire();</span><br><span class="line">            <span class="comment">//执行任务</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getId()+<span class="string">"完成任务"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            sem.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//信号量的学习</span></span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        TaskSem ts = <span class="keyword">new</span> TaskSem();</span><br><span class="line">        <span class="comment">//提交20次任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            es.submit(ts);</span><br><span class="line">        &#125;</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建了一个允许5个的Semaphore，任务被执行前先获取许可，执行完后需要释放资源，因此将其放在finallt中。在20个线程的线程池中，将20个任务提交，但结果为5个一组来执行，</p>
<p>因此可以看到Semaphore可以用在一些需要限流的场合，如数据库连接数是有限的，这样可以用信号量来控制最多同时访问的线程数。</p>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>倒计时器，常用来控制线程等待，让一个线程等待直到倒计时结束，再执行。</p>
<h5 id="具体方法-1"><a href="#具体方法-1" class="headerlink" title="具体方法"></a>具体方法</h5><p>构造函数，需要传入等待计数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>当计数没有到达设定次数时，调用await()方法的线程会处于等待，其他线程调用一次countDown()方法，计数-1，当计数为0的时候，处于等待的方法继续进行</p>
<h5 id="如何使用-1"><a href="#如何使用-1" class="headerlink" title="如何使用"></a>如何使用</h5><p>在主线程上阻塞，任务线程执行一次后执行countDown()方法，当执行10次后，主线程继续运行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskCoutDown</span>  <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch cd = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//执行一次，检查一次</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"check"</span>);</span><br><span class="line">            <span class="comment">//进行计数</span></span><br><span class="line">            cd.countDown();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TaskCoutDown tcd = <span class="keyword">new</span> TaskCoutDown();</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//执行 10次点火</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            es.submit(tcd);</span><br><span class="line">        &#125;</span><br><span class="line">        TaskCoutDown.cd.await();</span><br><span class="line">        System.out.println(<span class="string">"发射"</span>);</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>ThreadLocal，直观的语义理解为线程私有，可以先直观理解为每个线程内有自己的ThreadLocal对象，线程存在则ThreadLocal存在。线程A在ThreadLocal中设置的对象是自己私有的，线程B无法获取到。</p>
<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><ul>
<li>保存线程<strong>上下文信息</strong>，在任意需要的地方进行获取</li>
</ul>
<p>将信息set后，后续有切换的情况下，直接用get可以获取到之前的信息。</p>
<p>还有spring的事务管理，spring中的<code>@transaction</code>注解，事务注解，其中的方法要么全部完成，要么全部回滚，若有方法m()中有两个方法m1与m2，均需要读取数据库中的数据，需要保证二者用的同一个Connection才能构成事务，使用的是ThreadLocal，因为每个线程有自己私有的ThreadLocal，从当前线程中拿对象，拿到的是同一个。</p>
<ul>
<li>线程安全的，避免某些情况需要考虑线程安全必须同步带来的性能损失</li>
</ul>
<p>使用一些不是线程安全的对象，在不涉及共享对象的更新问题时，为了避免加锁带来的性能损失，将共享变量加入ThreadLocal，这样每个线程对ThreadLocal中读写数据是线程隔离的，互相之间不会影响，也就不存在竞争问题。</p>
<h5 id="底层实现-1"><a href="#底层实现-1" class="headerlink" title="底层实现"></a>底层实现</h5><p>下图为ThreadLocal的示意图。</p>
<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/threadlocal1.png" class title="This is an example image">

<blockquote>
<p>图片来源于微信公众号链接<a href="https://mp.weixin.qq.com/s/SysYihctu03RlUtI0pcG7w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/SysYihctu03RlUtI0pcG7w</a></p>
</blockquote>
<p>总的来说，每个Thread线程有一个ThreadLocalMap类型的threadLocals成员变量，在map中有键值对，用Entry来存储，Entry相当于map的一行，也是键值对。其中Entry中的key对ThreadLocal对象为弱引用，而value是对传进ThreadLocal中泛型对象的强引用。而作用后面会细说，先看ThreadLocal的set方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//set方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//key为this即当前ThreadLocal对象</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getMap方法，获取线程对应的map</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，通过当前线程获取到map，然后将ThreadLocal作为key，传入ThreadLocal的对象作为value，存入当前线程的map中。</p>
<p>而map.set()方法源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="comment">//相当于new了WeakReference，弱引用指向key</span></span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，map中的Entry继承了弱引用，因此调用super(key)代表着key是对ThreadLocal的弱引用。</p>
<h5 id="key为弱引用原因"><a href="#key为弱引用原因" class="headerlink" title="key为弱引用原因"></a>key为弱引用原因</h5><p>总的来说是为了避免内存泄漏。</p>
<img src="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/threadlocal2.png" class title="This is an example image">

<p>对于<code>ThreadLocal&lt;Node&gt; tl = new ThreadLocal&lt;&gt;();</code>语句，tl对ThreadLocal为强引用，key对ThreadLocal为弱引用，使用弱引用原因是防止内存泄漏。如果key为强引用，那么即使tl不指向ThreadLocal了，因为有key的指向，ThreadLocal对象也无法被回收。当使用弱引用后，当tl强引用为空，ThreadLocal对象可在GC时被回收。这样存在的问题是，当ThreadLocal被回收，key为null，但这行记录还存在，需要手动去remove()。当ThreadLocal对象tl不继续使用，必须调用tl.remove()方法。</p>
<blockquote>
<p>引用到的资料来源：</p>
<p><a href="https://blog.csdn.net/cy973071263/article/details/104546954" target="_blank" rel="noopener">https://blog.csdn.net/cy973071263/article/details/104546954</a></p>
<p><a href="https://blog.csdn.net/javazejian/article/details/72828483#理解java对象头与monitor" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/72828483#%E7%90%86%E8%A7%A3java%E5%AF%B9%E8%B1%A1%E5%A4%B4%E4%B8%8Emonitor</a></p>
<p><a href="https://blog.csdn.net/qq_37113604/article/details/81582784?depth_1-utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/qq_37113604/article/details/81582784?depth_1-utm_source=distribute.pc_relevant.none-task</a></p>
<p><a href="https://mp.weixin.qq.com/s/SysYihctu03RlUtI0pcG7w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/SysYihctu03RlUtI0pcG7w</a></p>
</blockquote>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记</title>
    <url>/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="OJ处理技巧"><a href="#OJ处理技巧" class="headerlink" title="OJ处理技巧"></a>OJ处理技巧</h1><p>类名为public class Main</p>
<p>较好的做法是将要用到的类都封装好，不要放在Main类中，主类只需要持有要用到的类的对象，然后调用即可。</p>
<p>StringBuilder类的append方法，res.append(str1).append(str2)比res.append(str1+str2)效率高。</p>
<p>其中牛客网要求格式化输出数据，可以用DecimalFormat类，进行一位小数的输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DecimalFormat df = <span class="keyword">new</span> DecimalFormat(<span class="string">"0.00000"</span>);</span><br></pre></td></tr></table></figure>

<p>或者使用String的format方法，支持float与double</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String result = String.format(<span class="string">"%.1f"</span>,data);</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="获取不知次数的输入"><a href="#获取不知次数的输入" class="headerlink" title="获取不知次数的输入"></a>获取不知次数的输入</h2><p>使用BufferedReader来获取，需要Import，主函数需要抛出异常</p>
<p>valueOf返回值类型为Integer，parseInt返回值类型为int</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((s = br.readLine())!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//获取第一行输入，输入为一个数</span></span><br><span class="line">            <span class="keyword">int</span> len = Integer.valueOf(s);</span><br><span class="line">            <span class="comment">//获取第二行输入，输入为数组</span></span><br><span class="line">            String[] arrStr = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">int</span> [] arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                arr[i] = Integer.valueOf(arrStr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(要求的函数);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取有限次数的输入"><a href="#获取有限次数的输入" class="headerlink" title="获取有限次数的输入"></a>获取有限次数的输入</h2><p>输出的结果先用StringBuilder类存起来，如果有多行，每一行最后要加上换行标识。最后要输出的时候，将stringbuilder转变为String类输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="comment">//要持有的写的类</span></span><br><span class="line">        DogCatQueue dq = <span class="keyword">new</span> DogCatQueue();</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s = br.readLine();</span><br><span class="line">        <span class="keyword">int</span> count = Integer.valueOf(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            String[] strArr = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//if或者switch判断</span></span><br><span class="line">            <span class="keyword">switch</span> (strArr[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"add"</span>:</span><br><span class="line">                    String type=strArr[<span class="number">1</span>];</span><br><span class="line">                    dq.add(<span class="keyword">new</span> Pet(type,Integer.valueOf(strArr[<span class="number">2</span>])));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"pollAll"</span>:</span><br><span class="line">                    <span class="keyword">while</span>(!dq.isEmpty())&#123;</span><br><span class="line">                        pet = dq.pollAll();</span><br><span class="line">                        res.append(pet.getPetType()+<span class="string">" "</span>+pet.getPetIndex()+<span class="string">"\n"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"isDogEmpty"</span> :</span><br><span class="line">                    res.append(dq.isDogEmpty()?<span class="string">"yes\n"</span>:<span class="string">"no\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res.substring(<span class="number">0</span>,res.length()-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取输入矩阵"><a href="#获取输入矩阵" class="headerlink" title="获取输入矩阵"></a>获取输入矩阵</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="comment">//要持有的写的类</span></span><br><span class="line">        <span class="comment">//PringtEdge pe = new PringtEdge();</span></span><br><span class="line">        String[] s = <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="comment">//获取第一行的矩阵行与列</span></span><br><span class="line">        <span class="keyword">int</span> row = Integer.valueOf(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> col = Integer.valueOf(s[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        <span class="comment">//获取后面几行的矩阵数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            s = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                arr[i][j] = Integer.valueOf(s[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过自己编写方法获取结果</span></span><br><span class="line">        <span class="comment">//res = pe.printCircle(arr);</span></span><br><span class="line">        System.out.println(res.substring(<span class="number">0</span>,res.length()-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取数组"><a href="#获取数组" class="headerlink" title="获取数组"></a>获取数组</h2><p>输入只有一行，为数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">	<span class="comment">//交换数组中的数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//打印数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArr</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            System.out.print(arr[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        String[] strArray = str.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span>[] intArray = <span class="keyword">new</span> <span class="keyword">int</span>[strArray.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;strArray.length;i++) &#123;</span><br><span class="line">            intArray[i] = Integer.parseInt(strArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//要解决的</span></span><br><span class="line">        Solution(intArray);</span><br><span class="line">    	<span class="comment">//输出数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;intArray.length;i++) &#123;</span><br><span class="line">            System.out.print(intArray[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//or</span></span><br><span class="line">    	printArr(printArr);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输入有两行，第一行为数组长度，第二行为数组</p>
<p>获取long类型的数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">int</span> len = Integer.parseInt(br.readLine());</span><br><span class="line">        <span class="keyword">long</span>[] arr = <span class="keyword">new</span> <span class="keyword">long</span>[len];</span><br><span class="line">        String[] strArray = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">            arr[i] = Long.parseLong(strArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        LessMoney lm = <span class="keyword">new</span> LessMoney();</span><br><span class="line">        System.out.println(lm.getLessMoney(arr));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取链表"><a href="#获取链表" class="headerlink" title="获取链表"></a>获取链表</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node next;</span><br><span class="line">    Node pre;</span><br><span class="line">    Node(<span class="keyword">int</span> value)&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建单向链表</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">createNode</span><span class="params">(String[] str,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        Node head = <span class="keyword">new</span> Node(Integer.parseInt(str[<span class="number">0</span>]));</span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(Integer.parseInt(str[i]));</span><br><span class="line">            node.next = newNode;</span><br><span class="line">            node = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建双向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">createNodeDL</span><span class="params">(String[] str,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        Node head = <span class="keyword">new</span> Node(Integer.parseInt(str[<span class="number">0</span>]));</span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(Integer.parseInt(str[i]));</span><br><span class="line">            node.next = newNode;</span><br><span class="line">            node.next.pre = node;</span><br><span class="line">            node = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//打印列表</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            builder.append(node.value).append(<span class="string">" "</span>);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(builder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//主函数部分</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="comment">//创建第一个链表</span></span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(input.readLine());</span><br><span class="line">        String[] strings1 = input.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        Node list1 = createNode(strings1,n);</span><br><span class="line">        <span class="comment">//创建第二个链表</span></span><br><span class="line">        <span class="keyword">int</span> m = Integer.parseInt(input.readLine());</span><br><span class="line">        String[] strings2 = input.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        Node list2 = createNode(strings2,m);</span><br><span class="line">        <span class="comment">//要操作的函数</span></span><br><span class="line">        <span class="comment">//printCommonPart(list1,list2);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取树"><a href="#获取树" class="headerlink" title="获取树"></a>获取树</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="comment">//读取总的节点数与根节点数</span></span><br><span class="line">        String[] s=reader.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> rootIdx = Integer.parseInt(s[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//构造桶，将每个节点放入对应值，分别存其左、右结点的值</span></span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="comment">//将节点的数放入对应的桶中，构造得到数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            String[] sts = reader.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            t = Integer.parseInt(sts[<span class="number">0</span>]);</span><br><span class="line">            arr[t][<span class="number">0</span>] = Integer.parseInt(sts[<span class="number">1</span>]);</span><br><span class="line">            arr[t][<span class="number">1</span>] = Integer.parseInt(sts[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拿出头节点</span></span><br><span class="line">        Node head = <span class="keyword">new</span> Node(rootIdx);</span><br><span class="line">        createTree(head,arr);</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        preOrderRecur(head,res);</span><br><span class="line">        System.out.println(res.substring(<span class="number">0</span>,res.length()-<span class="number">1</span>));</span><br><span class="line">        res.delete(<span class="number">0</span>,res.length());</span><br><span class="line">        inOrderRecur(head,res);</span><br><span class="line">        System.out.println(res.substring(<span class="number">0</span>,res.length()-<span class="number">1</span>));</span><br><span class="line">        res.delete(<span class="number">0</span>,res.length());</span><br><span class="line">        posOrderRecur(head,res);</span><br><span class="line">        System.out.println(res.substring(<span class="number">0</span>,res.length()-<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createTree</span><span class="params">(Node root,<span class="keyword">int</span>[][] a)</span></span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=root.value;</span><br><span class="line">        <span class="keyword">int</span> l=a[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> r=a[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//左子树不为空，构造左子树</span></span><br><span class="line">        <span class="keyword">if</span>(l!=<span class="number">0</span>)&#123;</span><br><span class="line">            Node leftNode=<span class="keyword">new</span> Node(l);</span><br><span class="line">            root.left=leftNode;</span><br><span class="line">            <span class="comment">//递归产生左子树</span></span><br><span class="line">            createTree(leftNode,a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右子树不为空，构造右子树</span></span><br><span class="line">        <span class="keyword">if</span>(r!=<span class="number">0</span>)&#123;</span><br><span class="line">            Node rightNode=<span class="keyword">new</span> Node(r);</span><br><span class="line">            root.right=rightNode;</span><br><span class="line">            createTree(rightNode,a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="左神算法笔记"><a href="#左神算法笔记" class="headerlink" title="左神算法笔记"></a>左神算法笔记</h1><p>对数器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//产生数组的对数器</span></span><br><span class="line">       <span class="comment">//1，有一个随机样本产生器</span></span><br><span class="line">       <span class="comment">//2,准备绝对正确的方法</span></span><br><span class="line">       <span class="comment">//3，大样本测试</span></span><br><span class="line">       <span class="keyword">int</span> testTime = <span class="number">500000</span>;</span><br><span class="line">       <span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line">       <span class="keyword">int</span> value = <span class="number">100</span>;</span><br><span class="line">       <span class="keyword">boolean</span> succeed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">//进行testTime次测试</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line">           <span class="keyword">int</span>[] arr1 = generateRandomArray(size,value);<span class="comment">//准备测试样本</span></span><br><span class="line">           <span class="keyword">int</span>[] arr2 = copyArray(arr1);</span><br><span class="line">           <span class="keyword">int</span>[] arr3 = copyArray(arr1);</span><br><span class="line">           <span class="comment">//待测试方法</span></span><br><span class="line">           shellSort2(arr1);</span><br><span class="line">           <span class="comment">//绝对正确方法</span></span><br><span class="line">           rightMethod(arr2);</span><br><span class="line">           <span class="keyword">if</span>(!isEqual(arr1,arr2))&#123;</span><br><span class="line">               succeed = <span class="keyword">false</span>;</span><br><span class="line">               printArray(arr3);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(succeed?<span class="string">"Nice!"</span>:<span class="string">"False!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//随机样本发生器</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] generateRandomArray(<span class="keyword">int</span> size, <span class="keyword">int</span> value)&#123;</span><br><span class="line">       <span class="comment">//Math.Random -&gt; double[0,1)</span></span><br><span class="line">       <span class="comment">//产生的长度为0-size</span></span><br><span class="line">       <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>)((size+<span class="number">1</span>)*Math.random())];</span><br><span class="line">       <span class="comment">//产生的值为-value-value</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; arr.length;i++)&#123;</span><br><span class="line">           arr[i] = (<span class="keyword">int</span>)((value+<span class="number">1</span>) * Math.random()) - (<span class="keyword">int</span>)(value * Math.random());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> arr;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//正确方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rightMethod</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       Arrays.sort(arr);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//拷贝数组</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] copyArray(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">       <span class="keyword">return</span> Arrays.copyOf(arr,arr.length);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//数组输出</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i : arr)</span><br><span class="line">           System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">       System.out.println();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//比较数组</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEqual</span><span class="params">(<span class="keyword">int</span>[] arr1,<span class="keyword">int</span>[] arr2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>((arr1==<span class="keyword">null</span>&amp;&amp;arr2!=<span class="keyword">null</span>)||(arr1!=<span class="keyword">null</span>&amp;&amp;arr2==<span class="keyword">null</span>))</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">if</span>(arr1 == <span class="keyword">null</span> &amp;&amp; arr2 ==<span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">if</span>(arr1.length != arr2.length)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span>(arr1[i] != arr2[i])</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a>排序问题</h2><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思想：第一个排到最后一个，第一个排到倒数第二个，以此类推</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length&lt;<span class="number">2</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="comment">//两层循环</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> end = arr.length-<span class="number">1</span>; end &gt; <span class="number">0</span>; end--) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; end; start++) &#123;</span><br><span class="line">               <span class="comment">//如果当前数比第二个数大，则交换</span></span><br><span class="line">               <span class="keyword">if</span> (arr[start]&gt;arr[start+<span class="number">1</span>])</span><br><span class="line">                   swap(arr,start,start+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思想：0-N-1比较，找最小的放第一个，1-N-1比较，找最小的放第二个，以此类推</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length&lt;<span class="number">2</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">int</span> minIndex = i;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">               minIndex = arr[minIndex]&gt;arr[j]?j:minIndex;</span><br><span class="line">           &#125;</span><br><span class="line">           swap(arr,i,minIndex);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思想：如果当前数一直比左边的小，就左右交换</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length&lt;<span class="number">2</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;=<span class="number">0</span> &amp;&amp; arr[j]&gt;arr[j+<span class="number">1</span>]; j--) &#123;</span><br><span class="line">               swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>插入排序的改进版，增量排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="comment">//gap为arr.length/2到1</span></span><br><span class="line">       <span class="keyword">int</span> temp = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap--) &#123;</span><br><span class="line">           <span class="comment">//从gap开始，后移一位</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">               <span class="comment">//记录开始的位置</span></span><br><span class="line">               j = i;</span><br><span class="line">               temp = arr[j];<span class="comment">//此轮被比较的数</span></span><br><span class="line">               <span class="comment">//只有在此组前一个数比当前大，才进行</span></span><br><span class="line">               <span class="keyword">if</span> (arr[j - gap] &gt; arr[j])&#123;</span><br><span class="line">                   <span class="comment">//找到这个组中j的位置</span></span><br><span class="line">                   <span class="keyword">while</span> (j-gap &gt;= <span class="number">0</span> &amp;&amp; arr[j - gap] &gt; temp)&#123;</span><br><span class="line">                       arr[j] = arr[j-gap];<span class="comment">//上一个大的数到当前位置</span></span><br><span class="line">                       j -= gap;<span class="comment">//更新j的位置</span></span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//将这轮比较的数放在自己的位置</span></span><br><span class="line">                   arr[j] = temp;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思想：将左边排好，将右边排好，然后将左右两边用外排的方式排好</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length&lt;<span class="number">2</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       sortProcess(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortProcess</span><span class="params">(<span class="keyword">int</span>[]arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">       <span class="comment">//base case</span></span><br><span class="line">       <span class="keyword">if</span> (left==right)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">       sortProcess(arr,left,mid);</span><br><span class="line">       sortProcess(arr,mid+<span class="number">1</span>,right);</span><br><span class="line">       merge(arr,left,mid,right);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> L,<span class="keyword">int</span> mid,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R-L+<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">int</span> p1 = L,p2 = mid+<span class="number">1</span>,i=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (p1&lt;=mid &amp;&amp; p2&lt;=R)&#123;</span><br><span class="line">           <span class="comment">//谁小动谁</span></span><br><span class="line">           help[i++]=arr[p1]&lt;=arr[p2]?arr[p1++]:arr[p2++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (p1&lt;=mid)&#123;</span><br><span class="line">           help[i++]=arr[p1++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (p2&lt;=R)&#123;</span><br><span class="line">           help[i++]=arr[p2++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//将help拷贝至arr</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; help.length; j++) &#123;</span><br><span class="line">           arr[L+j] = help[j];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思想：核心为partition部门，荷兰国旗思想，将数组分组小于，等于，大于区</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">       <span class="comment">//base case:L=R</span></span><br><span class="line">       <span class="keyword">if</span> (L &lt; R)&#123;</span><br><span class="line">           <span class="comment">//产生一个随机下标，和最后一位交换</span></span><br><span class="line">           swap(arr,L+(<span class="keyword">int</span>)Math.random()*(R-L+<span class="number">1</span>),R);</span><br><span class="line">           <span class="keyword">int</span>[] p = partition(arr,L,R);</span><br><span class="line">           quickSort(arr,L,p[<span class="number">0</span>]-<span class="number">1</span>);</span><br><span class="line">           quickSort(arr,p[<span class="number">1</span>]+<span class="number">1</span>,R);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//然后对小于和大于区继续进行partition过程</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> L,<span class="keyword">int</span> R)&#123;</span><br><span class="line">       <span class="comment">//小于区和大于区边界</span></span><br><span class="line">       <span class="keyword">int</span> less = L-<span class="number">1</span>,more = R;</span><br><span class="line">       <span class="comment">//只要当前位置没有碰到大于区</span></span><br><span class="line">       <span class="keyword">while</span> (L &lt; more)&#123;</span><br><span class="line">           <span class="comment">//如果当前数比最后一个数小，放在小于区</span></span><br><span class="line">           <span class="keyword">if</span> (arr[L] &lt; arr[R])&#123;</span><br><span class="line">               swap(arr,L++,++less);</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[L] &gt; arr[R])&#123;</span><br><span class="line">               <span class="comment">//如果比最后一个数大，放在大于区，当前位置不变</span></span><br><span class="line">               swap(arr,L,--more);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//相等就判断下一个位置</span></span><br><span class="line">               L++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       swap(arr,more,R);</span><br><span class="line">       <span class="comment">//返回等于区域的下标</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less+<span class="number">1</span>,more&#125;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思想：先构造大根堆，然后将根节点取出，重新构造大根堆</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length&lt;<span class="number">2</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           heapInsert(arr,i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> heapSize = arr.length;</span><br><span class="line">       <span class="comment">//取出一个，与最后个交换</span></span><br><span class="line">       swap(arr,<span class="number">0</span>,--heapSize);</span><br><span class="line">       <span class="keyword">while</span> (heapSize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           heapify(arr,<span class="number">0</span>,heapSize);</span><br><span class="line">           swap(arr,<span class="number">0</span>,--heapSize);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">       <span class="keyword">while</span> (arr[i] &gt; arr[(i-<span class="number">1</span>)/<span class="number">2</span>])&#123;</span><br><span class="line">           swap(arr,i,(i-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">           i = (i-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (left&lt;size)&#123;</span><br><span class="line">           <span class="keyword">int</span> largest = (left+<span class="number">1</span>)&lt;size &amp;&amp; arr[left+<span class="number">1</span>]&gt;arr[left] ? left+<span class="number">1</span> : left;</span><br><span class="line">           largest = arr[largest] &gt; arr[i] ? largest : i;</span><br><span class="line">           <span class="keyword">if</span> (largest == i)</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           swap(arr,i,largest);</span><br><span class="line">           i = largest;</span><br><span class="line">           left = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思想：如果全部为正数，将其装在对应的桶中，然后再倒出来</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length&lt;<span class="number">2</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="comment">//统计最大数</span></span><br><span class="line">       <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           max = arr[i] &gt; max ? arr[i] : max;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[max+<span class="number">1</span>];</span><br><span class="line">       <span class="comment">//装入桶中</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           bucket[arr[i]]++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//从桶中倒出来</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) &#123;</span><br><span class="line">           <span class="keyword">while</span> (bucket[j--] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">               <span class="comment">//数组的值等于对应位置的值</span></span><br><span class="line">               arr[i++] = j;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h3><p>题目描述：</p>
<p>数组小和的定义如下：</p>
<p>例如，数组s = [1, 3, 5, 2, 4, 6]，在s[0]的左边小于或等于s[0]的数的和为0；在s[1]的左边小于或等于s[1]的数的和为1；在s[2]的左边小于或等于s[2]的数的和为1+3=4；在s[3]的左边小于或等于s[3]的数的和为1；</p>
<p>在s[4]的左边小于或等于s[4]的数的和为1+3+2=6；在s[5]的左边小于或等于s[5]的数的和为1+3+5+2+4=15。所以s的小和为0+1+4+1+6+15=27</p>
<p>给定一个数组s，实现函数返回s的小和</p>
<p>[要求]</p>
<p>时间复杂度为O(nlogn)，空间复杂度为O(n)</p>
<p>思路：找小和，就是看当前数右边哪些数比他大 ，顺序并没有关系，因此可以用mergesort的思想，先分再合，产生小和的过程为merge的过程，如果右边数比左边大，那么总的小和个数为左边当前数*右边数个数，然后将两个数组sort中产生的数和当前merge共三部门数相加即可。</p>
<p>坑：</p>
<p>最后的小和可能很大，需要long类型才能过OJ，小和为小于等于，因此merge外排时判断为&lt;=</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        String s = null;</span><br><span class="line">        while((s=br.readLine())!=null)&#123;</span><br><span class="line">            int len = Integer.valueOf(s);</span><br><span class="line">            String[] arrStr = br.readLine().split(" ");</span><br><span class="line">            int[] arr = new int[len];</span><br><span class="line">            for(int i = 0;i &lt; len;i++)&#123;</span><br><span class="line">                arr[i] = Integer.parseInt(arrStr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(smallSum(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static long smallSum(int[] arr)&#123;</span><br><span class="line">        if(arr == null || arr.length &lt; 2)</span><br><span class="line">            return 0;</span><br><span class="line">        return sortProcess(arr,0,arr.length-1);</span><br><span class="line">    &#125;</span><br><span class="line">    public static long sortProcess(int[] arr,int l,int r)&#123;</span><br><span class="line">        if(l == r)</span><br><span class="line">            return 0;</span><br><span class="line">        int mid = l + (r - l)/2;</span><br><span class="line">        return sortProcess(arr,l,mid)+sortProcess(arr,mid+1,r)+<span class="keyword">merge</span>(arr,l,<span class="keyword">mid</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    public static long <span class="keyword">merge</span>(<span class="built_in">int</span>[] arr,<span class="built_in">int</span> l,<span class="built_in">int</span> <span class="keyword">mid</span>, <span class="built_in">int</span> r)&#123;</span><br><span class="line">        <span class="built_in">int</span> p1 = l,p2 = <span class="keyword">mid</span>+<span class="number">1</span>,i = <span class="number">0</span>;</span><br><span class="line">        int[] <span class="keyword">help</span> = <span class="keyword">new</span> <span class="built_in">int</span>[r-l+<span class="number">1</span>];</span><br><span class="line">        long res = 0;</span><br><span class="line">        while(p1&lt;=mid &amp;&amp; p2 &lt;= r)&#123;</span><br><span class="line">            if(arr[p1] &lt;= arr[p2])&#123;</span><br><span class="line">                res += arr[p1] * (r-p2+1);</span><br><span class="line">                <span class="keyword">help</span>[i++] = arr[p1++];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                <span class="keyword">help</span>[i++] = arr[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(p1&lt;=mid)&#123;</span><br><span class="line">            <span class="keyword">help</span>[i++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        while(p2&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">help</span>[i++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        for(i = 0;i&lt;help.length;i++)&#123;</span><br><span class="line">            arr[l+i] = <span class="keyword">help</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组排序后相邻数的最大差值"><a href="#数组排序后相邻数的最大差值" class="headerlink" title="数组排序后相邻数的最大差值"></a>数组排序后相邻数的最大差值</h3><p>题目描述</p>
<p>给定一个整形数组arr，返回排序后相邻两数的最大差值</p>
<p>arr = [9, 3, 1, 10]。如果排序，结果为[1, 3, 9, 10]，9和3的差为最大差值，故返回6。</p>
<p>arr = [5, 5, 5, 5]。返回0。</p>
<p>[要求]</p>
<p>时间复杂度为O(n)，空间复杂度为O(n)</p>
<p>当要排序，然后时间复杂度给定O(n)，那么只能使用桶排序，思路为把n个数放在n+1个桶中，那么肯定有1个桶中没有数字，这样最大的差值一定出现在两个桶之间，那么桶中有哪些数字不重要，只需要关注桶中是否有数字，最大数字和最小数字即可，最大差值为当前非空桶的最小值减去上一个非空桶的最大值。将数字放入桶，依据为将min-max的数据，放入0-len的桶中，数据长度为为len，桶的个数为len+1。在计算时为了避免越界，采用long型，然后转换为int。可以优化的点在于，如果算出来数组的最大值和最小值相等，那么可以直接返回0，不用建立桶。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((s=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> len = Integer.valueOf(s);</span><br><span class="line">            <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">            String[] arrStr = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                arr[i] = Integer.valueOf(arrStr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(maxGap(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxGap</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计数组最大和最小值</span></span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            min = Math.min(min,arr[i]);</span><br><span class="line">            max = Math.max(max,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果max=min，那么可以直接返回0</span></span><br><span class="line">        <span class="keyword">if</span>(max == min)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//建立桶，范围是0-len</span></span><br><span class="line">        <span class="comment">//有三个属性，是否进来过数，最大值，最小值</span></span><br><span class="line">        <span class="keyword">boolean</span>[] hasNum = <span class="keyword">new</span> <span class="keyword">boolean</span>[len+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] maxs = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] mins = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> bid = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将每一个数装入桶</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len;i++)&#123;</span><br><span class="line">            <span class="comment">//计算当前数应该在哪个桶</span></span><br><span class="line">            bid = bucket(arr[i],len,min,max);</span><br><span class="line">            <span class="comment">//统计桶的最大最小值，是否进去过数</span></span><br><span class="line">            maxs[bid] = hasNum[bid]?Math.max(maxs[bid],arr[i]):arr[i];</span><br><span class="line">            mins[bid] = hasNum[bid]?Math.min(mins[bid],arr[i]):arr[i];</span><br><span class="line">            hasNum[bid] = <span class="keyword">true</span>;<span class="comment">//当前桶进去了数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始计算差值</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lastMax = maxs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hasNum[i])&#123;</span><br><span class="line">                res = Math.max(res,mins[i]-lastMax);</span><br><span class="line">                lastMax = maxs[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bucket</span><span class="params">(<span class="keyword">long</span> num,<span class="keyword">long</span> len, <span class="keyword">long</span> min, <span class="keyword">long</span> max)</span></span>&#123;</span><br><span class="line">        <span class="comment">//目的，让值为min的在0桶，让值为max的在len桶</span></span><br><span class="line">        <span class="comment">//范围变换，从min-max变化为0-len</span></span><br><span class="line">        <span class="keyword">int</span> res = (<span class="keyword">int</span>)((num-min)*len/(max-min));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列和栈"><a href="#队列和栈" class="headerlink" title="队列和栈"></a>队列和栈</h2><h3 id="用数组实现栈和队列"><a href="#用数组实现栈和队列" class="headerlink" title="用数组实现栈和队列"></a>用数组实现栈和队列</h3><p>用数组实现栈比较简单，此类需要持有一个数组和当前位置标记，有初始化构造函数，获取最上面一个数peek方法，入栈push方法，出栈pop方法，要注意的是执行者三个方法时第一步为判断index范围，pop方法返回类型要是Integer而不是int，因为换成int不能返回null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用数组实现栈，应该持有数组，当前位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The init size is less than 0"</span>);</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//peek，获取最上面的数</span></span><br><span class="line">    <span class="comment">//返回类型为Integer，不然不能返回NULL</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> arr[index-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> obj)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果超出范围，报错</span></span><br><span class="line">        <span class="keyword">if</span> (index == arr.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"The stack is full"</span>);</span><br><span class="line">        <span class="comment">//如果正常，放入数据</span></span><br><span class="line">        arr[index++] = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"The stack is empty"</span>);</span><br><span class="line">        <span class="keyword">return</span> arr[--index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用数组实现队列，需要持有一个数组，一个入队列位置end，一个出队列位置start，一个队列大小size，用size来给end和start解耦</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用数组实现队列，需要持有数组，队列末尾，队列开始，size</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> initSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initSize &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The init size is less than 0"</span>);</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[initSize];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        end = <span class="number">0</span>;</span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//peek方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> arr[start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//push方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == arr.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"The queue is full"</span>);</span><br><span class="line">        size++;</span><br><span class="line">        arr[end] = obj;</span><br><span class="line">        <span class="comment">//循环队列</span></span><br><span class="line">        end = (end + <span class="number">1</span>) % arr.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//poll方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"The queue is empty"</span>);</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[start];</span><br><span class="line">        start = (start+<span class="number">1</span>)%arr.length;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getMin-功能的栈"><a href="#getMin-功能的栈" class="headerlink" title="getMin()功能的栈"></a>getMin()功能的栈</h3><p>实现一个特殊功能的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。</p>
<p>思路：持有两个栈，一个为数据栈，一个为最小栈，数据栈正常进出，而最小栈有两种方法实现。</p>
<p>方法一：当进来的数比最小数要小，直接入栈；当比最小数大，入栈最小数出栈时。两个栈正常出栈，返回data栈的值。</p>
<p>方法二：当进来的数比最小数要小，直接入栈；当比最小数大，min不入栈 。出栈时，当data出栈数等于最小数才出栈 ，其他时候min不出栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第二种方法，入栈的时候，如果当前数比较大，则min栈不进</span></span><br><span class="line">    <span class="comment">//出栈的时候，如果当前数比min栈小，min栈不出</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; dataStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getMin()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果栈为空，返回空</span></span><br><span class="line">        <span class="keyword">if</span> (minStack.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入栈方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minStack.empty()) &#123;</span><br><span class="line">            minStack.push(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt;= getMin()) &#123;</span><br><span class="line">            minStack.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        dataStack.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出栈方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dataStack.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> num = dataStack.pop();</span><br><span class="line">        <span class="comment">//只有当前数等于getmin，min栈才出</span></span><br><span class="line">        <span class="comment">//只有等于，没有小于</span></span><br><span class="line">        <span class="keyword">if</span> (num == getMin())</span><br><span class="line">            minStack.pop();</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h3><p>用队列来实现栈的功能，要有2个队列，当push的时候，正常进入队列，当peek的时候，先弹出其他的进入辅助队列，然后获取剩下来的一个的值，再将其放入辅助队列，再交换两个的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoQueueStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用两个队列实现栈</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; help;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoQueueStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        help = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//push</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        queue.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue.size()!=<span class="number">1</span>)&#123;</span><br><span class="line">            help.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = queue.poll();</span><br><span class="line">        help.add(res);</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            help.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = queue.poll();</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换两个队列引用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; temp = queue;</span><br><span class="line">        queue = help;</span><br><span class="line">        help = queue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><p>准备两个栈，一个push栈只用于push数据进去，一个pop栈只用于pop数据出来。从push栈倒数据进pop栈有两个要求，一个是pop栈中不能有数据，另一个是倒就要全部倒完。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoStackQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackPush;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackPop;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoStackQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stackPush = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stackPop = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        stackPush.push(num);</span><br><span class="line">        goTo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关键的倒数据步骤</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goTo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (stackPop.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//要倒完</span></span><br><span class="line">            <span class="keyword">while</span> (!stackPush.isEmpty())&#123;</span><br><span class="line">                stackPop.push(stackPush.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//peek步骤</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackPush.isEmpty() &amp;&amp; stackPop.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"The stack is empty"</span>);</span><br><span class="line">        goTo();</span><br><span class="line">        <span class="keyword">return</span> stackPop.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackPush.isEmpty() &amp;&amp; stackPop.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"The stack is empty"</span>);</span><br><span class="line">        goTo();</span><br><span class="line">        <span class="keyword">return</span> stackPop.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="猫狗队列"><a href="#猫狗队列" class="headerlink" title="猫狗队列"></a>猫狗队列</h3><p>实现一种猫狗队列的结构，要求如下：</p>
<ol>
<li><p>用户可以调用 add 方法将 cat 或者 dog 放入队列中</p>
</li>
<li><p>用户可以调用 pollAll 方法将队列中的 cat 和 dog 按照进队列的先后顺序依次弹出</p>
</li>
<li><p>用户可以调用 pollDog 方法将队列中的 dog 按照进队列的先后顺序依次弹出</p>
</li>
<li><p>用户可以调用 pollCat 方法将队列中的 cat 按照进队列的先后顺序依次弹出</p>
</li>
<li><p>用户可以调用 isEmpty 方法检查队列中是否还有 dog 或 cat</p>
</li>
<li><p>用户可以调用 isDogEmpty 方法检查队列中是否还有 dog</p>
</li>
<li><p>用户可以调用 isCatEmpty 方法检查队列中是否还有 cat</p>
</li>
</ol>
<p>思路：将Pet封装上一个index数据项，这样使用一个新类将二者封装。然后持有一个狗队列，一个猫队列，持有index，初始为0，在add操作中，如果是狗，就加入狗队列，是猫就加入猫队列。从队列中弹出较早入队列的，比较猫、狗队列中较小的index，弹出即可。</p>
<p>坑点：牛客网上的题目相比于原始题目，Pet自己也需要封装上一个index项，而比较的时候，比的是封装后的宠物队列类自己定义的index，而不是pet的index。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pet</span><span class="params">(String type,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.x = index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPetType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPetIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PetEnterQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//持有Pet和index</span></span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PetEnterQueue</span><span class="params">(Pet pet, <span class="keyword">long</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pet = pet;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//API：获取当前类型，index</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">getPet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPetType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pet.getPetType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DogCatQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//猫狗队列，一个持有猫，，一个持有狗</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;PetEnterQueue&gt; dogQueue;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;PetEnterQueue&gt; catQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DogCatQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dogQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        catQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Pet pet)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果为狗，加到狗；如果为猫，加到猫</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"dog"</span>.equals(pet.getPetType()))&#123;</span><br><span class="line">            dogQueue.add(<span class="keyword">new</span> PetEnterQueue(pet,index++));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"cat"</span>.equals(pet.getPetType()))&#123;</span><br><span class="line">            catQueue.add(<span class="keyword">new</span> PetEnterQueue(pet,index++));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"error, no dog or cat"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹出猫或者狗中较小的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">pollAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果两个均不为空</span></span><br><span class="line">        <span class="keyword">if</span> (!dogQueue.isEmpty() &amp;&amp; !catQueue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (dogQueue.peek().getIndex() &lt; catQueue.peek().getIndex())&#123;</span><br><span class="line">                <span class="keyword">return</span> dogQueue.poll().getPet();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> catQueue.poll().getPet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!dogQueue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//狗不为空</span></span><br><span class="line">            <span class="keyword">return</span> dogQueue.poll().getPet();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!catQueue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//猫不为空</span></span><br><span class="line">            <span class="keyword">return</span> catQueue.poll().getPet();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"The queue is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹出狗队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">pollDog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dogQueue.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Dog queue is empty"</span>);</span><br><span class="line">        <span class="keyword">return</span> dogQueue.poll().getPet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹出猫队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">pollCat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (catQueue.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Dog queue is empty"</span>);</span><br><span class="line">        <span class="keyword">return</span> catQueue.poll().getPet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isCatEmpty()&amp;&amp;isDogEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCatEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> catQueue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDogEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dogQueue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入输出的处理比较麻烦，使用StringBuilder来添加结果，最后用substring方法将其转换为字符串，要记得添加换行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        DogCatQueue dq = <span class="keyword">new</span> DogCatQueue();</span><br><span class="line">        Pet pet = <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s = br.readLine();</span><br><span class="line">        <span class="keyword">int</span> count = Integer.valueOf(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            String[] strArr = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">switch</span> (strArr[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"add"</span>:</span><br><span class="line">                    String type=strArr[<span class="number">1</span>];</span><br><span class="line">                    dq.add(<span class="keyword">new</span> Pet(type,Integer.valueOf(strArr[<span class="number">2</span>])));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"pollAll"</span>:</span><br><span class="line">                    <span class="keyword">while</span>(!dq.isEmpty())&#123;</span><br><span class="line">                        pet = dq.pollAll();</span><br><span class="line">                        res.append(pet.getPetType()+<span class="string">" "</span>+pet.getPetIndex()+<span class="string">"\n"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"pollCat"</span>:</span><br><span class="line">                    <span class="keyword">while</span>(!dq.isCatEmpty())&#123;</span><br><span class="line">                        pet = dq.pollCat();</span><br><span class="line">                        res.append(pet.getPetType()+<span class="string">" "</span>+pet.getPetIndex()+<span class="string">"\n"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"pollDog"</span>:</span><br><span class="line">                    <span class="keyword">while</span>(!dq.isDogEmpty())&#123;</span><br><span class="line">                        pet = dq.pollDog();</span><br><span class="line">                        res.append(pet.getPetType()+<span class="string">" "</span>+pet.getPetIndex()+<span class="string">"\n"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"isDogEmpty"</span> :</span><br><span class="line">                    res.append(dq.isDogEmpty()?<span class="string">"yes\n"</span>:<span class="string">"no\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"isCatEmpty"</span>:</span><br><span class="line">                    res.append(dq.isCatEmpty()?<span class="string">"yes\n"</span>:<span class="string">"no\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"isEmpty"</span>:</span><br><span class="line">                    res.append(dq.isEmpty()?<span class="string">"yes\n"</span>:<span class="string">"no\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res.substring(<span class="number">0</span>,res.length()-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="RandomPool结构"><a href="#RandomPool结构" class="headerlink" title="RandomPool结构"></a>RandomPool结构</h3><p>题目：</p>
<p>设计一种结构，在该结构中加入如下三种功能</p>
<p>insert(key)：将某个key加入到该结构，做到不重复加入</p>
<p>delete(key)：将原本在结构中的某个key移除</p>
<p>getRandom()：等概率随机返回结构中的任何一个key</p>
<p>要求：这三种方法的时间复杂度均为O(1)</p>
<p>思路：一个不行就两个。持有两个哈希表，一个为key-index映射，一个为index-key映射，麻烦的地方在于删除后如何保证之后的随机性，解决方法为每次找到要删除的位置，然后获取其key，获取最后行的key和index，然后将最后行的数据存到要删除行，再删除最后行数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomPool</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//持有两个哈希表，一个索引</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;K,Integer&gt; keyIndexMap;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer,K&gt; indexKeyMap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        keyIndexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        indexKeyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果已经存在了，返回</span></span><br><span class="line">        <span class="keyword">if</span> (keyIndexMap.containsKey(key))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        keyIndexMap.put(key,index);</span><br><span class="line">        indexKeyMap.put(index++,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//随机返回方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getRandom</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果没有数据，返回空</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> res = (<span class="keyword">int</span>)(Math.random()*index);</span><br><span class="line">        <span class="keyword">return</span> indexKeyMap.get(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!keyIndexMap.containsKey(key))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//1、找到要删除位置的index</span></span><br><span class="line">        <span class="keyword">int</span> deleteIndex = keyIndexMap.get(key);</span><br><span class="line">        <span class="comment">//2、找到最后的index和key</span></span><br><span class="line">        <span class="keyword">int</span> lastIndex = --index;</span><br><span class="line">        K lastKey = indexKeyMap.get(lastIndex);</span><br><span class="line">        <span class="comment">//3、将待删除位置的值替换为最后行的值</span></span><br><span class="line">        keyIndexMap.put(lastKey,deleteIndex);</span><br><span class="line">        indexKeyMap.put(deleteIndex,lastKey);</span><br><span class="line">        <span class="comment">//4、删除最后行数据，将行数-1</span></span><br><span class="line">        keyIndexMap.remove(key);</span><br><span class="line">        indexKeyMap.remove(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h3><p>解决问题</p>
<p>应用在多服务器的场合，为了解决负载均衡问题，即客户端的请求能较均衡的分配到每台服务器上。经典的服务器结构是若有n台机器，将前端获取信息计算一个哈希值，然后%n，得到对应服务器并访问，但当服务器个数变化时信息需要重新计算才能再次均衡。</p>
<p>如何做</p>
<p>而一致性哈希就是为了解决这个问题，将哈希域映射到一个圆环，将服务器信息计算出哈希值映射到圆上，客户端请求信息的key同样计算哈希值映射到圆上，将信息交给顺时针找到的第一台服务器进行处理。当减少一台服务器，将要访问此机器的数据交由顺时针的下一个机器即可。当增加一台服务器，将其映射到圆上，将此机器逆时针上一台机器到此机器之间的顺序交给本机器处理即可。</p>
<p>存在问题</p>
<p>但是这样当服务器个数较少的时候，不容易在环上均匀分配，这样无法实现负载均衡。可以采用虚拟节点的方式，给每台机器分配多个虚拟节点，让虚拟节点在环上均衡分配，数据的key寻找对应的虚拟节点，再由虚拟节点寻找对应的机器。</p>
<h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><p> 1、轮训法</p>
<p>将请求按顺序轮流分配到后端服务器上，均衡对待每一台服务器，而不关心服务器本身的连接数和负载情况</p>
<p>2、随机法</p>
<p>通过系统随机计算，从后端服务器中随机选取一台来访问，当访问次数多了后，根据概率论，每台服务器上访问会均衡</p>
<p>3、源地址哈希</p>
<p>根据客户端的ip，计算哈希值，对服务器台数进行取模运算，得到的便是要访问的服务器。</p>
<p>4、加权轮训法</p>
<p>不同服务器抗压能力不同，给配置高、负载低的服务器更高的权重，处理更多的请求；而配置低、负载高的服务器更低权重，处理更少请求，降低负载</p>
<p>5、加权随机法</p>
<p>根据负载不同计算不同权重，按照权重随机请求服务器，而不是顺序的</p>
<p>6、最小连接数法</p>
<p>根据后端服务器当前连接情况，动态的选取当前积压连接数最少的服务器来处理当前请求，尽可能提高后端的利用率。</p>
<p>7、一致性哈希</p>
<p>在源地址哈希上改进，将哈希域映射为环，将计算器映射到环上，计算请求的key对应的哈希值，在顺时针找到的第一台服务器上进行请求。增加虚拟节点，来解决初始服务器数量少，负载不均衡的问题。</p>
<h3 id="常见的hash算法"><a href="#常见的hash算法" class="headerlink" title="常见的hash算法"></a>常见的hash算法</h3><p>1、直接寻址法</p>
<p>取key的某个线性函数值作为散列地址，其哈希值为a*key+b</p>
<p>2、数字分析法</p>
<p>找出数字的规律，利用数据来构造冲突几率较低的散列地址</p>
<p>3、平方取中法</p>
<p>取key平方后的中间几位作为散列地址</p>
<p>4、折叠法</p>
<p>将key分割为位数相同的几部分，最后一部分位数可以不同，取这几份去除进位的叠加和来作为散列地址</p>
<p>5、随机数法</p>
<p>选择随机函数，取key的随机值作为散列地址，通常用在key长度不同的场合</p>
<p>6、除留余数法</p>
<p>将key对不大于散列表长的数p取余，得到的数为地址。不仅可以直接取模，也可以在折叠，平方取中后取模，一般将p取素数或散列表长</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="转圈打印矩阵"><a href="#转圈打印矩阵" class="headerlink" title="转圈打印矩阵"></a>转圈打印矩阵</h3><img src="/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%BD%AC%E5%9C%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.png" class title="This is an example image">

<p>思路：打印矩阵的思路一般都是宏观调度，用有限个变量去约束要打印的范围，然后循环调用打印函数。此处用左上角和右下角的点去约束范围，调用打印函数，然后将左上角和右下角的点进行收缩。打印矩阵函数为分别判断一行，一列和多行多列的情况，如果为单行单列的，用for循环控制行和列，如果为多行多列，分四次打印。</p>
<img src="/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%BD%AC%E5%9C%88%E7%9F%A9%E9%98%B5%E7%BA%A6%E6%9D%9F.png" class title="This is an example image">

<p>说明的是，在原方法中采用的是直接sout输出，此处使用StringBuilder进行添加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PringtEdge</span> </span>&#123;</span><br><span class="line">    <span class="comment">//转圈打印矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">printCircle</span><span class="params">(<span class="keyword">int</span>[][] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、找两个边界点</span></span><br><span class="line">        <span class="keyword">int</span> row1 = <span class="number">0</span>, col1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row2 = arr.length-<span class="number">1</span>,col2 = arr[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//只要满足边界条件，循环调用打印函数</span></span><br><span class="line">        <span class="keyword">while</span> (row1 &lt;= row2 &amp;&amp; col1 &lt;= col2)&#123;</span><br><span class="line">            printEdge(arr,sb,row1++,col1++,row2--,col2--);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(<span class="keyword">int</span>[][] arr, StringBuilder sb, <span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、如果只有一行</span></span><br><span class="line">        <span class="keyword">if</span> (row1 == row2)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = col1; i &lt;= col2; i++) &#123;</span><br><span class="line">                sb.append(arr[row1][i]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(col1 == col2)&#123;</span><br><span class="line">            <span class="comment">//2、如果只有一列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = row1; i &lt;= row2; i++) &#123;</span><br><span class="line">                sb.append(arr[i][col1]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//3、分四部分打印</span></span><br><span class="line">            <span class="keyword">int</span> curR = row1;<span class="comment">//当前行</span></span><br><span class="line">            <span class="keyword">int</span> curL = col1;<span class="comment">//当前列</span></span><br><span class="line">            <span class="keyword">while</span> (curL &lt; col2)&#123;</span><br><span class="line">                sb.append(arr[curR][curL++]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curR &lt; row2)&#123;</span><br><span class="line">                sb.append(arr[curR++][curL]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curL &gt; col1)&#123;</span><br><span class="line">                sb.append(arr[curR][curL--]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curR &gt; row1)&#123;</span><br><span class="line">                sb.append(arr[curR--][curL]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="comment">//要持有的写的类</span></span><br><span class="line">        PringtEdge pe = <span class="keyword">new</span> PringtEdge();</span><br><span class="line">        String[] s = <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span> row = Integer.valueOf(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> col = Integer.valueOf(s[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            s = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                arr[i][j] = Integer.valueOf(s[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = pe.printCircle(arr);</span><br><span class="line">        System.out.println(res.substring(<span class="number">0</span>,res.length()-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="之字型打印矩阵"><a href="#之字型打印矩阵" class="headerlink" title="之字型打印矩阵"></a>之字型打印矩阵</h3><img src="/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%B9%8B%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.png" class title="This is an example image">

<p>思路：宏观调度，打印的是两个点之间的对角线的值，那么只要解决点的运动路径和打印对角线即可。要注意的是点在运动过程中时，如果变量A依靠变量B来约束其行为，要先改变变量A，再改变B，不然B先改变则A会缺少值。而对角线打印的时候有方向变化，可以用标记变量来控制。</p>
<p>这种题目依靠的是宏观调度，不要去想每个点到底怎么变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//之字型打印矩阵，找宏观规律</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">printZhi</span><span class="params">(<span class="keyword">int</span>[][] m)</span></span>&#123;</span><br><span class="line">        <span class="comment">//往右，再下</span></span><br><span class="line">        <span class="keyword">int</span> row1 = <span class="number">0</span>,col1 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//往下，再右</span></span><br><span class="line">        <span class="keyword">int</span> row2 = <span class="number">0</span>,col2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> endR = m.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> endC = m[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//先下，再上</span></span><br><span class="line">        <span class="keyword">boolean</span> fromUp = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (row1 &lt;= endR)&#123;</span><br><span class="line">            printProcess(m,res,row1,col1,row2,col2,fromUp);</span><br><span class="line">            <span class="comment">//路径变化</span></span><br><span class="line">            <span class="comment">//关键为将引发判断的值后判断</span></span><br><span class="line">            row1 = col1 == endC ? row1+<span class="number">1</span>:row1;</span><br><span class="line">            col1 = col1 == endC ? col1:col1+<span class="number">1</span>;</span><br><span class="line">            col2 = row2 == endR ? col2+<span class="number">1</span> : col2;</span><br><span class="line">            row2 = row2 == endR ? row2:row2+<span class="number">1</span>;</span><br><span class="line">            fromUp = !fromUp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printProcess</span><span class="params">(<span class="keyword">int</span>[][] m,StringBuilder res, <span class="keyword">int</span> row1,<span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2,<span class="keyword">boolean</span> fromUp)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果fromUp为false，从左下向右上打印</span></span><br><span class="line">        <span class="keyword">if</span> (!fromUp)&#123;</span><br><span class="line">            <span class="keyword">while</span> (row1 &lt;= row2)&#123;</span><br><span class="line">                res.append(m[row2--][col2++]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (row1 &lt;= row2)&#123;</span><br><span class="line">                res.append(m[row1++][col1--]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="在行列都排好序的矩阵中找数"><a href="#在行列都排好序的矩阵中找数" class="headerlink" title="在行列都排好序的矩阵中找数"></a>在行列都排好序的矩阵中找数</h3><img src="/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%9F%A9%E9%98%B5%E6%89%BE%E6%95%B0.png" class title="This is an example image">

<p>思路：从右上角或者左下角开始找，此处选右上角，要是当前数小了就往下，当前数大了就往左。</p>
<p>精髓的点在于开始寻找的位置，利用矩阵的特征，可以将部分不可能的情况给排除掉，这题从右上角或者左下角开始找都可以。但是左上和右下不行，因为没办法缩小规模。核心在于右上或左下，<strong>一边比它大，一边比它小</strong>。这样子存在<strong>要么去一边，要么另一边</strong>的0 1情况，即非黑即白。</p>
<p>实质是将没有可能的数据直接舍弃，即将问题的规模进行缩小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在已排序的矩阵中找到数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNum</span><span class="params">(<span class="keyword">int</span>[][] m,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//选择右上角的数</span></span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>,col = m[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> endR = m.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (row&lt;=endR &amp;&amp; col &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//如果当前数小，往下走</span></span><br><span class="line">        <span class="keyword">if</span> (m[row][col] == k)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(m[row][col]&gt;k)&#123;</span><br><span class="line">            <span class="comment">//当前数比较大，往左走</span></span><br><span class="line">            col--;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="打印两个链表的公共部分"><a href="#打印两个链表的公共部分" class="headerlink" title="打印两个链表的公共部分"></a>打印两个链表的公共部分</h3><p>给定两个升序链表，打印两个升序链表的公共部分。</p>
<p>思路：类似于外排，谁小动谁，如果相等，打印并两个一起动</p>
<p>值得注意的点：将head1或者2为空的情况放在最上面，直接返回；将head1.value==head2.value的情况放在三种判断的第一个，这样可以缩短判断时间；整理链表基本结构及生成链表的套路。StringBuilder添加时候，使用两次append比一次append两个str效率高。原因是使用+的时候多了生成String的步骤，这样降低了效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印两个链表公共部分</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCommonPart</span><span class="params">(Node head1,Node head2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将不可能的情况先列出</span></span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//类似外排</span></span><br><span class="line">    <span class="comment">//谁小动谁，如果相等，添加并两个一起动</span></span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//将相等的判断放在最上面</span></span><br><span class="line">        <span class="keyword">if</span> (head1.value == head2.value) &#123;</span><br><span class="line">            <span class="comment">//这样比直接append(value+" ")效率高</span></span><br><span class="line">            res.append(head1.value).append(<span class="string">" "</span>);</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(head1.value &lt; head2.value)&#123;</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(res.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合并两个有序的链表"><a href="#合并两个有序的链表" class="headerlink" title="合并两个有序的链表"></a>合并两个有序的链表</h3><p>给定两个升序的单链表的头节点 head1 和 head2，请合并两个升序链表， 合并后的链表依然升序，并返回合并后链表的头节点。</p>
<p>思路：类似于外排，如果两个均不为空，谁小动谁；如果哪个为空，把另一个不为空的接到新链表后即可。</p>
<p>小技巧：新链表自己先做一个头节点会比较方便，在动链表的时候，流程为让新链表的下一个指向小节点，新链表当前节点跳到下一个，小节点链表头节点跳到下一个。另外如果有一个链表已经为空了，则不需要一个个节点去添加，直接把整个加上去即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//合并链表</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">mergeLink</span><span class="params">(Node head1, Node head2)</span></span>&#123;</span><br><span class="line">       <span class="comment">//类似于外排</span></span><br><span class="line">       Node res = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">       Node cur = res;</span><br><span class="line">       <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span> (head1.value &lt;= head2.value)&#123;</span><br><span class="line">               cur.next = head1;</span><br><span class="line">               cur = head1;</span><br><span class="line">               head1 = head1.next;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               cur.next = head2;</span><br><span class="line">               cur = head2;</span><br><span class="line">               head2 = head2.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//将空的链表部分直接拼接到新链表后面即可</span></span><br><span class="line">       cur.next = head1 == <span class="keyword">null</span> ? head2 : head1;</span><br><span class="line">       cur = res.next;</span><br><span class="line">       res = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">return</span> cur;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断链表是否为回文结构"><a href="#判断链表是否为回文结构" class="headerlink" title="判断链表是否为回文结构"></a>判断链表是否为回文结构</h3><p>给定链表的头结点，判断是否为回文链表</p>
<p>方式一：将链表元素全部存进栈中，利用栈先进后出的特点，与链表逐个比较，额外空间复杂度O(N)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解法1：将链表中的数据用栈存起来，然后一个个取出来进行对比</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome1</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//准备一个栈</span></span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Node node = head;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取出来比较</span></span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.value != stack.pop().value)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：只放一半的元素进栈中，缩短一半的额外空间。</p>
<p>为了找到链表中点，用到的方法为快慢指针，是链表题目中比较常见的方法，慢指针一下子走一步，快指针走两步，当快指针走到末尾时，慢指针正好走到中间。注意：如果是要中点位置，慢指针从头结点开始，如果是中点位置下一个，慢指针从头节点下一个开始。此处慢指针的起始点就是头节点下一个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解法2：只需要判断链表的一半即可，问题是如何找到链表的中点</span></span><br><span class="line">    <span class="comment">//用快慢指针</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome2</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Node slow = head.next;</span><br><span class="line">        Node fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时slow来到中点位置，将剩下的节点存入栈中</span></span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(slow);</span><br><span class="line">        &#125;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (slow.value != stack.pop().value)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>方法三：进阶方式，额外空间复杂度为O(1)，不依靠栈，而是先找到链表中点，将链表右半部分进行翻转，这里有个操作是将中点节点指向null，方便后面判断。然后从链表两端进行判断，注意不能直接返回值，因为还需要将链表还原。判断结束后，将链表右半部分还原。</p>
<p>注意：反转链表，删除链表节点需要利用3个指针，一个指向当前节点，一个指向当前节点的前序节点，一个指向当前节点的后序节点。先保存其下一个进行位置的，再进行操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解法3，不利用栈，先找到链表的中点，反转剩下的链表</span></span><br><span class="line">    <span class="comment">//进行判断，然后将链表还原</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome3</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//找到链表中点</span></span><br><span class="line">        Node n1 = head;</span><br><span class="line">        Node n2 = head;</span><br><span class="line">        <span class="keyword">while</span>(n2.next != <span class="keyword">null</span> &amp;&amp; n2.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            n1 = n1.next;</span><br><span class="line">            n2 = n2.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时n1来到中点，反转链表，先要记录n1下一个位置</span></span><br><span class="line">        n2 = n1.next;</span><br><span class="line">        n1.next = <span class="keyword">null</span>;</span><br><span class="line">        Node n3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//反转链表</span></span><br><span class="line">        <span class="keyword">while</span> (n2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            n3 = n2.next;</span><br><span class="line">            n2.next = n1;</span><br><span class="line">            n1 = n2;</span><br><span class="line">            n2 = n3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时n1为链表末尾，进行记录</span></span><br><span class="line">        n3 = n1;</span><br><span class="line">        <span class="comment">//开始判断头和尾的值是否相等</span></span><br><span class="line">        n2 = head;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (n2 != <span class="keyword">null</span> &amp;&amp; n1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (n2.value != n1.value)&#123;</span><br><span class="line">                <span class="comment">//不能直接返回假，这样链表没有被调整回来</span></span><br><span class="line">                res = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n2 = n2.next;</span><br><span class="line">            n1 = n1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//还原链表</span></span><br><span class="line">        n2 = n3.next;</span><br><span class="line">        n3.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (n2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            n1 = n2.next;</span><br><span class="line">            n2.next = n3;</span><br><span class="line">            n3 = n2;</span><br><span class="line">            n2 = n1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="单向链表的基础partition"><a href="#单向链表的基础partition" class="headerlink" title="单向链表的基础partition"></a>单向链表的基础partition</h3><p>题目描述：</p>
<p>给定一个链表，再给定一个整数 pivot，请将链表调整为左部分都是值小于 pivot 的节点，中间部分都是值等于 pivot 的节点， 右边部分都是大于 pivot 的节点。</p>
<p>除此之外，对调整后的节点顺序没有更多要求。</p>
<p>思路：将链表用数组存起来，然后对数组partition，再将数组组合成链表，返回arr[0]，要注意的是将数组的最后个元素的next指向null，以及partition过程的约束条件是index&lt;more，不能取等于，不然会越界。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单链表的partition基础问题，利用数组来实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listPartition</span><span class="params">(Node head,<span class="keyword">int</span> pivot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//1、统计链表长度</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、造数组，将链表中元素填充进去</span></span><br><span class="line">        Node[] arr = <span class="keyword">new</span> Node[len];</span><br><span class="line">        node = head;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            arr[i++] = node;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、数组的partition问题</span></span><br><span class="line">        <span class="comment">//将其封装为函数</span></span><br><span class="line">        partitionArr(arr,pivot);</span><br><span class="line">        <span class="comment">//将数组组合成链表</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            arr[i-<span class="number">1</span>].next = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将最后个节点指针指向null</span></span><br><span class="line">        arr[i-<span class="number">1</span>].next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">partitionArr</span><span class="params">(Node[] arr, <span class="keyword">int</span> pivot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> less = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> more = arr.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//约束条件为i &lt; more或者i != more</span></span><br><span class="line">        <span class="comment">//如果是等于，当more为数组最后，会越界</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; more)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i].value &lt; pivot)&#123;</span><br><span class="line">                swap(arr,i++,++less);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[i].value &gt; pivot)&#123;</span><br><span class="line">                swap(arr,i,--more);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="单链表的partition进阶"><a href="#单链表的partition进阶" class="headerlink" title="单链表的partition进阶"></a>单链表的partition进阶</h3><p>要求：在原来基础之上，partition后每个部分的节点从左至右的顺序和原链表中节点的顺序一致。要时间复杂度O（N）,额外空间复杂度O（1）。</p>
<p>思路：将原链表拆分为小，等，大三个区域，遍历链表，来一个就丢到对应的位置中去（将节点从原链表中断开），最后将三个链表合并，考察的是扣边界能力。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表的复杂partition</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listPartition2</span><span class="params">(Node head,<span class="keyword">int</span> pivot)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//分三个部分，小于、等于、大于区，来个节点就丢到对应的地方去</span></span><br><span class="line">    <span class="comment">//最后将三个部分合并</span></span><br><span class="line">    Node sH = <span class="keyword">null</span>;</span><br><span class="line">    Node sT = <span class="keyword">null</span>;</span><br><span class="line">    Node eH = <span class="keyword">null</span>;</span><br><span class="line">    Node eT = <span class="keyword">null</span>;</span><br><span class="line">    Node bH = <span class="keyword">null</span>;</span><br><span class="line">    Node bT = <span class="keyword">null</span>;</span><br><span class="line">    Node next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//将当前节点丢到三个部分中</span></span><br><span class="line">        <span class="keyword">if</span> (head.value &lt; pivot)&#123;</span><br><span class="line">            <span class="comment">//如果为空</span></span><br><span class="line">            <span class="keyword">if</span> (sH == <span class="keyword">null</span>)&#123;</span><br><span class="line">                sH = head;</span><br><span class="line">                sT = head;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sT.next = head;</span><br><span class="line">                sT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(head.value == pivot)&#123;</span><br><span class="line">            <span class="keyword">if</span> (eH == <span class="keyword">null</span>)&#123;</span><br><span class="line">                eH = head;</span><br><span class="line">                eT = head;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                eT.next = head;</span><br><span class="line">                eT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (bH == <span class="keyword">null</span>)&#123;</span><br><span class="line">                bH = head;</span><br><span class="line">                bT = head;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                bT.next = head;</span><br><span class="line">                bT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将三个链表连接</span></span><br><span class="line">    <span class="keyword">if</span> (sT != <span class="keyword">null</span>)&#123;</span><br><span class="line">        sT.next = eH;</span><br><span class="line">        eT = eT == <span class="keyword">null</span> ? sT:eT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (eT != <span class="keyword">null</span>)&#123;</span><br><span class="line">        eT.next = bH;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sH != <span class="keyword">null</span> ? sH : eH != <span class="keyword">null</span> ? eH : bH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复制含有随机节点的链表"><a href="#复制含有随机节点的链表" class="headerlink" title="复制含有随机节点的链表"></a>复制含有随机节点的链表</h3><p>方法一：用哈希表，将key为原链表节点，value为新链表节点，然后再复制下一个和rand指针关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">copyListWithRand1</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建存储用的HashMap，key与value均为Node</span></span><br><span class="line">    HashMap&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;Node,Node&gt;();</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="comment">//对每个结点进行拷贝</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        map.put(cur, <span class="keyword">new</span> Node(cur.value));</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//将复制节点的next与random指向cur相同部分</span></span><br><span class="line">        <span class="comment">//get(x)为得到x节点的拷贝结点x'</span></span><br><span class="line">        map.get(cur).next = map.get(cur.next);<span class="comment">//1' 指向 2(1.next)的对应节点2'</span></span><br><span class="line">        map.get(cur).random = map.get(cur.random);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：不使用其他数据结构，在原来链表中每个节点后面复制一个新节点，然后复制rand指针关系，再将两个链表拆分开来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">copyListWithRand2</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// copy node and link to every node</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        next = cur.next;</span><br><span class="line">        cur.next = <span class="keyword">new</span> Node(cur.value);</span><br><span class="line">        cur.next.next = next;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head;</span><br><span class="line">    Node curCopy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// set copy node rand</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        next = cur.next.next;</span><br><span class="line">        curCopy = cur.next;</span><br><span class="line">        curCopy.random = cur.random != <span class="keyword">null</span> ? cur.random.next : <span class="keyword">null</span>;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node res = head.next;<span class="comment">//记录下复制链表的头结点</span></span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="comment">// split</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        next = cur.next.next;</span><br><span class="line">        curCopy = cur.next;</span><br><span class="line">        cur.next = next;</span><br><span class="line">        curCopy.next = next != <span class="keyword">null</span> ? next.next : <span class="keyword">null</span>;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>非递归实现</p>
<p>反转单链表和双链表，基本思路是持有三个节点，当前节点的前序节点，当前节点，下一个节点。</p>
<p>对于单链表，如果当前节点不为空，保存其下一个节点next，当前节点指向前序节点pre，pre=当前节点，当前节点=next，这样便实现了反转；对于双向链表，只是多了一步让当前节点的前序节点=next，其他和单向链表一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反转单向链表</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseListSL</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">       <span class="comment">//准备三个节点</span></span><br><span class="line">       Node pre = <span class="keyword">null</span>;</span><br><span class="line">       Node cur = head;</span><br><span class="line">       Node next = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">           next = cur.next;</span><br><span class="line">           cur.next = pre;</span><br><span class="line">           pre = cur;</span><br><span class="line">           cur = next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pre;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//反转双向链表</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseListDL</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">       <span class="comment">//准备三个节点</span></span><br><span class="line">       Node pre = <span class="keyword">null</span>;</span><br><span class="line">       Node cur = head;</span><br><span class="line">       Node next = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">           next = cur.next;</span><br><span class="line">           cur.next = pre;</span><br><span class="line">           cur.pre = next;</span><br><span class="line">           pre = cur;</span><br><span class="line">           cur = next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pre;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>递归实现</p>
<p>看其是否可以分解成具有相同解决思路的子问题。反转链表1-&gt;2-&gt;3-&gt;4，如果把1以后的链表都反转好了，让2指向1,1指向空即可。对于1后面的子链表，也可以这样去处理。因此可以使用递归去解决</p>
<ol>
<li><p>定义递归函数，明确函数功能及返回值</p>
<p>此递归函数实现的功能是反转某个节点开始的链表，返回的是反转后的新的结点</p>
</li>
<li><p>寻找递归公式</p>
<ul>
<li>先反转当前节点以后的链表，这样1-&gt;2-&gt;3-&gt;4变为1-&gt;2&lt;-3&lt;-4</li>
<li>将当前node(1)的下一个节点(node.next)的指向(node.next.next)改为当前节点(node)，node的后继结点变为空</li>
<li>返回新的头结点</li>
</ul>
</li>
<li><p>将递推公式带入定义好的递归函数中</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反转链表的递归实现</span></span><br><span class="line"><span class="comment">//递归函数要实现的功能是反转链表，返回的是反转后的链表头节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseList2</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (node.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    <span class="comment">//对当前节点做操作</span></span><br><span class="line">    <span class="comment">//把后面的链表进行反转</span></span><br><span class="line">    Node newHead = reverseList2(node.next);</span><br><span class="line">    <span class="comment">//把后面的反转好后，让当前node的下一个节点的下一个指向当前节点</span></span><br><span class="line">    <span class="comment">//让当前节点的下一个指向空</span></span><br><span class="line">    node.next.next = node;</span><br><span class="line">    node.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//返回新的头节点</span></span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反转部分单向链表"><a href="#反转部分单向链表" class="headerlink" title="反转部分单向链表"></a>反转部分单向链表</h3><p>给定一个单链表，在链表中把第 L 个节点到第 R 个节点这一部分进行反转。</p>
<p>思路：找到from-1,from,to,to+1处的四个链表，如果from或者to为空，直接返回，反转from-to之间的链表，然后让from-1指向to，from指向to+1。如果from-1为空，那么to变为新链表的头结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反转from-to之间的链表</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reversePartList</span><span class="params">(Node head, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       <span class="comment">//找到from-1,fro,to,to+1处的链表节点</span></span><br><span class="line">       Node fromPre = <span class="keyword">null</span>;</span><br><span class="line">       Node from = <span class="keyword">null</span>;</span><br><span class="line">       Node to = <span class="keyword">null</span>;</span><br><span class="line">       Node toPos = <span class="keyword">null</span>;</span><br><span class="line">       Node cur = head;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//如果from和to的距离超过了链表长度，就不进行操作</span></span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">           count++;</span><br><span class="line">           <span class="keyword">if</span> (count == fromIndex - <span class="number">1</span>)&#123;</span><br><span class="line">               fromPre = cur;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> (count == fromIndex)&#123;</span><br><span class="line">               from = cur;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> (count == toIndex)&#123;</span><br><span class="line">               to = cur;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> (count == toIndex + <span class="number">1</span>)&#123;</span><br><span class="line">               toPos = cur;</span><br><span class="line">           &#125;</span><br><span class="line">           cur = cur.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (from == <span class="keyword">null</span> || to == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       <span class="comment">//反转from-to之间的结点</span></span><br><span class="line">       Node pre = <span class="keyword">null</span>;</span><br><span class="line">       cur = from;</span><br><span class="line">       Node next = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (cur != toPos)&#123;</span><br><span class="line">           next = cur.next;</span><br><span class="line">           cur.next = pre;</span><br><span class="line">           pre = cur;</span><br><span class="line">           cur = next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果from为头结点，新的头结点为to</span></span><br><span class="line">       <span class="keyword">if</span> (fromPre == <span class="keyword">null</span>)&#123;</span><br><span class="line">           head = to;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           fromPre.next = to;</span><br><span class="line">       &#125;</span><br><span class="line">       from.next = toPos;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="两链表相交问题（五星级）"><a href="#两链表相交问题（五星级）" class="headerlink" title="两链表相交问题（五星级）"></a>两链表相交问题（五星级）</h3><p>在本题中，单链表可能有环，也可能无环。给定两个链表的头节点，实现函数，如果两链表相交，返回相交的第一个节点；如果不相交，返回null即可。</p>
<p>要求：如果链表1的长度为N，链表2的长度为M，时间复杂度达到O（N+M），额外空间复杂度达到O（1）。</p>
<p>思路：遇到复杂问题进行拆解，首先需要判断两个链表是否有环，如果两个都没有环，那就是两个无环链表的相交问题；如果两个都有环，那就是两个有环链表的相交问题；如果一个有环，一个无环，是没有这种结构的。因此将问题差结成了三个，首先需要求解链表的入环节点。</p>
<p>判断链表是否有环有两种方法，一种是利用哈希表，如果当前节点在哈希表中，返回当前节点，否则加入哈希表，并遍历到下一个节点，此方法额外空间复杂度不为O(1)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getFirstLoopNode</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(head))&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方法是利用快慢指针，如果快指针没有遇到慢指针，快指针走2步，慢指针走1步，如果快指针后面为空，返回空。当快慢指针相遇，让快指针从链表头开始，和慢指针一起每次走一步，二者相遇的地方即为链表的入环节点。</p>
<img src="/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%93%BE%E8%A1%A8%E5%85%A5%E7%8E%AF.png" class title="This is an example image">

<p>假设起始点到入环处的长度为<code>a</code>，环的长度为<code>L</code>，当快指针与慢指针相遇时，设慢指针所走的路程为<code>b</code>，当慢指针入环时，快指针已经在环上了，设快指针距离入环点距离为c，这时候当慢指针继续走c步时，快指针就会赶上慢指针了，c&lt;=L，此时慢指针还没有走一圈。</p>
<p>当快慢指针相遇时 ，两个指针走的距离为</p>
<p>p慢=a+b=n</p>
<p>p快=a+b+k*L=2n（快指针比慢指针多走k圈）</p>
<p>因此有<code>n=a+b=k*L</code>。此时若让快指针从头节点重新走a步，<code>a=k*L-b</code>，对于慢指针，因为其已经走了b步，此时再走a步，正好在环上走了k圈（a+b=k*L）,因此两个指针会在入环点相遇。</p>
<p>判断条件是快慢指针没有相遇，而一旦快指针后面为null，返回即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLoopNode</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node slow = head.next;</span><br><span class="line">    Node fast = head.next.next;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样便可以判断出链表是否有环。对于两个都没有环的链表，如果他们相交，则最后个节点一定相等，让更长的链表先将多的部分走完，两个链表再一起走，便会在第一个相交的地方相遇。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两条链表没有环的情况</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">noLoop</span><span class="params">(Node head1, Node head2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node cur1 = head1;</span><br><span class="line">    Node cur2 = head2;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找到最后个节点并求两条链表长度差</span></span><br><span class="line">    <span class="keyword">while</span> (cur1.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        n++;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cur2.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        n--;</span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后节点不相同，一定不相交</span></span><br><span class="line">    <span class="keyword">if</span>(cur1 != cur2)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//将cur1指向更长的链表</span></span><br><span class="line">    cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">    cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">    n = Math.abs(n);<span class="comment">//得到较长链表需要多走的步数</span></span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>)&#123;</span><br><span class="line">        n--;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//共同走到相同的节点</span></span><br><span class="line">    <span class="keyword">while</span> (cur1 != cur2)&#123;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于两个都有环的链表，有如下的三种结构。</p>
<img src="/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.png" class title="This is an example image">

<p>其中如果两个链表的入环节点为同一个，则是第二种结构，可以简化为无环链表的相交问题；如果入环节点不为同一个，则让一个节点从环上走一圈，如果没有碰到另一个链表的入环节点，则说明是第一种，否则返回其中一个链表的入环节点即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两个链表都有环的情况</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">bothLoop</span><span class="params">(Node head1, Node loop1, Node head2, Node loop2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//有3种情况</span></span><br><span class="line">    Node cur1 = <span class="keyword">null</span>;</span><br><span class="line">    Node cur2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//演变为无环链表的相交问题</span></span><br><span class="line">    <span class="keyword">if</span>(loop1 == loop2)&#123;</span><br><span class="line">        cur1 = head1;</span><br><span class="line">        cur2 = head2;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != loop1)&#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur2 != loop2)&#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">        cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">        n = Math.abs(n);</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != cur2)&#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//遍历loop1到自己，看是否遇到loop2</span></span><br><span class="line">        cur1 = loop1.next;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != loop1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1 == loop2)&#123;</span><br><span class="line">                <span class="keyword">return</span> loop1;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下的主方法就比较简单，求两个链表的入环节点，然后对无环链表相交，有环链表相交和一个有环一个无环进行判断即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getIntersectNode</span><span class="params">(Node head1, Node head2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node loop1 = getLoopNode(head1);</span><br><span class="line">    Node loop2 = getLoopNode(head2);</span><br><span class="line">    <span class="keyword">if</span>(loop1 == <span class="keyword">null</span> &amp;&amp; loop2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> noLoop(head1, head2);</span><br><span class="line">    <span class="keyword">if</span>(loop1 != <span class="keyword">null</span> &amp;&amp; loop2 != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> bothLoop(head1,loop1,head2,loop2);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆本质是一个二叉树 ，在Java中实现为优先级队列（PriorityQueue），默认为小根堆，即最小的在最上面。可以通过在新建堆时传入比较器对象来定义大根堆或者小根堆。其中如果比较器只用到一次，没有必要去专门定义一个类，可以用匿名内部类，实现compare()方法即可，更简单的是用lambda表达式，更简洁。</p>
<p>堆的结构很好用，在取中位数，第k大or第k小的数，前k大or前k小，贪心中经常用到。</p>
<h3 id="随时找到数据流的中位数"><a href="#随时找到数据流的中位数" class="headerlink" title="随时找到数据流的中位数"></a>随时找到数据流的中位数</h3><p>题目描述：有一个源源不断的吐出整数的数据流，假设你有足够的空间来保存吐出的数。请设计一个名叫MedianHolder的结构，MedianHolder可以随时取得之前吐出所有数的中位数。</p>
<p>[要求]</p>
<ol>
<li><p>如果MedianHolder已经保存了吐出的N个数，那么将一个新数加入到MedianHolder的过程，其时间复杂度是O(logN)。</p>
</li>
<li><p>取得已经吐出的N个数整体的中位数的过程，时间复杂度为O(1)</p>
</li>
</ol>
<p>思路：持有两个堆，一个大根堆，一个小根堆，大根堆中存放较小的一半数，小根堆中存放较大的一半数，这样中位数就被大根堆和小根堆夹着。如果两个堆大小相等，则取平均；不然就返回较多的那个堆的堆顶元素。</p>
<p>其中比较关键的是将数加入堆的操作，如果大根堆为空或者当前数比大根堆顶的数小，则直接放入大根堆中，否则放入小根堆。然后进行堆的调整：哪个堆中的数据比另一个堆中数据多了2个，则拿一个到另一个堆中。这样将放数和调整堆进行了<strong>解耦</strong>，可以让代码变得更简洁。</p>
<p>其中牛客网要求格式化输出数据，可以用DecimalFormat类，进行一位小数的输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedianHolder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//随时找到数据流的中位数，需要持有两个堆</span></span><br><span class="line">    <span class="comment">//大根堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//小根堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 取出所有整数部分和一位小数，格式化输出</span></span><br><span class="line">    DecimalFormat df = <span class="keyword">new</span> DecimalFormat(<span class="string">"#.0"</span>);</span><br><span class="line">    <span class="comment">//构造方法，初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianHolder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((o1,o2)-&gt;o2-o1);</span><br><span class="line">        minHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((o1,o2)-&gt;o1-o2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将数添加进堆中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果大根堆为空或者数比大根堆顶的数小，添加到大根堆</span></span><br><span class="line">        <span class="keyword">if</span> (maxHeap.isEmpty() || num &lt;= maxHeap.peek())&#123;</span><br><span class="line">            maxHeap.add(num);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minHeap.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//堆的调整</span></span><br><span class="line">        modifyTwoHeap();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//调整堆</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">modifyTwoHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果大根堆比小根堆多两个，放一个进小根堆</span></span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() == minHeap.size() + <span class="number">2</span>)&#123;</span><br><span class="line">            minHeap.add(maxHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minHeap.size() == maxHeap.size() + <span class="number">2</span>)&#123;</span><br><span class="line">            maxHeap.add(minHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找中位数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMedian</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果两个为空，返回空</span></span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果两个堆中数相等，取两个堆顶平均</span></span><br><span class="line">        <span class="keyword">if</span> (minHeap.size() == maxHeap.size())&#123;</span><br><span class="line">            System.out.println(df.format((maxHeap.peek()+minHeap.peek())/<span class="number">2.0</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//哪个多返回哪个的</span></span><br><span class="line">            System.out.println(df.format(maxHeap.size() &gt; minHeap.size() ? maxHeap.peek() : minHeap.peek()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s = br.readLine();</span><br><span class="line">        <span class="keyword">int</span> count = Integer.valueOf(s);</span><br><span class="line">        <span class="comment">//要持有的写的类</span></span><br><span class="line">        MedianHolder m = <span class="keyword">new</span> MedianHolder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="comment">//读一行数据</span></span><br><span class="line">            String[] str = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"2"</span>.equals(str[<span class="number">0</span>]))&#123;</span><br><span class="line">                m.getMedian();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                m.addNum(Integer.valueOf(str[<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="切金条"><a href="#切金条" class="headerlink" title="切金条"></a>切金条</h3><p>题目描述：给定一个正数数组arr，arr的累加和代表金条的总长度，arr的每个数代表金条要分成的长度。规定长度为k的金条分成两块，费用为k个铜板。返回把金条分出arr中的每个数字需要的最小代价。</p>
<p>要求：时间复杂度为O(n log n)，空间复杂度为O(n)</p>
<p>题目说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果先分成40和20两块，将花费60个铜板，再把长度为40的金条分成10和30两块，将花费40个铜板，总花费为100个铜板；</span><br><span class="line">如果先分成10和50两块，将花费60个铜板，再把长度为50的金条分成20和30两块，将花费50个铜板，总花费为110个铜板；</span><br><span class="line">如果先分成30和30两块，将花费60个铜板，再把其中一根长度为30的金条分成10和20两块，将花费30个铜板，总花费为90个铜板；</span><br><span class="line">因此最低花费为90</span><br></pre></td></tr></table></figure>

<p>思路：哈夫曼编码问题，即每次选出权重最小的数，新节点权重为二者相加，将新节点加入，再拿出两个，直到之后只有一个数，其值就是总的权重。</p>
<p>哈夫曼编码的应用：给出传递的电文，计算每个字母的权重，选出较小的两个节点构造成一个二叉树（小的在左，大的在右），新二叉树的权重为二者权重之和，然后将新二叉树放入，再重新拿出两个权重最小的。树构造好后，进行编码，左边为0，右边为1，只有叶子节点在存储了信息，这样从头节点找到叶子节点，便可以找到每个字母对应的编码。当给定了编码后，要如何去找到对应的字母呢？可以从字符串中取出字符，然后在树中进行寻找，如果找到了叶子节点，就得到了一个字母，再继续找下去。</p>
<h3 id="做项目"><a href="#做项目" class="headerlink" title="做项目"></a>做项目</h3><p>题目描述：</p>
<p>输入：</p>
<p>参数1：正数数组costs</p>
<p>参数2：正数数组profits</p>
<p>参数3：正数k</p>
<p>参数4：正数m</p>
<p>参数说明：cost[i]表示i号项目的花费，profits[i]表示i号项目在扣除花费后还能挣到的钱（利润），k表示你不能并行、只能串行的最多做k个项目，m表示你初始的资金。</p>
<p>说明：你每做完一个项目，马上获得的收益，可以支持你去做下一个项目</p>
<p>输出：你最后获得的最大钱数。</p>
<p>分析：标准的贪心问题，选择项目的标准是：在花费比资金小的项目中，选择利润最多的，积累利润后，再选择花费比当前资金小的项目，直到做了k个项目。</p>
<p>思路：持有两个堆，一个小根堆，一个大根堆，小根堆依照项目花费排序，大根堆中依靠项目利润排序，从小根堆中弹出花费比当前资金少的项目进大根堆，然后从大根堆中弹出一个项目来做，累积资金，直到做了k个项目。</p>
<p>坑点：返回的收益需要是<strong>long</strong>类型，<strong>避免溢出</strong>！！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将项目的花费和利润封装为一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">proNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> p;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proNode</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">        <span class="keyword">this</span>.p = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindMaximizedCapital</span> </span>&#123;</span><br><span class="line">    <span class="comment">//持有两个堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;proNode&gt; minHeap;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;proNode&gt; maxHeap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FindMaximizedCapital</span><span class="params">()</span></span>&#123;</span><br><span class="line">        minHeap = <span class="keyword">new</span> PriorityQueue&lt;proNode&gt;((o1,o2)-&gt;o1.c-o2.c);</span><br><span class="line">        maxHeap = <span class="keyword">new</span> PriorityQueue&lt;proNode&gt;((o1,o2)-&gt;o2.p-o1.p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算项目最大利润</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">findMaximizedCapital</span><span class="params">(<span class="keyword">int</span>[] costs,<span class="keyword">int</span>[] profits,<span class="keyword">int</span> k,<span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将花费和利润封装放进小根堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; costs.length; i++) &#123;</span><br><span class="line">            minHeap.add(<span class="keyword">new</span> proNode(costs[i],profits[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行k次循环做项目</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="comment">//知道小根堆不为空且堆顶项目花费比m少，弹进大根堆</span></span><br><span class="line">            <span class="keyword">while</span> (!minHeap.isEmpty() &amp;&amp; minHeap.peek().c &lt;= m)&#123;</span><br><span class="line">                maxHeap.add(minHeap.poll());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//需要考虑到大根堆为空的情况，即虽然没有到k次，但没有项目可做</span></span><br><span class="line">            <span class="keyword">if</span> (maxHeap.isEmpty())</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            <span class="comment">//选出一个项目来做</span></span><br><span class="line">            m += maxHeap.poll().p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String[] str = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span> n = Integer.valueOf(str[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> w = Integer.valueOf(str[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> k = Integer.valueOf(str[<span class="number">2</span>]);</span><br><span class="line">        String[] strC = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        String[] strP = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span>[] costs = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] profits = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            costs[i] = Integer.parseInt(strC[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            profits[i] = Integer.parseInt(strP[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        FindMaximizedCapital fm = <span class="keyword">new</span> FindMaximizedCapital();</span><br><span class="line">        <span class="keyword">long</span> win = fm.findMaximizedCapital(costs,profits,k,w);</span><br><span class="line">        System.out.println(win);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>给定一个字符串类型的数组strs，找到一种拼接方式，使得把所有字符串拼起来之后形成的字符串具有最低的字典序。</p>
<p>​    字典序：每个字母相当于26进制的数，如果位数相同则比较字面值，长度不能的时候，把短的补到跟长的一样，补的内容相当于ASCII表中最小的内容，然后从最高位开始比较。</p>
<p>比较两个字符串，若str1+str2&lt;= str2 + str1，则str1放前面，否则str2放前面。不要去证明贪心问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比较器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//负数认为o1小，谁作为前缀小谁放前面</span></span><br><span class="line">        <span class="keyword">return</span> (o1 + o2).compareTo(o2 + o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用比较器来排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">lowestString</span><span class="params">(String[] strs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    Arrays.sort(strs,<span class="keyword">new</span> MyComparator());</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (String s : strs)&#123;</span><br><span class="line">        sb.append(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树的深度遍历"><a href="#树的深度遍历" class="headerlink" title="树的深度遍历"></a>树的深度遍历</h3><h4 id="递归遍历方法"><a href="#递归遍历方法" class="headerlink" title="递归遍历方法"></a>递归遍历方法</h4><p>先序遍历：先中、再左、再右。对每一个结点，先打印当前结点，再打印其左子树所有结点，再打印右子树所有结点。</p>
<p>中序遍历：先左、再中、再右。对每一个结点，先打印其左子树所有结点，再打印当前结点，再打印右子树所有结点。</p>
<p>后序遍历：先左、再右、再中。对每一个结点，先打印其左子树所有结点，再打印右子树所有结点，再打印当前结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序打印二叉树的递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//先打印当前节点</span></span><br><span class="line">    System.out.print(head.value+<span class="string">" "</span>);</span><br><span class="line">    <span class="comment">//递归打印左子树</span></span><br><span class="line">    preOrderRecur(head.left);</span><br><span class="line">    <span class="comment">//递归打印右子树</span></span><br><span class="line">    preOrderRecur(head.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序打印二叉树的递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//先打印左子树，再打印中间，再打印右子树</span></span><br><span class="line">    inOrderRecur(head.left);</span><br><span class="line">    System.out.print(head.value +<span class="string">" "</span>);</span><br><span class="line">    inOrderRecur(head.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序打印二叉树的递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">posOrderRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//先打印左子树，再打印右子树，再打印当前节点</span></span><br><span class="line">    posOrderRecur(head.left);</span><br><span class="line">    posOrderRecur(head.right);</span><br><span class="line">    System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="非递归遍历方法"><a href="#非递归遍历方法" class="headerlink" title="非递归遍历方法"></a>非递归遍历方法</h4><p>先序遍历用栈结构实现，顺序为先中，再左，再右。将头结点放入栈，如果栈不为空，弹出当前节点，弹出就打印。如果右不为空，把右边的放入栈中。如果左不为空，把左边的放入栈中。为了让先弹左，再弹右，因此放入栈的时候要先右再左。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderUnRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"pre-order: "</span>);</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//准备一个栈</span></span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        <span class="comment">//将头结点压入</span></span><br><span class="line">        stack.add(head);</span><br><span class="line">        <span class="comment">//只要栈不为空</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//弹出并打印头结点</span></span><br><span class="line">            head = stack.pop();</span><br><span class="line">            System.out.print(head.value+<span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//如果右节点不为空，压入</span></span><br><span class="line">            <span class="keyword">if</span>(head.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果左节点不为空，压入</span></span><br><span class="line">            <span class="keyword">if</span>(head.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中序遍历用栈结构实现，顺序为先左，再中，再右。栈中先放所有的左边界，head从头往左移动，直到空，这样所有的左边界都到栈中了。当往左移动不下去了，从栈中弹出一个并打印，并向右移动。</p>
<p>​    因为从中一直往左压栈，因此弹出的时候一定是从左到中，往右跑是因为要把右子树也按照这种方法压入栈。那么整个顺序是先左再中再右。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderUnRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"in-order: "</span>);</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//只要栈不为空或者head不为空就循环</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果head不为空，一直将左节点压入栈</span></span><br><span class="line">            <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head);</span><br><span class="line">                head = head.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果head为空，弹出并打印栈中元素，</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                head = stack.pop();</span><br><span class="line">                System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">                head = head.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后续遍历是先左再右再中。中左右，是先弹出中，然后压入右，压入左。那么中右左就是先弹出中，然后压入左，压入右。然后该打印的时候不打印，放入一个help，再弹出来，就是先左再右再中了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后序遍历非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">posOrderUnRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"pos order: "</span>);</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Node&gt; help = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//先把头节点压入</span></span><br><span class="line">        stack.push(head);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            head = stack.pop();</span><br><span class="line">            <span class="comment">//该输出的时候弹入辅助栈</span></span><br><span class="line">            help.push(head);</span><br><span class="line">            <span class="comment">//先压左后压右</span></span><br><span class="line">            <span class="keyword">if</span>(head.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将辅助栈中数据弹出</span></span><br><span class="line">        <span class="keyword">while</span> (!help.isEmpty())&#123;</span><br><span class="line">            System.out.print(help.pop().value+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="折纸问题"><a href="#折纸问题" class="headerlink" title="折纸问题"></a>折纸问题</h4><img src="/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8A%98%E7%BA%B8.png" class title="This is an example image">

<p>这个问题实质是二叉树的中序遍历问题，头结点为下，左孩子为下，右孩子为下，用递归方式解决，递归函数参数列表有当前树高度，为左还是右（左为下，右为上）</p>
<img src="/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8A%98%E7%BA%B8%E6%A0%91.png" class title="This is an example image">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直观打印折纸</span></span><br><span class="line"><span class="comment">//本质上是树的中序遍历，左结点为下，右结点为上，头节点为下</span></span><br><span class="line"><span class="comment">//用递归实现，功能是中序打印二叉树，需要传入当前树的高度，左还是右</span></span><br><span class="line"><span class="comment">//因为只有两种可能，所以可以用布尔类型的变量来表示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAllFolds</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    printProcess(<span class="number">1</span>,N,<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printProcess</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n, <span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; n)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//left,cur,right</span></span><br><span class="line">    printProcess(i+<span class="number">1</span>,n,<span class="keyword">true</span>);</span><br><span class="line">    System.out.println(b ? <span class="string">"下"</span> : <span class="string">"上"</span>);</span><br><span class="line">    printProcess(i+<span class="number">1</span>,n,<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在二叉树中找到一个节点的后继节点"><a href="#在二叉树中找到一个节点的后继节点" class="headerlink" title="在二叉树中找到一个节点的后继节点"></a>在二叉树中找到一个节点的后继节点</h3><p>现在树结点多了一个parent结点，指向父节点，头节点的parent指向null。只给一个在二叉树中某个节点node，实现返回node的后继节点的函数。在二叉树的后序遍历的序列中，node的下一个节点叫做node的后继节点。</p>
<p>中序遍历为左、中、右，考虑当前节点为中的情况，因此如果有右子树，后继节点应该是右子树的最左结点。当前节点如果为左，其为父节点的左孩子，则父节点就是后继节点。如果当前节点为右，表明其所在的左子树已被遍历完，需要找到某个节点，其为父节点的左孩子，返回此父节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getNextNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//node有右子树，找到右子树最左节点</span></span><br><span class="line">    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> getLeftMost(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有右子树</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node parent = node.parent;<span class="comment">//拿到父节点</span></span><br><span class="line">        <span class="comment">//只要此节点不为父节点的左子树</span></span><br><span class="line">        <span class="comment">//跳到node是parent左节点停，返回parent</span></span><br><span class="line">        <span class="comment">//加上Parent不为空是为了兼顾没有后继的情况</span></span><br><span class="line">        <span class="comment">//其中parent不为空要放在前面，不然就算空了，因为parent左孩子不为node，循环仍继续</span></span><br><span class="line">        <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; parent.left != node)&#123;</span><br><span class="line">            <span class="comment">//当前节点不是父节点的左孩子则继续</span></span><br><span class="line">            node = parent;</span><br><span class="line">            parent = node.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找最左节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLeftMost</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树的序列化"><a href="#树的序列化" class="headerlink" title="树的序列化"></a>树的序列化</h3><h4 id="树的先序方式序列化与反序列化"><a href="#树的先序方式序列化与反序列化" class="headerlink" title="树的先序方式序列化与反序列化"></a>树的先序方式序列化与反序列化</h4><p>中、左、右。将遍历的结果用字符串进行记录。当一个节点的左子树为空时，可以用一个特殊符号来记录，如#。</p>
<p>序列化思路：利用递归来进行中序遍历，如果是空节点，则添加#！，如果不为空，添加value!，然后遍历左子树与右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">serialByPre</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中、左、右的递归</span></span><br><span class="line">    String res = head.value + <span class="string">"!"</span>;</span><br><span class="line">    res += serialByPre(head.left);</span><br><span class="line">    res += serialByPre(head.right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反序列化思路：将字符串用！进行分割，然后将数组中的字符一个个构造成节点，可以将其加入到队列中，也可以用index+数组来取，这样当为#，返回空，构造一个新节点，递归构造其左子树与右子树，然后返回头节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序方式反序列化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reconByPreString</span><span class="params">(String preStr)</span></span>&#123;</span><br><span class="line">    <span class="comment">//分割字符串</span></span><br><span class="line">    String[] values = preStr.split(<span class="string">"!"</span>);</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//将所有元素加入到队列，用数组也可以，需要传递下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != values.length; i++) &#123;</span><br><span class="line">        queue.offer(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reconPreOrder(queue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给一个队列建立树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reconPreOrder</span><span class="params">(Queue&lt;String&gt; queue)</span></span>&#123;</span><br><span class="line">    String value = queue.poll();</span><br><span class="line">    <span class="comment">//空节点</span></span><br><span class="line">    <span class="keyword">if</span> (value.equals(<span class="string">"#"</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//建立新节点等于head</span></span><br><span class="line">    Node head = <span class="keyword">new</span> Node(Integer.valueOf(value));</span><br><span class="line">    <span class="comment">//左、右子树分别交给递归去实现</span></span><br><span class="line">    head.left = reconPreOrder(queue);</span><br><span class="line">    head.right = reconPreOrder(queue);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="树的层序方式序列化与反序列化"><a href="#树的层序方式序列化与反序列化" class="headerlink" title="树的层序方式序列化与反序列化"></a>树的层序方式序列化与反序列化</h4><p>层序方式也是广度优先遍历。</p>
<p>序列化思路：将头节点加入队列，并将其添加进StringBuilder，从队列中弹出一个节点，将其左右子树的值加入，没有就加入#，而不选择在弹出的时候添加是因为空节点无法加入队列。如果左子树不为空，加入队列；如果右子树不为空，加入队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按层序列化</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">serialByLevel</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       queue.offer(head);</span><br><span class="line">       sb.append(head.value).append(<span class="string">"!"</span>);</span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">           head = queue.poll();</span><br><span class="line">           <span class="comment">//在节点进去的时候就添加，不然添加不了空节点</span></span><br><span class="line">           <span class="keyword">if</span> (head.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">               queue.offer(head.left);</span><br><span class="line">               sb.append(head.left.value).append(<span class="string">"!"</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               sb.append(<span class="string">"#!"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (head.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">               queue.offer(head.right);</span><br><span class="line">               sb.append(head.right.value).append(<span class="string">"!"</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               sb.append(<span class="string">"#!"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sb.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>按层方式反序列化 思路：将字符串分割，建造头节点并放入队列中，记录头节点。从队列中弹出一个节点，建造其左子树与右子树，如果左子树不为空，加入队列；如果右子树不为空，加入队列。此处用index+数组来控制当前要利用的字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按层方式反序列化</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reconByLevelString</span><span class="params">(String levelStr)</span></span>&#123;</span><br><span class="line">       <span class="comment">//将字符串分割</span></span><br><span class="line">       String[] str = levelStr.split(<span class="string">"!"</span>);</span><br><span class="line">       <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//产生头节点，并放进队列中</span></span><br><span class="line">       Node res = generateNode(str[value++]);</span><br><span class="line">       Node head = res;</span><br><span class="line">       Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       queue.offer(head);</span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">           head = queue.poll();</span><br><span class="line">           head.left = generateNode(str[value++]);</span><br><span class="line">           head.right = generateNode(str[value++]);</span><br><span class="line">           <span class="keyword">if</span> (head.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">               queue.offer(head.left);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (head.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">               queue.offer(head.right);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断树的类型"><a href="#判断树的类型" class="headerlink" title="判断树的类型"></a>判断树的类型</h3><h4 id="判断树是否为平衡二叉树"><a href="#判断树是否为平衡二叉树" class="headerlink" title="判断树是否为平衡二叉树"></a>判断树是否为平衡二叉树</h4><p>平衡二叉树中，在任何一个节点，左子树与右子树高度差，不超过1。</p>
<p>思路：以每一个节点为头节点的树为平衡二叉树，总体才是，对当前节点，需要其左子树为平衡二叉树，右子树为平衡二叉树，两个子树高度差不超过1，才是平衡二叉树。可以用树的后序遍历递归方式解决，当前函数需要给下一级函数传递当前子树是否平衡，树的高度，如果树不平衡，则高度没有用。可以将是否平衡与树的高度信息进行封装。关键是看函数功能是什么，需要传递什么参数。</p>
<p>平衡性用来解决效率问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isB</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> process(head).isB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ReturnData <span class="title">process</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="comment">//空树是高度为0的平衡树</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">    ReturnData leftData = process(head.left);</span><br><span class="line">    <span class="comment">//左子树不平衡，则直接不平衡</span></span><br><span class="line">    <span class="comment">//在不满足时高度为0是因为高度用不上</span></span><br><span class="line">    <span class="keyword">if</span> (!leftData.isB) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ReturnData rightData = process(head.right);</span><br><span class="line">    <span class="keyword">if</span> (!rightData.isB)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左、右树均平衡</span></span><br><span class="line">    <span class="keyword">if</span> (Math.abs(leftData.h - rightData.h) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在满足的时候，子结构要给父过程提供高度，为二者中较高的+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">true</span>,Math.max(leftData.h, rightData.h)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断一棵二叉树是否是搜索二叉树"><a href="#判断一棵二叉树是否是搜索二叉树" class="headerlink" title="判断一棵二叉树是否是搜索二叉树"></a>判断一棵二叉树是否是搜索二叉树</h4><p>如果为搜索二叉树，则其中序遍历的输出一定是升序的，那么中序遍历树，如果当前节点的值小于上一个节点的值，则不为搜索二叉树，因此需要记录上一个节点的值 ，第一个节点的上一个节点为Integer的最小值，当遍历到节点比上一个节点小，返回假，否则更新上一个节点值为当前节点值，遍历下一个节点。当将树遍历完后，返回真。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否是搜索二叉树，用中序遍历非递归改</span></span><br><span class="line"><span class="comment">//只要在返回的时候，判断是否比前一个数大即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">int</span> pre = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() || head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(head);</span><br><span class="line">            head = head.left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//弹出一个元素</span></span><br><span class="line">            head = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (head.value &lt; pre)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = head.value;</span><br><span class="line">            head = head.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断一棵二叉树是否为完全二叉树"><a href="#判断一棵二叉树是否为完全二叉树" class="headerlink" title="判断一棵二叉树是否为完全二叉树"></a>判断一棵二叉树是否为完全二叉树</h4><p>思路：利用层级优先遍历，一个节点的左右子树有四种不同状态，如果左有且右有，则继续判断；如果左有，右没有，则后面不能出现叶子节点；如果左没有，右有，肯定不是；如果左没有，右没有，后面不能出现叶子节点。</p>
<p>因此有两种是绝对不可能的</p>
<ul>
<li>左没有，右有</li>
<li>之前有右边没有的，后来有非空节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCBT</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//双端链表，实现队列</span></span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//表示是否开启了情况2</span></span><br><span class="line">    <span class="keyword">boolean</span> leaf = <span class="keyword">false</span>;</span><br><span class="line">    Node l = <span class="keyword">null</span>;</span><br><span class="line">    Node r = <span class="keyword">null</span>;</span><br><span class="line">    queue.offer(head);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        head = queue.poll();</span><br><span class="line">        l = head.left;</span><br><span class="line">        r = head.right;</span><br><span class="line">        <span class="comment">//有右没左或子节点不全且之后有非叶节点</span></span><br><span class="line">        <span class="keyword">if</span> ((leaf &amp;&amp; (l !=<span class="keyword">null</span> || r != <span class="keyword">null</span>)) || (l == <span class="keyword">null</span> &amp;&amp; r !=<span class="keyword">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="keyword">null</span>)</span><br><span class="line">            queue.offer(l);</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(r);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//右为空，开启状态2</span></span><br><span class="line">            leaf = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="剑指Offer"><a href="#剑指Offer" class="headerlink" title="剑指Offer"></a>剑指Offer</h1><h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><h3 id="数组中重复数字"><a href="#数组中重复数字" class="headerlink" title="数组中重复数字"></a>数组中重复数字</h3><h4 id="允许修改数组"><a href="#允许修改数组" class="headerlink" title="允许修改数组"></a>允许修改数组</h4><p>长度为n的数组里所有数字均出现在o~n-1的范围内，数组内某些数字是重复的，但不知道几个重复了，也不知道数字重复了几次。找出数组中任意一个重复的数字。如 ，长度为7的数组{2,3,1,0,2,5,3}，对应的输出为重复数字为2或者3。</p>
<p>方法1：使用哈希表，如果一个元素添加进哈希表了，就返回此元素，如果没有加入过，就加入。</p>
<p>时间复杂度O(n)，额外空间复杂度O(n)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用哈希表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">findNumHash</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(arr[i]))</span><br><span class="line">            <span class="keyword">return</span> arr[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            set.add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下解决的是找到第一个重复元素的问题，但是要额外建立一个哈希表。</p>
<p>方法2：抽屉原理</p>
<p>如果有n个数分布为0-n-1，在没有重复的时候，必然是一个萝卜一个坑，即可以将值为<code>i</code>的元素（i=0~n-1）放在第<code>i</code>个坑中，但是因为有重复的元素存在，会出现在第<code>i</code>个坑中值不为i的情况，这时候可以将它放在它原本应在的地方，直到当前坑中放了对应的萝卜，如果此时第<code>i</code>个坑中元素为<code>k</code>，但第<code>k</code>个坑中元素也为<code>k</code>，说明当前元素就是重复的。</p>
<p>总的时间复杂度为O(n)，额外空间复杂度O(1)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到第一个重复的数字，抽屉原理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">findNum</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果数组的长度不在0-arr.length-1之间，返回</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; <span class="number">0</span> || arr[i] &gt; arr.length-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从第一个到最后一个</span></span><br><span class="line">        <span class="comment">//如果当前数和角标不等，交换，直到相等或和要交换角标处的值相等</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[i] != i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] == arr[arr[i]])&#123;</span><br><span class="line">                    <span class="keyword">return</span> arr[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//swap(arr,i,arr[i])</span></span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[arr[i]];</span><br><span class="line">                <span class="comment">//不能直接使用arr[arr[i]]，因为此时arr[i]已经变化了</span></span><br><span class="line">                arr[temp] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="不修改数组找到重复数字"><a href="#不修改数组找到重复数字" class="headerlink" title="不修改数组找到重复数字"></a>不修改数组找到重复数字</h4><p>在长度为n+1的数组里的所有数字都在1~n的范围之内，因此数组中至少有一个数字是重复的。找出任意一个重复的数字，但不能修改输入的数组，如输入长度为8的数组{2,3,5,4,3,2,6,7}，输出为重复的数字2或者3。额外空间复杂度为O(1)。</p>
<p>不能使用哈希表，不能使用抽屉原理，这时候可以考虑二分。因为如果<code>1~n</code>的数字没有重复，那么<code>1~(n-1)/2</code>和<code>(n-1)/2+1~n</code>中元素个数应该和其角标left-right之间的范围相同，但是因为有重复的，那么假设重复数字为3，那么<code>1~7</code>分为<code>1~4</code>和<code>5~7</code>，这时候<code>1~4</code>中的元素个数肯定会多于4，然后再到<code>1~4</code>中进行寻找，直到找到left=right，如果这时候left值的数字出现个数&gt;1，则输出left。</p>
<p>用到的为二分的模板</p>
<p>核心为</p>
<ol>
<li>left与right的取值很重要，需要夹住所有可能的情况</li>
<li>while循环中用left &lt; right，这样退出循环的时候一定有left==right，不用思考返回left还是right</li>
<li>mid选择左中位数（left + ((right - left) &gt;&gt; 1)）或者右中位数（left + ((right - left+1) &gt;&gt; 1)）</li>
<li>只用两个判断，一次排除一半的结果</li>
<li>可以选择是否在循环结束后对夹住的数进行判断</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> left = 数<span class="number">1</span>, right = 数<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(判断条件<span class="number">1</span>)&#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//或者</span></span><br><span class="line">    <span class="keyword">if</span>(判断条件<span class="number">1</span>)&#123;</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        left = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在while结束后，对left处的值选择性进行判断</span></span><br><span class="line"><span class="comment">//多种输出可能</span></span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line"><span class="keyword">return</span> arr[left];</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>此题具体的实现代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用二分的思路</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">findNum2</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//看是否在0-n-1范围之内</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; <span class="number">0</span> || arr[i] &gt; arr.length-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二分，看哪边的数字更多，再继续找</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right-left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//计算个数</span></span><br><span class="line">            <span class="keyword">int</span> count = getFre(arr,left,mid);</span><br><span class="line">            <span class="keyword">if</span> (count &gt; mid + <span class="number">1</span> - left)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//去另一半</span></span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = getFre(arr,left,right);</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        <span class="comment">//没有找到</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计在l-m之间出现的次数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getFre</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt;= l &amp;&amp; arr[i] &lt;= m)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="矩阵中的路径【回溯】"><a href="#矩阵中的路径【回溯】" class="headerlink" title="矩阵中的路径【回溯】"></a>矩阵中的路径【回溯】</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。</p>
<p>思路：回溯的经典案例。如果当前字符可以，则看其上下左右的是否符合，不进入已经去过的位置，如果匹配长度为字符串的长度，返回真，不然的话就返回假，并重置当前所做的操作。</p>
<p>关键在于要维护一个与矩阵大小相同的布尔型矩阵，表示当前字符是否已经遍历过，如果遍历过了则不进入，如果当前字符与要遍历的第i个字符相等，则将布尔型的矩阵相对应位置置为true，再看其上下左右的，如果失败了，则让当前位置的标志重置为false。</p>
<p>容易错的点为，base case判断不完全，应该有</p>
<ol>
<li>当前遍历到的(i,j)在矩阵范围内</li>
<li>当前位置的字符与第k个字符相等</li>
<li>当前位置没有进来过</li>
</ol>
<p>同时需要注意的是一维到二维的映射关系，应该是第i行*列数+当前列j。</p>
<p>最后成功的base case条件为已经将所有的字符都判断完毕了，需要传递给下一级递归函数一个int变量。</p>
<p>递归函数实现的功能为，判断当前字符周围的字符是否可以找到所给的字符串。需要传递的参数有基本的矩阵的参数等，以及下一次寻找的起始位置(i,j)，下一次遍历的字符串位置len。为了不让重复的字符遍历到，当遍历一个字符后，需要将其标志变量置为true，这样下一次不会再遍历。同时回溯为了消除下一次的影响，需要将标志位重置。</p>
<p>回溯的小总结</p>
<ol>
<li>利用递归来处理子问题</li>
<li>base case（递归终止条件，包括失败与成功条件）</li>
<li>改变当前位置状态，进行子问题的递归</li>
<li>子问题递归失败，重置当前状态</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果数据不相符，直接返回假</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || str == <span class="keyword">null</span> || matrix.length != rows * cols || str.length &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//新建一个判断矩阵</span></span><br><span class="line">        <span class="keyword">boolean</span>[] isIn = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows * cols];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; isIn.length; i++) &#123;</span><br><span class="line">            isIn[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用来检测现在判断字符串长度的变量</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//对每一个数都进行判断</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="comment">//如果当前字符开头的数组可以，则返回真</span></span><br><span class="line">                <span class="keyword">if</span> (process(matrix, rows, cols, str, isIn, i, j, len))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str, <span class="keyword">boolean</span>[] isIn, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一维映射到二维，很重要</span></span><br><span class="line">        <span class="keyword">int</span> index = i * cols + j;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="comment">//如果当前数据不再矩阵范围内，直接返回假</span></span><br><span class="line">        <span class="comment">//如果已经进入了当前位置，返回假</span></span><br><span class="line">        <span class="comment">//当前位置的数和str第len个字符不等</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols || matrix[index] != str[len] || isIn[index])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//如果已经将数字找完了，返回真</span></span><br><span class="line">        <span class="keyword">if</span> (len == str.length - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//当前数字进入过了</span></span><br><span class="line">        isIn[index] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//看当前数字的上下左右是否符合</span></span><br><span class="line">        <span class="keyword">if</span> (process(matrix,rows,cols,str,isIn,i-<span class="number">1</span>,j,len+<span class="number">1</span>)</span><br><span class="line">        || process(matrix,rows,cols,str,isIn,i+<span class="number">1</span>,j,len+<span class="number">1</span>)</span><br><span class="line">        || process(matrix,rows,cols,str,isIn,i,j-<span class="number">1</span>,len+<span class="number">1</span>)</span><br><span class="line">        || process(matrix,rows,cols,str,isIn,i,j+<span class="number">1</span>,len+<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//还原当前状态</span></span><br><span class="line">        isIn[index] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="机器人的行走路径"><a href="#机器人的行走路径" class="headerlink" title="机器人的行走路径"></a>机器人的行走路径</h3><p>描述：地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<p>思路：回溯法，从当前格子开始走，需要维护一个是否走过的矩阵。在递归中，如果超出范围，已经走过了，当前位置不适合，返回0，然后计算四个方向能走的个数+当前走的1步，进行返回。注意的是：因为之前的矩阵中的路径，当前位置走的路径是对其他位置开始的路径没有影响的，因此需要回溯消除当前影响，而这里因为走的位置不能重复，因此之前走的对其他步是有影响的，不能消除影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//基础判断</span></span><br><span class="line">        <span class="keyword">if</span>(rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span> || threshold &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//准备是否进入的矩阵</span></span><br><span class="line">        <span class="keyword">boolean</span>[]  f = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows * cols];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f.length; i++) &#123;</span><br><span class="line">            f[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = getCount(threshold,rows,cols,<span class="number">0</span>,<span class="number">0</span>,f);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span>[] f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = i * cols + j;</span><br><span class="line">        <span class="comment">//如果超出范围，已经进来过，得到的数不符合，返回0</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols || f[index] || getAllNum(i) + getAllNum(j) &gt; threshold)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前数字进来过了</span></span><br><span class="line">        f[index] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//总的计数+1，返回其他四个方向的</span></span><br><span class="line">        <span class="comment">//因为这个路径走过的，其他也不能走，因此不用重置f的状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + getCount(threshold,rows,cols,i - <span class="number">1</span>,j,f)</span><br><span class="line">                + getCount(threshold,rows,cols,i + <span class="number">1</span>,j,f)</span><br><span class="line">                + getCount(threshold,rows,cols,i,j - <span class="number">1</span>,f)</span><br><span class="line">                + getCount(threshold,rows,cols,i,j + <span class="number">1</span>,f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getAllNum</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//得到所有位数之和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            sum += i % <span class="number">10</span>;</span><br><span class="line">            i = i / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>总结：对于矩阵上路径的遍历或者人物的行走，非常适合用回溯算法。</p>
<h3 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h3><p>题目1：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<p>思路：典型的partition过程。但没法保证相对位置不变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//奇数放前面，偶数放后面，典型的partition问题</span></span><br><span class="line"><span class="comment">//但是这样不能保证相对位置不变</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> less = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> more = arr.length;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; more)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((arr[cur] &amp; <span class="number">1</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">            swap(arr,++less,cur++);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            swap(arr,--more,cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目2：</p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p>思路：找到第一个为偶数的数字，在其之后找到第一个为奇数的数字，让中间数字整体后移，空出来的原来偶数的位置放奇数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//保证数组元素是相对有序的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray2</span><span class="params">(<span class="keyword">int</span> [] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//遍历数组，找到一个为偶数的，再找到后面为奇数的，将偶数-奇数段整体后移，空出来的放奇数</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; arr.length)&#123;</span><br><span class="line">            <span class="comment">//为奇数，则继续找</span></span><br><span class="line">            <span class="keyword">while</span> (!isEven(arr[i]))&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从i+1开始找，为偶数继续找</span></span><br><span class="line">            j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; arr.length &amp;&amp; isEven(arr[j]))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果j还在范围内，交换i+1-j-1之间的数</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; arr.length)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j-<span class="number">1</span>; k &gt;= i; k--) &#123;</span><br><span class="line">                    arr[k+<span class="number">1</span>] = arr[k];</span><br><span class="line">                &#125;</span><br><span class="line">                arr[i] = temp;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//超出了就结束</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="众数"><a href="#众数" class="headerlink" title="众数"></a>众数</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<p>方法一：排序，然后取中位数，然后次数是否大于长度一半。</p>
<p>方法二：mergeSort，找到左边数组中位数，再找右边数组的中位数，比较两个是否相同，如果不同分别计算在数组中出现的次数，返回次数多的。如果不一定有众数，需要额外判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">moreThanHalfNum1</span><span class="params">(<span class="keyword">int</span> [] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//方法一，mergesort</span></span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> process(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">            <span class="keyword">return</span> arr[l];</span><br><span class="line">        <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> left = process(arr,l,mid);</span><br><span class="line">        <span class="keyword">int</span> right = process(arr,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">if</span> (left == right)</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        <span class="comment">//左边不一样，计算左，右两边数字的个数</span></span><br><span class="line">        <span class="keyword">int</span> leftNum = getNumFre(arr,l,mid,left);</span><br><span class="line">        <span class="keyword">int</span> rightNum = getNumFre(arr,mid+<span class="number">1</span>,r,right);</span><br><span class="line">        <span class="keyword">return</span> leftNum &gt; rightNum ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNumFre</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> mid,<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= mid; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == num)</span><br><span class="line">                res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>方法三：投票法。众数出现的次数比其他数多，那么用每个数来抵消。如果当前计数为0，则众数为当前数。如果当前数与众数相同，计数器+1，不然-1。最后判断众数出现次数是否超过一半。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//投票计数法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">moreThanHalfNum2</span><span class="params">(<span class="keyword">int</span> [] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//如果之前的数和现在相同，+1，如果计数为0，重新计数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>,  pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">                pre = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            count += arr[i] == pre ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == pre)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &gt; arr.length / <span class="number">2</span> ? pre : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h3><p>输入一个整型数组，数组里有正数也有负数。数组中一个或连续的多个整/数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。如6,-3,-2,7,-15,1,2,2，最大和的连续子数组为6,-3,-2,7，为8。</p>
<p>方法1：赌徒思想：如果之前拿到的数组和小于等于0，那么选择不要，因为加上只会让当前的和更小，让数组和为当前数；否则数组和加上当前数，判断当前和是否为最大。思路跟求众数的投票法比较类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到连续子数组的最大和</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span>, res = Integer.MIN_VALUE;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           <span class="comment">//如果之间的和小于等于0了，抛弃不要，为当前的；不然加上当前的</span></span><br><span class="line">           <span class="keyword">if</span> (sum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">               sum = arr[i];</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               sum += arr[i];</span><br><span class="line">           &#125;</span><br><span class="line">           res = Math.max(res, sum);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>方法2：dp，求其递归公式，对于dp(n)，如果n &lt;1或者dp(n-1)&lt;=0，dp(n)=arr[n]；如果 dp(n-1)&gt;0，dp(n)=dp(n-1)+arr[n]。第一种更优雅点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dp写法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">       dp[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">int</span> res = dp[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (dp[i-<span class="number">1</span>] &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">               dp[i] = arr[i];</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               dp[i] = dp[i-<span class="number">1</span>] + arr[i];</span><br><span class="line">           &#125;</span><br><span class="line">           res = Math.max(res,dp[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h3><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p><strong>示例 :</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102</span><br></pre></td></tr></table></figure>

<p>就是字符串的拼接问题，定义下比较器即可，可以使用堆，语法简单但是时间复杂度高。更好的是使用List的排序，然后自定义比较器即可。核心在于比较器的定义，算贪心。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">printMinNumber1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">       PriorityQueue&lt;String&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1,o2)-&gt;(o1+o2).compareTo(o2+o1));</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">           heap.add(String.valueOf(i));</span><br><span class="line">       &#125;</span><br><span class="line">       StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="keyword">while</span> (!heap.isEmpty())&#123;</span><br><span class="line">           sb.append(heap.poll());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sb.toString();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">printMinNumber2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">       ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">           list.add(i);</span><br><span class="line">       &#125;</span><br><span class="line">       Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">               String s1 = String.valueOf(o1);</span><br><span class="line">               String s2 = String.valueOf(o2);</span><br><span class="line">               <span class="keyword">return</span> (s1+s2).compareTo(s2+s1);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">           sb.append(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sb.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="把数字翻译成字符串"><a href="#把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a>把数字翻译成字符串</h3><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p>示例 :</p>
<p>输入: 12258<br>输出: 5<br>解释: 12258有5种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi”</p>
<p>思路：对于第一个字符的位置，即12258中的1，总共的个数为2258的个数跟258的个数。即f(n) = f(n+1)+gxf(n+2)，其中函数g可以取0或者1，取决于当前位置的数字与下一个数字组成的数字是否在10-25之间，要大于10是因为，如果像09这种，只能是0跟9，而小于25是因为最大英文字母只能到25。这样变成一个递归问题，但是如果直接这样递归算，有重复的子情况，选择动态规划，即从最后往前面算，对于最后一个数字，只能有1种情况，而对于倒数第二个数字，如果其与最后个数字合起来组成的数字符合规范，则个数是最后个数字+1，不然个数与最后个相同。而其他位置的使用递归公式计算，最后输出dp数组第一个位置的元素值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//看一串数字最多可以被翻译成多少种字符串</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTranslationCount</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">       String s = String.valueOf(number);</span><br><span class="line">       <span class="keyword">if</span> (s.length() &lt; <span class="number">2</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">       <span class="keyword">int</span> len = dp.length - <span class="number">1</span>;</span><br><span class="line">       dp[len] = <span class="number">1</span>;</span><br><span class="line">       dp[len - <span class="number">1</span>] = getCount(s,len-<span class="number">1</span>) ? dp[len] + <span class="number">1</span> : dp[len];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">           <span class="keyword">if</span> (getCount(s,i))&#123;</span><br><span class="line">               dp[i] = dp[i+<span class="number">1</span>] + dp[i+<span class="number">2</span>];</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               dp[i] = dp[i+<span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getCount</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">       <span class="comment">//判断i,i+1组成的字符串是否在10-25之间</span></span><br><span class="line">       String str = s.substring(i,i+<span class="number">2</span>);</span><br><span class="line">       <span class="keyword">int</span> temp = Integer.valueOf(str);</span><br><span class="line">       <span class="keyword">if</span> (temp &gt;= <span class="number">10</span> &amp;&amp; temp &lt;= <span class="number">25</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a>礼物的最大价值</h3><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<p>示例 :</p>
<p>输入:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出: 12<br>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</p>
<p>思路：dp，对于第一行元素与第一列元素，值为当前数加上左边或者上面的数。核心在于递归公式</p>
<blockquote>
<p>dp(i)(j)=grid(i)(j)+max(dp(i-1)(j),dp(i)(j-1))</p>
</blockquote>
<p>然后用递归公式计算即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//礼物拿取，明显的dp</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length &lt; <span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">       <span class="keyword">int</span> row = grid.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> col = grid[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">       dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">       <span class="comment">//第一行赋值</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= col; i++) &#123;</span><br><span class="line">           dp[<span class="number">0</span>][i] = grid[<span class="number">0</span>][i] + dp[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//第一列赋值</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= row; i++) &#123;</span><br><span class="line">           dp[i][<span class="number">0</span>] = grid[i][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//其他位置赋值</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= row; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= col; j++) &#123;</span><br><span class="line">               dp[i][j] = grid[i][j] + Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[row][col];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>而优化的写法是只用一维的dp矩阵，先更新第一行的，然后从左到右更新第二行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dp的优化写法</span></span><br><span class="line">   <span class="comment">//只用一维矩阵来存数据</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue2</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length &lt; <span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[grid[<span class="number">0</span>].length];</span><br><span class="line">       <span class="keyword">int</span> row = grid.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> col = grid[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">       dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">       <span class="comment">//更新第一行</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= col; i++) &#123;</span><br><span class="line">           dp[i] = grid[<span class="number">0</span>][i] + dp[i - <span class="number">1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//从第二行开始更新到最后一行</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= row; i++) &#123;</span><br><span class="line">           <span class="comment">//更新第一列</span></span><br><span class="line">           dp[<span class="number">0</span>] = dp[<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= col; j++) &#123;</span><br><span class="line">               dp[j] = grid[i][j] + Math.max(dp[j-<span class="number">1</span>],dp[j]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[col];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h3><p>题目1：判断一个数是不是丑数</p>
<p>编写一个程序判断给定的数是否为丑数。</p>
<p>丑数就是只包含质因数 <code>2, 3, 5</code> 的<strong>正整数</strong>。1也是丑数。</p>
<p>思路：一个数，如果与2的余数为0，就让他一直除以2；对3,5也一样，如果最后是1，说明是丑数，因为只有2,3,5这几个因数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(num % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        num = num / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(num % <span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        num = num / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(num % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        num = num / <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目2：求出第n个丑数</p>
<p>输入: n = 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</p>
<p>思路：有第一个丑数1，其他丑数是1x2，1x3,1x5中较小的那个。这样得到第二个丑数2，然后看当前哪个丑数有乘2,3,5的资格，发现是2x2与1x3,1x5比较，第三个丑数是3，有资格乘2,3,5的丑数分别是2,2,1，以此类推，直到求出第n个丑数。需要注意的是，需要更新所有可以有资格得到当前丑数的指针，不然会出现重复的丑数情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求第n个丑数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">       arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> p2 = <span class="number">0</span>, p3 = <span class="number">0</span>, p5 = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">           <span class="comment">//计算下一个丑数</span></span><br><span class="line">           arr[i] = Math.min(Math.min(arr[p2] * <span class="number">2</span>, arr[p3] * <span class="number">3</span>), arr[p5] * <span class="number">5</span>);</span><br><span class="line">           <span class="comment">//更新对应的资格指针</span></span><br><span class="line">           <span class="comment">//不使用else if是因为可能要同时更新多个资格指针</span></span><br><span class="line">           <span class="keyword">if</span> (arr[i] == arr[p2] * <span class="number">2</span>) &#123;</span><br><span class="line">               p2++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (arr[i] == arr[p3] * <span class="number">3</span>) &#123;</span><br><span class="line">               p3++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (arr[i] == arr[p5] * <span class="number">5</span>) &#123;</span><br><span class="line">               p5++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> arr[n - <span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>题目3：超级丑数</p>
<p>编写一段程序来查找第 n 个超级丑数。</p>
<p>超级丑数是指其所有质因数都是长度为 k 的质数列表 primes 中的正整数。</p>
<p>示例:</p>
<p>输入: n = 12, primes = [2,7,13,19]<br>输出: 32<br>解释: 给定长度为 4 的质数列表 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] </p>
<p>思路：与第n个丑数相同，其实<strong>上一题就是超级丑数的特殊情况</strong>，用n个资格指针指向当前的丑数位置，然后进行判断即可。然后需要更新资格指针的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//超级丑数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthSuperUglyNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] primes)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//一个数组存对应因子的资格指针</span></span><br><span class="line">       <span class="keyword">int</span>[] hasArr = <span class="keyword">new</span> <span class="keyword">int</span>[primes.length];<span class="comment">//默认为0，指向第一个数</span></span><br><span class="line">       <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//保存结果的数组</span></span><br><span class="line">       res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> minNum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">           <span class="comment">//求指针所对应位置乘当前指针代表的因此最小值</span></span><br><span class="line">           minNum = Integer.MAX_VALUE;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; primes.length; j++) &#123;</span><br><span class="line">               minNum = Math.min(minNum,res[hasArr[j]]*primes[j]);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//更新所有指针与当前丑数</span></span><br><span class="line">           res[i] = minNum;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; primes.length; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (minNum == res[hasArr[j]]*primes[j])&#123;</span><br><span class="line">                   hasArr[j]++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res[n-<span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>留坑：<a href="https://leetcode-cn.com/problems/ugly-number-iii/solution/er-fen-fa-si-lu-pou-xi-by-alfeim/" target="_blank" rel="noopener">力扣上的丑数3</a></p>
<h3 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<p>输入: [7,5,6,4]<br>输出: 5</p>
<p>思路：mergesort的过程，分而治之，在merge外排的时候，如果左边的数大于右边，则左边剩下的数都比右边的当前数大，那么逆序对的个数加上左边剩下数的个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组中的逆序对</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">inversePairs1</span><span class="params">(<span class="keyword">int</span> [] arr)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//mergeSort</span></span><br><span class="line">       <span class="keyword">return</span> process(arr,<span class="number">0</span>,arr.length - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (l == r)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">return</span> process(arr,l,mid) + process(arr,mid+<span class="number">1</span>,r)+merge(arr,l,mid,r);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//外排</span></span><br><span class="line">       <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> p1 = l, p2 = mid + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= r)&#123;</span><br><span class="line">           <span class="comment">//谁小动谁</span></span><br><span class="line">           <span class="keyword">if</span> (arr[p1] &lt;= arr[p2])&#123;</span><br><span class="line">               help[index++] = arr[p1++];</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           	<span class="comment">//关键</span></span><br><span class="line">               <span class="comment">//左边的都比右边当前的大</span></span><br><span class="line">               count += mid - p1 + <span class="number">1</span>;</span><br><span class="line">               help[index++] = arr[p2++];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (p1 &lt;= mid)&#123;</span><br><span class="line">           help[index++] = arr[p1++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (p2 &lt;= r)&#123;</span><br><span class="line">           help[index++] = arr[p2++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//copy array</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">           arr[l+i] = help[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a>数组中数字出现的次数</h3><p>题目1：一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<p>输入：nums = [4,1,4,6]<br>输出：[1,6] 或 [6,1]</p>
<p>思路：基础版是只有一个数出现一次，其他都是2次，那么将所有的数相异或，那么最后得到的数就是他本身。一个数异或自己为0，一个数异或0为自己。现在有2个数只出现一次，那么所有的数异或后肯定不为0，那么不为0的这个数肯定有1，则有1的那一位是因为一个数那位是0，另一个数那位是1，那么找到那个为1的位，将此位是1的分成1组，为0的分成1组，那么两个不同的数肯定在不同的组，将这两组数分别异或，得到的就是只出现一次的那两个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找出数组中只出现了1次的两个数字</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">       <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">       <span class="comment">//记录全^后的数子，找到是哪一位为1</span></span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">           res ^= num;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//找到res哪一位为1</span></span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> ((res &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; index &lt; <span class="number">32</span>)&#123;</span><br><span class="line">           res = res &gt;&gt; <span class="number">1</span>;<span class="comment">//右移一位</span></span><br><span class="line">           ++index;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//遍历数组，如果指定位是1，放到一组，指定位是0，放到另一组</span></span><br><span class="line">       <span class="keyword">int</span> count1 = <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">           <span class="keyword">if</span> (((num &gt;&gt;index) &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">               count1 ^= num;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               count2 ^= num;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;count1,count2&#125;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>题目2：在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<p>输入：nums = [3,4,3,3]<br>输出：4</p>
<p>思路：如果一个数出现3次，那么他的每一位出现的次数都是3的倍数。那么统计所有数字所有位是1的次数，用32的数组来存，如果某一位是3的倍数，说明当前位只出现一次的数是0，不然就是1.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个数出现1次，其他都出现了3次</span></span><br><span class="line">   <span class="comment">//统计所有数的每一位二进制个数，如果当前位可以整除3，说明那个数当前位是0，否则是1</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span>[] bitsMap = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];<span class="comment">//存每一位的个数</span></span><br><span class="line">       <span class="keyword">int</span> bit = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">           bit = <span class="number">1</span>;</span><br><span class="line">           <span class="comment">//统计当前数每一位</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">               <span class="keyword">if</span> ((num &amp; bit) != <span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="comment">//当前位+1</span></span><br><span class="line">                   bitsMap[i]++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//看下一位</span></span><br><span class="line">               bit = bit &lt;&lt; <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//看每一位</span></span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">           <span class="comment">//将之前结果左移</span></span><br><span class="line">           res = res &lt;&lt; <span class="number">1</span>;</span><br><span class="line">           res += bitsMap[i] % <span class="number">3</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1、2、3、4、5是某栈的压栈序列，序列4、5、3、2、1是该压栈序列对应的一个弹出序列，但4、3、5、1、2就不可能是该压栈序列的弹出序列。</p>
<p>思路：准备一个栈，两个指针，i指向数组1，j指向数组2，循环条件为i没有越界或栈不为空（i越界后 ，有可能j还可以往后继续判断），如果栈为空且栈顶元素与j位置不同，若i越界了，返回假，不然将i位置元素压入栈，i后移。如果栈顶元素与j位置相同，弹出栈顶元素，j后移。循环结束后，如果i与j都越界，说明是符合的，不然就返回假。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//base</span></span><br><span class="line">        <span class="keyword">if</span> (pushA == <span class="keyword">null</span> || popA == <span class="keyword">null</span> || pushA.length != popA.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//准备栈</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; pushA.length || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//如果栈为空或栈顶元素不为popA[j]，将pushA[i]压入栈</span></span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty() || stack.peek() != popA[j])&#123;</span><br><span class="line">                <span class="keyword">if</span> (i == pushA.length)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                stack.push(pushA[i++]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == pushA.length &amp;&amp; j == i)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><p>请实现一个函数，把字符串中的每个空格替换成“%20”，如输入“We are happy”，则输出“We%are%happy”</p>
<p>方法：先统计传入的字符串str中空格的个数，然后建造一个新的字符数组，其长度为str非空格字符长度+空格个数*待替换字符串长度，然后用两个指针，一个遍历str，一个指向新的字符数组末尾，如果str当前不为空格，直接复制到新数组，新数组指针移动；如果str当前为空格，新数组从后逐个拷贝传入的字符串，直到遍历完str。</p>
<p>其中要注意的是新数组长度，需要先将原数组长度减去空格，再加上空格长度乘待替换字符串长度。如果不减去空格长度，新数组前面会有空余。如果没有空格，直接返回输入字符串即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不用系统的split方法，先统计插入后的字符个数，再从最后一个开始插入</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceBlank2</span><span class="params">(String str, String s)</span></span>&#123;</span><br><span class="line">       <span class="comment">//统计str空格数量及s长度</span></span><br><span class="line">       <span class="keyword">int</span> spCount = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> sSize = s.length();</span><br><span class="line">       <span class="comment">//统计str中空格个数</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="string">' '</span>==str.charAt(i))&#123;</span><br><span class="line">               spCount++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (spCount == <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> str;</span><br><span class="line">       <span class="comment">//非空格字符数+替换后的字符数</span></span><br><span class="line">       <span class="keyword">int</span> newSize = str.length() - spCount + spCount * sSize;</span><br><span class="line">       <span class="keyword">char</span>[] res = <span class="keyword">new</span> <span class="keyword">char</span>[newSize];</span><br><span class="line">       <span class="comment">//两个指针，一个指向strArr，一个指向res</span></span><br><span class="line">       <span class="keyword">int</span> p1 = str.length() - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> p2 = res.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (; p1 &gt;= <span class="number">0</span>; p1--) &#123;</span><br><span class="line">           <span class="keyword">char</span> c = str.charAt(p1);</span><br><span class="line">           <span class="keyword">if</span> (<span class="string">' '</span> != c)&#123;</span><br><span class="line">               <span class="comment">//当前不为空格，直接复制</span></span><br><span class="line">               res[p2--] = c;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//如果为空格，p2拷贝s</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = sSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                   res[p2--] = s.charAt(i);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> String(res);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="打印1到最大的n位数"><a href="#打印1到最大的n位数" class="headerlink" title="打印1到最大的n位数"></a>打印1到最大的n位数</h3><p>输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。</p>
<p>思路：此题看上去很简单，其实真正的考点是大数问题，如超出了int和long类型长度的数字，这时候可以用字符串来手动模拟自增的过程，那么可以将这个问题进行拆解，一是字符串自增，二是打印字符串。</p>
<p>对于字符串自增，开辟长度为n的char数组，初始全部填充0，从最后位遍历到第一位。当前位的值是数组值-‘0’+进位，然后如果是最后一位自增+1模拟每次自增，然后判断当前位是否为10，如果当前位是第一位，说明到头了，可以返回真，如果不是，将当前位变成0，进位变成1。如果当前位小于10，说明没有进位，赋值后直接返回即可。</p>
<p>对于打印矩阵，找到第一个不是0的位置，然后将后面的数字全部打印即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印从1-n所有的数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print1ToMaxOfNDigits</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">char</span>[] ch = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ch.length; i++) &#123;</span><br><span class="line">          ch[i] = <span class="string">'0'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//只要第一位没有进位，就继续</span></span><br><span class="line">      <span class="keyword">while</span> (!increacement(ch))&#123;</span><br><span class="line">          <span class="comment">//打印矩阵</span></span><br><span class="line">          printNum(ch);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNum</span><span class="params">(<span class="keyword">char</span>[] ch)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//如果当前位数不为0，就加入</span></span><br><span class="line">      <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (n &lt; ch.length)&#123;</span><br><span class="line">          <span class="keyword">if</span> (ch[n] == <span class="string">'0'</span>)&#123;</span><br><span class="line">              n++;</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; ch.length; i++) &#123;</span><br><span class="line">          System.out.print(ch[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">increacement</span><span class="params">(<span class="keyword">char</span>[] ch)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//从最后一位开始，模拟自增</span></span><br><span class="line">      <span class="keyword">int</span> len = ch.length - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//当前位数的和</span></span><br><span class="line">      <span class="keyword">int</span> addNum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">          <span class="comment">//当前位加上进位</span></span><br><span class="line">          sum = ch[i] - <span class="string">'0'</span> + addNum;</span><br><span class="line">          <span class="comment">//如果是最低位，加一</span></span><br><span class="line">          <span class="keyword">if</span> (i == len)&#123;</span><br><span class="line">              sum++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//如果sum为10了，看是不是第一位，是的话返回true</span></span><br><span class="line">          <span class="keyword">if</span> (sum == <span class="number">10</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span> (i == <span class="number">0</span>)&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//不是，需要当前位改成0，进位</span></span><br><span class="line">                  sum = <span class="number">0</span>;</span><br><span class="line">                  ch[i] = (<span class="keyword">char</span>)(sum + <span class="string">'0'</span>);</span><br><span class="line">                  addNum = <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//没有进位，直接返回</span></span><br><span class="line">              ch[i] = (<span class="keyword">char</span>)(sum + <span class="string">'0'</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串全部子序列"><a href="#字符串全部子序列" class="headerlink" title="字符串全部子序列"></a>字符串全部子序列</h3><p>打印一个字符串的全部子序列，包括空字符串。子串是连在一起的，子序列中的字符在字符串中不一定是连在一起的。</p>
<p>思路：初始为一个空字符串，遍历每一个字符，可以选择要当前的字符或者不要，然后递归子字符串。最后输出的就是全部的子序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAllSebSeq</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">           System.out.println(<span class="string">""</span>);</span><br><span class="line">       allSubSequence(str.toCharArray(),<span class="number">0</span>,<span class="string">""</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">allSubSequence</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> i, String s)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//base case</span></span><br><span class="line">       <span class="keyword">if</span> (i == ch.length)&#123;</span><br><span class="line">           System.out.println(s);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//选择而要当前子串与不要</span></span><br><span class="line">       allSubSequence(ch,i+<span class="number">1</span>,s);</span><br><span class="line">       allSubSequence(ch,i+<span class="number">1</span>,s+ch[i]);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="打印字符串的全排列"><a href="#打印字符串的全排列" class="headerlink" title="打印字符串的全排列"></a>打印字符串的全排列</h3><p>打印一个字符串的全排列，如字符串123，有6种全排列，打印出来。</p>
<p>思路：递归。将所有的字符依次与第一个交换，然后递归变化交换后的子串。递归结束后，将字符交换回来，即回溯不影响下一次的结果。base case为没有子串为止，输出字符串。为了在遍历字符串进行交换的时候，不对重复的字符做操作，在每轮交换前定义一个set，只有没有出现过的字符才进行操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串的全排列</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAllPermutations</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (str == <span class="keyword">null</span>)&#123;</span><br><span class="line">           System.out.println(<span class="string">""</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       process(str.toCharArray(),<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//作用，打印出字符串的全排列</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//base case</span></span><br><span class="line">       <span class="keyword">if</span> (i == ch.length)&#123;</span><br><span class="line">           System.out.println(String.valueOf(ch));</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       <span class="comment">//将当前字符与后面每一个交换，然后递归子串</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; ch.length; j++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!set.contains(ch[j]))&#123;</span><br><span class="line">               set.add(ch[j]);</span><br><span class="line">               swap(ch,i,j);</span><br><span class="line">               <span class="comment">//处理子串</span></span><br><span class="line">               process(ch,i+<span class="number">1</span>);</span><br><span class="line">               <span class="comment">//回溯，交换回来</span></span><br><span class="line">               swap(ch,i,j);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">char</span> temp = ch[i];</span><br><span class="line">       ch[i] = ch[j];</span><br><span class="line">       ch[j] = temp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a>最长不含重复字符的子字符串</h3><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<p>方法一：滑动窗口</p>
<p>用哈希表来维护一个滑动窗口，如果当前字符没有加入过，加入，移动右边指针，计算长度；如果加入过了，将左边元素移出，右边指针不变，直到没有重复的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//滑动窗口解法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring1</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       HashSet&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (j &lt; s.length())&#123;</span><br><span class="line">           <span class="keyword">if</span> (!set.contains(s.charAt(j)))&#123;</span><br><span class="line">               set.add(s.charAt(j++));</span><br><span class="line">               res = j - i &gt; res ? j - i : res;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               set.remove(s.charAt(i++));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>方法二：滑动窗口改进版</p>
<p>保存每个字符出现的位置，初始默认为-1，保存上一次的长度cur。遍历字符串，如果此字符没有出现过，cur=cur+1；如果出现过，若出现的位置比当前窗口的起点小（起点为当前位置-窗口长度），说明不在当前维护的窗口中，cur=cur+1，否则，当前子串出现了重复的，更新cur为当前位置-当前字符上一次出现位置，即窗口起点为重复位置的下一个。因为不确定传入的字符范围，选择用一个较大长度的数组来存。如果确定只有a-z，可以只用26长度的数组存位置。</p>
<p>其中在更新的时候，写法选择 res = Math.max(res,++cur)，因为cur需要被更新，且计算最大值用的是更新后的，因此不需要cur++写法，而是++cur。即更新了位置，又可以用来比较是否是最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">130</span>];<span class="comment">//保存每个字母出现的位置，默认为-1</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           arr[i] = -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//定义上一个长度f(i-1)与当前长度f(n)</span></span><br><span class="line">       <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">//返回最大长度</span></span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//遍历s</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">           <span class="comment">//计算当前字母对应的位置</span></span><br><span class="line">           index = s.charAt(i);</span><br><span class="line">           <span class="comment">//如果没有出现或者距离比当前的大，+1</span></span><br><span class="line">           <span class="keyword">if</span> (arr[index] &lt; <span class="number">0</span> || i - arr[index] &gt; cur)&#123;</span><br><span class="line">               <span class="comment">//更新最大与当前长度</span></span><br><span class="line">               res = Math.max(res,++cur);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//出现过了，当前长度减少</span></span><br><span class="line">               cur = i - arr[index];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//更新字符出现位置</span></span><br><span class="line">           arr[index] = i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h3><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）</p>
<p>方法一：哈希表</p>
<p>第一次遍历求出每个字符出现的频率，第二次遍历找到第一次频率为1的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">firstNotRepeatingChar1</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        map.put(str.charAt(i),map.getOrDefault(str.charAt(i),<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.get(str.charAt(i)) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：用数组存，因为char2字节，最多256，用256数组模拟哈希表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">firstNotRepeatingChar2</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        arr[str.charAt(i)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[str.charAt(i)] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符流中第一个只出现一次的字符"><a href="#字符流中第一个只出现一次的字符" class="headerlink" title="字符流中第一个只出现一次的字符"></a>字符流中第一个只出现一次的字符</h3><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p>
<p>思路：用一个数组来对应每个字符，记录其出现的顺序，初始默认均为-1，如果第一次进来，赋值为顺序，第二次进来，赋值为-2。遍历数组的时候，找到大于等于0的最小的那个对应的位置，就可以得到对应的字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FisrtOneceCharInStream</span> </span>&#123;</span><br><span class="line">    <span class="comment">//字符流中第一个只出现一次的字符</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];<span class="comment">//表示字符出现的位置</span></span><br><span class="line">    <span class="keyword">int</span> index;<span class="comment">//记录出现的顺序</span></span><br><span class="line">    <span class="comment">//初始化均为-1，表示没有出现过</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FisrtOneceCharInStream</span><span class="params">()</span></span>&#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//没有出现过，放到对应的位置</span></span><br><span class="line">        <span class="keyword">if</span> (arr[(<span class="keyword">int</span>)ch] == -<span class="number">1</span>)&#123;</span><br><span class="line">            arr[(<span class="keyword">int</span>)ch] = index;<span class="comment">//对应的位置</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//已经出现过，变成-2</span></span><br><span class="line">            arr[(<span class="keyword">int</span>)ch] = -<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;   <span class="keyword">int</span> minFre = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//对应的字符转成int</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]  &gt; -<span class="number">1</span> &amp;&amp; arr[i] &lt; minFre)&#123;</span><br><span class="line">                minFre = arr[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minFre == Integer.MAX_VALUE)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">char</span>)index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h2><h3 id="反向打印链表"><a href="#反向打印链表" class="headerlink" title="反向打印链表"></a>反向打印链表</h3><p>输入一个链表的头节点，从尾到头反过来打印出每个节点的值。</p>
<p>方法1：遍历链表，将值存入栈。遍历栈，弹出值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反向打印链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reversePrint</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(node.value);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        sb.append(stack.pop()).append(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法2：既然有用到栈 ，那么也可以用递归来实现，递归函数的功能是打印此节点后面的节点。基本过程是调用递归函数，然后打印当前节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//既然有用到栈，那么就可以用递归来实现，先打印后面的，然后打印当前的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reversePrint2</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    process(node,sb);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Node node, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归来实现</span></span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归后面的节点</span></span><br><span class="line">    process(node.next,sb);</span><br><span class="line">    <span class="comment">//打印当前节点</span></span><br><span class="line">    sb.append(node.value).append(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除链表中重复的节点"><a href="#删除链表中重复的节点" class="headerlink" title="删除链表中重复的节点"></a>删除链表中重复的节点</h3><p>题目1：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<p>思路：链表删除的，如果头节点不好处理，就新建一个，设立两个指针，一个指向上一个不重复的节点pre，一个指向当前的节点cur，遍历链表，如果当前节点下一个节点的值和当前节点相同，移动cur，直到cur到末尾或者cur指向最后一个相同的节点，让pre的下一个指向cur.next，这样可以将重复的节点全部删除，然后cur再到下一个。注意，此时pre不能移动，因为不能确定cur的下一个与下下个是否相同，如果pre直接移动，遇到1-&gt;2-&gt;2-&gt;3-&gt;3这种，虽然两个2被跳过了，但是后面的3会被包含进去。只有在确定了cur与cur.next值不同，pre才移动，cur也移动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">deleteDuplication</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        <span class="comment">//基本判断</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//在现在头节点前造一个</span></span><br><span class="line">        Node newHead = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        newHead.next = head;</span><br><span class="line">        Node pre = newHead;<span class="comment">//一个不重复的节点</span></span><br><span class="line">        Node cur = head;<span class="comment">//当前节点</span></span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果下一个不为空且值跟当前相同，往后走</span></span><br><span class="line">            <span class="keyword">if</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.value == cur.value)&#123;</span><br><span class="line">                <span class="comment">//让cur走到最后一个不重复的节点处</span></span><br><span class="line">                <span class="keyword">while</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.next.value == cur.value)&#123;</span><br><span class="line">                    cur = cur.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//若重复节点一个不要，让pre下一个指向cur.next</span></span><br><span class="line">                <span class="comment">//pre不能前进，防止后面还有重复的，只有没有重复的pre才走</span></span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//没有重复，正常走</span></span><br><span class="line">                pre = pre.next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Node res = newHead.next;</span><br><span class="line">        newHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>题目2：删除链表中的重复节点，如给定1-&gt;2-&gt;2-&gt;3-&gt;3，返回1-&gt;2-&gt;3。</p>
<p>思路：比上一题简单，比如直观的做法是，让一个pre指针指向第一个，cur指针指向第二个，如果当前值与pre相等，删除当前节点。相同点是，删除节点的时候，pre均不移动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这样更简单，只需要判断当前节点与前一个节点值是否相等，相等则删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">deleteDuplicates</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        Node pre = head;</span><br><span class="line">        Node cur = head.next;</span><br><span class="line">        Node next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            <span class="comment">//如果当前的值等于前一个节点，删除</span></span><br><span class="line">            <span class="keyword">if</span>(cur.value == pre.value)&#123;</span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//正常走</span></span><br><span class="line">                pre = pre.next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表倒数第k个节点"><a href="#链表倒数第k个节点" class="headerlink" title="链表倒数第k个节点"></a>链表倒数第k个节点</h3><p>题目1：找到链表倒数第k个节点</p>
<p>输入一个链表，输出该链表中倒数第k个结点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾结点是倒数第1个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个结点是值为4的结点。</p>
<p>思路：比较简单的做法是两次遍历，先知道链表长度n为多少，然后找到正着第n-k+1个节点即可，但是可以只用一次遍历来完成。用两个指针，指针1先走k-1步，然后让指针2与1一起走，当走到链表末尾时，便走到了倒数第k个节点。原因是1走到末尾，2为了是倒数第k个，与1之间的距离是k-1。需要注意的是要对k和链表head做判断，如果k&lt;=0或者head为空，直接返回空，如果指针1还没走到k-1步就到了末尾，也返回空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">findKthToTail</span><span class="params">(Node head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//基础判断，k不大于0或者头节点为空，返回空</span></span><br><span class="line">    <span class="keyword">if</span>(k &lt;= <span class="number">0</span> || head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//增加一个头节点</span></span><br><span class="line">    <span class="comment">//两个指针，让一个指针先走k-1步</span></span><br><span class="line">    Node pre = head, cur = head;</span><br><span class="line">    k = k - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//k比链表长，返回空</span></span><br><span class="line">    <span class="keyword">if</span>(k != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//让两个链表一起走</span></span><br><span class="line">    <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目2：删除链表倒数第k个节点</p>
<p>思路：如果涉及到删除操作，因为可能删除的是头节点，因此自己造一个新的头节点会比较方便，让指针1,2都从新的头节点出发，让指针1先走k步，然后1与2一起走，当指针1走到链表末尾，2走到倒数第k+1个节点，然后执行删除操作即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除链表末尾的第k个节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">deleteKthToTail</span><span class="params">(Node head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//基础判断</span></span><br><span class="line">    <span class="keyword">if</span>(k &lt;= <span class="number">0</span> || head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//增加一个头节点</span></span><br><span class="line">    Node newHead = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">    newHead.next = head;</span><br><span class="line">    <span class="comment">//两个指针，让一个指针先走k步</span></span><br><span class="line">    Node pre = newHead, cur = newHead;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//k比链表长，返回空</span></span><br><span class="line">    <span class="keyword">if</span>(k != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//让两个链表一起走</span></span><br><span class="line">    <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除pre后一个节点</span></span><br><span class="line">    pre.next = pre.next.next;</span><br><span class="line">    head = newHead.next;</span><br><span class="line">    newHead = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树-1"><a href="#树-1" class="headerlink" title="树"></a>树</h2><h3 id="树的重构"><a href="#树的重构" class="headerlink" title="树的重构"></a>树的重构</h3><p>根据先序和中序数组来重构一棵二叉树</p>
<p>思路：先序数组中，第一个值为头节点，从中序中找到与头节点相同的下标，构造头节点，然后拷贝数组，构造左子树，拷贝数组构造右子树，递归完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据前序和中序构建二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] arrPre, <span class="keyword">int</span>[] arrIn)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果两个长度不等或为空，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (arrPre.length != arrIn.length || arrPre.length &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span> (arrPre.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(arrPre[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//在arrIn中找到与arrPre[0]相等的头节点</span></span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;arrIn.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arrIn[i] == arrPre[<span class="number">0</span>])&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没找到头节点，返回</span></span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//构造头节点</span></span><br><span class="line">        Node head = <span class="keyword">new</span> Node(arrPre[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//左子树前序遍历</span></span><br><span class="line">        <span class="keyword">int</span>[] lPreChild = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        System.arraycopy(arrPre,<span class="number">1</span>,lPreChild,<span class="number">0</span>,index);</span><br><span class="line">        <span class="comment">//左子树中序遍历</span></span><br><span class="line">        <span class="keyword">int</span>[] lInChild = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        System.arraycopy(arrIn,<span class="number">0</span>,lInChild,<span class="number">0</span>,index);</span><br><span class="line">        head.left = reConstructBinaryTree(lPreChild,lInChild);</span><br><span class="line">        <span class="comment">//右子树前序遍历</span></span><br><span class="line">        <span class="keyword">int</span>[] rPreChild = <span class="keyword">new</span> <span class="keyword">int</span>[arrPre.length-index-<span class="number">1</span>];</span><br><span class="line">        System.arraycopy(arrPre,index+<span class="number">1</span>,rPreChild,<span class="number">0</span>,rPreChild.length);</span><br><span class="line">        <span class="comment">//右子树中序遍历</span></span><br><span class="line">        <span class="keyword">int</span>[] rInChild = <span class="keyword">new</span> <span class="keyword">int</span>[rPreChild.length];</span><br><span class="line">        System.arraycopy(arrIn,index+<span class="number">1</span>,rInChild,<span class="number">0</span>,rPreChild.length);</span><br><span class="line">        head.right = reConstructBinaryTree(rPreChild,rInChild);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h3><p>输入两棵二叉树A和B，判断B是不是A的子结构。</p>
<p>思路：遍历树A，找到与B相同值的节点。判断两个子树是否有一样的结构。递归的解法为：判断A树，A树的左子树，A树的右子树是否与B数结构相同。判断函数为：如果B树为空了，说明结构相同；如果A树空了，B树不空，肯定不同；如果当前节点的值不同，肯定不同；再判断左右子树是否相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//看一个树是不是另外一个树的子树</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(Node root1, Node root2)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//层序遍历root1，找到与root2头节点相同的节点</span></span><br><span class="line">       <span class="comment">//判断两个树是否相同</span></span><br><span class="line">       <span class="keyword">if</span>(root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">//看当前节点是否相同或者左子树或者右子树</span></span><br><span class="line">       <span class="keyword">return</span> isSameTree(root1,root2) || isSameTree(root1.left,root2)</span><br><span class="line">               || isSameTree(root1.right,root2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(Node root1, Node root2)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//判断两个树是否相同</span></span><br><span class="line">       <span class="comment">//base case</span></span><br><span class="line">       <span class="comment">//如果root2为空，说明是真</span></span><br><span class="line">       <span class="keyword">if</span> (root2 == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">//如果root1为空，且右子树不为空，说明是假</span></span><br><span class="line">       <span class="keyword">if</span> (root1 == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">//判断当前</span></span><br><span class="line">       <span class="keyword">if</span> (root1.value != root2.value)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">//判断左，右子树</span></span><br><span class="line">       <span class="keyword">return</span> isSameTree(root1.left,root2.left) &amp;&amp; isSameTree(root1.right,root2.right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h3><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>思路：递归完成。如果树为空，返回；如果树的左右子树均为空，返回，否则交换左右子树；对左右子树进行同样操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到一个二叉树的镜像</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//交换左右子树</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Node temp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    <span class="comment">//递归左右子树</span></span><br><span class="line">    Mirror(root.left);</span><br><span class="line">    Mirror(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h3><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>思路：比较这棵树与自己是否为镜像。递归解决，如果两个有一个为空，若是均为空，说明为真，若一个为空，另一个不为空，说明肯定不对称。判断当前节点值是否相同。判断root的左子树与root的右子树是否对称，判断root的右子树与root的左子树是否对称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断一个树是否对称</span></span><br><span class="line">   <span class="comment">//可以判断两棵树是否为镜像树</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">//调用递归子函数</span></span><br><span class="line">       <span class="keyword">return</span> isSubSym(root,root);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSubSym</span><span class="params">(Node root1, Node root2)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//base case</span></span><br><span class="line">       <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span> (root1 == <span class="keyword">null</span> &amp;&amp; root2 == <span class="keyword">null</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           <span class="comment">//一个为空，一个不是，返回假</span></span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//判断当前节点是否相同</span></span><br><span class="line">       <span class="keyword">if</span> (root1.value != root2.value)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">//判断当前树的左子树与镜像的右子树</span></span><br><span class="line">       <span class="keyword">return</span> isSubSym(root1.left,root2.right) &amp;&amp; isSubSym(root1.right,root2.left);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h3><p>普通的就是层序遍历，有意思点的是从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<p>思路：大体仍是层序遍历，但是需要一下子将同一层的全部加入或打印，这样就需要统计一层的节点个数，初始一层为1个，将每层的左右节点全部加入，统计当层的个数，然后更新下一层的个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按层打印，一层为一行</span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; print(Node root) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, cur = <span class="number">1</span>;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//不一下子只弹出一个，而是弹出上一层的个数</span></span><br><span class="line">            list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//更新当前个数，作为下一次的pre</span></span><br><span class="line">            pre = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur; i++) &#123;</span><br><span class="line">                root = queue.poll();</span><br><span class="line">                list.add(root.value);</span><br><span class="line">                <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(root.left);</span><br><span class="line">                    pre++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(root.right);</span><br><span class="line">                    pre++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环完后，将一层结果加入，更新cur</span></span><br><span class="line">            res.add(list);</span><br><span class="line">            cur = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="之字型打印二叉树"><a href="#之字型打印二叉树" class="headerlink" title="之字型打印二叉树"></a>之字型打印二叉树</h3><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<p>思路：在之前从上往下打印的基础上增加了顺序判断，正常为从左到右打印，从右到左相当于是从左到右入栈的结果，因此在之前的基础上，加入判断即可，如果需要从右到左输出，加入栈中。然后将栈中元素全部添加至list中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按照之字型打印树</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; printZhiTree(Node root)&#123;</span><br><span class="line">       ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       <span class="comment">//广度优先遍历</span></span><br><span class="line">       Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       queue.offer(root);</span><br><span class="line">       <span class="keyword">boolean</span> flagZhi = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">int</span> pre = <span class="number">0</span>, cur = <span class="number">1</span>;</span><br><span class="line">       Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">           <span class="comment">//当层元素</span></span><br><span class="line">           ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           pre = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur; i++) &#123;</span><br><span class="line">               <span class="comment">//弹出元素</span></span><br><span class="line">               <span class="comment">//如果是true，直接加入list</span></span><br><span class="line">               <span class="comment">//如果是false，加入栈</span></span><br><span class="line">               root = queue.poll();</span><br><span class="line">               <span class="keyword">if</span> (flagZhi)&#123;</span><br><span class="line">                   list.add(root.value);</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   stack.add(root.value);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   queue.offer(root.left);</span><br><span class="line">                   pre++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   queue.offer(root.right);</span><br><span class="line">                   pre++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//将栈中或队列中元素信息取出</span></span><br><span class="line">           <span class="keyword">if</span> (!flagZhi)&#123;</span><br><span class="line">               <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">                   list.add(stack.pop());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//更新一层信息</span></span><br><span class="line">           res.add(list);</span><br><span class="line">           cur = pre;</span><br><span class="line">           flagZhi = !flagZhi;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h3><p>描述：输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p>
<p>思路：树的遍历。当遍历到当前节点的时候，将目标减去当前节点值，将当前节点值添加至list中，表示走过了，如果当前节点是叶子节点且目标值等于0，将list中值复制到结果中。递归其左，右子树。回溯，将list中最后个元素删除。</p>
<p>坑点有3个</p>
<ul>
<li>不能直接将list添加至res中，因为list会变化，而res中加的是list的地址，需要额外新建一个容器来将list中的值进行拷贝</li>
<li>在叶子节点处判断而不是空节点，不然会将一个叶子节点的路径重复添加</li>
<li>删除list的元素的时候，remove的是下标，不能直接remove当前节点的值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; findPath(TreeNode root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       <span class="comment">//递归解决</span></span><br><span class="line">       process(root,target);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//功能，求树的路径</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//base case</span></span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//处理当前情况</span></span><br><span class="line">       list.add(root.val);</span><br><span class="line">       target -= root.val;<span class="comment">//用减去来表示剩下要处理的值，传递给下一次</span></span><br><span class="line">       <span class="comment">//如果当前是叶子节点并且target=0，新建一个list，添加结果</span></span><br><span class="line">       <span class="comment">//不在空节点处理是因为在空节点处理会有重复添加情况</span></span><br><span class="line">       <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; target == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="comment">//不能直接加是因为加的是地址，list会变化</span></span><br><span class="line">           ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">               temp.add(i);</span><br><span class="line">           &#125;</span><br><span class="line">           res.add(temp);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//处理左，右子树</span></span><br><span class="line">       process(root.left,target);</span><br><span class="line">       process(root.right,target);</span><br><span class="line">       <span class="comment">//回溯，消除当前影响</span></span><br><span class="line">       <span class="comment">//清除使用的是角标，不是元素</span></span><br><span class="line">       list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h3><p>描述：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<p>思路：中序遍历二叉树，记录其前一个节点，如果前一个节点为空，当前节点为返回的头节点，让当前节点的left指向前一个节点；否则，让前序节点的right指向当前节点，当前节点left指向前序节点。更新前序节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将二叉搜索树转为双向链表</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> root;</span><br><span class="line">       <span class="comment">//Inrder</span></span><br><span class="line">       Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">       TreeNode res = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">               stack.push(root);</span><br><span class="line">               root = root.left;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               root = stack.pop();</span><br><span class="line">               <span class="keyword">if</span> (pre == <span class="keyword">null</span>)&#123;</span><br><span class="line">                   res = root;</span><br><span class="line">                   root.left = pre;</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   root.left = pre;</span><br><span class="line">                   pre.right = root;</span><br><span class="line">               &#125;</span><br><span class="line">               pre = root;</span><br><span class="line">               root = root.right;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉搜索树的第k个结点"><a href="#二叉搜索树的第k个结点" class="headerlink" title="二叉搜索树的第k个结点"></a>二叉搜索树的第k个结点</h3><p>描述：给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）  中，按结点数值大小顺序第三小结点的值为4。</p>
<p>思路：二叉树的中序遍历，当到第k个的时候，返回即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉搜索树第k小的结果</span></span><br><span class="line">   <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (k &lt; <span class="number">1</span> || root == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//中序遍历</span></span><br><span class="line">       Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">               stack.push(root);</span><br><span class="line">               root = root.left;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//弹出一个</span></span><br><span class="line">               root = stack.pop();</span><br><span class="line">               k--;</span><br><span class="line">               <span class="keyword">if</span> (k == <span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="keyword">return</span> root;</span><br><span class="line">               &#125;</span><br><span class="line">               root = root.right;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉搜索树的第k大节点"><a href="#二叉搜索树的第k大节点" class="headerlink" title="二叉搜索树的第k大节点"></a>二叉搜索树的第k大节点</h3><p>二叉搜索树按照左中右的顺序来，是递增的。而第k大节点，看的是递减的顺序，那么就先压入右边，再压入左边即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//中序遍历改动，右中左</span></span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span> || k &lt; <span class="number">1</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span>(!stack.isEmpty() || root != <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">               stack.push(root);</span><br><span class="line">               root = root.right;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               root = stack.pop();</span><br><span class="line">               <span class="keyword">if</span>(--k == <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">return</span> root.val;</span><br><span class="line">               root = root.left;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>思路：深度优先遍历，一个节点的深度，等于左右子树最大深度+1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求二叉树的深度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> getInOrderDepth(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getInOrderDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//处理当前的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(getInOrderDepth(root.left),getInOrderDepth(root.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="堆-1"><a href="#堆-1" class="headerlink" title="堆"></a>堆</h2><h3 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a>最小的K个数</h3><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p>
<p>思路：最小的K个数的类型一般用堆，遍历数组，如果堆容量小于k，直接放入k，不然如果当前数小于堆顶的数，弹出堆顶的数，将当前数加入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到最小的K个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">1</span> || k &gt; arr.length || k &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.size() &lt; k) &#123;</span><br><span class="line">                queue.add(arr[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; queue.peek()) &#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">                queue.add(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : queue) &#123;</span><br><span class="line">            res.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><h3 id="找旋转数组的最小值"><a href="#找旋转数组的最小值" class="headerlink" title="找旋转数组的最小值"></a>找旋转数组的最小值</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p>思路：先判断，如果最左边数比最右边树小，那么最左边的是最小的。如果最左边的与中间和最右边数相等，那么没法二分，只能顺序查找。</p>
<p>用二分模板，左边指向左侧升序数组，右边指向右侧升序数组，当左右相邻，说明左边到了升序数组末尾，右边到了右边升序数组的开头，这样右边的数为最小数。不然，当左边数比中间数小，说明左边为升序，那么将左边移动到中间；否则将右边移动到中间。判断依据是，在旋转数组中，最小的数一定不是出现在升序数组中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minNumberInRotatedArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="comment">//错误情况</span></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//如果为顺序，返回第一个</span></span><br><span class="line">    <span class="keyword">if</span> (arr[l] &lt; arr[r])</span><br><span class="line">        <span class="keyword">return</span> arr[l];</span><br><span class="line">    <span class="comment">//如果三个相等，顺序查找</span></span><br><span class="line">    <span class="keyword">if</span> (arr[l] == arr[mid] &amp;&amp; arr[mid] == arr[r])&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l+<span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[i-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分模板</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="comment">//r为右边的递增数组开头，l为左边递增数组末尾</span></span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> arr[r];</span><br><span class="line">        mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//若左边有序，往右边找</span></span><br><span class="line">        <span class="keyword">if</span> (arr[l] &lt;= arr[mid])&#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在排序数组中查找数字出现个数"><a href="#在排序数组中查找数字出现个数" class="headerlink" title="在排序数组中查找数字出现个数"></a>在排序数组中查找数字出现个数</h3><p>统计一个数字在排序数组中出现的次数。</p>
<p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: 2</p>
<p>思路1：先二分找到一个相等的数，然后左右移动寻找边界</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search1</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//简单版，找到一个后，往左右两边找</span></span><br><span class="line">       <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">1</span> || nums[<span class="number">0</span>] &gt; target || nums[nums.length - <span class="number">1</span>] &lt; target)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//二分</span></span><br><span class="line">       <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">           mid = l + ((r-l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">           <span class="keyword">if</span> (nums[mid] &lt; target)&#123;</span><br><span class="line">               l = mid + <span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               r = mid;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (nums[l] != target)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> p1 = l, p2 = l;</span><br><span class="line">       <span class="keyword">while</span> (p1 - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[p1-<span class="number">1</span>]==nums[p1])</span><br><span class="line">           p1--;</span><br><span class="line">       <span class="keyword">while</span> (p2 + <span class="number">1</span> &lt; nums.length &amp;&amp; nums[p2+<span class="number">1</span>]==nums[p2])</span><br><span class="line">           p2++;</span><br><span class="line">       <span class="keyword">return</span> p2-p1+<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>思路2：两次二分，查找左，右边界。找左边界的思路是：mid为左中位数，因为要让右边的r不断向左收缩，避免选右中位数导致mid与r相同 ，无法收缩。而遇到mid与tar相同时，不返回，而是让r等于mid。当mid处的值小于tar的时候，让l=mid+1。</p>
<p>在找右边界的时候，选择用右中位数，因为要让左边界不断往右收缩，使用左中位数，会让mid=l，无法向右收缩。在遇到mid=tar的时候，不返回，而是让l=mid。当mid处的值比tar大的时候，让r=mid-1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//找到左右边界</span></span><br><span class="line">       <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">1</span> || nums[<span class="number">0</span>] &gt; target || nums[nums.length - <span class="number">1</span>] &lt; target)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//二分</span></span><br><span class="line">       <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">           mid = l + ((r-l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">           <span class="comment">//找左边界，让mid等于左中位数，避免右边无法收缩</span></span><br><span class="line">           <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">               r = mid;</span><br><span class="line">           <span class="keyword">if</span> (nums[mid] &lt; target)&#123;</span><br><span class="line">               l = mid + <span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               r = mid;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (nums[l] != target)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> p1 = l;</span><br><span class="line">       l = <span class="number">0</span>;</span><br><span class="line">       r = nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">           <span class="comment">//找右边界，让mid等于右中位数，避免左边无法收缩</span></span><br><span class="line">           mid = l + ((r-l + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">           <span class="comment">//左边界往右收缩</span></span><br><span class="line">           <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">               l = mid;</span><br><span class="line">           <span class="keyword">if</span> (nums[mid] &gt; target)&#123;</span><br><span class="line">               r = mid - <span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               l = mid;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> l - p1 + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="0-n-1中缺失的数字"><a href="#0-n-1中缺失的数字" class="headerlink" title="0-n-1中缺失的数字"></a>0-n-1中缺失的数字</h3><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<p>输入: [0,1,3]<br>输出: 2</p>
<p>思路：有序，就想到二分，如果当前位置的数比其下标大，把右边收缩至mid，不然让左边等于mid+1。如果arr[l]=l，说明l在最后一个，缺失的是n</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有序，用二分</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">           mid = l + ((r-l)&gt;&gt;&gt;<span class="number">1</span>);</span><br><span class="line">           <span class="keyword">if</span> (nums[mid] &gt; mid)&#123;</span><br><span class="line">               r = mid;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               l = mid + <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//要是l在最后一个，缺失的是n</span></span><br><span class="line">       <span class="keyword">if</span> (l == nums[l])</span><br><span class="line">           <span class="keyword">return</span> nums.length;</span><br><span class="line">       <span class="keyword">return</span> l;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h3><p>描述：给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>思路：如果长度小于等于3的，必须要切，单独给出结果，如果长度为4的，可以切成1,3，也可以切成2,2，这样得到的递归公式为f(n)=max(f(i)*f(n-i))，拆分为小问题解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//数据不和规格的情况</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果是1-3的情况，只能再分，对应的数字较小</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//如果是大于3的情况，1，2,3可以不用再分，这时候值会更大</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                res = Math.max(res,dp[j] * dp[i - j]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>二进制的用法：</p>
<p>&amp;：</p>
<ul>
<li>将所有位清零 n &amp; 0</li>
<li>取指定位置上的数，如取二进制的后四位，n &amp; 00001111</li>
</ul>
<p>|：</p>
<ul>
<li>将某些位数置为1：n | 00001111</li>
</ul>
<p>^</p>
<ul>
<li>将某些位置取反：n ^ 00001111，将后四位取反</li>
<li>保留原值：n ^ 0</li>
<li>交换两个数：<code>a=a^b;b=a^b;a=a^b</code>，完成a与b的交换</li>
</ul>
<h3 id="1的个数"><a href="#1的个数" class="headerlink" title="1的个数"></a>1的个数</h3><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<p>如9的二进制为1001，得到的输出为2.</p>
<p>方法一：逐位相与。一个数为1的地方，与1与不为0，统计这个数每个位都与1相与，不为0的次数即可。有两种选择，一种是右移这个数，一种是左移1。如果是右移这个数，需要使用无符号位右移，因为如果是带符号的，对于负数会有死循环。而左移1，需要进行32次判断。</p>
<p>需要注意的是n&amp;1结果不为0，进行统计。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//将要计算的数右移</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">NumberOf1_Solution1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (n != <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">               ++count;</span><br><span class="line">           n = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//将1左移</span></span><br><span class="line">   <span class="comment">//看有多少个1，可以每一位与1相与，然后统计</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">NumberOf1_Solution2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//计算32次</span></span><br><span class="line">       <span class="keyword">while</span> (flag != <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span> ((n &amp; flag) != <span class="number">0</span>)</span><br><span class="line">               ++count;</span><br><span class="line">           flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>方法二：将当前数与减去1后的数相与，得到的数会将最右侧的1变为0，这样有几个1进行几次操作，最后会得到0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">NumberOf1_Solution3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将一个数和其减一后的数相与，会把最右边为1的数后均变为0</span></span><br><span class="line">    <span class="comment">//有几个1，进行几次这样的操作</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>)&#123;</span><br><span class="line">        ++count;</span><br><span class="line">        n = n &amp; (n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展：用一条语句判断整数是不是2的整数次方，如果是，则只有一个数为1，那么将其与减去1的数相与，如果得到0，说明只有一个1。</p>
<p>输入两个数m与n，统计需要改变m的二进制中多少个数才能得到n</p>
<ul>
<li>得到m与n的异或，不同的位置为1</li>
<li>统计1的个数</li>
</ul>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h3><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
<p>思路：需要考虑指数为整数，负数，及0的情况，同时要区分下base是不是0。0的负数次方是没有意义的。</p>
<p>求指数的时候，可以用递归的方式，如果是偶数，<code>f(n)=f(n/2)*f(n/2)</code>，如果是奇数，<code>f(n)=f(n-1)/2*f(n-1)/2*base</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义power函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//分三种情况，指数大于0，小于0，等于0的情况</span></span><br><span class="line">    <span class="keyword">if</span> (exponent &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//大于0正常计算</span></span><br><span class="line">        res = getPower(base,exponent);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//小于0，看是否为0,</span></span><br><span class="line">        <span class="keyword">if</span> (base == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//0的负数次方没有意义</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            res = <span class="number">1</span> / getPower(base,-exponent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//指数为0，返回1</span></span><br><span class="line">        res = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getPower</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归解决</span></span><br><span class="line">    <span class="keyword">if</span> (exponent == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (exponent == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    <span class="keyword">double</span> res = getPower(base,exponent &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    res *= res;</span><br><span class="line">    <span class="comment">//如果是奇数，再乘上base</span></span><br><span class="line">    <span class="keyword">if</span> ((exponent &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        res *= base;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-n整数中1出现的个数"><a href="#1-n整数中1出现的个数" class="headerlink" title="1-n整数中1出现的个数"></a>1-n整数中1出现的个数</h3><p>求出1-13的整数中1出现的次数,1~13中包含1的数字有1、10、11、12、13因此共出现6次。</p>
<p>思路：从1遍历到n，分别取每个数的每一位数字，如果有1，就加上1。思路清晰简单，但是时间复杂度高。</p>
<p>求一个数字每一个位数的数字的规律是，当前数%10，求得低位，然后当前数/10。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//直观解法，遍历每一个数，如果有1，+1，如果没有，+0</span></span><br><span class="line">       <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           count += process(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//判断当前数是否含有1</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (i % <span class="number">10</span> == <span class="number">1</span>) &#123;</span><br><span class="line">               count++;</span><br><span class="line">           &#125;</span><br><span class="line">           i /= <span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>方法二：找规律</p>
<blockquote>
<p>来源于<code>https://www.cnblogs.com/yongh/p/9947165.html</code></p>
</blockquote>
<p>分别取得当前位置的数，前面的数与后面的数。</p>
<blockquote>
<p>对于整数n，我们将这个整数分为三部分：当前位数字cur，更高位数字high，更低位数字low，如：对于n=21034，当位数是十位时，cur=3，high=210，low=4。</p>
<p>　　我们从个位到最高位 依次计算每个位置出现1的次数：</p>
<p>　　1）当前位的数字等于0时，例如n=21034，在百位上的数字cur=0，百位上是1的情况有：00100-00199，01100-01199，……，20100-20199。一共有21x100种情况，即00-20，共21种，highx100;</p>
<p>　　2）当前位的数字等于1时，例如n=21034，在千位上的数字cur=1，千位上是1的情况有：01000-01999，11000-11999，21000-21034。一共有2x1000+（34+1）种情况，即highx1000+(low+1)。</p>
<p>　　3）当前位的数字大于1时，例如n=21034，在十位上的数字cur=3，十位上是1的情况有：00010-00019，……，21010-21019。一共有（210+1）x10种情况，即(high+1)x10。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数学规律解法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> low = <span class="number">0</span>, high = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//看每一位</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i*=<span class="number">10</span>) &#123;</span><br><span class="line">           high = n / (i * <span class="number">10</span>);</span><br><span class="line">           low = n % i;</span><br><span class="line">           cur = (n / i) % <span class="number">10</span>;</span><br><span class="line">           <span class="keyword">if</span> (cur == <span class="number">0</span>)&#123;</span><br><span class="line">               count += high * i;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">1</span>)&#123;</span><br><span class="line">               count += high * i + low + <span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               count += (high + <span class="number">1</span>) * i;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><h2 id="数组-2"><a href="#数组-2" class="headerlink" title="数组"></a>数组</h2><h3 id="连续的子数组和"><a href="#连续的子数组和" class="headerlink" title="连续的子数组和"></a>连续的子数组和</h3><p>给定一个包含非负数的数组和一个目标整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。</p>
<p>输入: [23,2,4,6,7], k = 6<br>输出: True<br>解释: [2,4] 是一个大小为 2 的子数组，并且和为 6。</p>
<p>方法一：暴力法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubarraySum1</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">           sum = nums[i];</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">               sum += nums[j];</span><br><span class="line">               <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (sum == <span class="number">0</span>)</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum % k == <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>方法二：用哈希表加速</p>
<p>求数组的前缀和，如果当前的和%k余数为1，如果之前也出现过余数为1的数组和，那么第一次那个数到现在这个数之间的数组和%k肯定是0。则用哈希表判断即可。坑在于，k可能为0，只有在k!=0的时候，才对sum取余，只有在当前求出的数组和没有出现过的时候，才将其进行加入，避免这种[0,0]数组判断不出来的情况。第一次的时候，要把和为0的加入，因为如果有直接%k为0的子数组，没有将0加入的话就判断不出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用哈希表优化</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubarraySum2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//前缀和</span></span><br><span class="line">       map.put(<span class="number">0</span>,-<span class="number">1</span>);<span class="comment">//放入余数为0的，避免第一次余数为0的进去无法判断</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           sum += nums[i];</span><br><span class="line">           <span class="comment">//处理sum</span></span><br><span class="line">           <span class="keyword">if</span> (k != <span class="number">0</span>)&#123;</span><br><span class="line">               sum = sum % k;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果sum已经在表中了</span></span><br><span class="line">           <span class="keyword">if</span> (map.containsKey(sum))&#123;</span><br><span class="line">               <span class="comment">//如果此时距离大于1</span></span><br><span class="line">               <span class="keyword">if</span> (i - map.get(sum) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//没有就加入</span></span><br><span class="line">               map.put(sum,i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h2><h3 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h3><p>题目描述：给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<p>注意空字符串可被认为是有效字符串。</p>
<p>思路：先将左右括号的对应关系放入一个map中，然后如果是左括号，放入栈中；如果是右括号，若栈为空，则返回假，若不为空，弹出一个元素，如果在map中弹出元素对应的括号与当前括号不同，则返回假。遍历完字符串后，若栈不为空，返回假，否则返回真。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//准备一个栈和一个哈希表</span></span><br><span class="line">        HashMap&lt;Character,Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">'('</span>,<span class="string">')'</span>);</span><br><span class="line">        map.put(<span class="string">'['</span>,<span class="string">']'</span>);</span><br><span class="line">        map.put(<span class="string">'&#123;'</span>,<span class="string">'&#125;'</span>);</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Character c : s.toCharArray())&#123;</span><br><span class="line">            <span class="comment">//如果是左括号，压入栈</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(c))&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//不存在，先判断栈是否为空</span></span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//如果不符合，直接返回</span></span><br><span class="line">                <span class="keyword">if</span>(map.get(stack.pop()) != c)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty() ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h2><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
<p>字符串这种要输出最大长度的子串的，可以用<strong>子串长度</strong>及<strong>开始位置</strong>来确定其子串。</p>
<p>方法一：中间扩散法</p>
<p>遍历字符串，找到其最左边的与当前位置相同的位置，找到最右边与中间位置相同的位置，然后两边指针左右的字符如果相等，指针分别左右移动，统计两个指针夹住的最大长度及起始位置即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中心扩散法</span></span><br><span class="line">   <span class="comment">//先找到最左跟最右的，然后向两端开始比较</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestPalindrome1</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>)</span><br><span class="line">           <span class="keyword">return</span> s;</span><br><span class="line">       <span class="comment">//最大数，默认第一个为最大的</span></span><br><span class="line">       <span class="keyword">int</span> maxNum = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//可以不用哈希表，记录起始位置就可以</span></span><br><span class="line">       <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//两个指针</span></span><br><span class="line">       <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//循环去找</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">           <span class="comment">//找出最左的</span></span><br><span class="line">           p1 = i;</span><br><span class="line">           <span class="keyword">while</span> (p1 &gt;= <span class="number">1</span> &amp;&amp; s.charAt(p1-<span class="number">1</span>) == s.charAt(p1))&#123;</span><br><span class="line">               <span class="comment">//记录开始位置</span></span><br><span class="line">               p1--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//找到最右的</span></span><br><span class="line">           p2 = i;</span><br><span class="line">           <span class="keyword">while</span> (p2 &lt; s.length() - <span class="number">1</span> &amp;&amp; s.charAt(p2+<span class="number">1</span>) == s.charAt(p2))&#123;</span><br><span class="line">               <span class="comment">//记录开始位置</span></span><br><span class="line">               p2++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//向两边扩展</span></span><br><span class="line">           <span class="keyword">while</span>(p1 &gt;= <span class="number">1</span> &amp;&amp; p2 &lt; s.length() - <span class="number">1</span> &amp;&amp; s.charAt(p1-<span class="number">1</span>) == s.charAt(p2+<span class="number">1</span>))&#123;</span><br><span class="line">               p1--;</span><br><span class="line">               p2++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//p1-p2为回文子串的长度</span></span><br><span class="line">           <span class="keyword">if</span>(maxNum &lt; p2 - p1 + <span class="number">1</span>)&#123;</span><br><span class="line">               maxNum = p2 - p1 + <span class="number">1</span>;</span><br><span class="line">               start = p1;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//更新i</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//取出最大长度对应的子串</span></span><br><span class="line">       <span class="keyword">return</span> s.substring(start,start+maxNum);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>方法二：动态规划法</p>
<p>用二维数组统计哪些角标处的是回文子串，如<code>dp[2][0]</code>代表0-2角标处的是回文子串，用两个指针遍历，一个从1开始往后，第二个从0开始到第一个指针，如果第二个指针与第一个指针处字符相等，如果角标差小于等于2，说明子串长度在3以内，不用判断dp数组，不然就需要<code>dp[i-1][j+1]</code>之间为真，即其子串是回文的。然后统计长度及起始信息即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dp</span></span><br><span class="line">   <span class="comment">//如果某两个角标之间的已经是回文的了，那么可以不用寻找</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestPalindrome4</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>)</span><br><span class="line">           <span class="keyword">return</span> s;</span><br><span class="line">       <span class="keyword">int</span> maxNum = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//可以不用哈希表，记录起始位置就可以</span></span><br><span class="line">       <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line">       <span class="comment">//统计j-i之间的情况</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">               <span class="comment">//如果相等，且之间距离在2之间（3个以内），或j+1-i-1为回文，计算</span></span><br><span class="line">               <span class="keyword">if</span> (s.charAt(j) == s.charAt(i) &amp;&amp; (i-j&lt;=<span class="number">2</span> || dp[i-<span class="number">1</span>][j+<span class="number">1</span>]))&#123;</span><br><span class="line">                   <span class="comment">//更改dp状态</span></span><br><span class="line">                   dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                   <span class="comment">//统计信息</span></span><br><span class="line">                   <span class="keyword">if</span> (maxNum &lt; i-j+<span class="number">1</span>)&#123;</span><br><span class="line">                       maxNum = i-j+<span class="number">1</span>;</span><br><span class="line">                       start = j;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> s.substring(start,start+maxNum);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表-2"><a href="#链表-2" class="headerlink" title="链表"></a>链表</h2><h3 id="LRU缓存机制"><a href="#LRU缓存机制" class="headerlink" title="LRU缓存机制"></a>LRU缓存机制</h3><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>
<p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。时间复杂度O(1)。</p>
<p>思路：这种数据结构要求的特点是插入删除快，获取快。获取时间复杂度O(1)，想到哈希表，但是哈希表是无序的，没办法做到找到最近操作的数。为了让插入删除快，想到链表。因此将二者结合，便想到了LinkedHashMap，先自己造轮子，代码思路来自于<a href="https://leetcode-cn.com/problems/lru-cache/solution/lru-ce-lue-xiang-jie-he-shi-xian-by-labuladong/" target="_blank" rel="noopener">leetcode评论区解法</a>。</p>
<p>方法一：自己造轮子</p>
<p>为了让链表与哈希表相结合，需要让哈希表与链表进行映射，哈希表存储key和对应的节点，链表为了方便删除操作，使用双向链表，链表的节点定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    DoubleNode pre;</span><br><span class="line">    DoubleNode next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleNode</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于链表的操作，需要实现的功能有，在链表前面插入节点，删除一个节点，删除末尾节点，获取链表容量，双向链表的实现如下。维护头节点与尾节点，方便进行插入与删除的操作，对于插入一个元素，需要改变4个指向的关系，让size自增。对于删除一个节点，需要改变2个指向的关系，size递减，返回删除元素的key。对于删除末尾节点，调用删除节点的方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span></span>&#123;</span><br><span class="line">    <span class="comment">//头节点与尾节点</span></span><br><span class="line">    <span class="keyword">private</span> DoubleNode head;</span><br><span class="line">    <span class="keyword">private</span> DoubleNode tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> DoubleNode(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> DoubleNode(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//往链表头节点添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(DoubleNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//添加当前节点的指向</span></span><br><span class="line">        node.next = head.next;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        head.next.pre = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在链表中移除元素，其中节点一定在链表中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">(DoubleNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//删除2个关系</span></span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> node.key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移除链表末尾元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> remove(tail.pre);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于LRU缓存，需要维护一个哈希表和一个双向链表，同时需要设置一个阈值容量。get方法的逻辑为，如果哈希表中不存在key，返回-1；如果存在，调用put方法，更新哈希表和链表，返回对应的value。对于put方法，逻辑为，构造一个新节点，当这个key存在于map中，在链表中将此key对应的节点删除，将新节点插入到链表头部，更新map。如果不存在于map中，当容量满了，删除链表最后的元素，在哈希表中删除其对应的key，然后将节点添加至链表头部，更新哈希表。实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">//持有一个map和一个双向链表，根据key找到对应Node,然后在链表中操作</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer,DoubleNode&gt; map;</span><br><span class="line">    <span class="keyword">private</span> DoubleList list;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cap;<span class="comment">//容量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> cap)</span></span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        list = <span class="keyword">new</span> DoubleList();</span><br><span class="line">        <span class="keyword">this</span>.cap = cap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//get方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果不存在，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = map.get(key).value;</span><br><span class="line">        <span class="comment">//更新链表</span></span><br><span class="line">        put(key,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        DoubleNode node = <span class="keyword">new</span> DoubleNode(key,value);</span><br><span class="line">        <span class="comment">//如果已经存在了，进行替换</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key))&#123;</span><br><span class="line">            <span class="comment">//在链表中删除</span></span><br><span class="line">            list.remove(map.get(key));</span><br><span class="line">            <span class="comment">//将新节点加入</span></span><br><span class="line">            list.addFirst(node);</span><br><span class="line">            <span class="comment">//更新哈希表</span></span><br><span class="line">            map.put(key,node);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果链表长度等于容量，删除末尾节点，然后将新节点添加至头部</span></span><br><span class="line">            <span class="keyword">if</span> (list.getSize() == cap)&#123;</span><br><span class="line">                <span class="comment">//记录被删除节点的key，便于从哈希表中移出</span></span><br><span class="line">                <span class="keyword">int</span> temp = list.removeLast();</span><br><span class="line">                map.remove(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            list.addFirst(node);</span><br><span class="line">            map.put(key,node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：用轮子</p>
<p>Java中有序的哈希表为LinkedHashMap，直接用一个类去继承，初始化的时候为了让取出顺序为访问顺序，传入true，然后get方法调用父类的getOrDefault方法，put方法调用父类的put方法，为了删除超出容量的节点，需要覆写removeEldestEntry方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache2</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">Integer</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache2</span><span class="params">(<span class="keyword">int</span> cap)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当为true的时候,get的顺序为访问的顺序</span></span><br><span class="line">        <span class="keyword">super</span>(cap,<span class="number">0.75F</span>,<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.cap = cap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getOrDefault(key,-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer,Integer&gt; eldest)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; cap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树-2"><a href="#树-2" class="headerlink" title="树"></a>树</h2><h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>思路：采用递归解决，对于一个节点来说，p，q有可能在其左右子树上，也可能在其中一个子树上。如果节点为空，返回空，如果碰到了p或者q，返回当前节点。递归返回左，右子树中包含p或者q的节点。如果左右子树均不为空，则公共父节点是当前节点。否则返回不为空的那个节点（说明q在p的子树之中），都为空就随便返回一个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求两个节点的最近父节点</span></span><br><span class="line"><span class="comment">//两节点在同一子树或不同子树上</span></span><br><span class="line"><span class="comment">//若在同一子树上，则左右子树两个有个不为空，返回不为空的</span></span><br><span class="line"><span class="comment">//若在不同子树上，那么当前节点就是</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor1</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//看左右子树</span></span><br><span class="line">    TreeNode left = lowestCommonAncestor1(root.left,p,q);</span><br><span class="line">    TreeNode right = lowestCommonAncestor1(root.right,p,q);</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left != <span class="keyword">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h3><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<p>思路：如果其中一个为空，返回另一个。将当前节点合并，合并左子树，合并右子树，返回当前节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> t2;</span><br><span class="line">    <span class="keyword">if</span>(t2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    t1.val += t2.val;</span><br><span class="line">    t1.left = mergeTrees(t1.left,t2.left);</span><br><span class="line">    t1.right = mergeTrees(t1.right,t2.right);</span><br><span class="line">    <span class="keyword">return</span> t1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h3><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<p>示例:</p>
<p>输入: 3<br>输出: 5<br>解释:<br>给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</p>
<p>   1         3     3      2      1<br>    \       /     /       /    \      <br>     3     2     1     1     3      2<br>    /     /       \                        <br>   2     1         2                      3<br>思路：动态规划，1,2,3这3个数，总的情况为G(n)，则可以由以1为头，2为头，3为头的树种类决定，即</p>
<p>G(n)=sum(F(i))，i=1,2,…,n</p>
<p>而计算F(i)，是左边的数构建树的种类与右边的数构建树的种类的乘积。即F(i)=G(i-1)xG(ni)。这样，得到G(n)的表达式为G(n)=sum(G(i-1)xG(n-i))，i=1,2,…,n。其中G(0)=1,G(1)=1.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dp解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] G = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    G[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            G[i] += G[j-<span class="number">1</span>] * G[i - j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> G[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>左神算法</tag>
        <tag>剑指offer</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2020/02/09/MySQL/</url>
    <content><![CDATA[<blockquote>
<p>尚硅谷MySQL课程笔记</p>
</blockquote>
<h1 id="数据库操作基础"><a href="#数据库操作基础" class="headerlink" title="数据库操作基础"></a>数据库操作基础</h1><h2 id="数据库概述"><a href="#数据库概述" class="headerlink" title="数据库概述"></a>数据库概述</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><strong>可将数据持久化到硬盘</strong></li>
<li><strong>可存储大量数据</strong></li>
<li><strong>方便检索</strong></li>
<li>保证数据的一致性，完整性</li>
<li>安全，可共享</li>
<li>通过组合分析，可以产生新数据</li>
</ul>
<a id="more"></a>

<h3 id="常见数据库产品"><a href="#常见数据库产品" class="headerlink" title="常见数据库产品"></a>常见数据库产品</h3><ul>
<li>Oracle：甲骨文（产品免费，服务收费）</li>
<li>DB2：IBM（兼容性相对不好）</li>
<li>SQL Server：微软（兼容性不好）</li>
<li>MySQL：甲骨文（开源，免费，性能高）</li>
</ul>
<h3 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h3><ul>
<li><p>DB</p>
<p>数据库（database）：存储数据的“仓库”，保存了一系列有组织的数据</p>
</li>
<li><p>DBMS</p>
<p>数据库管理系统（Database Management System）：数据库是通过DBMS创建和操作的容器</p>
</li>
<li><p>SQL</p>
<p>结构化查询语言（Structure Query Language）：专门用来与数据库软件通信的语言</p>
</li>
</ul>
<h3 id="数据库存储数据特点"><a href="#数据库存储数据特点" class="headerlink" title="数据库存储数据特点"></a>数据库存储数据特点</h3><ol>
<li><p>将数据放到<strong>表</strong>中，表再放到库中</p>
</li>
<li><p>一个数据库可以有多个表，每个表有唯一性的用于标识的表名</p>
</li>
<li><p>表的<strong>特性</strong>定义了数据在表中如何存储，类似java中“类”的设计</p>
</li>
<li><p>表由<strong>列</strong>组成，也称为字段。所有表都是由一个或多个列组成，每一列类似java中的“<strong>属性</strong>”</p>
</li>
<li><p>表中的数据按<strong>行</strong>存储，每一行类似java中的“<strong>对象</strong>”</p>
</li>
<li><p>表中的所有记录，类似于“<strong>对象的集合</strong>”</p>
</li>
</ol>
<p>orm设计思想：object relation mapping 对象关系映射</p>
<h3 id="数据库存储"><a href="#数据库存储" class="headerlink" title="数据库存储"></a>数据库存储</h3><p>局部性原理：程序和数据的访问有聚集成群的倾向，在一个时间段内，仅使用其中一小部分（空间局部性），或最近访问的程序代码和数据，很快又被访问的可能性很大（时间局部性）。</p>
<ul>
<li><p>默认数据在硬盘中存储以页为逻辑单元，在InnoDB中，一页为16kb</p>
<p>在磁盘中，页是存储器的逻辑块，每个存储块为一页（许多操作系统中，页大小通常为4k），主存和磁盘以页为大小交换数据</p>
</li>
</ul>
<h2 id="初识MySQL"><a href="#初识MySQL" class="headerlink" title="初识MySQL"></a>初识MySQL</h2><h3 id="MySQL数据库介绍"><a href="#MySQL数据库介绍" class="headerlink" title="MySQL数据库介绍"></a>MySQL数据库介绍</h3><p>​    MySQL前身为瑞典公司AB，2008年被sun公司收购，2009sun被oracle收购。</p>
<p>特点：</p>
<ol>
<li>体积小，安装较方便</li>
<li>开源，免费</li>
<li>性能高，稳定性好</li>
<li>兼容性好</li>
</ol>
<p>​    MySQL是一种开源的关系型数据库管理系统，广泛应用在中小型网站中。</p>
<h3 id="DBMS分类"><a href="#DBMS分类" class="headerlink" title="DBMS分类"></a>DBMS分类</h3><ul>
<li><p>基于共享文件系统的DBMS（Access）</p>
</li>
<li><p>基于客户机–服务器的DBMS   C/S  （MySQL，Oracle，SqlServer）</p>
<p>主要安装服务端。</p>
</li>
</ul>
<h3 id="MySQL服务的启动与停止"><a href="#MySQL服务的启动与停止" class="headerlink" title="MySQL服务的启动与停止"></a>MySQL服务的启动与停止</h3><p><strong>方式一：图形化</strong></p>
<p>右击–计算机管理–服务–MySQL服务</p>
<p><strong>方式二：通过管理员身份运行dos</strong></p>
<p>net start 服务名</p>
<p>net stop 服务名</p>
<h3 id="MySQL服务的登录与退出"><a href="#MySQL服务的登录与退出" class="headerlink" title="MySQL服务的登录与退出"></a>MySQL服务的登录与退出</h3><p><strong>方式一：通过dos命令</strong></p>
<p>mysql -h主机名 -P端口号 -u用户名 -p密码</p>
<p>注意：</p>
<p>​    如果是本机，则-h主机名可以省略</p>
<p>​    如果端口号是3306，则-P端口号可以省略</p>
<p>​    默认端口号3306，要先开启服务端，以管理员身份开cmd输入net start mysql5.5，后面为自定义的mysql服务名，然后开启mysql服务，普通用户打开cmd，输入mysql -u用户名 -p密码，即可。</p>
<p>使用exit退出，也可以mysql -uroot -p，然后再输入密码，这样可以隐藏密码。</p>
<p>连接其他主机上的数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -h主机名 -P端口号 -u用户名 -p密码</span><br></pre></td></tr></table></figure>

<p><strong>方式二：通过图形化界面客户端</strong></p>
<p>通过sqlyog，直接输入用户名，密码等</p>
<h2 id="MySQL的常见命令和语法规范"><a href="#MySQL的常见命令和语法规范" class="headerlink" title="MySQL的常见命令和语法规范"></a>MySQL的常见命令和语法规范</h2><h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><ul>
<li><p>show databases; 看数据库有哪些</p>
<ul>
<li><p>information_schema 服务端基本信息数据</p>
</li>
<li><p>mysql 用户信息，表信息等</p>
</li>
<li><p>performance_schema 性能分析</p>
<p><strong>前三个都不要改动！！！</strong></p>
</li>
<li><p>test</p>
<p>默认为空</p>
</li>
</ul>
</li>
<li><p>show tables;                            显示当前库中所有表</p>
</li>
<li><p>show tables from  库名;        直接看某个数据库的表 不影响当前库，因为<strong>没有使用use切换库</strong>。</p>
</li>
<li><p>show columns from 表名;     显示指定表中所有列</p>
</li>
<li><p>desc 表名;                                看表结构  describe</p>
</li>
<li><p>use 库名;                                  使用/打开指定数据库</p>
</li>
<li><p>select database();                   查看当前所在库</p>
</li>
</ul>
<h3 id="语法规范"><a href="#语法规范" class="headerlink" title="语法规范"></a>语法规范</h3><ul>
<li><p>不区分大小写</p>
</li>
<li><p>每条命令结尾建议用分号，也可以用\g</p>
</li>
<li><p>注释</p>
<ul>
<li><p>单行注释：#注释文字</p>
</li>
<li><p>单行注释：– 注释文字，中间要有空格</p>
</li>
<li><p>多行注释：/* 注释文字 */</p>
</li>
</ul>
</li>
<li><p>每条命令如果根据需要，可以进行缩进或换行</p>
<p>关键字最好单独一行</p>
</li>
</ul>
<h2 id="DQL语言"><a href="#DQL语言" class="headerlink" title="DQL语言"></a>DQL语言</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>DDL（Data Definition Language）：数据定义语言，用来定义数据库对象：库、表、列等；</p>
<p>create/drop/alter</p>
</li>
<li><p><strong>DML</strong>（Data Manipulation Language）：数据操作语言，用来定义数据库记录（数据）；</p>
<p><strong>insert/update/delete</strong></p>
</li>
<li><p>DCL（Data Control Language）：数据控制语言，用来定义访问权限和安全级别；</p>
<p>TCL(Transaction Control Language)</p>
</li>
<li><p><strong>DQL</strong>（Data Query Language）：数据查询语言，用来查询记录（数据）。</p>
<p><strong>select</strong></p>
</li>
</ul>
<h3 id="进阶一：基础查询"><a href="#进阶一：基础查询" class="headerlink" title="进阶一：基础查询"></a>进阶一：基础查询</h3><p>语法：</p>
<p>select 查询列表 from 表名;</p>
<p>特点：</p>
<ol>
<li><p>查询的结果集是一个虚拟表</p>
</li>
<li><p>select 查询列表 类似于System.out.println(打印内容);</p>
<p>select后面跟的查询列表，可以有多个部分组成，中间用逗号隔开</p>
<p>例如：select 字段1,字段2, 表达式 from 表;</p>
<p>System.out.println()的打印内容，只能有一个。</p>
</li>
<li><p>执行顺序</p>
<p>select first_name from employees;</p>
<p>先执行from语句，查询是否有此表，然后执行select语句，输出查询的列</p>
</li>
<li><p>查询列表可以是：字段，表达式，常量，函数等，也可以是这些的组合</p>
</li>
</ol>
<h4 id="查询常量"><a href="#查询常量" class="headerlink" title="查询常量"></a>查询常量</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<h4 id="查询表达式"><a href="#查询表达式" class="headerlink" title="查询表达式"></a>查询表达式</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span>/<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h4 id="查询单个字段"><a href="#查询单个字段" class="headerlink" title="查询单个字段"></a>查询单个字段</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`last_name`</span> <span class="keyword">FROM</span> <span class="string">`employees`</span>;</span><br><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>​    注意，着重号的使用是为了区分关键字，如某一column名为name，但同时NAME为关键字，这时候需要加着重号。如果不为关键字，则不用加。为了快捷输入，可以双击名称。</p>
<img src="/2020/02/09/MySQL/%E6%9F%A5%E8%AF%A2%E5%8D%95%E4%B8%AA%E5%AD%97%E6%AE%B5.png" class title="This is an example image">

<h4 id="查询多个字段"><a href="#查询多个字段" class="headerlink" title="查询多个字段"></a>查询多个字段</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`first_name`</span>,<span class="string">`last_name`</span>,<span class="string">`email`</span> <span class="keyword">FROM</span> <span class="string">`employees`</span>;</span><br></pre></td></tr></table></figure>

<p>​    中间用逗号隔开。</p>
<img src="/2020/02/09/MySQL/%E6%9F%A5%E8%AF%A2%E5%A4%9A%E4%B8%AA%E5%AD%97%E6%AE%B5.png" class title="This is an example image">

<h4 id="查询所有字段"><a href="#查询所有字段" class="headerlink" title="查询所有字段"></a>查询所有字段</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`employees`</span>;</span><br></pre></td></tr></table></figure>

<img src="/2020/02/09/MySQL/%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E5%AD%97%E6%AE%B5.png" class title="This is an example image">

<p>​    不好点在于字段顺序为表中定义顺序，因此开发中更常用的是将所有字段按照需要的顺序点击，如果太长不方便阅读，使用快捷键F12，来自动换行。</p>
<h4 id="查询函数（调用函数，获取返回值）"><a href="#查询函数（调用函数，获取返回值）" class="headerlink" title="查询函数（调用函数，获取返回值）"></a>查询函数（调用函数，获取返回值）</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATABASE</span>(); <span class="comment">#查询当前的数据库</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">VERSION</span>();  <span class="comment">#查询当前数据库服务器版本</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>();     <span class="comment">#查询当前用户</span></span><br></pre></td></tr></table></figure>

<h4 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h4><p>方式一：使用as关键字</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>() <span class="keyword">AS</span> 用户名;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>() <span class="keyword">AS</span> <span class="string">`用户名`</span>;</span><br></pre></td></tr></table></figure>

<p>使用前</p>
<img src="/2020/02/09/MySQL/%E8%B5%B7%E5%88%AB%E5%90%8D%E5%89%8D.png" class title="This is an example image">

<p>使用后</p>
<img src="/2020/02/09/MySQL/%E8%B5%B7%E5%88%AB%E5%90%8D%E5%90%8E.png" class title="This is an example image">

<p>​    加<strong>着重号</strong>是为了方便识别，如下面例子。注意：是着重号而不是引号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">AS</span> 姓 名 <span class="keyword">FROM</span> <span class="string">`employees`</span>;    <span class="comment">#报错，因为不知道名是干嘛的</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name <span class="keyword">AS</span> <span class="string">"姓 名"</span> <span class="keyword">FROM</span> <span class="string">`employees`</span>;</span><br></pre></td></tr></table></figure>

<p>​    如果姓名中间有空格，不加<strong>着重号</strong>会报错。</p>
<p>方式二：使用空格</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>() <span class="string">`用户名`</span>;</span><br></pre></td></tr></table></figure>

<h4 id="concat的使用"><a href="#concat的使用" class="headerlink" title="concat的使用"></a>concat的使用</h4><p>– 需求：查询 first_name和last_name拼接成的全名，最终起别名为：姓 名</p>
<p>方案一：使用+号</p>
<p>​    如果是按照Java的思路</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> first_name+last_name <span class="keyword">AS</span> <span class="string">"姓 名"</span> <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>但是出来结果为</p>
<img src="/2020/02/09/MySQL/%E5%8A%A0%E6%B3%95.png" class title="This is an example image">

<p>​    这是因为在Java中+可以执行加法运算，也可以实现字符串的拼接（至少要求一个为字符串）。</p>
<p>​    但在MySQL中，+作用为</p>
<ol>
<li><p>加法运算</p>
<ul>
<li><p>两个操作数为数值型</p>
<p>100+1.5</p>
</li>
<li><p>其中一个操作数为字符型</p>
<p>将字符型数据强制转换成数值型，如果无法转换，则直接当做0处理</p>
<p>‘张无忌’+100 ===&gt; 100</p>
</li>
<li><p>其中一个操作数为null</p>
<p>null+null ===&gt; null</p>
<p>null+100 ===&gt; null</p>
</li>
</ul>
</li>
</ol>
<p>因此两个char直接相加，都不能识别，结果为0。</p>
<p>方案二：使用concat()拼接函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(first_name,last_name) <span class="keyword">AS</span> <span class="string">"姓 名"</span> </span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>​    concat()函数中支持任意长度的String。</p>
<img src="/2020/02/09/MySQL/concat%E6%8B%BC%E6%8E%A5.png" class title="This is an example image">

<h4 id="distinct去重"><a href="#distinct去重" class="headerlink" title="distinct去重"></a>distinct去重</h4><p>需求：查询员工涉及到的部门编号有哪些</p>
<p>​    如有10个员工都是部门90，有10个员工都是部分80，将所有部门编号不重复的显示出来。</p>
<p>如果直接敲入SELECT department_id FROM employees;，那么会出现重复的编号如下。</p>
<img src="/2020/02/09/MySQL/%E9%87%8D%E5%A4%8D%E9%83%A8%E9%97%A8%E7%BC%96%E5%8F%B7.png" class title="This is an example image">

<p>​    可以通过增加distinct关键字来去重</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="string">`department_id`</span> <span class="keyword">FROM</span> <span class="string">`employees`</span>;</span><br></pre></td></tr></table></figure>

<p>​    显示结果为</p>
<img src="/2020/02/09/MySQL/%E7%BC%96%E5%8F%B7%E5%8E%BB%E9%87%8D.png" class title="This is an example image">

<h4 id="查看表的结构"><a href="#查看表的结构" class="headerlink" title="查看表的结构"></a>查看表的结构</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DESC employees;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">COLUMNS</span> <span class="keyword">FROM</span> <span class="string">`employees`</span>;</span><br></pre></td></tr></table></figure>

<p>​    上面两种都可以显示表所有列的结构</p>
<img src="/2020/02/09/MySQL/%E6%98%BE%E7%A4%BA%E8%A1%A8%E7%BB%93%E6%9E%84.png" class title="This is an example image">

<h3 id="练习题1"><a href="#练习题1" class="headerlink" title="练习题1"></a>练习题1</h3><p>1、下面的语句是否可以执行成功</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  last_name,</span><br><span class="line">  job_id,</span><br><span class="line">  salary <span class="keyword">AS</span> sal </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  employees ;</span><br></pre></td></tr></table></figure>

<p>​    可以，输出多个，将salary起名为sal。</p>
<p>2、下面语句是否可以执行成功</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees ;</span><br></pre></td></tr></table></figure>

<p>​    可以，输出eployees中全部。</p>
<p>3、找出下面语句中的错误</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  employee_id,</span><br><span class="line">  last_name，</span><br><span class="line">  salary * <span class="number">12</span> “ ANNUAL SALARY ” </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  employees ;</span><br></pre></td></tr></table></figure>

<p>​    错误在于last_name后面的逗号为中文逗号，12后面的双引号为中文的符号，更改即可。salary*12起名为ANNUAL SALARY。</p>
<p>4、显示表 departments 的结构，并查询其中的全部数据 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DESC departments;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> departments;</span><br></pre></td></tr></table></figure>

<p>​    可以使用desc，也可以使用SHOW COLUMNS FROM departments;</p>
<p>5、显示出表 employees 中的全部 job_id （不能重复）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> job_id <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>​    考distinct关键字的使用，查哪个表，就from哪个。</p>
<p>6、显示出表 employees 的全部列，各个列之间用逗号连接，列头显示成 OUT_PUT </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(employee_id,<span class="string">','</span>,first_name,<span class="string">','</span>,last_name,<span class="string">','</span>,commission_pct) <span class="keyword">AS</span> <span class="string">"OUT_PUT"</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>​    考concat使用，在不同列之间还要拼接上‘,’，然后起名。</p>
<p>​    但是有的为null，有的是正常的。</p>
<img src="/2020/02/09/MySQL/%E5%B8%A6%E9%80%97%E5%8F%B7%E6%8B%BC%E6%8E%A5.png" class title="This is an example image">

<p>​    然后调用SELECT commission_pct FROM employees;，发现有的commission_pct为null值。在拼接时，只要有一个为null，那么就不能直接拼接。这时候需要判断，只有在不为空的时候才进行拼接。使用函数ifnull。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> commission_pct, <span class="keyword">IFNULL</span>(commission_pct,<span class="string">"空"</span>) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>​    此函数需要输入两个参数，一个是进行判断的参数，第二个是如果此参数为null要显示的参数。</p>
<img src="/2020/02/09/MySQL/IFNULL%E4%BD%BF%E7%94%A8.png" class title="This is an example image">

<p>​    因此将commission进行替换为ifnull即可</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(employee_id,<span class="string">','</span>,first_name,<span class="string">','</span>,last_name,<span class="string">','</span>,<span class="keyword">IFNULL</span>(commission_pct,<span class="string">''</span>)) <span class="keyword">AS</span> <span class="string">"OUT_PUT"</span> <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<h3 id="进阶二：条件查询"><a href="#进阶二：条件查询" class="headerlink" title="进阶二：条件查询"></a>进阶二：条件查询</h3><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><p>select 查询列表 </p>
<p>from 表名</p>
<p><strong>where 筛选条件</strong>;</p>
<p>​    执行顺序：1，from；2，where；3，select。</p>
<p>​    在没有索引时逐行查询，再筛选有where满足的语句，进行select输出。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`first_name`</span>,<span class="string">`last_name`</span> <span class="keyword">FROM</span> <span class="string">`employees`</span> <span class="keyword">WHERE</span> <span class="string">`salary`</span>&gt;<span class="number">2000</span>;</span><br></pre></td></tr></table></figure>

<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ol>
<li><p>按关系表达式筛选</p>
<p>关系运算符：</p>
<table>
<thead>
<tr>
<th>小于</th>
<th>&lt;</th>
</tr>
</thead>
<tbody><tr>
<td>小于等于</td>
<td>&lt;=</td>
</tr>
<tr>
<td>大于</td>
<td>&gt;</td>
</tr>
<tr>
<td>大于等于</td>
<td>&gt;=</td>
</tr>
<tr>
<td>等于</td>
<td>=</td>
</tr>
<tr>
<td>不等于</td>
<td>&lt;&gt;</td>
</tr>
</tbody></table>
<p>补充：不等于!=也可以，但不建议</p>
</li>
<li><p>按逻辑表达式</p>
<p>逻辑运算符</p>
<table>
<thead>
<tr>
<th>与</th>
<th>and</th>
</tr>
</thead>
<tbody><tr>
<td>或</td>
<td>or</td>
</tr>
<tr>
<td>非</td>
<td>not</td>
</tr>
</tbody></table>
<p>补充：也可以使用&amp;&amp;   ||    !   但不建议</p>
</li>
<li><p>模糊查询</p>
<ul>
<li>like</li>
<li>in</li>
<li>between and</li>
<li>is null</li>
</ul>
</li>
</ol>
<h4 id="按关系表达式查询"><a href="#按关系表达式查询" class="headerlink" title="按关系表达式查询"></a>按关系表达式查询</h4><p>案例1：查询部门编号不是100的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id &lt;&gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>​    先按照select,from,where写好，然后进行填充。输出的是员工信息，但是不确定，用*号，然后选择的表是员工表，条件是部门编号不为100。的后跟什么，select后加什么。的前面是什么，where后加什么</p>
<p>案例2：查询工资小于15000的姓名、工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary&lt;<span class="number">15000</span>;</span><br></pre></td></tr></table></figure>

<p>​    的后为姓名工资，放在select后，的前为工资小于15000，放在where后。</p>
<h4 id="按逻辑表达式查询"><a href="#按逻辑表达式查询" class="headerlink" title="按逻辑表达式查询"></a>按逻辑表达式查询</h4><p>案例1：查询部门编号不是50-100之间员工姓名、部门编号、邮箱</p>
<p>方式1：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_id,email</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id &gt; <span class="number">100</span> <span class="keyword">OR</span> department_id &lt; <span class="number">50</span>;</span><br></pre></td></tr></table></figure>

<p>方式2：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_id,email</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span>(department_id &gt;= <span class="number">50</span> <span class="keyword">AND</span> department_id &lt;= <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>案例2：查询奖金率&gt;0.03 或者员工编号在60-110之间的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct &gt; <span class="number">0.03</span> <span class="keyword">OR</span> (employee_id &gt;= <span class="number">60</span> <span class="keyword">AND</span> employee_id &lt;= <span class="number">110</span>);</span><br></pre></td></tr></table></figure>

<h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><h5 id="like"><a href="#like" class="headerlink" title="like"></a>like</h5><p>功能：一般和通配符搭配使用，对字符型数据进行<strong>部分匹配查询</strong></p>
<p>like/ not like</p>
<p>常见的通配符：</p>
<ul>
<li>_    任意单个字符</li>
<li>%   任意多个字符，支持0到多个字符</li>
</ul>
<p>案例1：查询姓名中包含字符a的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">'%a%'</span>;</span><br></pre></td></tr></table></figure>

<p>​    姓名中包含a，使用like，因为a前面有几个字符不知道，因此a前面加%；a后面有几个字符不知道，因此a后面加%。而sql中字符要用单引号括起来，因此是like ‘%a%’。</p>
<p>案例2：查询姓名中最后一个字符为e的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">'%e'</span>;</span><br></pre></td></tr></table></figure>

<p>​    最后个字符为e，因此e前面有几个字符不知道，但e后面没有字符，因此是like ‘%e’。</p>
<p>案例3：查询姓名中第一个字符为e的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">'e%'</span>;</span><br></pre></td></tr></table></figure>

<p>​    第一个个字符为e，因此e后面有几个字符不知道，但e前面没有字符，因此是like ‘e%’。</p>
<p>案例4：查询姓名中第三个字符为x的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">'__x%'</span>;</span><br></pre></td></tr></table></figure>

<p>​    x前面有2个字符，因此添加2个下划线_，然后x后面的字符个数位置，使用%，因此为‘__x%’。</p>
<p>案例5：查询姓名中包含第二个字符为_的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">'_\_%'</span>;</span><br></pre></td></tr></table></figure>

<p>​    第二个下划线需要使用转义字符在转义。</p>
<p>​    但这种在sql中不是常见语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">'_$_%'</span> ESCAPE <span class="string">'$'</span>;</span><br></pre></td></tr></table></figure>

<p>​    使用一个喜欢的而且不常见的字符作为转义字符，利用ESCAPE来标记其为转义字符。</p>
<h5 id="in"><a href="#in" class="headerlink" title="in"></a>in</h5><p>功能：查询某字段的值是否<strong>属于指定的列表</strong>之内</p>
<p>a  in(常量值1,常量值2,常量值3,….)  意思是看a是否是在这些值之内</p>
<p>a not in(常量值1,常量值2,常量值3,….)  意思是看a是否是均在这些值之内</p>
<p>in/not in  在或者不在</p>
<p>案例1：查询部门编号是30/50/90的员工名和部门编号</p>
<p>方式1：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span>(<span class="number">30</span>,<span class="number">50</span>,<span class="number">90</span>);</span><br></pre></td></tr></table></figure>

<p>方式2：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id =<span class="number">30</span></span><br><span class="line"><span class="keyword">OR</span> department_id =<span class="number">50</span></span><br><span class="line"><span class="keyword">OR</span> department_id =<span class="number">90</span>;</span><br></pre></td></tr></table></figure>

<p>案例2：查询工种编号不是SH_CLERK或IT_PROG的员工信息</p>
<p>方式1：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> job_id <span class="keyword">NOT</span> <span class="keyword">IN</span>(<span class="string">'SH_CLERK'</span>,<span class="string">'IT_PROG'</span>);</span><br></pre></td></tr></table></figure>

<p>方式2：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> (job_id = <span class="string">'SH_CLERK'</span></span><br><span class="line"><span class="keyword">OR</span> job_id = <span class="string">'IT_PROG'</span>);</span><br></pre></td></tr></table></figure>

<h5 id="between-and"><a href="#between-and" class="headerlink" title="between and"></a>between and</h5><p>功能：判断某个字段的值是否介于xx之间。判断的是区间值。<strong>包含临界值</strong>。</p>
<p>between and / not between and</p>
<p>案例1：查询部门编号是30-90之间的部门编号、员工姓名</p>
<p>方式1：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id,last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">BETWEEN</span> <span class="number">30</span> <span class="keyword">AND</span> <span class="number">90</span>;</span><br></pre></td></tr></table></figure>

<p>​    between和and之间，要<strong>先写小的数，再写大的</strong>。</p>
<p>方式2：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id,last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id &gt;= <span class="number">30</span> <span class="keyword">AND</span> department_id &lt;= <span class="number">90</span>;</span><br></pre></td></tr></table></figure>

<p>​    两种方式是等价的，因此一定要先写小的，不然查询不到。</p>
<p>案例2：查询年薪不是100000-200000之间的员工姓名、工资、年薪</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,salary,salary*<span class="number">12</span>*(<span class="number">1</span>+<span class="keyword">IFNULL</span>(commission_pct,<span class="number">0</span>)) 年薪</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary*<span class="number">12</span>*(<span class="number">1</span>+<span class="keyword">IFNULL</span>(commission_pct,<span class="number">0</span>)) <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">100000</span> <span class="keyword">AND</span> <span class="number">200000</span>;</span><br></pre></td></tr></table></figure>

<p>​    首先在表格中没有年薪，因此要明确年薪的计算</p>
<blockquote>
<p>年薪=月薪x12x(1+奖金率)</p>
</blockquote>
<p>​    但奖金率有可能为空，因此要使用ifnull进行判断，如果为空则设置为0，然后给年薪起名，条件语句是年薪不在100000和200000之间，因此使用not between。</p>
<p>​    小技巧：可以先进行select和from进行判断语句是否写正确，然后再写where语句。</p>
<h5 id="is-null"><a href="#is-null" class="headerlink" title="is null"></a>is null</h5><p>is null / is not null</p>
<p>案例1：查询没有奖金的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>​    直接用=null无法判断出来。</p>
<p>案例2：查询有奖金的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>=与is null比较</p>
<ul>
<li>=               只能判断普通的内容</li>
<li>IS              只能判断NULL值</li>
<li>&lt;=&gt;          安全等于，既能判断普通内容，又能判断NULL值，但<strong>可读性差</strong></li>
</ul>
<h3 id="进阶三：排序查询"><a href="#进阶三：排序查询" class="headerlink" title="进阶三：排序查询"></a>进阶三：排序查询</h3><p>语法：</p>
<p>select 查询列表</p>
<p>from 表格</p>
<p>where 筛选条件  （<strong>可省略</strong>）</p>
<p>order by 排序列表</p>
<p>执行顺序</p>
<ol>
<li><p>from 子句</p>
</li>
<li><p>where 子句</p>
</li>
<li><p>select 子句</p>
</li>
<li><p>order by 子句</p>
<p><strong>先查出来，再排序</strong></p>
</li>
</ol>
<p>特点：</p>
<ol>
<li><p>排序列表可以是单个字段、多个字段、表达式、函数、列数以及以上的组合</p>
</li>
<li><p>升序，通过  asc ， 默认行为</p>
<p>降序，通过 desc</p>
</li>
<li><p>order by的位置一般放在查询语句的最后（除limit语句之外）</p>
</li>
</ol>
<h4 id="按单个字段排序"><a href="#按单个字段排序" class="headerlink" title="按单个字段排序"></a>按单个字段排序</h4><p>案例1：将员工编号大于120的员工信息进行工资的升序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id &gt; <span class="number">120</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<p>​    其中ASC可以省略。</p>
<p>案例2：将员工编号大于120的员工信息进行工资的降序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id &gt; <span class="number">120</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h4 id="按表达式排序"><a href="#按表达式排序" class="headerlink" title="按表达式排序"></a>按表达式排序</h4><p>案例1：对有奖金的员工，按年薪降序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *,salary*<span class="number">12</span>*(<span class="number">1</span>+<span class="keyword">IFNULL</span>(commission_pct,<span class="number">0</span>))  年薪</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary*<span class="number">12</span>*(<span class="number">1</span>+<span class="keyword">IFNULL</span>(commission_pct,<span class="number">0</span>)) <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>​    计算出年薪表达式，然后选择奖金率不为空，再按照年薪排序，但表达式太长。</p>
<h4 id="按别名排序"><a href="#按别名排序" class="headerlink" title="按别名排序"></a>按别名排序</h4><p>案例1：对有奖金的员工，按年薪降序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *,salary*<span class="number">12</span>*(<span class="number">1</span>+<span class="keyword">IFNULL</span>(commission_pct,<span class="number">0</span>))  年薪</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 年薪 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>​    计算出年薪表达式，然后选择奖金率不为空，再按照年薪排序，但表达式太长。</p>
<p>​    判断：where判断处是否能使用年薪？</p>
<p>​    不能，因为执行顺序是from,where,select,order by，在where处别名年薪还没有被定义，因此只能在order by后使用。</p>
<p>​    这里语法可以被简化，因为经过where判断后，已经不存在奖金率为null的情况，因此不用在select中加上对奖金率IFNULL的判断。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *,salary*<span class="number">12</span>*(<span class="number">1</span>+commission_pct)  年薪</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 年薪 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h4 id="按函数的结果排序"><a href="#按函数的结果排序" class="headerlink" title="按函数的结果排序"></a>按函数的结果排序</h4><p>案例1：按姓名的字数长度进行升序</p>
<p>获取字数长度可以使用LENGTH()函数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LENGTH</span>(last_name),last_name</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<img src="/2020/02/09/MySQL/LENGTH%E5%87%BD%E6%95%B0.png" class title="This is an example image">

<p>​    因此直接order by length(last_name)即可</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">LENGTH</span>(last_name);</span><br></pre></td></tr></table></figure>

<h4 id="按多个字段排序"><a href="#按多个字段排序" class="headerlink" title="按多个字段排序"></a>按多个字段排序</h4><p>案例1：查询员工的姓名、工资、部门编号，先按工资升序，再按部门编号降序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,salary,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">ASC</span>, department_id <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>​    总体先 按照工资排序，当有工资相同的情况，按照部门编号降序</p>
<img src="/2020/02/09/MySQL/%E5%B7%A5%E8%B5%84%E5%8D%87%E5%BA%8F%E7%BC%96%E5%8F%B7%E9%99%8D%E5%BA%8F.png" class title="This is an example image">

<p>​    中间用逗号隔开，每个排序方式都是相独立指定的。</p>
<h4 id="按列数排序，用的少"><a href="#按列数排序，用的少" class="headerlink" title="按列数排序，用的少"></a>按列数排序，用的少</h4><p>案例1：查询员工信息，按照第二列排序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>​    用的较少，阅读性较差</p>
<h3 id="练习题2"><a href="#练习题2" class="headerlink" title="练习题2"></a>练习题2</h3><p>1、查询员工的姓名和部门号和年薪，按年薪降序 按姓名升序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_id,salary*<span class="number">12</span>*(<span class="number">1</span>+<span class="keyword">IFNULL</span>(commission_pct,<span class="number">0</span>)) 年薪</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 年薪 <span class="keyword">DESC</span>, last_name <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<p>疑问：当order by中别名加了引号后就不能正确排序，如下所示</p>
<img src="/2020/02/09/MySQL/%E5%BC%95%E5%8F%B7%E6%8E%92%E5%BA%8F.png" class title="This is an example image">

<p>​    后经人提醒，应该是<strong>着重号</strong>而不是引号，因此正确的使用别名方式应该如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_id,salary*<span class="number">12</span>*(<span class="number">1</span>+<span class="keyword">IFNULL</span>(commission_pct,<span class="number">0</span>)) <span class="string">`年 薪`</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`年 薪`</span> <span class="keyword">DESC</span>, last_name <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<p>2、选择工资不在8000到17000的员工的姓名和工资，按工资降序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">8000</span> <span class="keyword">AND</span> <span class="number">17000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>3、查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> email <span class="keyword">LIKE</span> <span class="string">'%e%'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">LENGTH</span>(email) <span class="keyword">DESC</span>, department_id <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<h3 id="进阶四：常见函数"><a href="#进阶四：常见函数" class="headerlink" title="进阶四：常见函数"></a>进阶四：常见函数</h3><p>函数：类似于java中的“方法”，为了解决某个问题，将编写的一系列的命令集合封装在一起，对外仅仅暴露方法名，供外部调用。</p>
<p>1、自定义方法（函数）</p>
<p>2、调用方法啊（函数）</p>
<ul>
<li>叫什么：函数名</li>
<li>干什么：函数功能</li>
</ul>
<p>常见函数：</p>
<ul>
<li>字符函数</li>
<li>数学函数</li>
<li>日期函数</li>
<li>流程控制函数</li>
</ul>
<h4 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h4><p>1、CONCAT 拼接函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(<span class="string">'hello,'</span>,first_name,last_name) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>​    可以指定多个参数</p>
<p>2、LENGTH 获取<strong>字节</strong>长度</p>
<p>​    一个汉字识别为3个字节</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LENGTH</span>(<span class="string">'hello,李四'</span>);</span><br></pre></td></tr></table></figure>

<p>​    输出为12。</p>
<p>3、CHAR_LENGTH 获取<strong>字符</strong>长度</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(<span class="string">'hello,李四'</span>);</span><br></pre></td></tr></table></figure>

<p>​    输出为8。</p>
<p>4、SUBSTRING 截取子串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUBSTR</span>(<span class="string">'武汉加油，中国加油'</span>,<span class="number">1</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>substr(str，起始索引，截取的字符长度)  <strong>起始索引从1开始</strong>！！！    </p>
<p>substr(str，起始索引)    默认将后面全部截取</p>
<p>第一个参数为完整字符串，第二个参数为起始位置，其中SQL中从1开始，第三个参数为截取长度。</p>
<p>5、INSTR 获取字符第一次出现的索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">INSTR</span>(<span class="string">'三打白骨精aa白骨精'</span>,<span class="string">'白骨精'</span>);</span><br></pre></td></tr></table></figure>

<p>​    结果为3，因为白骨精第一次出现的索引是3。</p>
<p>6、TRIM 去前后指定的字符，默认是去空格</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRIM</span>(<span class="string">'   虚 竹   '</span>) <span class="keyword">AS</span> <span class="string">`a`</span>;</span><br></pre></td></tr></table></figure>

<p>结果为虚 竹。前后空格被去掉，中间不去掉</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRIM</span>(<span class="string">'x'</span> <span class="keyword">FROM</span> <span class="string">'xxxxx虚xx竹xxxx'</span>) <span class="keyword">AS</span> <span class="string">`a`</span>;</span><br></pre></td></tr></table></figure>

<p>结果为虚xx竹，将指定的字符从字符串中去掉了，中间的不受影响。</p>
<p>7、LPAD/RPAD  左填充/右填充</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LPAD</span>(<span class="string">'武汉加油'</span>,<span class="number">10</span>,<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>

<p>结果为aaaaaa武汉加油，往左边填充指定的字符，至指定长度。</p>
<p>也可以用来<strong>截取字符串</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LPAD</span>(<span class="string">'庆历四年滕子京谪守巴陵郡'</span>,<span class="number">4</span>,<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>

<p>当指定长度比输入字符串长度更短时，会截取字符串为指定长度，因此输出为庆历四年。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> RPAD(<span class="string">'武汉加油'</span>,<span class="number">10</span>,<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>

<p>​    输出结果为武汉加油aaaaaa，在右边填充。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> RPAD(<span class="string">'庆历四年滕子京谪守巴陵郡'</span>,<span class="number">4</span>,<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>

<p>​    结果同样为庆历四年。</p>
<p>8、UPPER/LOWER  变大写/小写</p>
<p>案例：查询员工表中的姓名，要求格式：姓首字符大写，其他字符小写，名所有字符大写，且姓和名之间用_分割，最后起别名“OUTPUT”。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(<span class="keyword">SUBSTR</span>(first_name,<span class="number">1</span>,<span class="number">1</span>),<span class="keyword">LOWER</span>(<span class="keyword">SUBSTR</span>(first_name,<span class="number">2</span>)),<span class="string">'_'</span>,<span class="keyword">UPPER</span>(last_name)) <span class="keyword">AS</span> <span class="string">`OUTPUT`</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>9、STRCMP 比较两个字符大小</p>
<p>STRCMP(str1,str2)</p>
<p>​    如果str1比较大，输出1；如果str2比较大，输出-1；如果两个一样大，返回0。</p>
<p>​    <strong>字符均用单引号括起来</strong>。</p>
<p>​    对应String compareTo()方法，其从首位比较两个字符串，如果第一个不等，则返回二者ASCII码差值，如果相等，再比较第二个，以此类推。如果比较到最后都一样（较短长度的字符串位置），则返回二者长度的差值。</p>
<p>10、LEFT/RIGHT  截取子串</p>
<p>​    从左边截取指定的长度或从右边截取指定的长度</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LEFT</span>(<span class="string">'武汉加油'</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RIGHT</span>(<span class="string">'武汉加油'</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>分别输出武和加油。</p>
<p>11、REPLACE 替换</p>
<p>REPLACE（str, a, b）    用字符串b替换字符串str中所有出现的字符串a</p>
<h4 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h4><p>1、ABS 绝对值</p>
<p>2、CEIL 向上取整，返回<strong>&gt;=</strong>该参数的最小整数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CEIL</span>(<span class="number">1.1</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CEIL</span>(<span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CEIL</span>(<span class="number">-1.09</span>);</span><br></pre></td></tr></table></figure>

<p>​    结果为2和1和-1，因为是大于等于。</p>
<p>3、FLOOR 向下取整，返回&lt;=该参数的最大整数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FLOOR</span>(<span class="number">-1.09</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FLOOR</span>(<span class="number">0.09</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FLOOR</span>(<span class="number">1.00</span>);</span><br></pre></td></tr></table></figure>

<p>​    结果为-2,0和1，因为是小于等于。</p>
<p>4、ROUND 四舍五入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ROUND</span>(<span class="number">1.87</span>);</span><br></pre></td></tr></table></figure>

<p>​    结果为2，小数点后没有保存位数。</p>
<p>​    但是想保留两个小数，可以增加一个参数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ROUND</span>(<span class="number">1.8712345</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>​    结果为1.87。</p>
<p>5、<strong>TRUNCATE</strong> 截断</p>
<p>truncate(num,count)</p>
<p>​    在数字小数点后保留指定位数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">TRUNCATE</span>(<span class="number">1.8723131</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>​    小数点后保留一位小数，结果为1.8。</p>
<p>6、MOD 取余</p>
<p><strong>被除数的正负决定了结果的正负</strong></p>
<p>​    与%结果一样。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MOD</span>(<span class="number">-10</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MOD</span>(<span class="number">10</span>,<span class="number">-3</span>);</span><br></pre></td></tr></table></figure>

<p>​    结果为-1和1，正负决定于被除数，即前面一个数。</p>
<p> A%B = A - (A/B)*B</p>
<p>​    小技巧：绝对值取余再看正负。</p>
<p>6、RAND 随机数</p>
<p>RAND(x)    返回0~1的随机值</p>
<p>7、SQRT 平方根</p>
<p>SQRT(x)    返回x的平方根</p>
<p>8、POW 次方</p>
<p>POW(x,y)    返回x的y次方</p>
<h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><p>1、NOW  获取当前时间+时间，包括日期、小时</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NOW</span>();</span><br></pre></td></tr></table></figure>

<img src="/2020/02/09/MySQL/NOW%E5%87%BD%E6%95%B0.png" class title="This is an example image">

<p>2、CURDATE  获取当前日期</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CURDATE</span>();</span><br></pre></td></tr></table></figure>

<img src="/2020/02/09/MySQL/%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F.png" class title="This is an example image">

<p>3、CURTIME 获取当前时间，只有小时</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CURTIME</span>();</span><br></pre></td></tr></table></figure>

<img src="/2020/02/09/MySQL/%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4.png" class title="This is an example image">

<p>4、DATEDIFF 获取两个日期之差</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATEDIFF</span>(<span class="string">'2020-2-17'</span>,<span class="string">'2018-6-24'</span>);</span><br></pre></td></tr></table></figure>

<p>​    输出两个日期时间，前面日期减去后面，得到天数。</p>
<p>5、DATE_FORMAT 格式转换</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>(<span class="string">'2020-2-17'</span>,<span class="string">'%Y年%m月%d日 %H小时%i分钟%s秒'</span>) <span class="string">`当前日期`</span>;</span><br></pre></td></tr></table></figure>

<p>年月日小时分秒有规定的格式</p>
<img src="/2020/02/09/MySQL/%E6%97%A5%E6%9C%9F%E8%BD%AC%E6%8D%A2.png" class title="This is an example image">

<p>​    如可以查看员工的入职日期</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>(hiredate,<span class="string">'%Y年%m月%d日 %H小时%i分钟%s秒'</span>) <span class="string">`入职日期`</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>6、STR_TO_DATE 按指定格式解析字符串为日期</p>
<p>查看入职日期比指定日期小的人</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> hiredate &lt; <span class="keyword">STR_TO_DATE</span>(<span class="string">'3/15 1998'</span>,<span class="string">'%m/%d %Y'</span>);</span><br></pre></td></tr></table></figure>

<p>这样就可以进行比较。</p>
<p>7、返回具体的时间值</p>
<p>YEAR(date)<br>MONTH(date)<br>DAY(date)<br>HOUR(time)<br>MINUTE(time)<br>SECOND(time)    </p>
<h4 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h4><p>version 当前数据库服务器的版本</p>
<p>database 当前打开的数据库</p>
<p>user 当前用户</p>
<p>password(‘字符’) 返回该字符的密码形式</p>
<p>md5(‘字符’) 返回该字符的md5加密形式</p>
<h4 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h4><p>1、IF函数</p>
<p>if(条件表达式，表达式1，表达式2)</p>
<p>如果条件表达式成立，返回表达式1，否则返回表达式2</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">IF</span>(<span class="number">100</span>&gt;<span class="number">9</span>,<span class="string">'good'</span>,<span class="string">'bad'</span>);</span><br></pre></td></tr></table></figure>

<p>​    如果成立，输出第二个，不然输出第三个。类似于三目运算符。</p>
<p>需求：如果有奖金，则显示最终奖金，如果没有，则显示0</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">IF</span>(commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,salary*<span class="number">12</span>*commission_pct,<span class="number">0</span>) <span class="string">`奖金`</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`奖金`</span> <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<p>2、CASE函数</p>
<p>情况1：类似于switch语句，可以实现等值判断</p>
<p>CASE 表达式</p>
<p>WHEN 值1 THEN 结果1</p>
<p>WHEN 值2 THEN 结果2</p>
<p>…</p>
<p>ELSE 结果n</p>
<p>END</p>
<p>案例：部门编号是30，工资显示为2倍；部门编号是50，工资显示为3倍；部门编号是60，工资显示为4倍；否则不变。显示部门编号，新工资，旧工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id,salary,</span><br><span class="line"><span class="keyword">CASE</span> department_id</span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">30</span> <span class="keyword">THEN</span> salary*<span class="number">2</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">50</span> <span class="keyword">THEN</span> salary*<span class="number">3</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">60</span> <span class="keyword">THEN</span> salary*<span class="number">4</span></span><br><span class="line"><span class="keyword">ELSE</span> salary </span><br><span class="line"><span class="keyword">END</span> <span class="string">`new salary`</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>​    case开头到end结尾均为新工资，因此要起别名的话要<strong>写在end后面</strong>。</p>
<p>情况2：类似于多重IF语句，实现区间判断。</p>
<p>CASE</p>
<p>WHEN 条件1 THEN 结果1</p>
<p>WHEN条件2 THEN 结果2</p>
<p>…</p>
<p>ELSE 结果n</p>
<p>END</p>
<p>案例：如果工资&gt;20000，显示级别A；如果工资&gt;15000，显示级别B；如果工资&gt;10000，显示级别C；否则，显示D。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> salary,</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> salary&gt;<span class="number">20000</span> <span class="keyword">THEN</span> <span class="string">'A'</span></span><br><span class="line"><span class="keyword">WHEN</span> salary&gt;<span class="number">15000</span> <span class="keyword">THEN</span> <span class="string">'B'</span></span><br><span class="line"><span class="keyword">WHEN</span> salary&gt;<span class="number">10000</span> <span class="keyword">THEN</span> <span class="string">'C'</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">'D'</span></span><br><span class="line"><span class="keyword">END</span> <span class="string">`grade`</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>​    WHEN后面记得要加THEN。</p>
<h3 id="练习题3"><a href="#练习题3" class="headerlink" title="练习题3"></a>练习题3</h3><p>1、显示系统时间（注：日期+时间）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">NOW</span>();</span><br></pre></td></tr></table></figure>

<p>2、查询员工号，姓名，工资，以及工资提高百分之20%后的结果（new salary）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,salary,salary*<span class="number">1.2</span> <span class="string">`new lalary`</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>3、将员工的姓名按首字母排序，并写成姓名的长度（length）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LENGTH</span>(last_name) <span class="string">`长度`</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">SUBSTR</span>(last_name,<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<p>或者使用LEFT函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LENGTH</span>(last_name) <span class="string">`长度`</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">LEFT</span>(last_name,<span class="number">1</span>) <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<p>4、做一个查询，产生下面的效果</p>
<p><last_name> earns &lt; salary&gt; monthly but wants &lt;salary*3&gt; Dream Salary</last_name></p>
<p>King earns 24000 monthly but wants 72000</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(last_name,<span class="string">' earns '</span>,salary,<span class="string">' monthly but wants '</span>,salary*<span class="number">3</span>) <span class="string">`Dream Salary`</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>5、使用case-when，按照下面的条件：</p>
<p>job grade</p>
<p>AD_PRES A</p>
<p>ST_MAN B</p>
<p>IT_PROG C</p>
<p>SA_REP D</p>
<p>ST_CLERK E</p>
<p>产生下面的结果</p>
<p>Last_name Job_id Grade </p>
<p>king AD_PRES A</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,job_id,</span><br><span class="line"><span class="keyword">CASE</span> job_id</span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'AD_PRES'</span> <span class="keyword">THEN</span> <span class="string">'A'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'ST_MAN'</span> <span class="keyword">THEN</span> <span class="string">'B'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'IT_PROG'</span> <span class="keyword">THEN</span> <span class="string">'C'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'SA_REP'</span> <span class="keyword">THEN</span> <span class="string">'D'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">'ST_CLERK'</span> <span class="keyword">THEN</span> <span class="string">'E'</span></span><br><span class="line"><span class="keyword">END</span> <span class="string">`Grade`</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>​    <strong>凡是常量值均瑶用引号括起来</strong>！！！</p>
<p>以上为单行函数，一列出来一个值，还有分组函数，多列进去出来一个值。</p>
<h3 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h3><p>​    分组函数往往用于实现将一组数据进行统计计算，最终得到一个值，又称为聚合函数或统计函数</p>
<p>1、分组函数清单</p>
<ul>
<li>sum(字段名) ：求和</li>
<li>avg(字段名) ：求平均数</li>
<li>max(字段名) ：求最大值</li>
<li>min(字段名)：求最小值</li>
<li>count(字段名) ：计算非空字段值的个数</li>
</ul>
<p>2、支持的类型：</p>
<ul>
<li>sum和avg一般用于处理数值型</li>
<li>max，min，count可以处理任何数据类型</li>
</ul>
<p>3、以上分组函数都忽略NULL</p>
<p>4、都可以搭配DISTINCT使用，实现去重的统计</p>
<p>select max(distinct 字段) from 表</p>
<p>5、和分组函数一同查询的字段，要求是group by后出现的字段</p>
<p>案例1：查询员工信息表中，所有员工的工资和、工资平均值、最低工资、最高工资、有工资的个数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(salary),<span class="keyword">AVG</span>(salary),<span class="keyword">MIN</span>(salary),<span class="keyword">MAX</span>(salary),<span class="keyword">COUNT</span>(salary) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>案例2：添加筛选条件</p>
<p>1、查询emp表中记录数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(employee_id) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>​    选择一个不可能为空的，计算其count即可</p>
<p>2、查询emp表中有佣金的人数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(salary) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>3、查询emp表中月薪大于2500的人数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(salary) <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary&gt;<span class="number">2500</span>;</span><br></pre></td></tr></table></figure>

<p>​    天剑查询写在where中。</p>
<p>4、查询有领导的人数</p>
<p>COUNT本身去掉了空值，因此可以不用WHERE判断</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(manager_id) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<h4 id="count的补充介绍"><a href="#count的补充介绍" class="headerlink" title="count的补充介绍"></a>count的补充介绍</h4><p>1、统计结果集的行数，推荐使用count(*)</p>
<p>查询结果中的总行数，用*统计行数较多。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id = <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<p>这样可以不用关心count中到底要写哪个字段，可以用于方便获取行数。</p>
<p>也可以使用常量值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>相当于加了一个常量列，但是效率与可读性没*高。</p>
<p>效率上：</p>
<p>MyISAM存储引擎，count(*)最高</p>
<p>InnoDB存储引擎，count(*)和count(1)效率&gt;count(字段)</p>
<p>2、搭配distinct实现去重的统计</p>
<p>需求：查询有员工的部门个数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> department_id) <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<h3 id="进阶五：分组查询"><a href="#进阶五：分组查询" class="headerlink" title="进阶五：分组查询"></a>进阶五：分组查询</h3><h4 id="分组查询引入"><a href="#分组查询引入" class="headerlink" title="分组查询引入"></a>分组查询引入</h4><p>思考题：求每个部门的总工资，平均工资。需要使用分组查询。</p>
<img src="/2020/02/09/MySQL/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2.png" class title="This is an example image">

<p>​    使用GROUP BY 关键字</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(salary) <span class="string">`总工资`</span>,<span class="keyword">AVG</span>(salary) <span class="string">`平均工资`</span>,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br></pre></td></tr></table></figure>

<p>出来结果如下</p>
<img src="/2020/02/09/MySQL/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C.png" class title="This is an example image">

<p>​    查询需要一一对应，否则无意义。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>select 查询列表</p>
<p>from 表名</p>
<p>where 筛选条件</p>
<p>group by 分组列表</p>
<p>having 分组后筛选</p>
<p>order by 排序列表;</p>
<p>执行顺序</p>
<ol>
<li>from子句</li>
<li>where子句</li>
<li>group by子句</li>
<li>having子句</li>
<li>select子句</li>
<li>order by子句</li>
</ol>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li><p>查询列表往往是   分组函数和被分组的字段</p>
</li>
<li><p>分组查询中的筛选分为两类</p>
<table>
<thead>
<tr>
<th></th>
<th>筛选的基表</th>
<th>使用的关键词</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>分组前筛选</td>
<td>原始表(from后的表)</td>
<td>where</td>
<td>group by前面</td>
</tr>
<tr>
<td>分组后筛选</td>
<td>分组后的结果集</td>
<td>having</td>
<td>group by后面</td>
</tr>
</tbody></table>
<p>where—group by—having</p>
<p>分组函数做条件只可能放在having后面</p>
</li>
<li><p>group by后面可以接函数</p>
</li>
</ol>
<h4 id="简单的分组"><a href="#简单的分组" class="headerlink" title="简单的分组"></a>简单的分组</h4><p>案例1：查询每个工种的员工平均工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary),job_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id;</span><br></pre></td></tr></table></figure>

<p>select后将分组函数和被分组字段放在一起。</p>
<p>案例2：查询每个领导的手下人数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*),manager_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> manager_id <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> manager_id;</span><br></pre></td></tr></table></figure>

<p>人数，使用COUNT(*)来查询，用领导id来分组。将领导id为空的去掉。</p>
<h4 id="可以实现分组前的筛选"><a href="#可以实现分组前的筛选" class="headerlink" title="可以实现分组前的筛选"></a>可以实现分组前的筛选</h4><p>案例1：查询邮箱中包含a字符的每个部门的最高工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary) <span class="string">`最高工资`</span>,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> email <span class="keyword">LIKE</span> <span class="string">'%a%'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br></pre></td></tr></table></figure>

<p>案例2：查询每个领导收下有奖金的员工的平均工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary) <span class="string">`平均工资`</span>,manager_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> manager_id;</span><br></pre></td></tr></table></figure>

<p>按照领导分组。</p>
<h4 id="可以实现分组后的筛选"><a href="#可以实现分组后的筛选" class="headerlink" title="可以实现分组后的筛选"></a>可以实现分组后的筛选</h4><p>案例1：查询哪个部门的员工个数&gt;5</p>
<p>分析1：查询每个部门的员工个数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="string">`员工个数`</span>,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br></pre></td></tr></table></figure>

<p>分析2：在刚才的结果基础上，筛选哪个部门的员工个数&gt;5</p>
<p>因此思路是在where后加count(<em>)&gt;5的判断，但会报错，原因在于select执行在where后，count函数此时还无意义。此时where的条件只能看到from后面emp的表，没有包含count()这一列，因此应该放在group by后面，但会报错，因为此时不应该用where，而是使用having连接词，*</em>having才支持后面加分组函数和分组后的筛选**。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="string">`员工个数`</span>,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*)&gt;<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>小结：分组前筛选，还没有group by，此时能够筛选的列只能够从from后面的原始表格列中获取；而分组后筛选，基于的表是分组后的表，因此此时可以按照分组后的结果来筛选。为了区分分组前和分组后，使用关键词不同，分组前为where，分组后为having。</p>
<p>案例2：每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> job_id,<span class="keyword">MAX</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">MAX</span>(salary)&gt;<span class="number">12000</span>;</span><br></pre></td></tr></table></figure>

<p>有奖金的判断在分组前，最高工资的判断在分组后。</p>
<p>案例3：领导编号&gt;102的每个领导手下的最低工资大于5000的领导编号和最低工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> manager_id,<span class="keyword">MIN</span>(salary) <span class="string">`最低工资`</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> manager_id &gt; <span class="number">102</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> manager_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">MIN</span>(salary) &gt; <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<p>将题干分段，先查询每个领导手下的最低工资，筛选刚才的结果。领导编号可以在分组前计算出来，因此可以放在where这。也可以放在having那，虽然结果一样，但这样效率比较低。因此既能放where和having的，优先放在where后面。</p>
<h4 id="可以实现排序"><a href="#可以实现排序" class="headerlink" title="可以实现排序"></a>可以实现排序</h4><p>案例：查询没有奖金的员工的最高工资&gt;6000的工种编号和最高工资，按最高工资升序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> job_id,<span class="keyword">MAX</span>(salary) <span class="string">`最高工资`</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="string">`最高工资`</span> &gt; <span class="number">6000</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`最高工资`</span> <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<p>先按照工种分类，查询每个工种没有奖金的员工的最高工资；筛选刚才的 结果，看哪个最高工资&gt;6000；按最高工资升序。</p>
<h4 id="按多个字段分组"><a href="#按多个字段分组" class="headerlink" title="按多个字段分组"></a>按多个字段分组</h4><p>案例：查询每个工种每个部门的最低工资，并按最低工资降序</p>
<p>​    多个分组字段用<strong>逗号隔开</strong>，两个字段没有顺序要求。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(salary) <span class="string">`最低工资`</span>,job_id,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id,department_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`最低工资`</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h3 id="进阶六：连接查询"><a href="#进阶六：连接查询" class="headerlink" title="进阶六：连接查询"></a>进阶六：连接查询</h3><p>含义：又称多表查询，当查询的字段来自多个表时，就会用到连接查询。</p>
<p>如果直接使用以下语法，相当于用第一张表每一行内容去匹配第二张表每行内容，这样均能匹配成功。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,boyName <span class="keyword">from</span> beauty,boys;</span><br></pre></td></tr></table></figure>

<p>这样一个人的“理想男友”会变成多个。即为笛卡尔乘积现象，两个表所有行数相乘。两个表实现完全连接。</p>
<p>笛卡尔成绩现象：表1有m行，表2有n行，结果=m*n行</p>
<p>发生原因：没有有效的连接条件</p>
<p>如何避免：添加有效的连接条件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`name`</span>,boyName <span class="keyword">FROM</span> beauty,boys</span><br><span class="line"><span class="keyword">WHERE</span> beauty.<span class="string">`boyfriend_id`</span> = boys.<span class="string">`id`</span>;</span><br></pre></td></tr></table></figure>

<p>用点号来标识属性的归属。</p>
<p>分类：</p>
<ul>
<li><p>按年代分类</p>
<ul>
<li>sql92标准：MySQL中仅仅支持内连接</li>
<li>sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接</li>
</ul>
</li>
<li><p>按功能分类</p>
<ul>
<li><p>内连接</p>
<ul>
<li>等值连接</li>
<li>非等值连接</li>
<li>自连接</li>
</ul>
</li>
<li><p>外连接</p>
<ul>
<li>左外连接</li>
<li>右外连接</li>
<li>全外连接</li>
</ul>
</li>
<li><p>交叉连接</p>
</li>
</ul>
</li>
</ul>
<h4 id="sql92标准"><a href="#sql92标准" class="headerlink" title="sql92标准"></a>sql92标准</h4><h5 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h5><p>1、等值连接</p>
<p>语法：</p>
<p>select 查询列表</p>
<p>from 表1 别名，表2，别名</p>
<p>where 表1.key=表2.key</p>
<p>【and 筛选条件】</p>
<p>【group by 分组字段】</p>
<p>【having 分组后的筛选】</p>
<p>【order by 排序字段】</p>
<p>特点：</p>
<ul>
<li>多表等值连接额结果为多表的交集部分</li>
<li>n表连接，至少需要n-1个连接条件</li>
<li>多表的顺序没有要求</li>
<li>一般需要为表起别名</li>
<li>可以搭配前面介绍的所有子句使用，如筛选，分组，排序</li>
</ul>
<p>案例1：查询女神名和对应的男神名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`name`</span>,boyName </span><br><span class="line"><span class="keyword">FROM</span> beauty,boys</span><br><span class="line"><span class="keyword">WHERE</span> beauty.<span class="string">`boyfriend_id`</span> = boys.<span class="string">`id`</span>;</span><br></pre></td></tr></table></figure>

<p>将要查询的两个属性写在select中，查询的表写在from中，用逗号隔开，最重要的是写where语句。</p>
<p>用第一个表的每一行去匹配第二个表的每一行。</p>
<p>案例2：查询员工名和对应的部门名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees,departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.<span class="string">`department_id`</span> = departments.<span class="string">`department_id`</span>;</span><br></pre></td></tr></table></figure>

<p>2、为表起别名</p>
<ul>
<li>提高语句的简洁度</li>
<li>区分多个重名的字段</li>
</ul>
<p>注意：如果为表起了别名，则查询的字段就不能使用原来的表名去限定。</p>
<p>案例：查询员工名，工种号，工种名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,employees.<span class="string">`job_id`</span>,job_title</span><br><span class="line"><span class="keyword">FROM</span> employees,jobs</span><br><span class="line"><span class="keyword">WHERE</span> employees.<span class="string">`job_id`</span> = jobs.<span class="string">`job_id`</span>;</span><br></pre></td></tr></table></figure>

<p>如果一个字段在多个表中都出现，为了避免歧义，那么需要加上完整的表名，为了方便，给表起别名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name,e.<span class="string">`job_id`</span>,j.job_title</span><br><span class="line"><span class="keyword">FROM</span> employees e,jobs j</span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`job_id`</span> = j.<span class="string">`job_id`</span>;</span><br></pre></td></tr></table></figure>

<p><strong>起了别名后，就不能再使用原来的名称了</strong>，因为from先执行，这样表就有了别名。</p>
<p>3、两个表的顺序是否可以调换</p>
<p>可以替换</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name,e.<span class="string">`job_id`</span>,j.job_title</span><br><span class="line"><span class="keyword">FROM</span> jobs j,employees e</span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`job_id`</span> = j.<span class="string">`job_id`</span>;</span><br></pre></td></tr></table></figure>

<p>表的交集</p>
<p>4、加筛选</p>
<p>案例1：查询有奖金的员工名、部门名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e,departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">AND</span> e.<span class="string">`commission_pct`</span> <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>在WHERE后利用AND添加筛选</p>
<p>案例2：查询城市名中第二个字符为o的部门名和城市名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_name,city</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`departments`</span> d,<span class="string">`locations`</span> l</span><br><span class="line"><span class="keyword">WHERE</span> d.<span class="string">`location_id`</span>=l.<span class="string">`location_id`</span></span><br><span class="line"><span class="keyword">AND</span> city <span class="keyword">LIKE</span> <span class="string">'_o%'</span>;</span><br></pre></td></tr></table></figure>

<p>关键：找到两个的连接关系。一般都给表起别名，更方便。</p>
<p>5、加分组</p>
<p>案例1：查询每个城市的部门个数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="string">`部门个数`</span>,city</span><br><span class="line"><span class="keyword">FROM</span> departments d,locations l</span><br><span class="line"><span class="keyword">WHERE</span> d.<span class="string">`location_id`</span>=l.<span class="string">`location_id`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> city;</span><br></pre></td></tr></table></figure>

<p>部门个数，为count(*)，部门个数跟城市在两个表中，利用location_id进行连接，然后每个城市，用城市来进行分组。</p>
<p>案例2：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_name,d.manager_id,<span class="keyword">MIN</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`departments`</span> d,<span class="string">`employees`</span> e</span><br><span class="line"><span class="keyword">WHERE</span> d.<span class="string">`department_id`</span> = e.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">AND</span> e.<span class="string">`commission_pct`</span> <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_name,manager_id;</span><br></pre></td></tr></table></figure>

<p>先把要查询的写在select，然后来自的表，先加表格的连接条件，然后增加筛选，最后加上按照部门名和领导编号进行分组。</p>
<p>因为要查询的有两个列，不能确定这两个列是否一一对应，因此分组的时候最好将这两个组都添加上。</p>
<p>6、加排序</p>
<p>案例：查询每个工种的工种名和员工的个数，并且按员工个数降序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> job_title,<span class="keyword">COUNT</span>(*) <span class="string">`员工个数`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`jobs`</span> j,<span class="string">`employees`</span> e</span><br><span class="line"><span class="keyword">WHERE</span> j.<span class="string">`job_id`</span>=e.<span class="string">`job_id`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_title</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`员工个数`</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>7、三表连接</p>
<p>案例：查询员工名、部门名和所在的城市</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_name,city</span><br><span class="line"><span class="keyword">FROM</span> employees e,departments d,locations l</span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">AND</span> d.<span class="string">`location_id`</span>=l.<span class="string">`location_id`</span>;</span><br></pre></td></tr></table></figure>

<h5 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h5><p>语法：</p>
<p>select 查询列表</p>
<p>from 表1 别名，表2，别名</p>
<p>where 非等值条件</p>
<p>【and 筛选条件】</p>
<p>【group by 分组字段】</p>
<p>【having 分组后的筛选】</p>
<p>【order by 排序字段】</p>
<p>案例1：查询员工的工资和工资级别</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> salary,grade_level</span><br><span class="line"><span class="keyword">FROM</span> employees e,job_grades j</span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`salary`</span> <span class="keyword">BETWEEN</span> j.<span class="string">`lowest_sal`</span> <span class="keyword">AND</span> j.<span class="string">`highest_sal`</span>;</span><br></pre></td></tr></table></figure>

<p>salary在最低和最高之间的范围即可。也可以在后面加AND用于筛选或者增加排序。</p>
<h5 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h5><p>案例：查询员工名和上级的名称</p>
<p>​    如员工有对应的领导编号，然后用领导编号再找为此编号的员工姓名。相当于<strong>一个表和自己相连接</strong>。</p>
<img src="/2020/02/09/MySQL/%E8%87%AA%E8%BF%9E%E6%8E%A5.png" class title="This is an example image">

<p>将一张表当成2张或更多来使用。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.employee_id,e.last_name,m.employee_id,m.last_name</span><br><span class="line"><span class="keyword">FROM</span> employees e,employees m</span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`manager_id`</span>=m.<span class="string">`employee_id`</span>;</span><br></pre></td></tr></table></figure>

<p>这时候就体现出了起别名的好处，增加了代码可读性。</p>
<h3 id="练习题4"><a href="#练习题4" class="headerlink" title="练习题4"></a>练习题4</h3><p>1、显示员工表的最大工资，工资平均值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(salary),<span class="keyword">avg</span>(salary) <span class="keyword">from</span> employees;</span><br></pre></td></tr></table></figure>

<p>2、查询员工表的employee_id，job_id，last_name，按department_id降序，salary升序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> employee_id，job_id，last_name</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> department_id <span class="keyword">desc</span>,salary <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure>

<p>3、查询员工表的job_id中包含a和e的，并且a在e的前面</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> job_id</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> job_id <span class="keyword">like</span> <span class="string">'%a%e%'</span>;</span><br></pre></td></tr></table></figure>

<p>4、已知表student，里面有id(学号)，name,grade_id(年级编号)；已知表grade，里面有id(年级编号),name(年级名)；已知表result，里面有id，score，studentNo(学号)。要求查询姓名、年级名、成绩。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.name,g.name,r.score</span><br><span class="line"><span class="keyword">from</span> student s,grade g,<span class="keyword">result</span> r</span><br><span class="line"><span class="keyword">where</span> s.grade_id=g.id</span><br><span class="line"><span class="keyword">and</span> s.id=r.studentNo;</span><br></pre></td></tr></table></figure>

<p>5、显示当前日期，以及去前后空格，截取子字符串的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select now();</span><br><span class="line">select trim(字符 from &#39;&#39;);</span><br><span class="line">select substr(str,startIndex);</span><br><span class="line">select substr(str,startIndex,length);</span><br></pre></td></tr></table></figure>

<p>6、显示所有员工的姓名，部门号和部门名称</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,d.department_id,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e,departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span>;</span><br></pre></td></tr></table></figure>

<p>7、查询90号部门员工的job_id和90号部门的location_id</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.job_id,d.location_id</span><br><span class="line"><span class="keyword">FROM</span> employees e,departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">AND</span> e.<span class="string">`department_id`</span>=<span class="number">90</span>;</span><br></pre></td></tr></table></figure>

<p>限定条件为员工的部门编号为90</p>
<p>8、选择所有有奖金的员工的last_name,department_name,location_id,city</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name,d.department_name,d.location_id,l.city</span><br><span class="line"><span class="keyword">FROM</span> employees e,departments d,locations l</span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">AND</span> d.<span class="string">`location_id`</span>=l.<span class="string">`location_id`</span></span><br><span class="line"><span class="keyword">AND</span> e.<span class="string">`commission_pct`</span> <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>9、选择city在Toronto工作的员工的last_name，job_id，department_id，department_name</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name,e.job_id,e.department_id,d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e,departments d,locations l</span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">AND</span> d.<span class="string">`location_id`</span>=l.<span class="string">`location_id`</span></span><br><span class="line"><span class="keyword">AND</span> l.<span class="string">`city`</span>=<span class="string">'Toronto'</span>;</span><br></pre></td></tr></table></figure>

<p>10、查询每个工种、每个部门的部门名、工种名和最低工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> d.department_name,j.job_title,<span class="keyword">MIN</span>(salary) <span class="string">`最低工资`</span></span><br><span class="line"><span class="keyword">FROM</span> departments d,jobs j,employees e</span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">AND</span> e.<span class="string">`job_id`</span>=j.<span class="string">`job_id`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> j.job_title,d.department_name;</span><br></pre></td></tr></table></figure>

<p>11、查询每个国家下的部门个数大于2的国家编号</p>
<p>将位置表和部门表连接，这时候部门编号没有重复，每个部门编号都有对应的国家名，然后利用国家分组，就可以算出其部门个数。</p>
<img src="/2020/02/09/MySQL/%E5%9B%BD%E5%AE%B6%E5%AF%B9%E9%83%A8%E9%97%A8%E8%A1%A8.png" class title="This is an example image">

<p>最后加上分组后的筛选条件，放在having语句后</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> country_id,<span class="keyword">COUNT</span>(*) <span class="string">`部门个数`</span></span><br><span class="line"><span class="keyword">FROM</span> locations l,departments d</span><br><span class="line"><span class="keyword">WHERE</span> d.<span class="string">`location_id`</span>=l.<span class="string">`location_id`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> country_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*)&gt;<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>having后也可以支持别名，但不太建议。</p>
<p>12、选择指定员工的姓名，员工号，以及他的管理者的姓名和员工号</p>
<p>格式类似于</p>
<p>employees     Emp#        manager            Mgr#</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name employees,e.employee_id <span class="string">`Emp#`</span>,m.last_name manager,m.employee_id <span class="string">`Mgr#`</span></span><br><span class="line"><span class="keyword">FROM</span> employees e,employees m</span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`manager_id`</span>=m.<span class="string">`employee_id`</span>;</span><br></pre></td></tr></table></figure>

<h4 id="sql99标准"><a href="#sql99标准" class="headerlink" title="sql99标准"></a>sql99标准</h4><p>语法：</p>
<p>select 查询列表</p>
<p>from 表1 别名【连接类型】</p>
<p>join 表2 别名</p>
<p>on连接条件</p>
<p>【where 筛选条件】</p>
<p>【group by 分组】</p>
<p>【having 筛选条件】</p>
<p>【order by 排序列表】</p>
<p>对比sql92，将连接条件和筛选条件进行了分类，提高可读性</p>
<p>分类：</p>
<ul>
<li><p><strong>内连接</strong>（重点）：inner</p>
</li>
<li><p>外连接</p>
<ul>
<li><strong>左外</strong>（重点）：left 【outer】</li>
<li><strong>右外</strong>（重点）：right【outer】</li>
<li>全外：full【outer】</li>
</ul>
</li>
<li><p>交叉连接：cross</p>
</li>
</ul>
<h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p>select 查询列表</p>
<p>from 表1 别名</p>
<p>inner join 表2 别名</p>
<p>on 连接条件</p>
<p>【join 表3 别名 on 连接条件】</p>
<p>可以<strong>多个join相连接</strong>。</p>
<p>特点：</p>
<ul>
<li>添加排序、分组、筛选</li>
<li>inner可以省略</li>
<li>筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读</li>
<li>inner join连接和sql92语法中的等值连接效果是一样，都是查询多表的交集</li>
</ul>
<p>1、等值连接</p>
<p>案例1：查询员工名、部门名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span>;</span><br></pre></td></tr></table></figure>

<p>将两个表的位置调换顺序也可以</p>
<p>案例2：查询名字中包含e的员工名和工种名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,job_title</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> jobs j</span><br><span class="line"><span class="keyword">ON</span> e.<span class="string">`job_id`</span>=j.<span class="string">`job_id`</span></span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">'%e%'</span>;</span><br></pre></td></tr></table></figure>

<p>案例3：查询部门个数&gt;3的城市名和部门个数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> city,<span class="keyword">COUNT</span>(*) 部门个数</span><br><span class="line"><span class="keyword">FROM</span> locations l</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> l.<span class="string">`location_id`</span>=d.<span class="string">`location_id`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> city</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*)&gt;<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>可以分步来做，先按照城市来分组，然后按照部门个数来筛选</p>
<p>案例4：查询哪个部门的部门员工个数&gt;3的部门名和员工个数，并按个数降序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_name,<span class="keyword">COUNT</span>(*) 员工个数</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_name</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*)&gt;<span class="number">3</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">COUNT</span>(*) <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>案例5：查询员工名、部门名、工种名，并按部门名排序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_name,job_title</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> jobs j <span class="keyword">ON</span> e.<span class="string">`job_id`</span>=j.<span class="string">`job_id`</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department_name;</span><br></pre></td></tr></table></figure>

<p>三表连接，先写一个inner join 表1 别名 on 连接条件，然后再写一个inner join 表2 别名 on 连接条件。保证第三个表和前两个表中的<strong>至少一个有连接条件</strong>。</p>
<p>2、非等值连接</p>
<p>案例1：查询员工的工资级别</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> salary,grade_level</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> job_grades g</span><br><span class="line"><span class="keyword">ON</span> e.<span class="string">`salary`</span> <span class="keyword">BETWEEN</span> g.<span class="string">`lowest_sal`</span> <span class="keyword">AND</span> g.<span class="string">`highest_sal`</span>;</span><br></pre></td></tr></table></figure>

<img src="/2020/02/09/MySQL/jobgrades.png" class title="This is an example image">

<p>案例2：查询工资级别的个数&gt;2的个数，并且按工资级别降序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> grade_level,<span class="keyword">COUNT</span>(*) 工资级别个数</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> job_grades g</span><br><span class="line"><span class="keyword">ON</span> e.<span class="string">`salary`</span> <span class="keyword">BETWEEN</span> g.<span class="string">`lowest_sal`</span> <span class="keyword">AND</span> g.<span class="string">`highest_sal`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> grade_level</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*)&gt;<span class="number">2</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> grade_level <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>3、自连接</p>
<p>案例：查询姓名中包含字符k员工的名字，上级的名字</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name,m.last_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> employees m</span><br><span class="line"><span class="keyword">ON</span> e.<span class="string">`manager_id`</span>=m.<span class="string">`employee_id`</span></span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`last_name`</span> <span class="keyword">LIKE</span> <span class="string">'%k%'</span>;</span><br></pre></td></tr></table></figure>

<h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p>应用场景：用于查询一个表中有，另一个表没有的记录</p>
<p>特点：</p>
<ol>
<li><p>外连接的查询结果为主表中的所有记录</p>
<ul>
<li>如果从表中有和它匹配的，则显示匹配的值</li>
<li>如果从表中没有和它匹配的，则显示null</li>
<li>外连接查询结果=内连接结果+主表中有而从表没有的记录</li>
</ul>
</li>
<li><p>左外连接，left join左边的是左表</p>
<p>右外连接，right join右边的是主表</p>
</li>
<li><p>左外和右外交换两个表的顺序，可以实现同样的效果</p>
</li>
<li><p>全外连接=内连接的结果+表1中有但表2没有的+表2中有但表1没有的</p>
</li>
</ol>
<p>引入：查询男朋友不在男神表的女神名</p>
<p>之前的内连接查两个表的交集部分，因此无法直接用来实现这里的需求。</p>
<p>做外连接实现</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b.name,bo.*</span><br><span class="line"><span class="keyword">FROM</span> beauty b</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> boys bo</span><br><span class="line"><span class="keyword">ON</span> b.<span class="string">`boyfriend_id`</span>=bo.<span class="string">`id`</span>;</span><br></pre></td></tr></table></figure>

<img src="/2020/02/09/MySQL/%E5%B7%A6%E6%9F%A5%E8%AF%A21.png" class title="This is an example image">

<p>如果只想看没有男朋友不在表中的女神信息，可以加入筛选</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b.name,bo.*</span><br><span class="line"><span class="keyword">FROM</span> beauty b</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> boys bo</span><br><span class="line"><span class="keyword">ON</span> b.<span class="string">`boyfriend_id`</span>=bo.<span class="string">`id`</span></span><br><span class="line"><span class="keyword">WHERE</span> bo.<span class="string">`id`</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>选择id来判断是因为boys中的id为主键，不能为null。判断时最好选从表中的主键列。</p>
<p>右外连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b.name,bo.*</span><br><span class="line"><span class="keyword">FROM</span> boys bo</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> beauty b</span><br><span class="line"><span class="keyword">ON</span> b.<span class="string">`boyfriend_id`</span>=bo.<span class="string">`id`</span></span><br><span class="line"><span class="keyword">WHERE</span> bo.<span class="string">`id`</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>案例1：查询哪个部门没有员工</p>
<p>左外</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> d.*,e.employee_id</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> employees e</span><br><span class="line"><span class="keyword">ON</span> d.<span class="string">`department_id`</span>=e.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`employee_id`</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>查询的没有员工的部门，因此主表是部门，然后与员工表左连接，筛选条件为没有员工即员工的id为NULL。</p>
<p>右外</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> d.*,e.employee_id</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d </span><br><span class="line"><span class="keyword">ON</span> d.<span class="string">`department_id`</span>=e.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">WHERE</span> e.<span class="string">`employee_id`</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h5 id="全外"><a href="#全外" class="headerlink" title="全外"></a>全外</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> b.*,bo.*</span><br><span class="line"><span class="keyword">from</span> beauty b</span><br><span class="line"><span class="keyword">full</span> <span class="keyword">join</span> boys bo</span><br><span class="line"><span class="keyword">on</span> b.boyfriend_id=bo.id</span><br></pre></td></tr></table></figure>

<p>MySQL不支持</p>
<h5 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b.*,bo.*</span><br><span class="line"><span class="keyword">FROM</span> beauty b</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> boys bo;</span><br></pre></td></tr></table></figure>

<p>结果就为笛卡尔乘积</p>
<h4 id="sql92与sql99"><a href="#sql92与sql99" class="headerlink" title="sql92与sql99"></a>sql92与sql99</h4><p>功能：sql99支持的更多</p>
<p>可读性：sql99实现连接条件和筛选条件的分离，可读性较高</p>
<p>下为内连接，左外，右外的比较</p>
<img src="/2020/02/09/MySQL/%E4%B8%89%E7%A7%8D%E8%BF%9E%E6%8E%A5.png" class title="This is an example image">

<p>下为左外，右外加筛选和全外的比较</p>
<img src="/2020/02/09/MySQL/%E5%B7%A6%E5%A4%96%E5%8F%B3%E5%A4%96%E5%85%A8%E5%A4%96.png" class title="This is an example image">

<h3 id="多表连接练习"><a href="#多表连接练习" class="headerlink" title="多表连接练习"></a>多表连接练习</h3><p>1、查询编号&gt;3的女神的男朋友信息，如果有则列出详细，如果没有，用null填充</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b.name,b.<span class="string">`id`</span>,bo.*</span><br><span class="line"><span class="keyword">FROM</span> beauty b</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> boys bo</span><br><span class="line"><span class="keyword">ON</span> b.<span class="string">`boyfriend_id`</span>=bo.<span class="string">`id`</span></span><br><span class="line"><span class="keyword">WHERE</span> b.<span class="string">`id`</span>&gt;<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>2、查询哪个城市没有部门</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> city</span><br><span class="line"><span class="keyword">FROM</span> locations l</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> l.<span class="string">`location_id`</span>=d.<span class="string">`location_id`</span></span><br><span class="line"><span class="keyword">WHERE</span> d.<span class="string">`department_id`</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>用从表的主键去判断</p>
<p>3、查询部门名为SAL或IT的员工信息</p>
<p>这两个部门可能没有员工，会外连接会比较全。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_name,e.*</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> employees e</span><br><span class="line"><span class="keyword">ON</span> d.<span class="string">`department_id`</span>=e.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">WHERE</span> d.<span class="string">`department_name`</span> <span class="keyword">IN</span>(<span class="string">'SAL'</span>,<span class="string">'IT'</span>);</span><br></pre></td></tr></table></figure>

<p>如果用departments来当主表，信息会比较全，会将空的员工信息也显示上去。用d来当主表对比用e来当主表，会多出NULL的员工信息，因为有的部门中没有员工。想要哪个表信息更全，就用哪个表来当主键。差的是部门的员工信息，因此主要是看部门。如果用员工表当主表，会去掉空的员工信息。</p>
<h3 id="进阶七：子查询"><a href="#进阶七：子查询" class="headerlink" title="进阶七：子查询"></a>进阶七：子查询</h3><h4 id="含义："><a href="#含义：" class="headerlink" title="含义："></a>含义：</h4><p>出现在其他语句中的select语句，称为子查询或内查询</p>
<p>外部的查询语句，称为主查询或外查询</p>
<p>外面的语句可以是insert、update、delete、<strong>select</strong>等，一般select作为外面语句较多</p>
<h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><p>按子查询出现的位置：</p>
<ul>
<li>select后面<ul>
<li>仅仅支持标量子查询</li>
</ul>
</li>
<li>from后面<ul>
<li>支持表子查询</li>
</ul>
</li>
<li><strong>where或having后面</strong>（重点）<ul>
<li><strong>标量子查询</strong>（单行）（重点）</li>
<li><strong>列子查询</strong>（多行）（重点）</li>
<li>行子查询（较少）</li>
</ul>
</li>
<li>exists后面（相关子查询）<ul>
<li>表子查询    </li>
</ul>
</li>
</ul>
<p>按结果集的行列数不同：</p>
<ul>
<li>标量子查询（结果集只有一行一列）</li>
<li>列子查询（结果集有只一列多行）</li>
<li>行子查询（结果集有一行多列）</li>
<li>表子查询（结果集一般为多行多列）</li>
</ul>
<h4 id="where或having后面"><a href="#where或having后面" class="headerlink" title="where或having后面"></a>where或having后面</h4><p>1、标量子查询（单行子查询）</p>
<p>2、列子查询（多行子查询）</p>
<p>3、行子查询（多列多行）</p>
<p>特点：</p>
<ul>
<li><p>子查询放在小括号内</p>
</li>
<li><p>子查询一般放在条件的右侧</p>
</li>
<li><p>标量子查询，一般搭配着单行操作符使用</p>
<p>&lt;  &gt;  &lt;=  &gt;=  =  &lt;&gt;</p>
</li>
<li><p>列子查询，一般搭配多行操作符使用</p>
<p>IN,ANY/SOME,ALL</p>
</li>
<li><p>子查询的的执行优先于主查询执行，主查询的条件用到了子查询的结果</p>
</li>
</ul>
<p>1、标量子查询</p>
<p>案例1：谁的工资比Abel高</p>
<p>步骤1：查询Abel的工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> last_name=<span class="string">'Abel'</span>;</span><br></pre></td></tr></table></figure>

<p>出来的结果为一行一列，因此为标量子查询</p>
<p>步骤2：查询员工的信息，满足salary大于步骤1结果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary&gt;(</span><br><span class="line">	<span class="keyword">SELECT</span> salary</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> last_name=<span class="string">'Abel'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>案例2：返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id和工资</p>
<p>步骤1：查询141号员工的job_id</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> job_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id=<span class="number">141</span>;</span><br></pre></td></tr></table></figure>

<p>步骤2：查询143号员工的salary</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> salary</span><br><span class="line"><span class="keyword">FROM</span>  employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id=<span class="number">143</span>;</span><br></pre></td></tr></table></figure>

<p>步骤3：查询员工的姓名，job_id和工资，要求job_id=步骤1，并且salary&gt;步骤2</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,job_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> job_id=(</span><br><span class="line">	<span class="keyword">SELECT</span> job_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> employee_id=<span class="number">141</span></span><br><span class="line">) <span class="keyword">AND</span> salary&gt;(</span><br><span class="line">	<span class="keyword">SELECT</span> salary</span><br><span class="line">	<span class="keyword">FROM</span>  employees</span><br><span class="line">	<span class="keyword">WHERE</span> employee_id=<span class="number">143</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>案例3：返回公司工资最少的员工的last_name,job_id和salary</p>
<p>步骤1：查询公司的最低工资</p>
<p>步骤2：查询last_name,job_id和salary，要求salary=步骤1</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,job_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary=(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>案例4：查询最低工资大于50号部门最低工资的部门id和其最低工资</p>
<p>步骤1：查询50号部门最低工资</p>
<p>步骤2：查询每个部门的最低工资</p>
<p>步骤3：在步骤2基础上筛选，满足min(salary)&gt;步骤1结果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(salary),department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">MIN</span>(salary)</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> department_id=<span class="number">50</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>非法使用标量子查询</p>
<p>子查询结果不为一行一列，可能为空或者多行，都不可以。</p>
<p>2、列子查询（多行子查询）</p>
<ul>
<li>使用多行</li>
<li>使用多行比较操作符</li>
</ul>
<table>
<thead>
<tr>
<th><strong>操作符</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>IN/NOT IN</strong></td>
<td>等于列表中的<strong>任意一个</strong></td>
</tr>
<tr>
<td>ANY|SOME</td>
<td>和子查询返回的<strong>某一个</strong>值比较</td>
</tr>
<tr>
<td>ALL</td>
<td>和子查询返回的<strong>所有</strong>值比较</td>
</tr>
</tbody></table>
<p>a &gt; any(10,15,20)，意思为a比其中某一个大即可，此时可以替换成min</p>
<p>a&gt;all(10,15,20)，要大于所有，此时可以替换成max</p>
<p>案例1：返回location_id是1400或1700的部门中的所有员工姓名</p>
<p>步骤1：查询location_id是1400或1700的部门标号</p>
<p>最好去重</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id</span><br><span class="line"><span class="keyword">FROM</span> departments</span><br><span class="line"><span class="keyword">WHERE</span> location_id <span class="keyword">IN</span>(<span class="number">1400</span>,<span class="number">1700</span>)</span><br></pre></td></tr></table></figure>

<p>步骤2：查询员工姓名，要求部门号是步骤1结果中的某一个</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id</span><br><span class="line">    <span class="keyword">FROM</span> departments</span><br><span class="line">    <span class="keyword">WHERE</span> location_id <span class="keyword">IN</span>(<span class="number">1400</span>,<span class="number">1700</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>也可以将IN替换为= ANY，因为IN意思为在其中某个就可以，与= ANY意思相同。如果是NOT IN，表示全不在这个范围内，那么可以替换为NOT ALL，所有的都不在。</p>
<p>案例2：返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary</p>
<p>步骤1：查询job_id为‘IT_PROG’部门任一工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> job_id=<span class="string">'IT_PROG'</span></span><br></pre></td></tr></table></figure>

<p>步骤2：查询员工号、姓名、job_id 以及salary，salary&lt;any（步骤1结果），job_id不为IT</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,job_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary&lt;<span class="keyword">ANY</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> salary</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> job_id=<span class="string">'IT_PROG'</span></span><br><span class="line">) <span class="keyword">AND</span> job_id &lt;&gt; <span class="string">'IT_PROG'</span>;</span><br></pre></td></tr></table></figure>

<p>或者小于其中任意工资，就是小于其最大工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,job_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary&lt;(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> job_id=<span class="string">'IT_PROG'</span></span><br><span class="line">) <span class="keyword">AND</span> job_id &lt;&gt; <span class="string">'IT_PROG'</span>;</span><br></pre></td></tr></table></figure>

<p>案例3：返回其它工种中比job_id为‘IT_PROG’工种所有工资都低的员工的员工号、姓名、job_id 以及salary</p>
<p>相比于案例2，相当于把any替换为all</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,job_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary&lt;<span class="keyword">ALL</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> salary</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> job_id=<span class="string">'IT_PROG'</span></span><br><span class="line">) <span class="keyword">AND</span> job_id &lt;&gt; <span class="string">'IT_PROG'</span>;</span><br></pre></td></tr></table></figure>

<p>或者小于所有，就是小于最小工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,job_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary&lt;(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">Min</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> job_id=<span class="string">'IT_PROG'</span></span><br><span class="line">) <span class="keyword">AND</span> job_id &lt;&gt; <span class="string">'IT_PROG'</span>;</span><br></pre></td></tr></table></figure>

<p>3、行子查询（结果集一行多列或多行多列）</p>
<p>案例：查询员工编号最小并且工资最高的员工信息</p>
<p>之前的写法</p>
<p>步骤1：查询最小的员工编号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(employee_id) </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br></pre></td></tr></table></figure>

<p>步骤2：查询最高工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary) </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br></pre></td></tr></table></figure>

<p>步骤3：查询员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id=(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(employee_id) </span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">) <span class="keyword">AND</span> salary=(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary) </span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>利用行子查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> (employee_id,salary)=(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(employee_id),<span class="keyword">MAX</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>比较有局限性，要求查询的多个结果能用相同的运算符计算得出。</p>
<h4 id="select后面"><a href="#select后面" class="headerlink" title="select后面"></a>select后面</h4><p>案例1：查询每个部门的员工个数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> d.*,(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</span><br><span class="line">	<span class="keyword">FROM</span> employees e</span><br><span class="line">	<span class="keyword">WHERE</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span></span><br><span class="line">) <span class="string">`个数`</span></span><br><span class="line"><span class="keyword">FROM</span> departments d;</span><br></pre></td></tr></table></figure>

<p>查询员工个数，然后显示在select后，因为要查询的员工数有要求和部门数id相同，需要加上筛选</p>
<p>如果用<strong>左外连接</strong>来做，如果直接查询count(*）这样查询到的员工数最少为1，错误将员工数为0的部门员工数查询为1，因为忽略了NULL值，应该使用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> d.*,<span class="keyword">COUNT</span>(employee_id)</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> employees e</span><br><span class="line"><span class="keyword">ON</span> d.<span class="string">`department_id`</span>=e.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> d.<span class="string">`department_id`</span></span><br></pre></td></tr></table></figure>

<p>案例2：查询员工号=102的部门名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> department_name</span><br><span class="line">	<span class="keyword">FROM</span> departments d</span><br><span class="line">	<span class="keyword">JOIN</span> employees e</span><br><span class="line">	<span class="keyword">ON</span> d.<span class="string">`department_id`</span>=e.<span class="string">`department_id`</span></span><br><span class="line">	<span class="keyword">WHERE</span> e.<span class="string">`employee_id`</span>=<span class="number">102</span></span><br><span class="line">) <span class="string">`部门名`</span>;</span><br></pre></td></tr></table></figure>

<p>没必要多加一层select。可以被其他方式代替</p>
<h4 id="from后面"><a href="#from后面" class="headerlink" title="from后面"></a>from后面</h4><p>将子查询结果充当一张表，要求必须起别名</p>
<p>案例：查询每个部门的平均工资的工资等级</p>
<p>步骤1：查询每个部门的平均工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary),department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br></pre></td></tr></table></figure>

<p>这样就得到了平均工资的表</p>
<p>步骤2：连接步骤1的结果集和job_grades表，筛选平均工资在最低和最高之间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ag_dep.*,g.<span class="string">`grade_level`</span></span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary) ag,department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">) ag_dep</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> job_grades g</span><br><span class="line"><span class="keyword">ON</span> ag_dep.ag <span class="keyword">BETWEEN</span> g.<span class="string">`lowest_sal`</span> <span class="keyword">AND</span> g.<span class="string">`highest_sal`</span>;</span><br></pre></td></tr></table></figure>

<p>注意，步骤1得到的表需要起别名，要用到的平均工资也起别名，将1得到的表和登记表内连接，然后输出1的所有信息和等级表的等级。</p>
<h4 id="exists后面（相关子查询）"><a href="#exists后面（相关子查询）" class="headerlink" title="exists后面（相关子查询）"></a>exists后面（相关子查询）</h4><p>语法：</p>
<p>exists（完整的查询语句）</p>
<p>结果：1或0</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> employee_id <span class="keyword">FROM</span> employees);</span><br></pre></td></tr></table></figure>

<p>输出为1，表示子查询有值。输出0，表示子查询没有值</p>
<p>案例 1：查询有员工的部门名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_name</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> *</span><br><span class="line">	<span class="keyword">FROM</span> employees e</span><br><span class="line">	<span class="keyword">WHERE</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>或者使用WHERE后加IN</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_name</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">WHERE</span> d.<span class="string">`department_id`</span> <span class="keyword">IN</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>案例2：查询没有女朋友的男神信息</p>
<p>in的方式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> bo.*</span><br><span class="line"><span class="keyword">from</span> boys bo</span><br><span class="line"><span class="keyword">where</span> bo.id <span class="keyword">not</span> <span class="keyword">in</span>(</span><br><span class="line">	<span class="keyword">select</span> boyfiend_id</span><br><span class="line">	<span class="keyword">from</span> beauty</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>exists方式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> bo.*</span><br><span class="line"><span class="keyword">from</span> boys bo</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(</span><br><span class="line">	<span class="keyword">select</span> boyfriend_id</span><br><span class="line">	<span class="keyword">from</span> beauty b</span><br><span class="line">	<span class="keyword">where</span> bo.id=b.boyfriend_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="练习题5"><a href="#练习题5" class="headerlink" title="练习题5"></a>练习题5</h3><p>1、查询和Zlotkey相同部门的员工姓名和工资</p>
<p>步骤1：查询Zlotkey的部门</p>
<p>步骤2：查询部门号=步骤1的姓名和工资 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id=(</span><br><span class="line">	<span class="keyword">SELECT</span> department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> last_name=<span class="string">'Zlotkey'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>2、查询工资比公司平均工资高的员工的员工号，姓名和工资</p>
<p>步骤1：查询平均工资</p>
<p>步骤2：查询工资大于步骤1的员工号，姓名和工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> employee_id,last_name,salary</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> salary&gt;(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>3、查询各部门中工资比本部门平均工资高的员工的员工号，姓名和工资</p>
<p>步骤1：查询各部门的平均工资</p>
<p>步骤2：连接步骤1结果集和employee表，进行筛选</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,e.salary,<span class="string">`avg`</span></span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> department_id dep,<span class="keyword">AVG</span>(salary) <span class="string">`avg`</span></span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">) avg_dep</span><br><span class="line"><span class="keyword">ON</span> e.department_id=dep</span><br><span class="line"><span class="keyword">WHERE</span> e.salary &gt; <span class="string">`avg`</span>;</span><br></pre></td></tr></table></figure>

<p>技巧：先要自己知道大概是什么样的结果，再写了去验证</p>
<p>4、查询和姓名中包含字母u的员工在相同部门的员工的员工号和姓名</p>
<p>步骤1：查询姓名中包含u的员工部门（去重）</p>
<p>步骤2：查询部门号=步骤1中任意一个的员工号和姓名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id,last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">'%u%'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>5、查询在部门的location_id为1700的部门工作的员工的员工号</p>
<p>步骤1：查询location_id为1700的部门</p>
<p>步骤2：查询部门号=步骤1中任意一个的员工号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id</span><br><span class="line">	<span class="keyword">FROM</span> departments</span><br><span class="line">	<span class="keyword">WHERE</span> location_id=<span class="number">1700</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>6、查询管理者是King的员工姓名和工资</p>
<p>步骤1：查询姓名为King的员工编号</p>
<p>步骤2：查询哪个员工 的manager_id=步骤1</p>
<p>当不知道用in还是=的时候，用in即可。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> manager_id <span class="keyword">IN</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> employee_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> last_name=<span class="string">'K_ing'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>7、查询工资最高的员工的姓名，要求first_name和last_name显示为一列，列名为姓.名</p>
<p>步骤1：查询最高工资</p>
<p>步骤2：查询工资=步骤1的结果的姓，名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(first_name,<span class="string">'.'</span>,last_name) <span class="string">`姓.名`</span></span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> salary=(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span>  employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="进阶八：分页查询"><a href="#进阶八：分页查询" class="headerlink" title="进阶八：分页查询"></a>进阶八：分页查询</h3><p>应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 查询列表</span><br><span class="line"><span class="keyword">from</span> 表</span><br><span class="line">【<span class="keyword">join</span> <span class="keyword">type</span>  <span class="keyword">join</span> 表<span class="number">2</span></span><br><span class="line"><span class="keyword">on</span> 连接条件</span><br><span class="line"><span class="keyword">where</span>筛选条件</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span>分组字段</span><br><span class="line"><span class="keyword">having</span> 分组后的筛选</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 排序的字段】</span><br><span class="line"><span class="keyword">limit</span> 【<span class="keyword">offset</span>】,<span class="keyword">size</span>;</span><br><span class="line">offset：要显示条目的起始索引（起始索引从0开始）</span><br><span class="line">size：要显示的条目个数</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li><p>limit语句放在查询语句的最后，执行也是最后，select–order by–limit</p>
</li>
<li><p>公式</p>
<p>要显示的页数page，每页的条目数size</p>
<p>select 查询列表</p>
<p>from 表</p>
<p>limit (page-1)*size,size</p>
</li>
</ul>
<p>案例1：查询前五条员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">LIMIT</span> <span class="number">0</span>,<span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">LIMIT</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>offset是可选的</p>
<p>案例2：查询第11条-25条</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">LIMIT</span> <span class="number">10</span>,<span class="number">15</span>;</span><br></pre></td></tr></table></figure>

<p>案例3：有奖金的员工信息，并且工资较高的前10名显示</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="练习题6"><a href="#练习题6" class="headerlink" title="练习题6"></a>练习题6</h3><p>已知表 stuinfo，包含有以下字段</p>
<ul>
<li>id    学号</li>
<li>name姓名</li>
<li>email 邮箱 <a href="mailto:john@126.com">john@126.com</a></li>
<li>gradeId 年级编号</li>
<li>sex 性别 男/女</li>
<li>age 年龄</li>
</ul>
<p>已知表grade</p>
<ul>
<li>id 年级编号</li>
<li>gradeName 年级名称</li>
</ul>
<p>1、查询所有学员邮箱的用户名（注：邮箱中@前面的字符）</p>
<p>select substr(email,1,instr(email,’@’)-1)</p>
<p>from stuinfo;</p>
<p>用到的函数有截取字符串，获取指定字符在字符串中的位置</p>
<p>2、查询男生和女生的个数</p>
<p>select count(*) 个数,sex</p>
<p>from stuinfo</p>
<p>group by sex;</p>
<p>主要为对性别进行分组，然后计数</p>
<p>3、查询年龄&gt;18岁的所有学生的姓名和年级名称</p>
<p>select name,gradeName</p>
<p>from stuinfo s</p>
<p>inner join grade g</p>
<p>on s.gradeId=g.id</p>
<p>where age&gt;18;</p>
<p>考察连接查询</p>
<p>4、查询哪个年级的学生最小年龄&gt;20</p>
<p>步骤1：查询每个年级的最小年龄</p>
<p>select min(age),gradeId</p>
<p>from stuinfo</p>
<p>group by gradeId</p>
<p>步骤2：在步骤1的结果上进行筛选，因此直接加上having判断即可</p>
<p>select min(age) ,gradeId</p>
<p>from stuinfo</p>
<p>group by gradeId</p>
<p>having min(age)&gt;20;</p>
<p>5、说出查询语句中涉及到的所有的关键字，以及执行先后顺序</p>
<p>select 查询列表</p>
<p>from 表                                                </p>
<p>连接类型 join 表2</p>
<p>on    连接条件</p>
<p>where    筛选条件</p>
<p>group by    分组列表</p>
<p>having    分组后的筛选</p>
<p>order by    排序列表</p>
<p>limit 偏移,条目数;</p>
<p>执行顺序：1、from锁定数据源；2、join两表连接生成笛卡尔乘积表；3、on将满足条件的数据过滤出生成新表；4、where在3的基础上筛选生成新表；5、group by分组生成新的虚拟表格；6、having将分组后的表格进行筛选；7、select将筛选完毕后的表选出进行查看；8、order by进行排序；9、limit记性分页显示。</p>
<p>注意：<strong>having后执行的是select</strong>！！！<strong>select在order by前面</strong>！！！</p>
<p>6、查询生日在“1988-1-1”后的学生姓名、专业名称</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`studentname`</span>,<span class="string">`majorname`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span> s</span><br><span class="line"><span class="keyword">JOIN</span> <span class="string">`major`</span> m</span><br><span class="line"><span class="keyword">ON</span> s.<span class="string">`majorid`</span>=m.<span class="string">`majorid`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">DATEDIFF</span>(<span class="string">`borndate`</span>,<span class="string">'1988-1-1'</span>)&gt;<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>生日在某个日期之后，可以使用DATEDIFF函数来判断。或者使用WHERE borndate&gt;’1988-1-1’;也可以。</p>
<p>7、<strong>查询每个专业的男生人数和女生人数分别是多少</strong></p>
<p>方式一：</p>
<p>按照专业和性别进行分组，<strong>多个分组条件用逗号隔开</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) 个数,sex,<span class="string">`majorid`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sex,<span class="string">`majorid`</span></span><br></pre></td></tr></table></figure>

<p>但是这样显示效果不好，不是非常直观</p>
<p>方式二：</p>
<p>希望显示的效果是专业，男生，女神</p>
<p>因此基本语法应该为</p>
<p>select majorid,男，女</p>
<p>from student</p>
<p>group by major id;</p>
<p>然后男生，女生个数 可以使用子查询。如果直接使用select count(*) from student where sex=‘男’或者女，这样查到的人数是总体的，而并不是某个年级的。因此还需要附加条件，加上majorid的限制。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> majorid,</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sex=<span class="string">'男'</span> <span class="keyword">AND</span> majorid=s.majorid) 男,</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sex=<span class="string">'女'</span> <span class="keyword">AND</span> majorid=s.majorid) 女</span><br><span class="line"><span class="keyword">FROM</span> student s</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> majorid;</span><br></pre></td></tr></table></figure>

<img src="/2020/02/09/MySQL/%E7%94%B7%E7%94%9F%E5%A5%B3%E7%94%9F.png" class title="This is an example image">

<p>8、查询专业和张翠山一样的学生的最低分<br>步骤1：查询张翠山的专业</p>
<p>步骤2：查询学生最低分，筛选条件为专业为步骤1结果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(score)</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span> s</span><br><span class="line"><span class="keyword">JOIN</span> <span class="string">`result`</span> r</span><br><span class="line"><span class="keyword">ON</span> s.<span class="string">`studentno`</span>=r.<span class="string">`studentno`</span></span><br><span class="line"><span class="keyword">WHERE</span> s.<span class="string">`majorid`</span>=(</span><br><span class="line">	<span class="keyword">SELECT</span> majorid</span><br><span class="line">	<span class="keyword">FROM</span> student</span><br><span class="line">	<span class="keyword">WHERE</span> <span class="string">`studentname`</span>=<span class="string">'张翠山'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>或者可以先查张翠山专业，然后查哪些编号学生在这个专业中，然后查这些学生的最低分</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(score)</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">result</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`studentno`</span> <span class="keyword">IN</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="string">`studentno`</span></span><br><span class="line">	<span class="keyword">FROM</span> <span class="string">`student`</span></span><br><span class="line">	<span class="keyword">WHERE</span> <span class="string">`majorid`</span>=(</span><br><span class="line">		<span class="keyword">SELECT</span> majorid</span><br><span class="line">		<span class="keyword">FROM</span> student</span><br><span class="line">		<span class="keyword">WHERE</span> <span class="string">`studentname`</span>=<span class="string">'张翠山'</span></span><br><span class="line">	)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>9、查询大于60分的学生的姓名、密码、专业名</p>
<p>使用sql92写法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`studentname`</span>,<span class="string">`loginpwd`</span>,<span class="string">`majorname`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span> s,<span class="string">`result`</span> r,<span class="string">`major`</span> m</span><br><span class="line"><span class="keyword">WHERE</span> s.<span class="string">`studentno`</span>=r.<span class="string">`studentno`</span></span><br><span class="line"><span class="keyword">AND</span> s.<span class="string">`majorid`</span>=m.<span class="string">`majorid`</span></span><br><span class="line"><span class="keyword">AND</span> r.<span class="string">`score`</span>&gt;<span class="number">60</span>;</span><br></pre></td></tr></table></figure>

<p>使用sql99写法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`studentname`</span>,<span class="string">`loginpwd`</span>,<span class="string">`majorname`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span> s</span><br><span class="line"><span class="keyword">JOIN</span> <span class="string">`major`</span> m <span class="keyword">ON</span> s.<span class="string">`majorid`</span>=m.<span class="string">`majorid`</span></span><br><span class="line"><span class="keyword">JOIN</span> <span class="string">`result`</span> r <span class="keyword">ON</span> s.<span class="string">`studentno`</span>=r.<span class="string">`studentno`</span></span><br><span class="line"><span class="keyword">WHERE</span> r.<span class="string">`score`</span>&gt;<span class="number">60</span>;</span><br></pre></td></tr></table></figure>

<p>建议用99写法，更加直观，可读性较高。</p>
<p>10、<strong>按邮箱位数分组，查询每组的学生个数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*),<span class="keyword">LENGTH</span>(email)</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">LENGTH</span>(email);</span><br></pre></td></tr></table></figure>

<p><strong>group by后面也可以接函数</strong>。</p>
<p>11、查询学生名、专业名、分数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`studentname`</span>,<span class="string">`majorname`</span>,<span class="string">`score`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`student`</span> s</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="string">`major`</span> m <span class="keyword">ON</span> s.<span class="string">`majorid`</span>=m.<span class="string">`majorid`</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="string">`result`</span> r <span class="keyword">ON</span> s.<span class="string">`studentno`</span>=r.<span class="string">`studentno`</span></span><br></pre></td></tr></table></figure>

<p>因为有的人分数为空，为了显示所有情况，使用左连接。</p>
<p>12、查询哪个专业没有学生，分别用左连接和右连接实现</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> m.<span class="string">`majorid`</span>,m.<span class="string">`majorname`</span>,s.<span class="string">`studentno`</span></span><br><span class="line"><span class="keyword">FROM</span> major m</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student s</span><br><span class="line"><span class="keyword">ON</span> s.<span class="string">`majorid`</span>=m.<span class="string">`majorid`</span></span><br><span class="line"><span class="keyword">WHERE</span> s.<span class="string">`studentno`</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>专业表为主表，为了显示没有学生即null的情况，需要使用左连接或者右连接（一个表有另一个没有），筛选条件为学生的主键为NULL。</p>
<p>13、查询没有成绩的学生人数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) 学生人数</span><br><span class="line"><span class="keyword">FROM</span> student s</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="string">`result`</span> r</span><br><span class="line"><span class="keyword">ON</span> s.<span class="string">`studentno`</span>=r.<span class="string">`studentno`</span></span><br><span class="line"><span class="keyword">WHERE</span> r.<span class="string">`id`</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>先将没有成绩学生查出来，即用左连接，学生为主表，筛选条件为成绩的主键为空，然后在此基础上统计人数。</p>
<h3 id="子查询经典案例"><a href="#子查询经典案例" class="headerlink" title="子查询经典案例"></a>子查询经典案例</h3><p>1、查询工资最低的员工信息：last_name，salary</p>
<p>步骤1：查询最低工资</p>
<p>步骤2：查询员工信息，要求salary=最低工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary=(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">MIN</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>2、查询平均工资最低的部门信息</p>
<p>方式一：</p>
<p>步骤1：查询各部门的平均工资</p>
<p>步骤2：查询最低的平均工资</p>
<p>步骤3：查询部门编号等于最低平均工资的</p>
<p>步骤4：查询此部门信息</p>
<p>过于麻烦和啰嗦</p>
<p>方式二：</p>
<p>步骤1：查询各部门的平均工资</p>
<p>步骤2：求出最低平均工资的部门编号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">AVG</span>(salary)</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>步骤3：查询部门信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> departments</span><br><span class="line"><span class="keyword">WHERE</span> department_id = (</span><br><span class="line">	<span class="keyword">SELECT</span> department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">AVG</span>(salary)</span><br><span class="line">	<span class="keyword">LIMIT</span> <span class="number">1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>思路：在得到部门与平均工资表后，按照平均工资排序并只要最小的，得到部门编号，效率较高。</p>
<p>方式三：</p>
<p>步骤1：查询各部门的平均工资</p>
<p>步骤2：查询平均工资最低的部门信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary) <span class="string">`平均工资`</span>,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">) avg_dep <span class="keyword">ON</span> d.department_id=avg_dep.department_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`平均工资`</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>思路：得到表后与部门表连接，然后排序后选出1条，效率较低。</p>
<p>3、查询平均工资最低的部门信息和该部门的平均工资</p>
<p>查询出最低工资及部门编号的表，和部门表进行连接输出</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> d.*,ag</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">JOIN</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary) ag,department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">AVG</span>(salary)</span><br><span class="line">	<span class="keyword">LIMIT</span> <span class="number">1</span></span><br><span class="line">) avg_dep </span><br><span class="line"><span class="keyword">ON</span> d.department_id=avg_dep.department_id;</span><br></pre></td></tr></table></figure>

<p>表子查询及连接的方式</p>
<p>4、查询平均工资最高的job信息</p>
<p>步骤1：查询每个job的平均工资（先排序，再limit）</p>
<p>步骤2：找到最高的平均工资的job_id</p>
<p>步骤3：得到此job信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> jobs</span><br><span class="line"><span class="keyword">WHERE</span> job_id = (</span><br><span class="line">	<span class="keyword">SELECT</span> job_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id</span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">AVG</span>(salary) <span class="keyword">DESC</span></span><br><span class="line">	<span class="keyword">LIMIT</span> <span class="number">1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>5、查询平均工资高于公司平均工资的部门有哪些</p>
<p>步骤1：查询公司平均工资</p>
<p>步骤2：查询每个部门的平均工资表，筛选条件为工资大于平均工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary) ag,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> ag &gt;(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary)</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>6、查询出公司中所有manager的详细信息</p>
<p>方式一：</p>
<p>两个表自连接，输出m表的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> m.*</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> employees m</span><br><span class="line"><span class="keyword">ON</span> e.manager_id=m.employee_id;</span><br></pre></td></tr></table></figure>

<p>方式二：</p>
<p>步骤1：查询出所有的manager_id</p>
<p>步骤2：查询员工信息，需要满足employee_id在步骤1的结果中</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="keyword">IN</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> manager_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>查询结果：自连接更快</p>
<p>7、各个部门中，最高工资中最低的那个部门的最低工资是多少 </p>
<p>步骤1：选出各个部门的最高工资</p>
<p>步骤2：找到最高工资最低的部门编号（order by,limit）</p>
<p>步骤3：得到id=步骤2的部门的最低工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id = (</span><br><span class="line">	<span class="keyword">SELECT</span> department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">MAX</span>(salary) <span class="keyword">ASC</span></span><br><span class="line">	<span class="keyword">LIMIT</span> <span class="number">1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>8、查询平均工资最高的部门的manager的详细信息：last_name，department_id，email，salary</p>
<p>方法一：</p>
<p>步骤1：查询平均工资最高的部门Id</p>
<p>步骤2：在departments表中找到id=步骤1结果的manager_id</p>
<p>步骤3：查询em_id=步骤2结果中的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,department_id,email,salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id = (</span><br><span class="line">	<span class="keyword">SELECT</span> manager_id</span><br><span class="line">	<span class="keyword">FROM</span> departments</span><br><span class="line">	<span class="keyword">WHERE</span> department_id = (</span><br><span class="line">		<span class="keyword">SELECT</span> department_id</span><br><span class="line">		<span class="keyword">FROM</span> employees</span><br><span class="line">		<span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">		<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">AVG</span>(salary) <span class="keyword">DESC</span></span><br><span class="line">		<span class="keyword">LIMIT</span> <span class="number">1</span></span><br><span class="line">	)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<p>步骤1：查询平均工资最高的部门Id</p>
<p>步骤2：将员工表和部门表进行连接，筛选条件为步骤1结果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,d.department_id,email,salary</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.employee_id=d.manager_id</span><br><span class="line"><span class="keyword">WHERE</span> e.department_id=(</span><br><span class="line">	<span class="keyword">SELECT</span> department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">AVG</span>(salary) <span class="keyword">DESC</span></span><br><span class="line">	<span class="keyword">LIMIT</span> <span class="number">1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>两表连接效率比较低，执行时间比方式一更长。</p>
<h3 id="进阶九：union联合查询"><a href="#进阶九：union联合查询" class="headerlink" title="进阶九：union联合查询"></a>进阶九：union联合查询</h3><p>union：联合，合并，将多条查询语句结果合成一个结果</p>
<p>引入案例：查询部门编号&gt;90或邮箱中包含a的员工信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id&gt;<span class="number">90</span> <span class="keyword">OR</span> email <span class="keyword">LIKE</span> <span class="string">'%a%'</span>;</span><br></pre></td></tr></table></figure>

<p>如果使用union</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id&gt;<span class="number">90</span> </span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> email <span class="keyword">LIKE</span> <span class="string">'%a%'</span>;</span><br></pre></td></tr></table></figure>

<p>语法：</p>
<p>查询语句1</p>
<p>union</p>
<p>查询语句2</p>
<p>union</p>
<p>…</p>
<p>应用场景：要查询的结果来自多个表，且多个表没有直接的连接关系，但查询的信息一致时</p>
<p>特点：</p>
<ol>
<li>要求多条查询语句的查询列数是一致的</li>
<li>要求多条查询语句的查询的每一列的类型和顺序最好是一致的</li>
<li>使用union关键字默认去重，如果使用<strong>union all</strong>可以包含重复项</li>
</ol>
<h3 id="查询总结"><a href="#查询总结" class="headerlink" title="查询总结"></a>查询总结</h3><p>select 查询列表                       7</p>
<p>from 表1 别名                         1</p>
<p>连接类型 join 表2 别名          2</p>
<p>on 连接条件                            3</p>
<p>where 筛选                             4</p>
<p>group by 分组列表                 5</p>
<p>having 筛选                            6</p>
<p>order by 排序列表                 8</p>
<p>limit offset,limit;                    9</p>
<p>group by和having别名使用相对较少。select *输出全部信息，但实际为了可读性，最好写完整对应列。</p>
<h2 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h2><p>数据操作语言</p>
<ul>
<li>插入：insert</li>
<li>修改：update</li>
<li>删除：delete</li>
</ul>
<h3 id="插入语句"><a href="#插入语句" class="headerlink" title="插入语句"></a>插入语句</h3><h4 id="方式一：经典插入"><a href="#方式一：经典插入" class="headerlink" title="方式一：经典插入"></a>方式一：经典插入</h4><p>语法：</p>
<p>insert into 表名(列名,…) values(值1,…),(值2,…),…;</p>
<p>1、插入的值的类型要与列的类型一致或兼容</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(<span class="keyword">id</span>,<span class="keyword">NAME</span>,sex,borndate,phone,photo,boyfriend_id) </span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">13</span>,<span class="string">'唐艺昕'</span>,<span class="string">'女'</span>,<span class="string">'1990-4-23'</span>,<span class="string">'18988888888'</span>,<span class="literal">NULL</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>如果插入数据是‘1234’也可以插入到int列中，可以隐式转换。</p>
<p>2、不可以为null的列必须插入值，可以为null的列如何插入值</p>
<p>方式一：值直接写null</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(<span class="keyword">id</span>,<span class="keyword">NAME</span>,sex,borndate,phone,photo,boyfriend_id) </span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">13</span>,<span class="string">'唐艺昕'</span>,<span class="string">'女'</span>,<span class="string">'1990-4-23'</span>,<span class="string">'18988888888'</span>,<span class="literal">NULL</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>方式二：列和值均不写</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(<span class="keyword">id</span>,<span class="keyword">NAME</span>,sex,borndate,phone,boyfriend_id) </span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">14</span>,<span class="string">'金星'</span>,<span class="string">'女'</span>,<span class="string">'1990-4-23'</span>,<span class="string">'13888888888'</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>photo列和值均被省略</p>
<p>3、列的顺序可以调换，但要一一对应</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(<span class="keyword">NAME</span>,sex,<span class="keyword">id</span>,phone)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'蒋欣'</span>,<span class="string">'女'</span>,<span class="number">16</span>,<span class="string">'123'</span>);</span><br></pre></td></tr></table></figure>

<p>4、列数和值的个数必须一致</p>
<p>5、可以省略列名，默认所有列，而且列的顺序和表中的顺序一致</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">18</span>,<span class="string">'张飞'</span>,<span class="string">'男'</span>,<span class="literal">NULL</span>,<span class="string">'1212'</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<h4 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h4><p>语法：</p>
<p>insert into 表名</p>
<p>set 列名=值,列名=值,…</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">id</span>=<span class="number">19</span>,<span class="keyword">NAME</span>=<span class="string">'刘涛'</span>,phone=<span class="string">'9001'</span>;</span><br></pre></td></tr></table></figure>

<h4 id="两种方式比较"><a href="#两种方式比较" class="headerlink" title="两种方式比较"></a>两种方式比较</h4><p>1、方式一支持插入多行，方式二不支持</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(<span class="keyword">id</span>,<span class="keyword">NAME</span>,sex,borndate,phone,photo,boyfriend_id) </span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">23</span>,<span class="string">'唐艺昕1'</span>,<span class="string">'女'</span>,<span class="string">'1990-4-23'</span>,<span class="string">'18988888888'</span>,<span class="literal">NULL</span>,<span class="number">2</span>)</span><br><span class="line">,(<span class="number">24</span>,<span class="string">'唐艺昕2'</span>,<span class="string">'女'</span>,<span class="string">'1990-4-23'</span>,<span class="string">'18988888888'</span>,<span class="literal">NULL</span>,<span class="number">2</span>)</span><br><span class="line">,(<span class="number">25</span>,<span class="string">'唐艺昕3'</span>,<span class="string">'女'</span>,<span class="string">'1990-4-23'</span>,<span class="string">'18988888888'</span>,<span class="literal">NULL</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>在values后用逗号隔开，然后加括号写要插入的值。</p>
<p>2、方式一支持子查询，方式二不支持</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(<span class="keyword">id</span>,<span class="keyword">NAME</span>,phone) </span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">26</span>,<span class="string">'宋茜'</span>,<span class="string">'183298'</span>;</span><br></pre></td></tr></table></figure>

<p>这样也可以实现插入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> beauty(<span class="keyword">id</span>,<span class="keyword">NAME</span>,phone) </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,boyname,<span class="string">'1423432'</span></span><br><span class="line"><span class="keyword">FROM</span> boys</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span>&lt;<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h3 id="修改语句"><a href="#修改语句" class="headerlink" title="修改语句"></a>修改语句</h3><h4 id="修改单表的记录【重要】"><a href="#修改单表的记录【重要】" class="headerlink" title="修改单表的记录【重要】"></a>修改单表的记录【重要】</h4><p>语法：</p>
<p>update 表名</p>
<p>set 列=新值，列=新值,…</p>
<p>where 筛选条件;</p>
<p>案例1：修改beauty表中姓唐的女神电话为13888888888</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> beauty <span class="keyword">SET</span> phone=<span class="string">'13888888888'</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NAME</span> <span class="keyword">LIKE</span> <span class="string">'唐%'</span>;</span><br></pre></td></tr></table></figure>

<p>案例2：修改boys表中id号为2的名称为张飞，魅力值为10</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> boys <span class="keyword">SET</span> boyName=<span class="string">'张飞'</span>,userCp=<span class="number">10</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h4 id="修改多表的记录【补充】"><a href="#修改多表的记录【补充】" class="headerlink" title="修改多表的记录【补充】"></a>修改多表的记录【补充】</h4><p>语法：</p>
<p>sql92语法</p>
<p>update 表1 别名，表2 别名</p>
<p>set 列=值,….</p>
<p>where 连接条件</p>
<p>and 筛选条件;</p>
<p>sql99语法</p>
<p><strong>update 表1 别名</strong></p>
<p><strong>inner|left|right|full join 表2 别名</strong></p>
<p><strong>on 连接条件</strong></p>
<p><strong>set 列=值,….</strong></p>
<p><strong>where 筛选条件;</strong></p>
<p>案例1：修改张无忌的女朋友的手机号为114</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> boys bo</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> beauty b</span><br><span class="line"><span class="keyword">ON</span> bo.<span class="string">`id`</span>=b.<span class="string">`boyfriend_id`</span></span><br><span class="line"><span class="keyword">SET</span> b.<span class="string">`phone`</span>=<span class="string">'114'</span></span><br><span class="line"><span class="keyword">WHERE</span> bo.<span class="string">`boyName`</span>=<span class="string">'张无忌'</span>;</span><br></pre></td></tr></table></figure>

<p>案例2：修改没有男朋友的女神的男朋友编号都为2号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> boys bo</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> beauty b</span><br><span class="line"><span class="keyword">ON</span> bo.<span class="string">`id`</span>=b.<span class="string">`boyfriend_id`</span></span><br><span class="line"><span class="keyword">SET</span> b.<span class="string">`boyfriend_id`</span>=<span class="number">2</span></span><br><span class="line"><span class="keyword">WHERE</span> bo.<span class="string">`id`</span> <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>筛选条件为从表的主键为空</p>
<h3 id="删除语句"><a href="#删除语句" class="headerlink" title="删除语句"></a>删除语句</h3><p>方式一：delete</p>
<p>语法：</p>
<ol>
<li><p>单表的删除【重点】</p>
<p>delete from 表名【 where 筛选条件】【limit 条目数】</p>
<p>筛选条件是可选的，如果不写删除条件，就是删除整个表数据。</p>
</li>
<li><p>多表的删除【补充】</p>
<ul>
<li><p>sql92语法</p>
<p>delete 删除表的别名 【，表2的别名，…】</p>
<p>from 表1 别名，表2 别名</p>
<p>where 连接条件</p>
<p>and 筛选条件;</p>
</li>
<li><p>sql99语法</p>
<p>delete 表1的别名【,表2的别名】</p>
<p>from 表1 别名</p>
<p>inner|left|right join 表2 别名 on 连接条件</p>
<p>where 筛选条件;</p>
</li>
</ul>
</li>
</ol>
<p>方式二：truncate</p>
<p>语法：truncate table 表名</p>
<p>清空数据，不能加where，将表中信息全部删除</p>
<h4 id="方式一：delete"><a href="#方式一：delete" class="headerlink" title="方式一：delete"></a>方式一：delete</h4><p>1、单表的删除</p>
<p>案例：删除手机号以9结尾的女神信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> beauty <span class="keyword">WHERE</span> phone <span class="keyword">LIKE</span> <span class="string">'%9'</span>;</span><br></pre></td></tr></table></figure>

<p>delete 和from 之间不能加列，删除的是一整行的信息。</p>
<p>2、多表 的删除</p>
<p>案例1：删除张无忌的女朋友的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除哪个表信息就delete那个表</span></span><br><span class="line"><span class="keyword">DELETE</span> b</span><br><span class="line"><span class="keyword">FROM</span> boys bo</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> beauty b <span class="keyword">ON</span> bo.<span class="string">`id`</span>=b.<span class="string">`boyfriend_id`</span></span><br><span class="line"><span class="keyword">WHERE</span> bo.<span class="string">`boyName`</span>=<span class="string">'张无忌'</span>;</span><br></pre></td></tr></table></figure>

<p>案例2：删除黄晓明的信息及他女朋友的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> bo,b</span><br><span class="line"><span class="keyword">FROM</span> beauty b</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> boys bo <span class="keyword">ON</span> b.<span class="string">`boyfriend_id`</span>=bo.<span class="string">`id`</span></span><br><span class="line"><span class="keyword">WHERE</span> bo.<span class="string">`boyName`</span>=<span class="string">'黄晓明'</span>;</span><br></pre></td></tr></table></figure>

<p>将要删除的表写在delete后面。</p>
<h4 id="方式二：truncate语句"><a href="#方式二：truncate语句" class="headerlink" title="方式二：truncate语句"></a>方式二：truncate语句</h4><p>案例：将魅力值&gt;100的男神信息删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> boys;</span><br></pre></td></tr></table></figure>

<p>不能加where筛选，只能把表全部删除。</p>
<h4 id="两种方式比较【面试题，重要】"><a href="#两种方式比较【面试题，重要】" class="headerlink" title="两种方式比较【面试题，重要】"></a>两种方式比较【面试题，重要】</h4><ol>
<li>delete 可以加where条件，truncate不能加</li>
<li>truncate删除，效率高一点</li>
<li>加入要删除的表中有自增长列，用<strong>delete</strong>删除后，再插入数据，<strong>自增长列的值从断点开始</strong>；而用<strong>truncate</strong>删除后，再插入数据，<strong>自增长列的值从1</strong>开始</li>
<li><strong>truncate</strong>删除<strong>没有返回值</strong>，<strong>delete</strong>删除<strong>有返回值</strong></li>
<li>truncate删除不能回滚，delete删除可以回滚</li>
</ol>
<h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><p>1、插入语法的两种方式</p>
<p>方式一：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> my_employees</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'patel'</span>,<span class="string">'Ralph'</span>,<span class="string">'Rpatel'</span>,<span class="number">895</span>)</span><br><span class="line">,(<span class="number">2</span>,<span class="string">'Dancs'</span>,<span class="string">'Betty'</span>,<span class="string">'Bdancs'</span>,<span class="number">860</span>)</span><br><span class="line">,(<span class="number">3</span>,<span class="string">'Biri'</span>,<span class="string">'Ben'</span>,<span class="string">'Bbiri'</span>,<span class="number">1100</span>)</span><br><span class="line">,(<span class="number">4</span>,<span class="string">'Newman'</span>,<span class="string">'Chad'</span>,<span class="string">'Cnewman'</span>,<span class="number">750</span>)</span><br><span class="line">,(<span class="number">5</span>,<span class="string">'Ropeburn'</span>,<span class="string">'Audrey'</span>,<span class="string">'Aropebur'</span>,<span class="number">1550</span>);</span><br></pre></td></tr></table></figure>

<p>方式二：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> my_employees</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span>,<span class="string">'patel'</span>,<span class="string">'Ralph'</span>,<span class="string">'Rpatel'</span>,<span class="number">895</span> <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">2</span>,<span class="string">'Dancs'</span>,<span class="string">'Betty'</span>,<span class="string">'Bdancs'</span>,<span class="number">860</span> <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">3</span>,<span class="string">'Biri'</span>,<span class="string">'Ben'</span>,<span class="string">'Bbiri'</span>,<span class="number">1100</span> <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">4</span>,<span class="string">'Newman'</span>,<span class="string">'Chad'</span>,<span class="string">'Cnewman'</span>,<span class="number">750</span> <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">5</span>,<span class="string">'Ropeburn'</span>,<span class="string">'Audrey'</span>,<span class="string">'Aropebur'</span>,<span class="number">1550</span>;</span><br></pre></td></tr></table></figure>

<p>insert into后面可以跟select语句，利用union将多条select语句变为一条，最后一个select后不用加union。</p>
<p>2、将3号员工的last_name修改为“drelxer”</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> my_employees</span><br><span class="line"><span class="keyword">SET</span> Last_name=<span class="string">'drelxer'</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>3、将userid 为Bbiri的user表和my_employees表的记录全部删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> my,us</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">users</span> us</span><br><span class="line"><span class="keyword">JOIN</span> my_employees my <span class="keyword">ON</span> us.<span class="string">`userid`</span>=my.<span class="string">`Userid`</span></span><br><span class="line"><span class="keyword">WHERE</span> us.<span class="string">`userid`</span>=<span class="string">'Bbiri'</span>;</span><br></pre></td></tr></table></figure>

<p>4、检查表所做的修正</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> my_employees;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span>;</span><br></pre></td></tr></table></figure>

<h2 id="DDL语言"><a href="#DDL语言" class="headerlink" title="DDL语言"></a>DDL语言</h2><p>数据定义语言，库和表的管理</p>
<p>1、库的管理</p>
<p>创建、修改、删除</p>
<p>2、表的管理</p>
<p>创建、修改、删除</p>
<p>与数据操作语言区分，这里管理的是表的结构，而不是数据</p>
<ul>
<li>创建：create</li>
<li>修改：alter</li>
<li>删除：drop</li>
</ul>
<h3 id="库的管理"><a href="#库的管理" class="headerlink" title="库的管理"></a>库的管理</h3><h4 id="库的创建"><a href="#库的创建" class="headerlink" title="库的创建"></a>库的创建</h4><p>语法：</p>
<p>create database 【if not exsits】库名 【character set 字符集名】;</p>
<p>案例：创建库books</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> books;</span><br></pre></td></tr></table></figure>

<p>但是这样创建完成后，再次执行会报错，采用下面语句提高语句容错性</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> books;</span><br></pre></td></tr></table></figure>

<h4 id="库的修改"><a href="#库的修改" class="headerlink" title="库的修改"></a>库的修改</h4><p><strong>基本不修改</strong></p>
<p>库名不能使用sql语句去修改</p>
<p>可以更改库的字符集</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> books <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> gbk;</span><br></pre></td></tr></table></figure>

<h4 id="库的删除"><a href="#库的删除" class="headerlink" title="库的删除"></a>库的删除</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> books;</span><br></pre></td></tr></table></figure>

<p>存在才删除</p>
<h3 id="表的管理"><a href="#表的管理" class="headerlink" title="表的管理"></a>表的管理</h3><h4 id="表的创建【重要】"><a href="#表的创建【重要】" class="headerlink" title="表的创建【重要】"></a>表的创建【重要】</h4><p>create table 【if not exists】表名(</p>
<p>​    列名 列的类型【（长度）约束】，</p>
<p>​    列名 列的类型【（长度）约束】，</p>
<p>​    ….</p>
<p>​    列名 列的类型【（长度）约束】</p>
<p>);</p>
<p>案例：创建表book</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span>,<span class="comment">#编号</span></span><br><span class="line">	bName <span class="built_in">VARCHAR</span>(<span class="number">20</span>),<span class="comment">#书名</span></span><br><span class="line">	price <span class="keyword">DOUBLE</span>,<span class="comment">#价格</span></span><br><span class="line">	authorId <span class="built_in">INT</span>,<span class="comment">#作者编号</span></span><br><span class="line">	publishDate DATETIME<span class="comment">#出版日期</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>不同字段用逗号隔开，最后个不用加逗号。</p>
<h4 id="表的修改"><a href="#表的修改" class="headerlink" title="表的修改"></a>表的修改</h4><p><strong>alter table 表名 add|drop|modify|change column 列名 【列类型 约束】;</strong></p>
<p>1、修改列名</p>
<p>alter table 表名 change column 旧列名 新列名 新列名类型</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book <span class="keyword">CHANGE</span> <span class="keyword">COLUMN</span> publishDate pubDate DATETIME;</span><br></pre></td></tr></table></figure>

<p>change column要求加上新的列名和类型。column可以省略。</p>
<p>2、修改列的类型或约束</p>
<p>alter table 表名 modify column 列名 新类型 【新约束】</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> pubDate <span class="built_in">TIMESTAMP</span> 【新约束】;</span><br></pre></td></tr></table></figure>

<p>用到的为modify。</p>
<p>3、添加新列</p>
<p>默认添加在最后列，可以自己指定位置。在最开头，使用first，在某个字段后面，使用after字段名。</p>
<p>alter table 表名 add column 列名 类型 【first|after 字段名】</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> author <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> annual <span class="keyword">DOUBLE</span> 【<span class="keyword">first</span>|<span class="keyword">after</span> 字段名】;</span><br></pre></td></tr></table></figure>

<p>用到的为add。同样需要加上类型。</p>
<p>4、删除列</p>
<p>alter table 表名 drop column 列名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> annual;</span><br></pre></td></tr></table></figure>

<p>用到的为drop，这时候就不需要指定类型了。</p>
<p>5、修改表名</p>
<p>alter table 表名 rename 【to】新表名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> author <span class="keyword">RENAME</span> <span class="keyword">TO</span> book_author;</span><br></pre></td></tr></table></figure>

<h4 id="表的删除"><a href="#表的删除" class="headerlink" title="表的删除"></a>表的删除</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> 【<span class="keyword">IF</span> <span class="keyword">EXISTS</span>】 book_author;</span><br></pre></td></tr></table></figure>

<p>通用写法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> 旧库名;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> 新库名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> 旧库名;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名();</span><br></pre></td></tr></table></figure>

<h4 id="表的复制"><a href="#表的复制" class="headerlink" title="表的复制"></a>表的复制</h4><p>1、仅复制表的结构</p>
<p>create table 表名 like 旧表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> copy <span class="keyword">LIKE</span> author;</span><br></pre></td></tr></table></figure>

<p>没有复制内容。</p>
<p>2、复制表的结构+数据</p>
<p>create table 表名</p>
<p>select 查询列表 from 表 【where 筛选】</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> copy2 </span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> author;</span><br></pre></td></tr></table></figure>

<p>后面跟select查询语句</p>
<p>复制部门数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> copy3</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,au_name</span><br><span class="line"><span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">WHERE</span> nation=<span class="string">'中国'</span>;</span><br></pre></td></tr></table></figure>

<p>仅复制某些字段</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> copy4</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>,au_name</span><br><span class="line"><span class="keyword">FROM</span> author</span><br><span class="line"><span class="keyword">WHERE</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>利用where 0来获取数据。</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>1、将其他库中的表信息复制进当前库中的表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept2</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">`department_id`</span>,<span class="string">`department_name`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`myemployees`</span>.<span class="string">`departments`</span>;</span><br></pre></td></tr></table></figure>

<p>使用库名.表名来进行调用。利用create后面+select子查询。</p>
<p>2、复制其他库中表的结构</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees2 <span class="keyword">LIKE</span> <span class="string">`myemployees`</span>.employees;</span><br></pre></td></tr></table></figure>

<p>3、删除表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> emp5;</span><br></pre></td></tr></table></figure>

<h3 id="常见的数据类型"><a href="#常见的数据类型" class="headerlink" title="常见的数据类型"></a>常见的数据类型</h3><ul>
<li>数值型<ul>
<li>整数</li>
<li>小数<ul>
<li>定点数</li>
<li>浮点数</li>
</ul>
</li>
</ul>
</li>
<li>字符型<ul>
<li>较短的文本：char,varchar</li>
<li>较长的文本：text，blob（较长的二进制数据）</li>
</ul>
</li>
<li>日期型</li>
</ul>
<h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><p>所选择的类型越简单越好，能保存数值的类型越小越好</p>
<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>分类：</p>
<p>tinyint（1字节）、smallint（2字节）、mediumint（3字节）、int/integer（4字节）、bigint（8字节）</p>
<p>特点：</p>
<ol>
<li><p>如果不设置有符号还是无符号，默认是有符号，如果要设置无符号，加上关键字unsigned</p>
</li>
<li><p>如果插入的数值超出了整形的范围，会报out of range异常，并且插入临界值</p>
<p>临界值为对应允许范围内最接近插入值的值如果tinyint范围是-128-127，插入-129，存入-128；插入128，存入127</p>
</li>
<li><p>如果不设置长度，会有默认长度</p>
<p>宽度效果为：如果数据长度没有达到指定长度，则在左方用0补齐，需要搭配关键字<strong>zerofill</strong>使用，此时整形默认变为<strong>无符号</strong>类型</p>
</li>
</ol>
<p>1、设置无符号和有符号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_int (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">	id2 <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h4><p>分类</p>
<ol>
<li>浮点型<ul>
<li>float(M,D)  4字节</li>
<li>double(M,D) 8字节</li>
</ul>
</li>
<li>定点型<ul>
<li>dec(M,D)  M+2字节，最大取值范围与double相同</li>
<li>decimal(M,D)</li>
</ul>
</li>
</ol>
<p>特点：</p>
<ol>
<li><p>M：整数部位+小数部位的总长度</p>
<p>D：小数部位</p>
<p>如果超过范围，则插入临界值</p>
</li>
<li><p>M和D都可以省略</p>
<p>如果是decimal，则M默认是10，D默认是0</p>
<p>如果是float和double，则会根据插入数值的精度来决定精度</p>
</li>
<li><p>定点型的精确度较高，如果要求插入数值的精度较高，如货币运算则考虑使用</p>
</li>
</ol>
<h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><p>分类：</p>
<p>较短的文本：char、varchar【必须加单引号！！！】</p>
<p>其他：</p>
<p>binary和varbiary用于保存较短的二进制</p>
<p>enum用于保存枚举</p>
<p>set用于保存集合</p>
<p>较长的文本：text、blob（较大的二进制数据）</p>
<p>特点：</p>
<h5 id="char和varchar类型【重要】"><a href="#char和varchar类型【重要】" class="headerlink" title="char和varchar类型【重要】"></a>char和varchar类型【重要】</h5><table>
<thead>
<tr>
<th>字符串类型</th>
<th>最多字符数</th>
<th>描述及存储需求</th>
<th>空间耗费</th>
<th>效率</th>
</tr>
</thead>
<tbody><tr>
<td>char(M)</td>
<td>M，可以省略，默认为1</td>
<td>M为0-255之间的整数</td>
<td>固定长度字符，比较耗费空间</td>
<td>高</td>
</tr>
<tr>
<td>varchar(M)</td>
<td>M，不可省略</td>
<td>M为0-65535之间的整数</td>
<td>可变长度字符，比较节省空间</td>
<td>低</td>
</tr>
</tbody></table>
<p>M为字符，一个汉字或者一个英文字符均为1字符。char固定长度，代表所有字符均用统一长度存储；varchar可变长度，代表存储长度随数据具体情况而变化。如果字符长度较为固定，用char，如性别；如果字符长度变化较大，用varchar，如姓名。</p>
<h5 id="binary和varbinary类型"><a href="#binary和varbinary类型" class="headerlink" title="binary和varbinary类型"></a>binary和varbinary类型</h5><p>类似于char和varchar，不同的是它们包含二进制字符串而不包含非二进制字符串</p>
<h5 id="Enum类型"><a href="#Enum类型" class="headerlink" title="Enum类型"></a>Enum类型</h5><p>枚举类型，要求插入的值必须属于列表中指定的值之一。如果列表成员为1~255，则需要1个字节存储，如果列表成员为255-65535，则需要2个字节存储，最多需要65535个成员！</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">c1 Enum('a','b','c');</span><br></pre></td></tr></table></figure>

<p>如果插入为对应的大写，保存为小写。如果插入类型不在枚举类型中，插入为空。</p>
<h5 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h5><p>说明：和ENUM类型类似，里面可以保存0~64个成员。和ENUM类型最大的区别是：SET类型一次可以选<strong>取多个成员</strong>，而ENUM只能选一个<br>根据成员个数不同，存储所占的字节也不同</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">s1 <span class="keyword">SET</span>(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_set <span class="keyword">values</span>(<span class="string">'a,b,c'</span>)</span><br></pre></td></tr></table></figure>

<p>同样不区分大小写。</p>
<h4 id="日期型"><a href="#日期型" class="headerlink" title="日期型"></a>日期型</h4><p>分类：</p>
<p>date 只保存日期</p>
<p>time 只保存时间</p>
<p>year 只保存年</p>
<p>datetime 保存日期+时间</p>
<p>timestamp 保存日期+时间</p>
<p>特点：</p>
<table>
<thead>
<tr>
<th></th>
<th>字节</th>
<th>范围</th>
<th>时区的影响</th>
</tr>
</thead>
<tbody><tr>
<td>datetime</td>
<td>8</td>
<td>1000-9999</td>
<td>不受</td>
</tr>
<tr>
<td>timestamp</td>
<td>4</td>
<td>1970-2038</td>
<td>受</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>日期和时间类型</th>
<th>字节</th>
<th>最小值</th>
<th>最大值</th>
</tr>
</thead>
<tbody><tr>
<td>date</td>
<td>4</td>
<td>1000-01-01</td>
<td>9999-12-31</td>
</tr>
<tr>
<td>datetime</td>
<td>8</td>
<td>1000-01-01 00:00:00</td>
<td>9999-12-31 23:59:59</td>
</tr>
<tr>
<td>timestam</td>
<td>4</td>
<td>19700101080001</td>
<td>2038年的某个时刻</td>
</tr>
<tr>
<td>time</td>
<td>3</td>
<td>-838:59:59</td>
<td>838:59:59</td>
</tr>
<tr>
<td>year</td>
<td>1</td>
<td>1901</td>
<td>2155</td>
</tr>
</tbody></table>
<p>重点为datatime和timestam。</p>
<h5 id="datetime和timestamp区别"><a href="#datetime和timestamp区别" class="headerlink" title="datetime和timestamp区别"></a>datetime和timestamp区别</h5><p>1、<strong>Timestamp</strong>支持的时间<strong>范围较小</strong>，取值范围：<br>    19700101080001——2038年的某个时间<br>    Datetime的取值范围：1000-1-1 ——9999-12-31<br>2、timestamp和<strong>实际时区</strong>有关，更能反映<strong>实际的日期</strong>，而datetime则只能反映出<strong>插入时的当地时区</strong><br>3、timestamp的属性受Mysql版本和SQLMode的影响很大</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_date(</span><br><span class="line">	t1 DATETIME,</span><br><span class="line">	t2 <span class="built_in">TIMESTAMP</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_date <span class="keyword">VALUES</span>(<span class="keyword">NOW</span>(),<span class="keyword">NOW</span>());</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tab_date;</span><br></pre></td></tr></table></figure>

<p>这时候出来结果相同，但是当更改时区后</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">time_zone</span>=<span class="string">'+9:00'</span>;<span class="comment">#从东八更改为东九</span></span><br></pre></td></tr></table></figure>

<p>这时候，timestamp类型数据存储的时间比datetime存储的时间快一个小时，随着时区而变化了。</p>
<h3 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h3><p>含义：一种限制，用于限制表中的数据，为了保证表中数据的准确和可靠性</p>
<p>分类：六大约束</p>
<ul>
<li><p>NOT NULL：非空，用于保证该字段的值不能为空</p>
<p>如姓名，学号等</p>
</li>
<li><p>DEFAULT：默认，用于保证该字段有默认值</p>
<p>如性别</p>
</li>
<li><p>PRIMARY KEY：主键，用于保证该字段的值有<strong>唯一性</strong>，且要<strong>非空</strong></p>
<p>如学号，员工编号等，可以多个列组合成一个主键</p>
<p>primary key(id,stuname)，插入值要求不能所有组成主键的列相同</p>
</li>
<li><p>UNIQUE：唯一，用于保证该字段的值具有唯一性，可以为空</p>
<p>如座位号，但<strong>最多只能有一个为空</strong></p>
</li>
<li><p>CHECK：检查约束【mysql不支持】</p>
<p>比如年龄，性别</p>
</li>
<li><p>FOREIGN KEY：外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值</p>
<p>在从表添加外键约束，用于引用主表中某列的值</p>
<p>如专业编号，员工表的部门编号，员工表的工种编号</p>
</li>
</ul>
<p><strong>一个字段可以添加多个约束，用空格隔开，无顺序要求</strong></p>
<p>添加约束的时机：</p>
<ol>
<li>创建表时</li>
<li>修改表时</li>
</ol>
<p>约束的添加分类：</p>
<ol>
<li><p>列级约束</p>
<p>六大约束语法上都支持，但外键约束没有效果</p>
</li>
<li><p>表级约束</p>
<p>除了<strong>非空</strong>，<strong>默认</strong>，其他都支持</p>
</li>
</ol>
<p>CREATE TABLE 表名(</p>
<p>​    字段名 字段类型 列级约束，</p>
<p>​    字段名 字段类型，</p>
<p>​    表级约束</p>
<p>)</p>
<h4 id="列级约束与表级约束"><a href="#列级约束与表级约束" class="headerlink" title="列级约束与表级约束"></a>列级约束与表级约束</h4><table>
<thead>
<tr>
<th></th>
<th>位置</th>
<th>支持的约束类型</th>
<th>是否可以起约束名</th>
</tr>
</thead>
<tbody><tr>
<td>列级约束</td>
<td>列的后面</td>
<td>语法都支持，但外键没有效果</td>
<td>不可以</td>
</tr>
<tr>
<td>表级约束</td>
<td>所有列下面</td>
<td>默认和非空不支持，其他支持</td>
<td>可以（对主键没有效果）</td>
</tr>
</tbody></table>
<h4 id="主键和唯一的对比【面试考-，重要】"><a href="#主键和唯一的对比【面试考-，重要】" class="headerlink" title="主键和唯一的对比【面试考 ，重要】"></a>主键和唯一的对比【面试考 ，重要】</h4><table>
<thead>
<tr>
<th></th>
<th>保证唯一性</th>
<th>是否允许为空</th>
<th>一个表中可以有多少个</th>
<th>是否允许组合</th>
</tr>
</thead>
<tbody><tr>
<td>主键</td>
<td>是</td>
<td>否</td>
<td>至多有1个</td>
<td>是，但不推荐</td>
</tr>
<tr>
<td>唯一</td>
<td>是</td>
<td>是，但最多一个为空</td>
<td>可以有多个</td>
<td>是，但不推荐</td>
</tr>
</tbody></table>
<h4 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h4><ol>
<li>要求在从表设置外键关系</li>
<li>从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求</li>
<li>主表的关联列<strong>必须是一个key</strong>（一般是<strong>主键</strong>或唯一）</li>
<li>插入数据时，先插入主表，再插入从表</li>
<li>删除数据时，先删除从表，再删除主表</li>
</ol>
<p>可通过以下两种方式删除主表的记录</p>
<p>方式一：级联删除</p>
<p>一般直接删除主表的信息不行因为要先删除从表，但加上级联删除后，直接删除主表信息后，从表信息也会被删除。</p>
<p>在添加外键的约束后加上on delete cascade</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stuinfo <span class="keyword">add</span> <span class="keyword">constraint</span> fk_stu_major <span class="keyword">foreign</span> <span class="keyword">key</span>(majorid) <span class="keyword">references</span> major(<span class="keyword">id</span>) <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">cascade</span>;</span><br></pre></td></tr></table></figure>

<p>方式二：级联置空</p>
<p>如果不想删除主表信息时从表信息也被删除，就是用级联置空，主表信息被删除后，从表相应位置信息置空</p>
<p>在添加外键的约束后加上on delete set null</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stuinfo <span class="keyword">add</span> <span class="keyword">constraint</span> fk_stu_major <span class="keyword">foreign</span> <span class="keyword">key</span>(majorid) <span class="keyword">references</span> major(<span class="keyword">id</span>) <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">set</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h4 id="创建表时添加约束"><a href="#创建表时添加约束" class="headerlink" title="创建表时添加约束"></a>创建表时添加约束</h4><p>1、添加列级约束</p>
<p>语法：</p>
<p>直接在字段名和类型后面追加约束类型即可</p>
<p>只支持：主键、唯一、默认、非空</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stuinfo(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,<span class="comment">#主键</span></span><br><span class="line">	stuName <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,<span class="comment">#非空</span></span><br><span class="line">	gender <span class="built_in">CHAR</span>(<span class="number">1</span>) <span class="keyword">CHECK</span>(gender <span class="keyword">IN</span> (<span class="string">'男'</span>,<span class="string">'女'</span>)),<span class="comment">#检查</span></span><br><span class="line">	seat <span class="built_in">INT</span> <span class="keyword">UNIQUE</span>,<span class="comment">#唯一</span></span><br><span class="line">	age <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">18</span>,<span class="comment">#默认约束</span></span><br><span class="line">	majorId <span class="built_in">INT</span> <span class="keyword">REFERENCES</span> major(<span class="keyword">id</span>)<span class="comment">#外键</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>外键在列级约束时没有用</strong>。主键，外键，唯一键自动生成索引，使用下面语句查看索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> stuinfo;</span><br></pre></td></tr></table></figure>

<p>2、添加表级约束</p>
<p>语法：在各个字段的最下面，constraint 约束名可省略</p>
<p>【constraint 约束名】 约束类型（字段名）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stuinfo(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span>,</span><br><span class="line">	stuName <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	gender <span class="built_in">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">	seat <span class="built_in">INT</span>,</span><br><span class="line">	age <span class="built_in">INT</span>,</span><br><span class="line">	majorId <span class="built_in">INT</span>,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> pk PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>),<span class="comment">#主键</span></span><br><span class="line">	<span class="keyword">CONSTRAINT</span> uk <span class="keyword">UNIQUE</span>(seat),<span class="comment">#唯一键</span></span><br><span class="line">	<span class="keyword">CONSTRAINT</span> ck <span class="keyword">CHECK</span>(gender <span class="keyword">IN</span> (<span class="string">'男'</span>,<span class="string">'女'</span>)),<span class="comment">#检查</span></span><br><span class="line">	<span class="keyword">CONSTRAINT</span> fk_stuinfo_major <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(majorid) <span class="keyword">REFERENCES</span> major(<span class="keyword">id</span>)<span class="comment">#外键</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>主键名是默认的，改了没有效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">外键名一般为fk_当前表名_主键名</span><br></pre></td></tr></table></figure>

<p>通用写法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> stuinfo(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">	stuname <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	gender <span class="built_in">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">	age <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">18</span>,</span><br><span class="line">	seat <span class="built_in">INT</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">	majorid <span class="built_in">INT</span>,</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> fk_stuinfo_major <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(majorid) <span class="keyword">REFERENCES</span> major(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="修改表时添加约束"><a href="#修改表时添加约束" class="headerlink" title="修改表时添加约束"></a>修改表时添加约束</h4><p>总结：</p>
<p>1、添加列级约束</p>
<p>alter table 表名 <strong>modify column</strong> 字段名 字段类型 新约束；</p>
<p>2、添加表级约束</p>
<p>alter table 表名 <strong>add</strong> 【constraint 约束名】 约束类型（字段名）【外键的引用】；</p>
<p>1、添加非空约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> stuname <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>2、添加默认约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> age <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure>

<p>3、添加主键</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、列级约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>;</span><br><span class="line"><span class="comment">#2、表级约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure>

<p>4、添加唯一键</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、列级约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> seat <span class="built_in">INT</span> <span class="keyword">UNIQUE</span>;</span><br><span class="line"><span class="comment">#2、表级约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span>(seat);</span><br></pre></td></tr></table></figure>

<p>5、添加外键</p>
<p>关键词为ADD，只有表级约束才有效果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(majorid) <span class="keyword">REFERENCES</span> major(<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure>

<h4 id="修改表时删除约束"><a href="#修改表时删除约束" class="headerlink" title="修改表时删除约束"></a>修改表时删除约束</h4><p>1、删除非空约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> stuname <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>2、删除默认约束</p>
<p>不加约束即可</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">MODIFY</span> <span class="keyword">COLUMN</span> age <span class="built_in">INT</span>;</span><br></pre></td></tr></table></figure>

<p>3、删除主键</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span>;</span><br></pre></td></tr></table></figure>

<p>4、删除唯一</p>
<p>drop index 唯一键名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">DROP</span> <span class="keyword">INDEX</span> seat;</span><br></pre></td></tr></table></figure>

<p>5、删除外键</p>
<p>drop foreign key 外键名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stuinfo <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> fk_stuinfo_major;</span><br></pre></td></tr></table></figure>

<h3 id="标识列"><a href="#标识列" class="headerlink" title="标识列"></a>标识列</h3><p>又称为自增长列，关键字为auto_increament</p>
<p>含义：可以<strong>不用手动的插入值</strong>，系统提供默认的序列值，默认从1开始，步长为1</p>
<p>特点：</p>
<ol>
<li><p>标识列必须和<strong>key搭配</strong></p>
</li>
<li><p>一个表中<strong>至多</strong>有一个标识列</p>
</li>
<li><p>标识列的类型只能是<strong>数值型</strong></p>
</li>
<li><p>标识列可以通过SET auto_increment_increment=2;设置步长</p>
<p>可以通过手动插入值，设置起始值</p>
</li>
</ol>
<p>一、创建表时设置标识列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tab_identity(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">	<span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tab_identity <span class="keyword">VALUES</span>(<span class="literal">NULL</span>,<span class="string">'john'</span>);</span><br></pre></td></tr></table></figure>

<p>可以设置自增长的步长，一般不会改</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'%auto_increment%'</span>;</span><br><span class="line"><span class="keyword">SET</span> auto_increment_increment=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>二、修改表时设置标识列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tab_identity <span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT;</span><br></pre></td></tr></table></figure>

<p>三、修改表时删除标识列</p>
<p>去掉自增长列标识即可</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tab_identity <span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">INT</span>;</span><br></pre></td></tr></table></figure>

<h2 id="TCL语言"><a href="#TCL语言" class="headerlink" title="TCL语言"></a>TCL语言</h2><p>Transaction Control Language 事务控制语言</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务：</p>
<p>一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。每个sql语句是相互依赖的。整个单独单元作为一个不可分割的整体，如果单元中某条sql语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事务开始以前的状态；如果单元中的所有sql语句均执行成功，则事务被顺利执行。</p>
<h4 id="了解存储引擎"><a href="#了解存储引擎" class="headerlink" title="了解存储引擎"></a>了解存储引擎</h4><p>1、概念：在mysql中的数据用各种不同的技术存储在文件（或内存）中。</p>
<p>2、通过show engines;来查看mysql支持的存储引擎</p>
<p>3、在mysql中用的最多的存储引擎有：innodb，myisam，memory等。其中innodb支持事务，而myisam，memory等不支持事务</p>
<h4 id="事务的ACID（acid）属性【重要】"><a href="#事务的ACID（acid）属性【重要】" class="headerlink" title="事务的ACID（acid）属性【重要】"></a>事务的ACID（acid）属性【重要】</h4><p>事务的特性：</p>
<ol>
<li><p><strong>原子性</strong>（Atomicity）</p>
<p>原子性指事务是一个<strong>不可分割</strong>的工作单位，事务中的操作要么都发生，要么都不发生</p>
</li>
<li><p><strong>一致性</strong>（Consistency）</p>
<p>事务必须使数据库从一个一致性状态变换到另外一个一致性状态，保证数据的<strong>可靠性</strong></p>
<p>数据要准确，可靠    </p>
</li>
<li><p><strong>隔离性</strong>（Isolation）</p>
<p>事务的隔离性是指一个事务的执行<strong>不能被其他事务干扰</strong>，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
</li>
<li><p><strong>持久性</strong>（Durability）</p>
<p>持久性指一个事务一旦被提交，它对数据库中数据的改变就是<strong>永久性</strong>的，接下来的其他操作和数据库故障不应该对其有任何影响</p>
</li>
</ol>
<h4 id="事务的创建"><a href="#事务的创建" class="headerlink" title="事务的创建"></a>事务的创建</h4><p><strong>隐式事务</strong>：事务没有明显的开启和结束的标记</p>
<p>比如insert、update、delete语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表 <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>显式事务</strong>：事务具有明显的开启和结束的标记</p>
<p>前提：必须先设置自动提交功能为禁用</p>
<p>只针对当前会话有效</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'%autocommit'</span>;</span><br><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>步骤1：开启事务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;<span class="comment">#可选的</span></span><br></pre></td></tr></table></figure>

<p>步骤2：编写事务中的sql语句（<strong>select insert update delete</strong>）</p>
<p>语句1；</p>
<p>语句2；</p>
<p>…</p>
<p>【设置回滚点：</p>
<p>savepoint 回滚点名;】</p>
<p>步骤3：结束事务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">commit</span>;提交事务</span><br><span class="line"><span class="keyword">rollback</span>;回滚事务</span><br><span class="line">[回滚到指定的地方：<span class="keyword">rollback</span> <span class="keyword">to</span> 回滚点名;]</span><br></pre></td></tr></table></figure>

<p>savepoint 节点名;#设置保存点</p>
<h5 id="演示事务的使用步骤"><a href="#演示事务的使用步骤" class="headerlink" title="演示事务的使用步骤"></a>演示事务的使用步骤</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、开启事务</span></span><br><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="comment">#2、编写sql语句</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> balance = <span class="number">500</span> <span class="keyword">WHERE</span> username=<span class="string">'张无忌'</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> balance = <span class="number">1500</span> <span class="keyword">WHERE</span> username=<span class="string">'赵敏'</span>;</span><br><span class="line"><span class="comment">#3、结束事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>如果使用commit，可以正常修改数据，如果使用的是rollback，那么对数据没有影响</p>
<h3 id="并发事务【重要】"><a href="#并发事务【重要】" class="headerlink" title="并发事务【重要】"></a>并发事务【重要】</h3><p>对于同时运行的<strong>多个事务</strong>，当这些事务访问<strong>数据库中相同的数据</strong>时，如果没有采取必要的隔离机制，就会导致各种并发问题： </p>
<ul>
<li><p><strong>更新丢失</strong>：多个事务选择同一行，最后的更新会覆盖之前的更新。在提交事务前，不能访问同一文件，可避免。</p>
</li>
<li><p><strong>脏读</strong>：对于两个事务T1、T2，T1读取了已经被T2<strong>更新</strong>但<strong>还没有提交</strong>的字段，之后若T2回滚，T1读取的内容就是<strong>临时且无效</strong>的</p>
</li>
<li><p><strong>不可重复读</strong>：对于两个事务T1、T2，T1读取了一个字段，然后T2<strong>更新</strong>了该字段，之后T1再次读取同一个字段，<strong>值就不同</strong>了</p>
</li>
<li><p><strong>幻读</strong>：对于两个事务T1、T2，T1从一个表中读取了一个字段，然后T2在该表中<strong>插入</strong>了一些新的行，之后如果T1再次读取同一个表，就会多出几行</p>
</li>
</ul>
<p>脏读与幻读相对比，脏读侧重于字段的<strong>更新</strong>，幻读侧重于行的<strong>插入</strong>。</p>
<h4 id="解决并发问题【重要】"><a href="#解决并发问题【重要】" class="headerlink" title="解决并发问题【重要】"></a>解决并发问题【重要】</h4><p><strong>数据库的隔离级别</strong>：数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题</p>
<p>数据库提供的4种事务隔离级别</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>READ UNCOMMITTED（读未提交数据）</td>
<td>允许事务读取未被其他事务提交的变更，<strong>脏读、不可重复度和幻读</strong>的问题都会出现</td>
</tr>
<tr>
<td>READ COMMITTED（读已提交数据）</td>
<td>只允许事务读取已经被其他事务提交的变更，可以避免脏读，但<strong>不可重复读和幻读</strong>问题仍可能出现</td>
</tr>
<tr>
<td>REPEATABLE READ（可重复读）</td>
<td>确保事务可以多次从一个字段中读取相同的值，在这个事务持续期间，禁止其他事务对这个字段进行更新，可以避免脏读和不可重复读，但<strong>幻读</strong>的问题仍然存在</td>
</tr>
<tr>
<td>SERIALIZABLE（串行化）</td>
<td>确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入，更新和删除操作，所有并发问题都可以避免，但性能十分低下</td>
</tr>
</tbody></table>
<p>Oracle支持的2种事务级别：<strong>READ COMMITTED</strong>，SERIALIZABLE。Oracle默认的事务隔离级别为READ COMMITTED</p>
<p>Mysql支持4种事务级别，Mysql默认的事务隔离级别为<strong>REPETABLE READ</strong></p>
<h4 id="具体演示"><a href="#具体演示" class="headerlink" title="具体演示"></a>具体演示</h4><p>查看当前隔离级别</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @@tx_isolation;</span><br><span class="line">8.0后改为<span class="keyword">select</span> @@transaction_isolation;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'tx_isolation'</span>;</span><br></pre></td></tr></table></figure>

<p>将隔离级别设置成最低</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> uncommitted;</span><br></pre></td></tr></table></figure>

<p>如果中文显示为乱码，更改字符集</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">names</span> gbk;</span><br></pre></td></tr></table></figure>

<p>这时候如果开启两个事务，一个将表中姓名更改但没有提交，这时候另一个事务去读表中内容，读到了没有提交的内容，当事务1回滚，再次读的时候事务2仍读到原来的，出现脏读。</p>
<p>当更改事务1的隔离级别为读已提交，更改数据但不提交，更改事务2的隔离级别为读已提交，查看表中数据，无法看到表格修改的内容。因此脏读被避免。但当事务1提交后，事务2再查看表中内容，发现两次看的数据不一样，出现不可重复读。</p>
<p>可重复读下：</p>
<p>当更改事务1和2的隔离级别为可重复读，更改事务1的数据但不提交，事务2查看表中数据，为未修改前的；当事务1提交，事务2查看仍是未修改的。只有事务2提交后，再次查看才是修改后的。解决了脏读和不可重复读。但当事务1要更改所有行数据的名字，还未执行，在此时事务2插入了一条数据并commit了，这样当事务1执行的时候多影响到了事务2插入的这一条数据，有幻读出现。只有执行插入语句的事务提交后，事务1的更改语句才能执行成功。</p>
<table>
<thead>
<tr>
<th></th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>SET autocommit=0;</td>
<td>SET autocommit=0;</td>
</tr>
<tr>
<td>T2</td>
<td>select * from account;3条</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>insert into account values();插入一条</td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>commit</td>
</tr>
<tr>
<td>T5</td>
<td>update account set balance=100;会影响4条</td>
<td></td>
</tr>
</tbody></table>
<p>在可重复读下，执行以上时间点的操作，可以发现，当事务A第一次读取数据，只有3条，当事务B插入一行数据后，事务A再次更新的时候，会影响4条数据，出现了幻读。但是如果此时事务A去读取数据，仍然只有3条。原因是select读是快照读，MVCC解决了快照读的幻读问题。而update为当前读，在当前读下仍然会出现幻读情况。</p>
<p>同时，使用select * from account for update;这种当前读的select也会出现幻读。</p>
<p>当事务1,2的隔离级别修改为串行化后，当事务1，2均开启，事务1要执行update操作，事务2执行插入语句，但无法执行成功，只有事务1提交后，事务2才能执行。一次只能执行一个事务。</p>
<p>经过试验，在最高等级下，哪个事务先被开启不重要，如果同时有两个事务被开启，事务1要执行插入操作，事务2没有执行sql语句，此时事务1的插入操作可以成功；但一旦事务2执行了sql语句，插入操作便不能成功，当插入数据的事务没有提交前，其他事务不能进行查询操作。小结：只要其他表使用了sql语句查看or操作表，修改表的操作就不能被执行；只要有其他事务修改了表，就不能查看表。看了不能改，改了不能看。</p>
<h4 id="Mysql中设置隔离级别"><a href="#Mysql中设置隔离级别" class="headerlink" title="Mysql中设置隔离级别"></a>Mysql中设置隔离级别</h4><ul>
<li><p>每启动一个mysql程序，就会获得一个单独的数据库连接，每个数据库连接都有一个全局变量@@tx_isolation，表示当前的事务隔离级别</p>
</li>
<li><p>查看当前的隔离级别：select @@tx_isolation;</p>
</li>
<li><p>设置当前mysql连接的隔离级别</p>
<p>set session transaction isolation level <strong>read uncommitted</strong>;将其替换为需要的级别</p>
</li>
<li><p>设置数据库的全局隔离级别</p>
<p>set <strong>global</strong> transaction isolation level <strong>read uncommitted</strong>;</p>
</li>
</ul>
<h4 id="delete和truncate在事务使用时的区别"><a href="#delete和truncate在事务使用时的区别" class="headerlink" title="delete和truncate在事务使用时的区别"></a>delete和truncate在事务使用时的区别</h4><p>delete和truncate是针对数据的操作语言，而不是针对表结构的，要删除表使用drop table，删除数据使用delete from 表名和truncate table 表名。</p>
<p>演示delete</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">account</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<p>数据并没有被删除。</p>
<p>演示truncate</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> <span class="keyword">account</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<p>这时候数据仍然被删除了，没有回滚。因此truncate不支持回滚。</p>
<h4 id="savepoint的使用"><a href="#savepoint的使用" class="headerlink" title="savepoint的使用"></a>savepoint的使用</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">account</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SAVEPOINT</span> a;<span class="comment">#设置保存点</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">account</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> a;<span class="comment">#回滚至保存点</span></span><br></pre></td></tr></table></figure>

<p>savepoint搭配rollback使用，回滚到保存点，因此id=1的行被删除，但是id=3的行没有。</p>
<h3 id="ACID的实现"><a href="#ACID的实现" class="headerlink" title="ACID的实现"></a>ACID的实现</h3><blockquote>
<p>参考博客：</p>
<p><code>https://www.cnblogs.com/kismetv/p/10331633.html</code></p>
<p><code>https://blog.csdn.net/SnailMann/article/details/94724197?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</code></p>
</blockquote>
<h4 id="原子性（A）的实现"><a href="#原子性（A）的实现" class="headerlink" title="原子性（A）的实现"></a>原子性（A）的实现</h4><p>原子性为一个事务是不可分割的工作单位，操作要么一起做，要么都不做，若一个sql执行失败，已经执行的语句需要回滚。</p>
<p>而原子性的实现依靠的是undo log（回滚日志），实现原子性的关键为可以撤销成功执行的sql语句。当事务要对数据库进行修改时，InnoDB生成对应的undo log，若事务执行失败或调用了roll back，可以使用undo log来将数据修改为回滚前的状态。</p>
<p>undo log是逻辑日志，记录sql执行相关信息，属于存储引擎层。当发生回滚时，InnoDB根据undo log的内容做与之前相反的操作：对insert，进行delete；对delete，进行insert；对update，执行相反的update，将数据改回去。</p>
<h4 id="持久性（D）的实现"><a href="#持久性（D）的实现" class="headerlink" title="持久性（D）的实现"></a>持久性（D）的实现</h4><p>持久性为事务一旦提交，对数据库的改变应该是永久性的，接下来的其他操作或故障不应该对其有影响。</p>
<p>持久性的实现依靠的是redo log（重做日志），与undo log回滚日志一样属于InnoDB的事务日志。</p>
<p>InnoDB提供缓存Buffer Pool，包含磁盘中部分数据页的映射，作为数据库的缓冲，减少IO次数。数据库读取数据的逻辑是：先在Buffer Pool中读取，若缓冲中没有，从磁盘读取后放入缓冲。当向数据库写数据，先写入缓冲，Buffer Pool中修改的数据定期刷新到磁盘中（刷脏）。Buffer Pool的优点是提高了读写效率，但问题是，若MySQL宕机，会导致Buffer Pool中数据没有刷新到磁盘，数据丢失，持久性也就无法保证。因此redo log被引入。</p>
<p>数据修改时，除了在Buffer Pool中修改，也会在redo log中记录；redo log默认在事务提交时刷盘，也有每秒刷盘等。MySQL宕机后，重启时可以读取redo log中的数据，对数据库进行恢复。而所有修改先写入redo log，再更新到Buffer Pool，这样可以保证持久性。</p>
<p>而redo log可以保证持久性的关键是它比刷脏要更快，不然刷脏很快也没有必要使用redo log，redo log更快的原因是</p>
<ul>
<li>刷脏是随机IO，修改数据随机；redo log是追加操作，为顺序IO（不用多个地方移动磁头）</li>
<li>刷脏以数据页为单位，MySQL默认页是16kb，对页上做小修改要整页写入；redo log只包含真正需要写入的数据（修改量更少）</li>
</ul>
<h4 id="隔离性（I）的实现"><a href="#隔离性（I）的实现" class="headerlink" title="隔离性（I）的实现"></a>隔离性（I）的实现</h4><p>隔离性为事务的内部操作与其他事务隔离，并发执行的事务之间不能相互干扰。最严格的隔离性，对应事务隔离级别中的串行化。</p>
<p>主要考虑读与写之间的隔离性</p>
<ul>
<li>事务A写操作对事务B写操作的影响：锁机制保证</li>
<li>事务写操作对事务B读操作的影响：MVCC保证</li>
</ul>
<p>MyISAM的锁为表锁，而InnoDB为行锁，粒度更小。当事务A对一行数据执行写操作时，对相同行执行写操作的事务B会被阻塞，直到事务A提交。</p>
<p>并发事务会产生脏读，不可重复读和幻读问题，对应的，数据库依靠前面所说的四个隔离级别来消除这些影响，但隔离级别越高，虽然读取问题变少，但性能也变差，一般数据库默认可重复读（MySQL）或读已提高（Oracle）。</p>
<p>而隔离级别解决脏读、不可重复读或幻读，依靠的是MVCC，即Multi-Version Concurrency Control，多版本并发事务控制。MVCC的特点是不同事务读取到的数据可能是不同的（多版本的），因为读为快照读（读取不是最新的）。最大的优先是读不加锁，因此读写不冲突，并发性能好。InnoDB实现MVCC，多个版本的数据可以共存，主要依靠的是数据<strong>隐藏列</strong>（标记位），<strong>undo log</strong>和<strong>Read View</strong>（读视图）。</p>
<p>要实现多版本控制，需要保存有<strong>不同版本的数据</strong>，需要当前版本可以<strong>找到上一个版本的数据</strong>，和判断当前版本<strong>可以看到哪些版本的数据</strong>，分别依靠undo log，隐藏列与Read View。</p>
<p>隐藏列中包括</p>
<ul>
<li>最近<strong>修改事务ID</strong></li>
<li><strong>回滚指针</strong>：配合undo  log，指向此记录上一个版本</li>
<li>隐含的自增ID</li>
<li>实际还有删除flag隐藏字段，记录被更新或删除不是真的删除，而是flag变化</li>
</ul>
<p>读取数据时，MySQL可以判断是否需要回滚并找到所需要的undo log，从而实现。</p>
<p>对MVCC有帮助的是undo log中记录了update 和 delete的日志，在快照读时有用。</p>
<p>当有新事务对数据进行了修改，新事务会有指针指向旧事务。</p>
<img src="/2020/02/09/MySQL/MVCC%E9%93%BE%E8%A1%A8.png" class title="This is an example image">

<p>这样undo log形成一个单向链表，表头为最新的旧记录，表尾是最早的旧记录。</p>
<p>而Read View是在事务进行快照读的时候产生的读视图，维护了活跃事务的ID（自增，越新事务ID越大），用来判断当前版本的视图可以看到哪个版本的数据。其用来做数据的可见性判断，其可见性算法是，取出要修改数据的最新记录中的事务ID，与Read View中维护的活跃事务ID比较，若不符合可见性，则通过回滚指针找到undo log中上一条记录，直到找到符合可见性规则的（从表头到表尾）。</p>
<p>其判断的逻辑为：在Read View中维护了一系列生成时刻事务ID，其中有最小事务ID与已创建最大事务ID。</p>
<ul>
<li>如果数据中当前事务ID小于生成时最小事务ID，说明此记录是在Read View前面就出现了，最新的数据是可以被看到的；若大于等于进入下一个判断</li>
<li>如果当前事务ID大于等于已创建最大事务ID，说明此记录是在Read View后才出现的，肯定对当前事务不可见；若小于，进入下一个判断</li>
<li>判断数据中事务ID是否仍在活跃事务之中，如果在，代表Read View时刻，事务还在活跃，没有commit，修改的数据当前事务也看不到；如果不在，说明事务在Read View前已经commit了，修改的结果对当前事务是可见的</li>
</ul>
<p>如果一个数据被删除了，将版本链上的数据复制一份，更新修改事务ID，然后将标志位更改为true，如果查询到了已经删除的数据（flag为true），则不返回数据。</p>
<p>因此可以看出快照读的结果非常依赖于Read View生成的时机。</p>
<p>在读已提交下，每个快照读都会生成并获取最新的Read View，可重复读下同一个事务的第一个快照才生成Read View，之后快照读取的仍为同一个Read View。</p>
<p>个人小总结为：若是快照读生成的时机越早，更新的次数越少，越有可能对其他事务修改的数据不可见。</p>
<h4 id="一致性（C）的实现"><a href="#一致性（C）的实现" class="headerlink" title="一致性（C）的实现"></a>一致性（C）的实现</h4><p>一致性为数据库完整性约束没有被破坏，事务执行的前后数据状态都是合法的。一致性是事务的最终目标，是依靠于原子性、隔离性和持久性来实现的。在数据库层面与应用层层面都需要来保障一致性。</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>含义：虚拟表，和普通表一起使用</p>
<p>mysql5.1版本出现的新特性，行和列的数据来自自定义视图的查询中使用的表，并且是在使用视图时<strong>动态生成</strong>的，<strong>只保存了sql逻辑，不保存查询结果</strong></p>
<p>应用场景：</p>
<ul>
<li>多个地方用到<strong>同样的查询结果</strong></li>
<li>该查询结果使用的sql语句<strong>较复杂</strong></li>
</ul>
<p>好处：</p>
<p>1、简化了sql语句</p>
<p>2、提高了sql的重用性</p>
<p>3、保护了基表的数据，提高了安全性    </p>
<p>案例：查询姓张的学生名和专业名</p>
<p>以前的做法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> stuname,majorName</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`stuinfo`</span> s</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="string">`major`</span> m <span class="keyword">ON</span> s.<span class="string">`majorId`</span>=m.<span class="string">`id`</span></span><br><span class="line"><span class="keyword">WHERE</span> stuname <span class="keyword">LIKE</span> <span class="string">'张%'</span>;</span><br></pre></td></tr></table></figure>

<p>现在可以将常用的语句封装为视图</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v1</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> stuname,majorName</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`stuinfo`</span> s</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="string">`major`</span> m <span class="keyword">ON</span> s.<span class="string">`majorId`</span>=m.<span class="string">`id`</span>;</span><br></pre></td></tr></table></figure>

<p>要调用的时候</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> v1 <span class="keyword">WHERE</span> stuname <span class="keyword">LIKE</span> <span class="string">'张%'</span>;</span><br></pre></td></tr></table></figure>

<h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><p>语法：</p>
<p>create view 视图名</p>
<p>as</p>
<p>查询语句;</p>
<p>1、查询姓名中包含a字符的员工名、部门名和工种信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、创建</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myv1</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> last_name,department_name,job_title</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`employees`</span> e</span><br><span class="line"><span class="keyword">JOIN</span> <span class="string">`departments`</span> d <span class="keyword">ON</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span></span><br><span class="line"><span class="keyword">JOIN</span><span class="string">`jobs`</span> j <span class="keyword">ON</span> j.<span class="string">`job_id`</span>=e.<span class="string">`job_id`</span>;</span><br><span class="line"><span class="comment">#2、使用</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> myv1 <span class="keyword">WHERE</span> last_name <span class="keyword">LIKE</span> <span class="string">'%a%'</span>;</span><br></pre></td></tr></table></figure>

<p>2、查询各部门的平均工资级别</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、创建视图查看每个部门的平均工资</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myv2</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary) ag,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"><span class="comment">#2、使用</span></span><br><span class="line"><span class="keyword">SELECT</span> myv2.<span class="string">`ag`</span>,g.grade_level</span><br><span class="line"><span class="keyword">FROM</span> myv2</span><br><span class="line"><span class="keyword">JOIN</span> job_grades g</span><br><span class="line"><span class="keyword">ON</span> myv2.<span class="string">`ag`</span> <span class="keyword">BETWEEN</span> g.<span class="string">`lowest_sal`</span> <span class="keyword">AND</span> g.<span class="string">`highest_sal`</span>;</span><br></pre></td></tr></table></figure>

<p>3、查询平均工资最低的部门信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#平均工资视图已经被创建</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> myv2 <span class="keyword">ORDER</span> <span class="keyword">BY</span> myv2.<span class="string">`ag`</span> <span class="keyword">ASC</span> <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>4、查询平均工资最低的部门名和工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建平均工资最低的部门id表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myv3</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> myv2 <span class="keyword">ORDER</span> <span class="keyword">BY</span> myv2.<span class="string">`ag`</span> <span class="keyword">ASC</span> <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">#将视图与部门表进行连接</span></span><br><span class="line"><span class="keyword">SELECT</span> d.*,m.ag</span><br><span class="line"><span class="keyword">FROM</span> myv3 m</span><br><span class="line"><span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> m.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span>;</span><br></pre></td></tr></table></figure>

<h3 id="视图的好处"><a href="#视图的好处" class="headerlink" title="视图的好处"></a>视图的好处</h3><ul>
<li>重用sql语句</li>
<li>简化复杂的sql操作，不必知道其细节</li>
<li>保护数据，提高安全性</li>
</ul>
<h3 id="视图的修改"><a href="#视图的修改" class="headerlink" title="视图的修改"></a>视图的修改</h3><p>方式一：</p>
<p>意思为存在就替代，不存在就创建</p>
<p><strong>create or replace</strong> view 视图名</p>
<p>as</p>
<p>查询语句;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">VIEW</span> myv3</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary),job_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job_id;</span><br></pre></td></tr></table></figure>

<p>方式二：</p>
<p>语法：</p>
<p>alter view 视图名</p>
<p>as</p>
<p>查询语句;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> myv3</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<h3 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h3><p>语法：</p>
<p><strong>drop view</strong> 视图名，视图名，…;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> myv1,myv2,myv3;</span><br></pre></td></tr></table></figure>

<h3 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DESC myv3;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myv3;</span><br></pre></td></tr></table></figure>

<h3 id="视图练习"><a href="#视图练习" class="headerlink" title="视图练习"></a>视图练习</h3><p>1、创建视图emp_v1，要求查询电话号码以011开头的员工姓名和工资、邮箱</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">VIEW</span> emp_v1</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary,email</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> phone_number <span class="keyword">LIKE</span> <span class="string">'011%'</span>;</span><br></pre></td></tr></table></figure>

<p>不能先创建没有phone筛选的视图再调用视图筛选，因为视图中没有phone这一列。</p>
<p>2、创建视图emp_v2，要求查询的部门最高工资高于12000的部门信息</p>
<p>之前做法：先得到部门最高工资高于12000的工资和编号表，然后和部门表连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> d.*,m.mx</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">JOIN</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary) mx,department_id</span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">	<span class="keyword">HAVING</span> <span class="keyword">MAX</span>(salary)&gt;<span class="number">12000</span></span><br><span class="line">) <span class="keyword">AS</span> m</span><br><span class="line"><span class="keyword">ON</span> d.department_id=m.department_id;</span><br></pre></td></tr></table></figure>

<p>视图的做法，先将部门最高工资高于12000的工资和编号表作为视图，然后用视图和部门表连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> emp_v2</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary) mx,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">MAX</span>(salary)&gt;<span class="number">12000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> d.*,emp_v2.mx</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">JOIN</span> emp_v2</span><br><span class="line"><span class="keyword">ON</span> d.department_id=emp_v2.department_id;</span><br></pre></td></tr></table></figure>

<h3 id="视图的更新"><a href="#视图的更新" class="headerlink" title="视图的更新"></a>视图的更新</h3><p>对视图的数据更新，而不是结构。一般给视图添加权限，只允许读，不允许写。</p>
<p>视图的可更新性和视图中查询的定义有关系，以下类型的视图是不允许更新的</p>
<ul>
<li>包含以下关键字的sql语句：分组函数、distinct、group by、having、union或者union all</li>
<li>常量视图</li>
<li>select中包含子查询</li>
<li>join</li>
<li>from一个不能更新的视图</li>
<li>where子句的子查询引用了from子句中的表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">VIEW</span> myv1</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,email</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>1、插入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> myv1 <span class="keyword">VALUES</span>(<span class="string">'张飞'</span>,<span class="string">'zf@qq.com'</span>);</span><br></pre></td></tr></table></figure>

<p>此时在原始的employees表中也插入了数据。</p>
<p>2、修改</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> myv1 <span class="keyword">SET</span> last_name=<span class="string">'张无忌'</span> <span class="keyword">WHERE</span> last_name=<span class="string">'张飞'</span>;</span><br></pre></td></tr></table></figure>

<p>原始表依然被更改了</p>
<p>3、删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> myv1 <span class="keyword">WHERE</span> last_name=<span class="string">'张无忌'</span>;</span><br></pre></td></tr></table></figure>

<h3 id="视图与表的比较"><a href="#视图与表的比较" class="headerlink" title="视图与表的比较"></a>视图与表的比较</h3><table>
<thead>
<tr>
<th></th>
<th>创建语法的关键字</th>
<th>是否实际占用屋里空间</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>视图</td>
<td>create view</td>
<td>只是保存了sql逻辑</td>
<td>一般仅用来查</td>
</tr>
<tr>
<td>表</td>
<td>create table</td>
<td>保存了数据</td>
<td>增删改查</td>
</tr>
</tbody></table>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>系统变量</p>
<ul>
<li><p>全局变量</p>
<p>作用域：服务器每次启动将为所有的全局变量赋初始值，针对于所有的会话（连接）有效，但不能跨重启。</p>
</li>
<li><p>会话变量</p>
<p>作用域：仅仅针对于当前会话（连接）有效</p>
</li>
</ul>
<p>自定义变量</p>
<ul>
<li>用户变量</li>
<li>局部变量</li>
</ul>
<h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>说明：变量由系统提供，不是用户定义，属于服务器层面</p>
<p>使用的语法    ：</p>
<p>1、查看所有的系统变量</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> <span class="keyword">VARIABLES</span>;<span class="comment">#全局变量</span></span><br><span class="line"><span class="keyword">SHOW</span> 【<span class="keyword">SESSION</span>】 <span class="keyword">VARIABLES</span>;<span class="comment">#会话变量</span></span><br></pre></td></tr></table></figure>

<p>2、查看满足条件的部分系统变量</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span>|[<span class="keyword">SESSION</span>] <span class="keyword">VARIABLES</span> <span class="keyword">like</span> <span class="string">'%查询字符%'</span>;</span><br></pre></td></tr></table></figure>

<p>3、查看指定的某个系统变量的值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @@global.系统变量名;<span class="comment">#全局变量</span></span><br><span class="line"><span class="keyword">select</span> @@[session.]系统变量名;<span class="comment">#会话变量</span></span><br></pre></td></tr></table></figure>

<p>4、为某个系统变量赋值</p>
<p>方式一：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span>|【<span class="keyword">session</span>】 系统变量名=值;</span><br></pre></td></tr></table></figure>

<p>方式二：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @@<span class="keyword">global</span>|【<span class="keyword">session</span>】 .系统变量名=值;</span><br></pre></td></tr></table></figure>

<p>注意：如果是全局级别，则需要加global，如果是会话级别，则需要加session，如果不写，则默认session</p>
<h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>说明：变量是用户自定义的，不是由系统定义的。</p>
<p>使用步骤：</p>
<p>声明</p>
<p>赋值</p>
<p>使用（查看、比较、运算等）</p>
<p>1、用户变量</p>
<p>作用域：针对于当前的会话（连接）有效，同于会话变量的作用域</p>
<p>应用在任何地方，也就是begin end里面或者外面</p>
<p>赋值的操作符：=或:=</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、声明并初始化</span></span><br><span class="line"><span class="keyword">SET</span> @用户变量名=值;或</span><br><span class="line"><span class="keyword">SET</span> @用户变量名:=值;或</span><br><span class="line"><span class="keyword">SELECT</span> @用户变量名:=值;</span><br><span class="line"><span class="comment">#2、赋值（更新用户变量的值）</span></span><br><span class="line">方式一：通过<span class="keyword">SET</span>或<span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">SET</span> @用户变量名=值;或</span><br><span class="line">    <span class="keyword">SET</span> @用户变量名:=值;或</span><br><span class="line">    <span class="keyword">SELECT</span> @用户变量名:=值;</span><br><span class="line">方式二：通过<span class="keyword">SELECT</span> <span class="keyword">INTO</span></span><br><span class="line">    <span class="keyword">SELECT</span> 字段 <span class="keyword">INTO</span> @变量名</span><br><span class="line">    <span class="keyword">FROM</span> 表;</span><br><span class="line"><span class="comment">#3、使用（查看用户变量的值）</span></span><br><span class="line">    <span class="keyword">SELECT</span> @用户变量名;</span><br></pre></td></tr></table></figure>

<p>2、局部变量</p>
<p>作用域：仅仅在定义它的begin end中有效</p>
<p>应用在 begin end中的第一句话</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1、声明</span><br><span class="line">  <span class="keyword">DECLARE</span> 变量名 类型;</span><br><span class="line">  <span class="keyword">DECLARE</span> 变量名 类型 <span class="keyword">DEFAULT</span> 值;</span><br><span class="line">2、赋值</span><br><span class="line">  方式一：通过<span class="keyword">SET</span>或<span class="keyword">SELECT</span></span><br><span class="line">      <span class="keyword">SET</span> 局部变量名=值;或</span><br><span class="line">      <span class="keyword">SET</span> 局部变量名:=值;或</span><br><span class="line">      <span class="keyword">SELECT</span> @局部变量名:=值;</span><br><span class="line">  方式二：通过<span class="keyword">SELECT</span> <span class="keyword">INTO</span></span><br><span class="line">      <span class="keyword">SELECT</span> 字段 <span class="keyword">INTO</span> 局部变量名</span><br><span class="line">      <span class="keyword">FROM</span> 表;</span><br><span class="line">3、使用</span><br><span class="line">  <span class="keyword">SELECT</span> 局部变量名;</span><br></pre></td></tr></table></figure>

<h4 id="对比用户变量和局部变量"><a href="#对比用户变量和局部变量" class="headerlink" title="对比用户变量和局部变量"></a>对比用户变量和局部变量</h4><table>
<thead>
<tr>
<th></th>
<th>作用域</th>
<th>定义和使用的位置</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td>用户变量</td>
<td>当前会话</td>
<td>会话中的任何地方</td>
<td>必须加@符号</td>
</tr>
<tr>
<td>局部变量</td>
<td>BEGIN END中</td>
<td>只能在BEGIN END 中，且为第一句话</td>
<td>一般不用加@符号，需要限定类型</td>
</tr>
</tbody></table>
<p>案例：声明两个变量并赋初值，求和，并打印</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、用户变量</span></span><br><span class="line"><span class="keyword">SET</span> @m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> @n = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">sum</span> = @m + @n;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">sum</span>;</span><br><span class="line"><span class="comment">#语法报错，需要使用在BEGIN END中</span></span><br><span class="line"><span class="comment">#2、局部变量</span></span><br><span class="line"><span class="keyword">DECLARE</span> m <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> n <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="keyword">SUM</span> <span class="built_in">INT</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">SUM</span>=m+n;</span><br></pre></td></tr></table></figure>

<h2 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h2><p>类似Java中的方法</p>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><h4 id="存储过程创建与调用"><a href="#存储过程创建与调用" class="headerlink" title="存储过程创建与调用"></a>存储过程创建与调用</h4><p>含义：一组预先编译好的SQL语句的集合，理解成批处理语句</p>
<p>好处：</p>
<ol>
<li>提高代码的重用性</li>
<li>简化操作</li>
<li>减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</li>
</ol>
<p>一、创建语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">create procedure 存储过程名(in|out|inout 参数名  参数类型,...)</span><br><span class="line">begin</span><br><span class="line">	存储过程体（一组合法的SQL语句）</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>1、参数列表包括三部分</p>
<p>参数模式 参数名 参数类型</p>
<p>举例：</p>
<p>IN stuname VARCHAR(20)</p>
<p>参数模式：</p>
<p>IN：该参数可以作为输入，即该参数需要调入方传入值</p>
<p>OUT：该参数可以作为输出，即该参数可以作为返回值</p>
<p>INOUT：该参数即可以作为输入又可以作为输出，该参数既需要传入值，又可以返回值</p>
<p>2、如果存储过程体只有一句话，begin end可以省略</p>
<p>存储过程中的每条sql语句的结尾必须加分号。存储过程的结尾可以使用DELIMITER重新设置</p>
<p>语法：</p>
<p>DELIMITER 结束标记</p>
<p>DELIMITER $</p>
<p>二、调用语法</p>
<p>CALL 存储过程名（实参列表）；</p>
<p>1、空参列表</p>
<p>案例：插入到admin表中5条记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、创建存储过程</span></span><br><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> myp1()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">admin</span>(username,<span class="string">`password`</span>)</span><br><span class="line">	<span class="keyword">VALUES</span>(<span class="string">'john1'</span>,<span class="string">'0000'</span>),(<span class="string">'lili'</span>,<span class="string">'0000'</span>),(<span class="string">'rose'</span>,<span class="string">'0000'</span>),(<span class="string">'jack'</span>,<span class="string">'0000'</span>),(<span class="string">'tom'</span>,<span class="string">'0000'</span>);</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"><span class="comment">#2、调用</span></span><br><span class="line"><span class="keyword">CALL</span> myp1()$</span><br></pre></td></tr></table></figure>

<p>2、创建带in模式参数的存储过程</p>
<p>案例1：创建存储过程实现根据女神名，查询对应的男神信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、创建</span></span><br><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> myp2(<span class="keyword">IN</span> beautyName <span class="built_in">VARCHAR</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> bo.*</span><br><span class="line">	<span class="keyword">FROM</span> boys bo</span><br><span class="line">	<span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> beauty b</span><br><span class="line">	<span class="keyword">ON</span> bo.id = b.<span class="string">`boyfriend_id`</span></span><br><span class="line">	<span class="keyword">WHERE</span> b.name=beautyName;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"><span class="comment">#2、调用</span></span><br><span class="line"><span class="keyword">CALL</span> myp2(<span class="string">'小昭'</span>);</span><br></pre></td></tr></table></figure>

<p>案例2：创建存储过程实现用户是否登录成功</p>
<p>思路：先创建存储过程来查询表中与输入信息相同的个数（count(*)），然后为了将个数赋值给变量，声明了int类型的变量result，然后用if语句来判断如果个数&gt;0，则输出成功。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> myp4(<span class="keyword">IN</span> username <span class="built_in">VARCHAR</span>(<span class="number">20</span>),<span class="keyword">IN</span> <span class="keyword">PASSWORD</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="comment">#声明并初始化</span></span><br><span class="line">	<span class="keyword">DECLARE</span> <span class="keyword">result</span> <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">INTO</span> <span class="keyword">result</span><span class="comment">#赋值 select into用法</span></span><br><span class="line">	<span class="keyword">FROM</span> <span class="keyword">admin</span> </span><br><span class="line">	<span class="comment">#出现冲突时，使用表名.变量名的形式</span></span><br><span class="line">	<span class="keyword">WHERE</span> admin.username = username</span><br><span class="line">	<span class="keyword">AND</span> admin.password = <span class="keyword">PASSWORD</span>;</span><br><span class="line">	<span class="comment">#使用</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">IF</span>(<span class="keyword">result</span>&gt;<span class="number">0</span>,<span class="string">'成功'</span>,<span class="string">'失败'</span>);</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> myp4(<span class="string">'张飞'</span>,<span class="string">'8888'</span>);</span><br></pre></td></tr></table></figure>

<p>3、创建带out模式的存储过程</p>
<p>案例1：根据女神名，返回对应的男神名</p>
<p>思路：查询后的结果利用select into 参数名进行传递，然后调用时可以定义用户变量在begin end外面接收，然后输出即可。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> myp5(<span class="keyword">IN</span> beautyName <span class="built_in">VARCHAR</span>(<span class="number">20</span>),<span class="keyword">OUT</span> boyName <span class="built_in">VARCHAR</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> bo.<span class="string">`boyName`</span> <span class="keyword">INTO</span> boyName</span><br><span class="line">	<span class="keyword">FROM</span> <span class="string">`boys`</span> bo</span><br><span class="line">	<span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="string">`beauty`</span> b</span><br><span class="line">	<span class="keyword">ON</span> bo.<span class="string">`id`</span> = b.<span class="string">`boyfriend_id`</span></span><br><span class="line">	<span class="keyword">WHERE</span> b.<span class="string">`name`</span>=beautyName;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line"><span class="keyword">SET</span> @bName;</span><br><span class="line"><span class="keyword">CALL</span> myp5(<span class="string">'小昭'</span>,@bName);</span><br><span class="line"><span class="keyword">SELECT</span> @bName;</span><br></pre></td></tr></table></figure>

<p>案例2：根据女神名，返回对应的男神名和男神魅力值</p>
<p>注意：为了输出多个OUT，需要在select写完后，再INTO后面加变量1，变量2。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> myp6(<span class="keyword">IN</span> beautyName <span class="built_in">VARCHAR</span>(<span class="number">20</span>),<span class="keyword">OUT</span> boyName <span class="built_in">VARCHAR</span>(<span class="number">20</span>),<span class="keyword">OUT</span> userCP <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> bo.<span class="string">`boyName`</span> ,bo.<span class="string">`userCP`</span> <span class="keyword">INTO</span> boyName,userCP</span><br><span class="line">	<span class="keyword">FROM</span> <span class="string">`boys`</span> bo</span><br><span class="line">	<span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="string">`beauty`</span> b</span><br><span class="line">	<span class="keyword">ON</span> bo.<span class="string">`id`</span> = b.<span class="string">`boyfriend_id`</span></span><br><span class="line">	<span class="keyword">WHERE</span> b.<span class="string">`name`</span>=beautyName;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> myp6(<span class="string">'小昭'</span>,@bName,@userCP);</span><br><span class="line"><span class="keyword">SELECT</span> @bName,@userCP;</span><br></pre></td></tr></table></figure>

<p>4、创建带inout模式参数的存储过程</p>
<p>案例1：传入a和b两个值，最终a和b都翻倍并返回</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> myp7(INOUT a <span class="built_in">INT</span>, INOUT b <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SET</span> a=a*<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">SET</span> b=b*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @m=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">SET</span> @n=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">CALL</span> myp7(@m,@n);</span><br><span class="line"><span class="keyword">SELECT</span> @m,@n;</span><br></pre></td></tr></table></figure>

<h4 id="存储过程删除"><a href="#存储过程删除" class="headerlink" title="存储过程删除"></a>存储过程删除</h4><p>语法：drop procedure 存储过程名</p>
<h4 id="查看存储过程的信息"><a href="#查看存储过程的信息" class="headerlink" title="查看存储过程的信息"></a>查看存储过程的信息</h4><p>show create procedure 存储过程名</p>
<h4 id="存储过程练习"><a href="#存储过程练习" class="headerlink" title="存储过程练习"></a>存储过程练习</h4><p>1、创建存储过程实现传入用户名和密码，插入到admin表中</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_pro1(<span class="keyword">IN</span> username <span class="built_in">VARCHAR</span>(<span class="number">20</span>), <span class="keyword">IN</span> <span class="keyword">PASSWORD</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">admin</span>(admin.username,admin.<span class="string">`password`</span>)</span><br><span class="line">	<span class="keyword">VALUES</span>(username,<span class="keyword">PASSWORD</span>);</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> test_pro1(<span class="string">'admin'</span>,<span class="string">'0000'</span>);</span><br></pre></td></tr></table></figure>

<p>2、创建存储过程或函数实现传入女神编号，返回女神名称和女神电话</p>
<p>有复制，用select 字段 into 变量名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_pro2(<span class="keyword">IN</span> beautyID <span class="built_in">INT</span>,<span class="keyword">OUT</span> beautyName <span class="built_in">VARCHAR</span>(<span class="number">20</span>),<span class="keyword">OUT</span> beautyPhone <span class="built_in">VARCHAR</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="string">`name`</span> ,<span class="string">`phone`</span> <span class="keyword">INTO</span> beautyName,beautyPhone</span><br><span class="line">	<span class="keyword">FROM</span> <span class="string">`beauty`</span></span><br><span class="line">	<span class="keyword">WHERE</span> <span class="keyword">id</span>=beautyID;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> test_pro2(<span class="number">12</span>,@<span class="keyword">name</span>,@phone);</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">name</span>,@phone;</span><br></pre></td></tr></table></figure>

<p>3、创建存储过程或函数实现传入两个女神生日，返回大小</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_pro3(<span class="keyword">IN</span> birth1 DATETIME, <span class="keyword">IN</span> birth2 DATETIME, <span class="keyword">OUT</span> <span class="keyword">result</span> <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DATEDIFF</span>(birth1,birth2) <span class="keyword">INTO</span> <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> test_pro3(<span class="string">'1988-1-1'</span>,<span class="keyword">NOW</span>(),@<span class="keyword">result</span>);</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">result</span>;</span><br></pre></td></tr></table></figure>

<p>4、创建存储过程或函数传入一个日期，格式化成xx年xx月xx日并返回</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_pro4(<span class="keyword">IN</span> mydate DATETIME, <span class="keyword">OUT</span> <span class="keyword">str</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>(mydate,<span class="string">'%y年%m月%d日'</span>) <span class="keyword">INTO</span> <span class="keyword">str</span>;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> test_pro4(<span class="keyword">NOW</span>(),@<span class="keyword">str</span>);</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">str</span>;</span><br></pre></td></tr></table></figure>

<p>5、创建存储过程或函数传入女神名称，返回：女神 and 男神 格式的字符串</p>
<p>如：传入 小昭</p>
<p>返回：小昭 and 张无忌</p>
<p>思路：正常查询，其中字符串拼接使用CONCAT函数，中间用逗号隔开，输出存入变量，查询用右外连接，加上筛选条件。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_pro5(<span class="keyword">IN</span> beautyName <span class="built_in">VARCHAR</span>(<span class="number">20</span>), <span class="keyword">OUT</span> <span class="keyword">str</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(beautyName,<span class="string">' and '</span>,boyName) <span class="keyword">INTO</span> <span class="keyword">str</span></span><br><span class="line">	<span class="keyword">FROM</span> boys bo</span><br><span class="line">	<span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> beauty b</span><br><span class="line">	<span class="keyword">ON</span> bo.id=b.boyfriend_id</span><br><span class="line">	<span class="keyword">WHERE</span> b.name=beautyName;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> test_pro5(<span class="string">'小昭'</span>,@<span class="keyword">str</span>);</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">str</span>;</span><br></pre></td></tr></table></figure>

<p>但是这样写的话，当boyName为null的时候，拼接在一起也是null，因此最好使用ifnull来进行判断，只要有为空可能的字段，要是跟其他字符串拼接或者要使用它，最好加上IFNULL判断。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_pro5(<span class="keyword">IN</span> beautyName <span class="built_in">VARCHAR</span>(<span class="number">20</span>), <span class="keyword">OUT</span> <span class="keyword">str</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(beautyName,<span class="string">' and '</span>,<span class="keyword">IFNULL</span>(boyName,<span class="string">'null'</span>)) <span class="keyword">INTO</span> <span class="keyword">str</span></span><br><span class="line">	<span class="keyword">FROM</span> boys bo</span><br><span class="line">	<span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> beauty b</span><br><span class="line">	<span class="keyword">ON</span> bo.id=b.boyfriend_id</span><br><span class="line">	<span class="keyword">WHERE</span> b.name=beautyName;</span><br><span class="line"><span class="keyword">END</span> $</span><br></pre></td></tr></table></figure>

<p>6、创建存储过程或函数，根据传入的条目数和起始索引，查询beauty表的记录</p>
<p>其中用到了分页，limit 【offset】，size</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_pro6(<span class="keyword">IN</span> <span class="keyword">size</span> <span class="built_in">INT</span>, <span class="keyword">IN</span> startIndex <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> beauty <span class="keyword">LIMIT</span> startIndex,<span class="keyword">size</span>;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> test_pro6(<span class="number">3</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>与存储过程的区别是：</p>
<ul>
<li>存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新</li>
<li>函数：有且仅有1个返回，适合做处理数据后返回一个结果</li>
</ul>
<h4 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h4><p>1、创建语法</p>
<p>create function 函数名（参数列表）<strong>returns</strong> 返回类型</p>
<p>begin</p>
<p>​    函数体</p>
<p>end</p>
<p>注意：</p>
<ul>
<li><p>参数列表包含两部分，参数名  参数类型</p>
</li>
<li><p>函数体：肯定会有return语句，如果没有会报错，如果return语句不放在函数体最后不报错，但不建议</p>
</li>
<li><p>函数体中仅有一句话，可以省略begin end</p>
</li>
<li><p>使用delimiter语句设置结束标记</p>
</li>
</ul>
<h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>执行语句并显示返回值</p>
<p>语法：</p>
<p>select 函数名（参数列表）</p>
<p>1、无参有返回</p>
<p>案例：返回公司的员工个数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> myf1() <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> c <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;<span class="comment">#定义变量</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">INTO</span> c<span class="comment">#赋值</span></span><br><span class="line">	<span class="keyword">FROM</span> employees;</span><br><span class="line">	RETURN c;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line"><span class="keyword">SELECT</span> myf1();</span><br></pre></td></tr></table></figure>

<p>2、有参有返回</p>
<p>案例1：根据员工名，返回它的工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> myf2(empName <span class="built_in">VARCHAR</span>(<span class="number">20</span>)) <span class="keyword">RETURNS</span> <span class="keyword">DOUBLE</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SET</span> @sal=<span class="number">0</span>;<span class="comment">#定义用户变量</span></span><br><span class="line">	<span class="keyword">SELECT</span> salary <span class="keyword">INTO</span> @sal<span class="comment">#赋值</span></span><br><span class="line">	<span class="keyword">FROM</span> employees</span><br><span class="line">	<span class="keyword">WHERE</span> last_name = empName;</span><br><span class="line">	RETURN @sal;<span class="comment">#返回值</span></span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> myf2(<span class="string">'Kochhar'</span>);</span><br></pre></td></tr></table></figure>

<p>案例2：根据部门名，返回该部门的平均工资</p>
<p>规律：</p>
<ul>
<li>记得写returns 变量 类型</li>
<li>在begin end中定义变量（declare sal double）or （set @sal double）</li>
<li>利用select 字段 into 变量赋值</li>
<li>最后return 变量。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> myf3(depName <span class="built_in">VARCHAR</span>(<span class="number">20</span>)) <span class="keyword">RETURNS</span> <span class="keyword">DOUBLE</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="comment">#定义返回值</span></span><br><span class="line">	<span class="keyword">DECLARE</span> sal <span class="keyword">DOUBLE</span>;</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(salary) <span class="keyword">INTO</span> sal</span><br><span class="line">	<span class="keyword">FROM</span> employees e</span><br><span class="line">	<span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.<span class="string">`department_id`</span>=d.<span class="string">`department_id`</span></span><br><span class="line">	<span class="keyword">WHERE</span> d.<span class="string">`department_name`</span>= depName;</span><br><span class="line">	RETURN sal;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> myf3(<span class="string">'IT'</span>);</span><br></pre></td></tr></table></figure>

<h4 id="查看函数"><a href="#查看函数" class="headerlink" title="查看函数"></a>查看函数</h4><p>语法</p>
<p>show create function 函数名;</p>
<h4 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h4><p>语法</p>
<p>drop function 函数名；</p>
<h4 id="函数练习"><a href="#函数练习" class="headerlink" title="函数练习"></a>函数练习</h4><p>案例：创建函数，实现传入两个float，返回二者之和</p>
<p>这里给变量赋值，可以使用set 变量=语句，也可以使用select 语句 into 变量名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> myf4(num1 <span class="built_in">FLOAT</span>,num2 <span class="built_in">FLOAT</span>) <span class="keyword">RETURNS</span> <span class="built_in">FLOAT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> num3 <span class="built_in">FLOAT</span>;</span><br><span class="line">	<span class="keyword">SET</span> num3 = num1 + num2;</span><br><span class="line">	RETURN num3;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> myf4(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h2 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h2><ul>
<li>顺序结构：程序从上往下一次执行</li>
<li>分支结构：程序从两条或多条路径中选择一条去执行</li>
<li>循环结构：程序在满足一定条件的基础上，重复执行一段代码</li>
</ul>
<h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><h4 id="IF函数"><a href="#IF函数" class="headerlink" title="IF函数"></a>IF函数</h4><p>功能：实现简单的双分支</p>
<p>select If(表达式1，表达式2，表达式3)</p>
<p>执行顺序：如果IF函数成立，则IF函数返回表达式2的值，否则返回表达式3的值</p>
<p>应用在任何地方</p>
<h4 id="CASE结构"><a href="#CASE结构" class="headerlink" title="CASE结构"></a>CASE结构</h4><p>情况1：类似于java中的switch语句，一般用于实现等值判断</p>
<p>语法：</p>
<p>case 变量|表达式|字段</p>
<p>when 要判断的值 then 返回的值1或语句1【；】</p>
<p>when 要判断的值 then 返回的值2或语句2【；】</p>
<p>…</p>
<p>else 要返回的值 n或语句n【；】</p>
<p>end 【case;】</p>
<p>情况2：类似于java中的多重IF语句，一般用于实现区间判断</p>
<p>case </p>
<p>when 要判断的条件1 then 返回的值1或语句1【；】</p>
<p>when 要判断的条件2 then 返回的值2或语句2【；】</p>
<p>…</p>
<p>else 要返回的值 n或语句n【；】</p>
<p>end 【case；】</p>
<p>特点：</p>
<ol>
<li><p>可以作为表达式，嵌套在其他语句中使用，可以放在任何地方，begin end中或外面</p>
<p>可以作为<strong>独立的语句</strong>使用，只能放在begin end中</p>
</li>
<li><p>如果when中的值满足或条件成立，则执行对应的then后面的语句，并且结束case </p>
<p>如果都不满足，则执行else中的语句或值</p>
</li>
<li><p>else可以省略，如果else省略了，并且所有的when条件都不满足，则返回null</p>
</li>
</ol>
<p>案例：创建存储过程，根据传入的成绩来显示等级，如传入成绩：90-100，显示A；80-90，显示B；60-80，显示C；否则显示D</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_case(<span class="keyword">IN</span> score <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">CASE</span> </span><br><span class="line">	<span class="keyword">WHEN</span> score&gt;=<span class="number">90</span> <span class="keyword">AND</span> score&lt;=<span class="number">100</span> <span class="keyword">THEN</span> <span class="keyword">SELECT</span> <span class="string">'A'</span>;</span><br><span class="line">	WHEN score&gt;=80 THEN SELECT 'B';</span><br><span class="line">	WHEN score&gt;=60 THEN SELECT 'C';</span><br><span class="line">	ELSE <span class="keyword">SELECT</span> <span class="string">'D'</span>;</span><br><span class="line">	<span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> test_case(<span class="number">55</span>);</span><br></pre></td></tr></table></figure>

<h4 id="IF结构"><a href="#IF结构" class="headerlink" title="IF结构"></a>IF结构</h4><p>功能：实现多重分支</p>
<p>语法：</p>
<p>if 条件1 then 语句1；</p>
<p>elseif 条件2 then 语句2；</p>
<p>…</p>
<p>【else 语句n;】</p>
<p>end if;</p>
<p>应用场景：应用在begin end中</p>
<p>案例：根据传入的成绩，来显示等级，比如传入成绩：90-100，返回A；80-90，返回B；60-80，返回C；否则返回D</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $	 </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> test_if(score <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">CHAR</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">IF</span> score&gt;=<span class="number">90</span> <span class="keyword">AND</span> score&lt;=<span class="number">100</span> <span class="keyword">THEN</span> <span class="keyword">RETURN</span> <span class="string">'A'</span>;</span><br><span class="line">	ELSEIF score&gt;=80 THEN RETURN 'B';</span><br><span class="line">	ELSEIF score&gt;=60 THEN RETURN 'C';</span><br><span class="line">	ELSE RETURN 'D';</span><br><span class="line">	<span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> test_if(<span class="number">86</span>);</span><br></pre></td></tr></table></figure>

<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>分类：while、loop、repeat</p>
<p>循环控制：</p>
<p>iterate类似于continue，继续，结束本次循环，继续下一次</p>
<p>leave类似于break，跳出，结束当前所在的循环</p>
<h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>语法：</p>
<p>【标签：】while 循环条件 do</p>
<p>​    循环体;</p>
<p>end while【标签】；</p>
<h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h4><p>语法：</p>
<p>【标签：】loop</p>
<p>​    循环体；</p>
<p>end loop【标签】；</p>
<p>可以用来模拟简单的死循环</p>
<h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h4><p>类似于do while，至少执行一次</p>
<p>语法：</p>
<p>【标签：】repeat</p>
<p>​    循环体；</p>
<p>until 结束循环的条件</p>
<p>end repeat 【标签】；</p>
<h4 id="循环的使用"><a href="#循环的使用" class="headerlink" title="循环的使用"></a>循环的使用</h4><p>没有添加循环控制语句</p>
<p>案例：批量插入，根据次数插入到admin表中多条记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> pro_while1(<span class="keyword">IN</span> insertCount <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="comment">#定义循环变量i，int类型初始值为1</span></span><br><span class="line">	<span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">	WHILE i&lt;=insertCount DO</span><br><span class="line">		<span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">admin</span>(username,<span class="string">`password`</span>) <span class="keyword">VALUES</span>(<span class="keyword">CONCAT</span>(<span class="string">'rose'</span>,i),<span class="string">'666'</span>);</span><br><span class="line">		<span class="keyword">SET</span> i=i+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">END</span> <span class="keyword">WHILE</span>; </span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> pro_while1(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>添加leave语句</p>
<p>案例：批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止</p>
<p>这里配合了IF结构来使用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_while1(<span class="keyword">IN</span> insertCount <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">	a:WHILE i&lt;=insertCount DO</span><br><span class="line">		<span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">admin</span>(username,<span class="string">`password`</span>) <span class="keyword">VALUES</span>(<span class="keyword">CONCAT</span>(<span class="string">'hua'</span>,i),<span class="string">'0000'</span>);</span><br><span class="line">		IF i&gt;=20 THEN LEAVE a;</span><br><span class="line">		<span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">		<span class="keyword">SET</span> i=i+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">END</span> <span class="keyword">WHILE</span> a;	</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> test_while1(<span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>添加iterate语句</p>
<p>案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次</p>
<p>思路：在不为偶数次的时候，iterate退出即可。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test_while2(<span class="keyword">IN</span> insertCount <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	a:WHILE i&lt;=insertCount DO</span><br><span class="line">		<span class="keyword">SET</span> i=i+<span class="number">1</span>;</span><br><span class="line">		IF MOD(i,2)!=0 THEN ITERATE a;</span><br><span class="line">		<span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">		<span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">admin</span>(username,<span class="string">`password`</span>) <span class="keyword">VALUES</span>(<span class="keyword">CONCAT</span>(<span class="string">'xi'</span>,i),<span class="string">'0000'</span>);</span><br><span class="line">	<span class="keyword">END</span> <span class="keyword">WHILE</span> a;	</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> test_while2(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<h4 id="循环总结"><a href="#循环总结" class="headerlink" title="循环总结"></a>循环总结</h4>

<h2 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h2><h3 id="IFNULL【重要】"><a href="#IFNULL【重要】" class="headerlink" title="IFNULL【重要】"></a>IFNULL【重要】</h3><p>IFNULL（变量名，常量）</p>
<p>如果变量为空，则用常量代替。</p>
<p>只要有为空可能的字段，要是跟其他字符串拼接或者要使用它，最好加上IFNULL判断。</p>
<h3 id="SET-NAMES-gbk"><a href="#SET-NAMES-gbk" class="headerlink" title="SET NAMES gbk;"></a>SET NAMES gbk;</h3><p>要是字符集报错，一般需要重新设置字符集</p>
<h3 id="DATEDIFF（time1-time2）"><a href="#DATEDIFF（time1-time2）" class="headerlink" title="DATEDIFF（time1,time2）"></a>DATEDIFF（time1,time2）</h3><p>返回两个datetime类型的时间差，返回为整数</p>
<h3 id="NOW"><a href="#NOW" class="headerlink" title="NOW()"></a>NOW()</h3><p>返回现在的时间，datetime类型</p>
<h3 id="CONCAT"><a href="#CONCAT" class="headerlink" title="CONCAT()"></a>CONCAT()</h3><p>拼接字符串，中间用逗号隔开</p>
<h3 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h3><p>limit 【offset】，size</p>
<p>用来分页，其中offset为开始的地方，从0开始，size表示数据量。</p>
<h2 id="牛客网题目"><a href="#牛客网题目" class="headerlink" title="牛客网题目"></a>牛客网题目</h2><p>1、查找当前薪水(to_date=’9999-01-01’)排名第二多的员工编号emp_no、薪水salary、last_name以及first_name，不准使用order by</p>
<p>思路：不能使用order by，就只能先找到最高薪水，然后将其排除在salary的选择之中（NOT IN），然后在剩下的工资中选择最大的，即为总体第二大的，用到的是内连接+where子查询的嵌套。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> e.emp_no,<span class="keyword">max</span>(salary) salary ,e.last_name,e.first_name</span><br><span class="line"><span class="keyword">from</span> employees e</span><br><span class="line"><span class="keyword">join</span> salaries s</span><br><span class="line"><span class="keyword">on</span> e.emp_no=s.emp_no</span><br><span class="line"><span class="keyword">where</span> s.to_date=<span class="string">'9999-01-01'</span></span><br><span class="line"><span class="keyword">and</span> s.salary <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">max</span>(salary)</span><br><span class="line">    <span class="keyword">from</span> salaries</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">to_date</span>=<span class="string">'9999-01-01'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>2、查找员工编号emp_no为10001其自入职以来的薪水salary涨幅值growth</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`salaries`</span> (</span><br><span class="line"><span class="string">`emp_no`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`salary`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`from_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`to_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`emp_no`</span>,<span class="string">`from_date`</span>));</span><br></pre></td></tr></table></figure>

<p>将工资按照时间排序，找出第一个和最后一个，然后二者相减。考察的是<strong>select的子句查询</strong>。最外层的select不用加from表，因为用不到。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">(<span class="keyword">select</span> salary <span class="keyword">from</span> salaries <span class="keyword">where</span> emp_no = <span class="number">10001</span> <span class="keyword">order</span> <span class="keyword">by</span> from_date <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>)</span><br><span class="line">-(<span class="keyword">select</span> salary <span class="keyword">from</span> salaries <span class="keyword">where</span> emp_no = <span class="number">10001</span> <span class="keyword">order</span> <span class="keyword">by</span> from_date <span class="keyword">asc</span> <span class="keyword">limit</span> <span class="number">1</span>)</span><br><span class="line"><span class="keyword">as</span> growth;</span><br></pre></td></tr></table></figure>

<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>Java DtaBase Connectivity</p>
<p>将Java程序与数据库连接在一起。JDBC统一接口，java程序与JDBC通信，JDBC通过不同驱动连接不同的数据库，相当于在java和数据库之间加了一层。一层不行就加两层。</p>
<h3 id="Driver-Manager"><a href="#Driver-Manager" class="headerlink" title="Driver Manager"></a>Driver Manager</h3><p>就是一个类库。通过Maneger连接不同的数据库</p>
<h3 id="JDBC使用"><a href="#JDBC使用" class="headerlink" title="JDBC使用"></a>JDBC使用</h3><ol>
<li>加载对应数据库的驱动</li>
<li>根据指定的URL建立连接</li>
<li>通过连接过去语句对象</li>
<li>在语句对象中写入要执行的语句，获取结果集</li>
<li>遍历结果集，获取数据</li>
<li>关闭资源</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、加载驱动</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line"><span class="comment">//2、通过Manager创建连接</span></span><br><span class="line">String url = <span class="string">"jdbc:mysql://localhost/girls?user=root&amp;password=qkxzs&amp;serverTimezone=UTC"</span>;</span><br><span class="line">Connection conn = DriverManager.getConnection(url);</span><br><span class="line"><span class="comment">//3、创建语句对象</span></span><br><span class="line">Statement statement = conn.createStatement();</span><br><span class="line"><span class="comment">//4、用语句对象去执行语句</span></span><br><span class="line">ResultSet resultSet = statement.executeQuery(<span class="string">"select * from admin"</span>);</span><br><span class="line"><span class="comment">//5、获取结果集中内容</span></span><br><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">    System.out.println(resultSet.getInt(<span class="string">"id"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6、关闭资源</span></span><br><span class="line">resultSet.close();</span><br><span class="line">statement.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure>

<p>使用技巧：语句对象中执行的sql语句先在客户端执行，看是否正确；结果集的指针指向第一条记录的上面，因此next后才是第一条语句。</p>
<p>完善的写法如下，在加载的时候，进行try,catch，在创建的时候，进行try，catch，在关闭的时候，进行判断是否为空，然后在finally中关闭。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1、加载驱动</span></span><br><span class="line">            Class.forName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、通过Manager创建连接</span></span><br><span class="line">        String url = <span class="string">"jdbc:mysql://localhost/girls?user=root&amp;password=qkxzs&amp;serverTimezone=UTC"</span>;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//3、创建语句对象</span></span><br><span class="line">        Statement statement = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//4、用语句对象去执行语句</span></span><br><span class="line">        ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = DriverManager.getConnection(url);</span><br><span class="line">            statement = conn.createStatement();</span><br><span class="line">            resultSet = statement.executeQuery(<span class="string">"select * from admin"</span>);</span><br><span class="line">            <span class="comment">//5、获取结果集中内容</span></span><br><span class="line">            <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">                System.out.println(resultSet.getInt(<span class="string">"id"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//6、关闭资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (resultSet != <span class="keyword">null</span>)</span><br><span class="line">                    resultSet.close();</span><br><span class="line">                <span class="keyword">if</span> (statement != <span class="keyword">null</span>)</span><br><span class="line">                    statement.close();</span><br><span class="line">                <span class="keyword">if</span> (conn != <span class="keyword">null</span>)</span><br><span class="line">                    conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果是传入的参数是不确定的，如sql语句中大于某个字段的值一开始不确定，那么sql语句中用占位符?先表示，然后使用PreparedStatement，将占位符？进行替换，再进行查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3、创建语句对象</span></span><br><span class="line">      PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//4、用语句对象去执行语句</span></span><br><span class="line">      ResultSet resultSet = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">int</span> id = <span class="number">10</span>;</span><br><span class="line">      String sql = <span class="string">"select * from admin where id &gt; ?"</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          conn = DriverManager.getConnection(url);</span><br><span class="line">          ps = conn.prepareStatement(sql);</span><br><span class="line">          ps.setInt(<span class="number">1</span>,id);<span class="comment">//替换在第一个问号处</span></span><br><span class="line">          resultSet = ps.executeQuery();</span><br><span class="line">          <span class="comment">//5、获取结果集中内容</span></span><br><span class="line">          <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">              System.out.println(resultSet.getInt(<span class="string">"id"</span>)+<span class="string">" "</span>+resultSet.getString(<span class="string">"username"</span>));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>如果是sql语句为insert，update，delete这种更新的语句，则不需要获取结果集，而且执行语句时使用statement.executeUpdate即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Statement statement = <span class="keyword">null</span>;</span><br><span class="line">        String sql = <span class="string">"insert into admin values(64,'jdbc','0001')"</span>;</span><br><span class="line">        <span class="comment">//String sql = "update admin set username='jdbc2' where id = 64";</span></span><br><span class="line">		<span class="comment">//String sql = "delete from admin where id = 64";</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = DriverManager.getConnection(url);</span><br><span class="line">            statement = conn.createStatement();</span><br><span class="line">            statement.executeUpdate(sql);<span class="comment">//insert update delete</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>如果是更新的数据不确定，同样使用PreparedStatement即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3、创建语句对象</span></span><br><span class="line">      PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">      String sql = <span class="string">"insert into admin values(?,?,?)"</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          conn = DriverManager.getConnection(url);</span><br><span class="line">          ps = conn.prepareStatement(sql);</span><br><span class="line">          ps.setInt(<span class="number">1</span>,<span class="number">64</span>);</span><br><span class="line">          ps.setString(<span class="number">2</span>,<span class="string">"jdbc3"</span>);</span><br><span class="line">          ps.setString(<span class="number">3</span>,<span class="string">"0002"</span>);</span><br><span class="line">          ps.executeUpdate();<span class="comment">//insert update delete</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h3><p>步骤：</p>
<p>1、connection关闭自动提交</p>
<p>2、一组sql语句</p>
<p>3、connection提交</p>
<p>4、在catch中，有异常时回滚</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1、加载驱动</span></span><br><span class="line">            Class.forName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、通过Manager创建连接</span></span><br><span class="line">        String url = <span class="string">"jdbc:mysql://localhost/test?user=root&amp;password=qkxzs&amp;serverTimezone=UTC"</span>;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//3、创建语句对象</span></span><br><span class="line">        Statement statement = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = DriverManager.getConnection(url);</span><br><span class="line">            statement = conn.createStatement();</span><br><span class="line">            conn.setAutoCommit(<span class="keyword">false</span>);<span class="comment">//关闭自动提交</span></span><br><span class="line">            statement.executeUpdate(<span class="string">"update account set balance= 50 where id = 1"</span>);</span><br><span class="line">            statement.executeUpdate(<span class="string">"update account set balance= 150 where id = 2"</span>);</span><br><span class="line">            conn.commit();<span class="comment">//手动提交</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.rollback();<span class="comment">//有异常时回滚</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//6、关闭资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (statement != <span class="keyword">null</span>)</span><br><span class="line">                    statement.close();</span><br><span class="line">                <span class="keyword">if</span> (conn != <span class="keyword">null</span>)</span><br><span class="line">                    conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="MySQL客户端"><a href="#MySQL客户端" class="headerlink" title="MySQL客户端"></a>MySQL客户端</h3><ul>
<li>F12 将选中语句自动换行</li>
</ul>
<h1 id="MySQL高级"><a href="#MySQL高级" class="headerlink" title="MySQL高级"></a>MySQL高级</h1><h2 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h2><p>有点类似设计模式中设计原则，即如何设计设计模式，而数据库范式就是如何设计数据库，即设计数据库需要满足的规范。</p>
<p>有第一范式、第二范式、第三范式、BC范式、第四范式和第五范式</p>
<p>范式并不是越高越好，范式越高，数据库冗余越小，查询性能越低。一般满足第三范式即可。</p>
<h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><p>数据库的每一列是原子性的，不可再分。即一个列中不应该还能再拆分为多个属性。</p>
<h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><p>要满足第一范式，属性完全依赖于主键，不能部分依赖。如果有2个主键，有个属性只依赖于其中一个主键，就不满足第二范式。</p>
<h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><p>要满足第二范式，属性不能依赖于其他非主键属性，只依赖于主键。</p>
<p>简单来说，就是拆表。</p>
<h2 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h2><ol>
<li><p>连接层</p>
<p>客户端与连接服务，主要完成类似于连接处理、授权认证及相关的安全方案。该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。可实现基于SSL的安全链接。</p>
</li>
<li><p>服务层</p>
<p>完成大多数的核心服务功能，如SQL接口，完成缓存的查询，SQL的分析和优化及部分内置函数执行。</p>
</li>
<li><p>引擎层</p>
<p>存储引擎层，存储引擎真正负责MySQL中数据的存储和提取，服务器通过API与存储引擎通信。</p>
</li>
<li><p>存储层</p>
<p>数据存储层，将数据存储在运行与裸设备的文件系统之上，并完成与存储引擎的交互</p>
</li>
</ol>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>插件式存储引擎架构将查询处理和其他的系统任务以及数据的存储提取相分离。</p>
<p>存储引擎是针对表而生效的，而不是数据库。</p>
<p>查看存储引擎</p>
<p>show engines;</p>
<p>show variables like ‘%storage_engine%’;</p>
<p>MySQL默认InnoDB</p>
<h4 id="MyISAM与InnoDB"><a href="#MyISAM与InnoDB" class="headerlink" title="MyISAM与InnoDB"></a>MyISAM与InnoDB</h4><table>
<thead>
<tr>
<th>对比</th>
<th align="left">MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>主外键</td>
<td align="left">不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td align="left">不支持</td>
<td>支持</td>
</tr>
<tr>
<td>行表锁</td>
<td align="left">表锁，操作一条数据锁整个表，不适合高并发</td>
<td>行锁，操作只锁一行，不对其他行有影响。适合<strong>高并发</strong></td>
</tr>
<tr>
<td>缓存</td>
<td align="left">只缓存索引，不缓存真实数据</td>
<td>缓存索引与真实数据，对内存要求高，而且内存大小对性能有决定性影响</td>
</tr>
<tr>
<td>表空间</td>
<td align="left">小</td>
<td>大</td>
</tr>
<tr>
<td>关注点</td>
<td align="left"><strong>性能</strong></td>
<td><strong>事务</strong></td>
</tr>
<tr>
<td>默认安装</td>
<td align="left">是</td>
<td>是</td>
</tr>
<tr>
<td>表文件</td>
<td align="left">3个，frm存放表结构信息，MYD存放数据，MYI存放表索引</td>
<td>2个，frm存放表结构信息，</td>
</tr>
</tbody></table>
<p>阿里巴巴大部分mysql数据库使用的为percona的原型加以修改，percona提升了高负载下InnoDB性能，更多的诊断与控制行为。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>性能下降SQL慢，如果执行时间长或者等待时间长</p>
<ul>
<li>查询语句写的烂</li>
<li>索引失效</li>
<li>关联查询太多join（设计缺陷或不得已的需求）</li>
<li>服务器调优及各个参数设置（缓冲、线程数等）</li>
</ul>
<img src="/2020/02/09/MySQL/sql%E9%A1%BA%E5%BA%8F.png" class title="This is an example image">

<p>sql的执行顺序为</p>
<ol>
<li>from</li>
<li>join</li>
<li>where</li>
<li>group by</li>
<li>having</li>
<li>select</li>
<li>order by</li>
<li>limit</li>
</ol>
<h3 id="join分类"><a href="#join分类" class="headerlink" title="join分类"></a>join分类</h3><img src="/2020/02/09/MySQL/%E5%B7%A6%E5%A4%96%E5%8F%B3%E5%A4%96%E5%85%A8%E5%A4%96.png" class title="This is an example image">

<img src="/2020/02/09/MySQL/%E4%B8%89%E7%A7%8D%E8%BF%9E%E6%8E%A5.png" class title="This is an example image">

<p>在左外，右外，全连接上加筛选得到。</p>
<h3 id="索引的认识"><a href="#索引的认识" class="headerlink" title="索引的认识"></a>索引的认识</h3><p>索引Index是帮助MySQL高效获取数据的数据结构，即索引的本质是<strong>数据结构</strong>。    </p>
<p>索引的目的是提高查询效率，可以类比字典。直观理解为<strong>排好序</strong>的<strong>快速查找</strong>数据结构。影响where的查找与order后的排序。</p>
<p>数据库分别维护着索引与数据，索引指向数据。</p>
<p>二叉查找树，左子树所有节点值比当前值小，右子树所有节点值比当前值大，左右子树分别为二叉查找树。为了检验，可以用中序遍历，得到为递增序列就是二叉查找树。这样用二叉查找树，每次可以过滤一半数据，而树的节点指向了数据。</p>
<p>因为索引本身也很大，一般以索引<strong>文件</strong>的形式存在于<strong>磁盘</strong>上。 （索引存在于文件系统中）</p>
<p>索引的文件存储形式与<strong>存储引擎</strong>有关（InnoDB将索引与数据存在一起，MyISAM将索引与数据分开存放）</p>
<p>放在磁盘中，就会存在IO，需要减少IO的时间</p>
<ul>
<li>减少IO的量</li>
<li>减少IO的次数</li>
</ul>
<p>平常说的索引，一般默认指B树（多路搜索树，不一定为二叉）结构组织的索引。</p>
<h3 id="索引的优势与劣势"><a href="#索引的优势与劣势" class="headerlink" title="索引的优势与劣势"></a>索引的优势与劣势</h3><p>优势</p>
<ul>
<li>提高数据<strong>检索的效率</strong>，降低数据库的IO成本</li>
<li>通过索引对数据<strong>排序</strong>，降低数据排序的成本，降低CPU消耗</li>
</ul>
<p>劣势</p>
<ul>
<li>索引列占据空间</li>
<li>索引虽然提高了查询速度，但会降低更新表的速度，因为索引需要更新</li>
<li>索引只是提高效率的一个因素，还需要优化索引建立或优化查询</li>
</ul>
<h3 id="MySQL索引分类"><a href="#MySQL索引分类" class="headerlink" title="MySQL索引分类"></a>MySQL索引分类</h3><p>1、单值索引</p>
<p>一个索引只包含单个列，一个表可以有多个单列索引</p>
<p>2、唯一索引</p>
<p>索引值必须要唯一，但允许有空值</p>
<p>3、复合索引</p>
<p>一个索引包含多个列</p>
<h3 id="密集索引与稀疏索引"><a href="#密集索引与稀疏索引" class="headerlink" title="密集索引与稀疏索引"></a>密集索引与稀疏索引</h3><ul>
<li>密集索引文件中每个搜索码值对应一个索引值</li>
<li>稀疏索引只为索引码的某些值建立索引项（需要找到对应地址，再继续搜索）</li>
</ul>
<img src="/2020/02/09/MySQL/%E5%AF%86%E9%9B%86%E7%B4%A2%E5%BC%95.png" class title="This is an example image">

<p>而下图展示了InnoDB和MyISAM的索引图</p>
<img src="/2020/02/09/MySQL/%E5%AF%86%E9%9B%86%E7%B4%A2%E5%BC%952.png" class title="This is an example image">

<p>对于Innodb</p>
<ul>
<li>主键为密集索引，叶子节点存储了索引和行数据，主键检索可以直接查找</li>
<li>对于非主键索引，其为稀疏索引，需要先在稀疏索引的B+树中检索定位主键信息，在主键中进行第二次寻找，在叶子节点中获取数据</li>
</ul>
<p>对MyISAM</p>
<ul>
<li>主键索引与非主键索引均为稀疏索引，即索引的叶子节点中不存储数据，索引与数据分开存储</li>
<li>对表来说这两个索引没有区别，非主键索引不用访问主键索引来获取数据</li>
</ul>
<h3 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>create [unique] index indexName on mytable(columnname(length));</p>
<p>alter table mytable add [unique] index [indexName] on (columnname(length));</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>drop index [indexName] on mytable;</p>
<h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><p>show index from table_name\G</p>
<h4 id="详细添加索引"><a href="#详细添加索引" class="headerlink" title="详细添加索引"></a>详细添加索引</h4><p>alter table tbl_name add primary key(column_list)：添加一个主键，以为索引必须唯一，且不能为空</p>
<p>alter table tbl_name add unique index_name(column_list)：创建索引值必须唯一（除了null，null可能出现多次）</p>
<p>alter table tbl_name add index index_name (column_list)：添加普通索引，索引值可出现多次</p>
<p>alter table tbl_name add fulltext index_name (column_list)：该语句指定了索引为fulltext，用于全文索引</p>
<h3 id="MySQL索引结构"><a href="#MySQL索引结构" class="headerlink" title="MySQL索引结构"></a>MySQL索引结构</h3><p>1、BTree索引</p>
<p>B树与B+树。</p>
<p>对B+树，<strong>真实数据只存在于叶子节点</strong>，<strong>非叶子节点不存储真实的数据</strong>，只存储指引搜索方向的数据项。树中每一层都是不同的磁盘块，读取算一次IO，树的高度越高，IO次数越多。</p>
<p>2、Hash索引</p>
<p>只有memory才显式支持hash</p>
<p>InnoDB支持哈希索引，自适应的，人为不可控制</p>
<p>3、full-text全文索引</p>
<p>4、R-Tree索引</p>
<h4 id="为什么用B-树而不用红黑树"><a href="#为什么用B-树而不用红黑树" class="headerlink" title="为什么用B+树而不用红黑树"></a>为什么用B+树而不用红黑树</h4><p>常见的树</p>
<p>BST：Binary Search Tree，二分查找树。左子树小，右子树大，极端情况下会退换成链表。</p>
<p>AVL：二叉平衡查找树，二叉树，节点有大小要求，左右子树高度差不超过1，让树更平衡。用低的插入性能换高的查询性能。适用于查询更多，但若插入更多，不适合。</p>
<p>红黑树：也是二叉平衡查找树，最长路径不超过最短路径2倍即可。数据多时，树的高度会比较高。</p>
<p>红黑树的旋转涉及到整棵树，因此需要将全部数据加载进内存，而且树的高度较高，而索引结构通常很大，一般以索引文件存在于硬盘中，使用红黑树IO次数多，因此红黑树不太适合索引的设计，而B树（B与B+）分块从磁盘中读取文件，只读取需要的块，树的高度更低，IO次数更少，适用于外部数据的读取，更适合索引的结构设计。</p>
<p>B+树结点数据存储一般应该为页的整数倍，Mysql在读取时候，默认一页为16k。</p>
<h4 id="B树与B-树区别"><a href="#B树与B-树区别" class="headerlink" title="B树与B+树区别"></a>B树与B+树区别</h4><blockquote>
<p>详细的数据结构，可参考此网站，动态展示了树的变化过程</p>
<p><code>https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</code></p>
</blockquote>
<p>B树与B+树均为平衡多路查找树，避免了二叉查找树树高度过高IO频繁的问题，所有叶节点高度相同，因此树是平衡的。</p>
<p>B树在所有节点上既存储数据又存储索引。如果一个节点为16k，而因为数据放在每一个节点中，数据需要占据一定的内存，因此每个节点存放数据大小有限。</p>
<p>而B+树在B树的基础之上，仅用叶子节点存储数据或指向数据的指针（InnoDB中主键索引中叶子节点有数据，非主键索引存放主键索引地址；MyISAM中主键与非主键索引均存放数据地址），非叶子节点的关键字个数与指针相同，可存储更多关键字，非叶子节点不存放数据，是从叶子节点中提取出的冗余索引，便于去查找数据，所有节点索引从左至右递增。所有的<strong>叶子节点</strong>有指针指向下一个节点。</p>
<img src="/2020/02/09/MySQL/B+%E6%A0%91%E8%8A%82%E7%82%B9.png" class title="This is an example image">

<p>每个节点如果设置太大，那么单次IO时间太长；如果设置太小，则树的高度不可控。Mysql默认设置一个节点16kb（一页），如果索引设置bigint为8字节，存储地址的字符大小为6字节，这样单个索引+指针占用14字节，这样可以存储1170个索引。若叶子节点存放数据，单个索引+数据大小假设为16kb，则一个叶子节点可放16个索引+数据，则总的为1170x1170x16约等于2.2kw。因此B+树可以存储更多数据，一般3层可以支持千万级别的数据量查询。而根节点一般常驻内存，3层的B+树一次查询的IO次数为2。</p>
<p>这样，B+树的优势为：更有利于对数据库的<strong>扫描</strong>与<strong>范围查询</strong>（叶子节点存在指针）。</p>
<p>B树的优势为：在某些查询条件下，查询效率更高，为O(1)。</p>
<p>数据结构没有好坏之分，只有合不合适。</p>
<p>因此，对于Mysql这种关系型数据库，表与表之间的关联性很强，利用一个表的字段去遍历另一个表的数据是非常常见的操作，因此使用B+树方便去遍历与范围查找，比较符合关系型数据库的应用场景。</p>
<p>而对于MongoDB，其为NoSQL数据库的一种，文档型数据库，用类似JSON的方式存储数据，用键的形式去获取数据效率较高，数据量很大而且注重效率。B树的key与data有对应关系，且单次查询效率更高，因此可以使用B树更符合这种非关系型数据库的应用场景。</p>
<p>而hash索引的效率理论上要更高，hash索引只支持IN或者=的查询，无法支持范围查询，因此在等值查询较少，范围查询更多的情况下，hash索引不太适合。hash表中需要将数据放入内存，适合memory。</p>
<p>而B*树在B+树的基础之上，非叶子节点之间也存在指针。</p>
<h4 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h4><p>InnoDB与MyISAM索引均为红黑树，但前者为聚集索引和密集索引，后者为非聚集索引和稀疏索引。InnoDB为聚集索引，将索引与数据存放在一起，主键索引可通过叶子节点访问数据，而非主键索引需要先找到对应主键再获取数据（需要2棵B+树查找），因此数据量较少的时候建立索引效率不一定会更高，这就是<strong>回表</strong>。</p>
<p>对比以下两个语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">"zs"</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 表名 <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">"zs"</span>;</span><br></pre></td></tr></table></figure>

<p>如果对id为主键索引，name也建立了索引，第一条语句在name索引的B+树叶子节点可以直接找到需要的id，而第二条数据，就必须用name索引树中获取的id在主键索引中回表，再次查找获取数据。不需要经过回表过程的叫做索引覆盖（查询的字段与建立索引相同）</p>
<p>而MyISAM索引与数据分开，为非聚集索引，叶子节点上存储的指向数据的指针，非主键索引不需要先找到主键索引再获取数据。</p>
<p>此聚集索引，如果在指定了主键情况下，为主键；如果有非空唯一键，为唯一键；如果均为没有，会自动生成一个隐藏的rowID作为聚集索引。</p>
<h3 id="建立索引情况"><a href="#建立索引情况" class="headerlink" title="建立索引情况"></a>建立索引情况</h3><h4 id="建立索引情况-1"><a href="#建立索引情况-1" class="headerlink" title="建立索引情况"></a>建立索引情况</h4><ol>
<li><strong>主键</strong>自动建立唯一索引</li>
<li><strong>频繁</strong>作为<strong>查询</strong>条件的字段应该创建索引</li>
<li>查询中与其他表相关联的字段，<strong>外键</strong>关系创立索引</li>
<li>在高并发下倾向于创建<strong>组合索引</strong></li>
<li>查询中<strong>排序</strong>的字段，排序字段若通过索引访问将大大提高排序速度</li>
<li>查询中统计或者分组字段</li>
</ol>
<h4 id="不建立索引情况"><a href="#不建立索引情况" class="headerlink" title="不建立索引情况"></a>不建立索引情况</h4><ol>
<li><p><strong>where条件里用不到</strong>的字段不要创建索引</p>
</li>
<li><p>表<strong>记录太少</strong></p>
</li>
<li><p>经常增删改的表</p>
</li>
<li><p>若某个数据列包括太多重复内容，建立索引无太大效果</p>
<p>数据重复且平均分配的值建索引效果不大</p>
</li>
</ol>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><h4 id="Mysql-Query-Optimizer"><a href="#Mysql-Query-Optimizer" class="headerlink" title="Mysql Query Optimizer"></a>Mysql Query Optimizer</h4><p>Mysql自带的分析工具，负责SELECT语句优化器，主要功能，提供Mysql认为最优的数据检索方式，但不认为DBA认为是最优的</p>
<h4 id="Mysql常见瓶颈"><a href="#Mysql常见瓶颈" class="headerlink" title="Mysql常见瓶颈"></a>Mysql常见瓶颈</h4><ul>
<li>CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘读取数据的时候</li>
<li>IO：磁盘I/O瓶颈发生在装入数据远大于内容容量的时候</li>
<li>服务器硬件性能瓶颈：top，free，iostat与vmstat来查看系统性能状态</li>
</ul>
<h4 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h4><p>是什么？（查看执行计划）</p>
<p>使用explain关键字可以模拟优化器执行SQL查询语句，从而知道Mysql如何处理你的SQL语句，分析你的查询语句或是表结构的性能瓶颈。</p>
<p>能干嘛 ？</p>
<ul>
<li>表的读取顺序：id</li>
<li>数据读取操作的操作类型：select_type</li>
<li>哪些索引可以使用</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询</li>
</ul>
<p>怎么用？</p>
<p><strong>explain+SQL语句</strong></p>
<p>表头信息</p>
<p>id|select_type|table|type|possible_keys|key|key_len|ref|rows|Extra</p>
<p><strong>id</strong></p>
<p>select查询的序列号，包含一组数字，表示查询中执行的select子句或操作表的顺序</p>
<p>三种情况</p>
<ul>
<li>id<strong>相同</strong>，<strong>执行顺序由上至下</strong></li>
<li>id<strong>不同</strong>，如果是子查询，id的序号会递增，<strong>id值越大优先级越高</strong></li>
<li>id不同，同时存在（大的先行，相同的从上至下）</li>
</ul>
<p>衍生=derived</p>
<p><strong>select_type</strong></p>
<ol>
<li>simple：简单的select查询，不包括子查询或者union</li>
<li>primary：查询中若包含复杂的子部分，最外层查询被标记</li>
<li>subquery：在select或where列表包含了子查询</li>
<li>derived：在from列表中包含的子查询被标记为derived（衍生），Mysql会递归执行这些子查询，将结果放在<strong>临时表</strong>中</li>
<li>union：若第二个select出现在union之后，被标记为union；若union包含在from子句的子查询中，外层select将被标记为derived</li>
<li>union result：从union表获取结果的select</li>
</ol>
<p>table：这行数据关于哪张表</p>
<p><strong>type</strong></p>
<p>访问类型排列</p>
<p>显示<strong>查询</strong>使用了何种<strong>类型</strong>，从最好到最差以此是</p>
<p>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;All</p>
<p>一般得保证查询至少达到<strong>range</strong>级别，<strong>最好能到ref</strong></p>
<p>system：表只有一行记录（等于系统表），为const类型的特例，平时不会出现</p>
<p>const：通过索引一次就找到了，const用于比较primary_key或者unique索引。因为只匹配一行数据，所以很快。如将索引置于where列表中，Mysql就能将该查询优化为常量</p>
<p>eq_ref：唯一性<strong>索引扫描</strong>，对于每个索引键，<strong>表中只有一条记录与之匹配</strong>，常见于主键或唯一索引扫描</p>
<p>ref：<strong>非唯一性索引扫描</strong>，返回匹配某个单独值的所有行。本质上也是一种<strong>索引访问</strong>，它返回所有匹配某个单独值的行，然而，可能会找到<strong>多个符合条件的行</strong>，应属于查找与扫描的混合体。</p>
<p>range：只检索给定范围的行，使用一个索引来选择行。一般为出现了between，and，&lt;，&gt;，in等的查询</p>
<p>index：full index scan，index与all区别为index类型只遍历索引树，通常比all快。（index从索引中读，all从硬盘中读）</p>
<p>all：全表扫描</p>
<p><strong>possible_keys与key</strong></p>
<ul>
<li>是否使用到索引</li>
<li>索引竞争时，最后用到哪个索引</li>
</ul>
<p>possible_key：显示可能应用在这个表上的索引，<strong>不一定被实际使用</strong></p>
<p>key：实际使用的索引，如果没null，没有使用到索引。查询中若使用了<strong>覆盖索引</strong>，该索引仅出现在key列表中。（<strong>查询的字段与建立的复合索引匹配</strong>）</p>
<p><strong>key_len</strong></p>
<p>表示索引中使用的字节数，可通过该列计算查询中使用的索引长度。在不损失精度下，越短越好。索引字段的最大可能长度，<strong>并非实际使用长度</strong>。根据表定义计算而得，不是通过表内检索出的。</p>
<p><strong>ref</strong></p>
<p> 显示索引的哪一列被使用，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。</p>
<p><strong>rows</strong></p>
<p>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数（越小越好） </p>
<p><strong>Extra</strong></p>
<p>包含不适合在其他列中显示但十分重要的信息</p>
<ul>
<li><p><strong>Using filesort</strong>：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序读取。Mysql无法使用索引完成的排序操作称为 “文件排序”。出现了<strong>不好</strong>！如索引顺序为col1，col2，col3，排序时从col3开始</p>
</li>
<li><p><strong>Using temporary</strong>：使用了临时表保存中间结果，Mysql在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。出现了<strong>很不好</strong>！<strong>group by的个数和顺序最好和索引相同</strong>！</p>
</li>
<li><p><strong>Using index</strong>：相应的select操作中使用了覆盖索引，避免访问了表的数据行，<strong>效率不错</strong>！如果同时出现using where，说明索引被用来执行索引键值的查找；如果没有，说明索引用来读取数据而非执行查找动作。</p>
<p>覆盖索引：建立了索引，且查询的列与索引的顺序与个数正好匹配。如果要使用覆盖索引，select列表中只取出所需要的列，不可select *。</p>
</li>
<li><p>Using where：使用了where</p>
</li>
<li><p>using join buffer：使用了连接缓存</p>
</li>
<li><p>impossible where：where子句的值为false</p>
</li>
<li><p>select tables optimized away：优化索引操作</p>
</li>
<li><p>distinct：优化distinct操作</p>
</li>
</ul>
<h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><h4 id="索引分析"><a href="#索引分析" class="headerlink" title="索引分析"></a>索引分析</h4><h5 id="单表"><a href="#单表" class="headerlink" title="单表"></a>单表</h5><p>先检验是否能查询出结果，再看如何优化</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`article`</span>(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">	author_id <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	category_id <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	views <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	comments <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	title VARBINARY(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	<span class="keyword">content</span> <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>	</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> article(<span class="string">`author_id`</span>,<span class="string">`category_id`</span>,<span class="string">`views`</span>,<span class="string">`comments`</span>,<span class="string">`title`</span>,<span class="string">`content`</span>) </span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="string">'1'</span>,<span class="string">'1'</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="string">'2'</span>,<span class="string">'2'</span>),(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="string">'3'</span>,<span class="string">'3'</span>);</span><br></pre></td></tr></table></figure>

<p>查询的为category_id为1，评论数&gt;1，views最多的作者id</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="string">`author_id`</span> <span class="keyword">FROM</span> <span class="string">`article`</span> <span class="keyword">WHERE</span> <span class="string">`category_id`</span>=<span class="number">1</span> <span class="keyword">AND</span> <span class="string">`comments`</span>&gt;<span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> views <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>查询结果为</p>
<img src="/2020/02/09/MySQL/%E5%8D%95%E8%A1%A8%E4%BC%98%E5%8C%961.png" class title="This is an example image">

<p>可以看出type为最差的All即全表扫描，Extra中有Using filesort，最坏的情况，需要优化。</p>
<p>因此需要建立索引，在where后面出现的可以建立索引。</p>
<p>尝试1：给where和order by后的`category_id，comments，views建立符合索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_article_ccv <span class="keyword">ON</span> article(category_id,comments,views);</span><br></pre></td></tr></table></figure>

<img src="/2020/02/09/MySQL/%E5%8D%95%E8%A1%A8%E4%BC%98%E5%8C%962.png" class title="This is an example image">

<p>这时候type为range，不是全表扫描了，但是Using filesort。因为是comment&gt;1，范围会导致索引失效，Mysql无法利用索引对views部分进行检索，后面的索引用不上。如果此时comment为=1，便可以用上。</p>
<p>将当前索引删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> idx_article_ccv <span class="keyword">ON</span> article;</span><br></pre></td></tr></table></figure>

<p>尝试2：不将comment作为索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_article_cv <span class="keyword">ON</span> article(category_id,views);</span><br></pre></td></tr></table></figure>

<p>这时候，再次查看explain结果</p>
<img src="/2020/02/09/MySQL/%E5%8D%95%E8%A1%A8%E4%BC%98%E5%8C%963.png" class title="This is an example image">

<p>发现type为ref，用到了索引，而且没有全文扫描，达到效果。</p>
<h5 id="两表"><a href="#两表" class="headerlink" title="两表"></a>两表</h5><p>两表连接时，当两个join时，索引该如何建立呢？</p>
<p>当有两个表，使用left join的时候，连接条件为，发现两个表的type都为all，因此可以建立索引。</p>
<p>左连接，索引加在右表，右表此时为ref，使用到了索引。</p>
<p>左连接，索引加载左表，左表为index，效果没有加在右表上好。</p>
<p>因为左连接的特性：左边一定有。left join条件用于确定如何从右边搜索行，左边一定都有。<strong>右边为关键点，一定要建立索引</strong>。</p>
<p>因此，左连接，给右表建立索引；右连接，给左表建立索引。换而言之，有索引的表作为从表。</p>
<p>join语句的优化：</p>
<ul>
<li>尽可能减少join语句中的循环次数，<strong>用小表驱动大表</strong>。</li>
<li>优先优化NestedLoop的内层循环</li>
<li>保证join语句中被驱动表上join条件字段已经被索引</li>
<li>当无法保证被驱动表的join字段被索引且内存资源充足的情况下，不要太吝惜JoinBuffer的设置</li>
</ul>
<h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4><ol>
<li><p>全值匹配最好（where查询为全部索引）</p>
</li>
<li><p><strong>最佳左前缀法则</strong>（火车头不能丢，中间车厢不能断）</p>
<p>如果索引了多列，要遵循最佳左前缀法则，查询从索引的<strong>最左前列开始</strong>并且<strong>不跳过索引中的列</strong></p>
<p>如果索引顺序为i1，i2，i3，查询时候为i3，i2，i1，会被Mysql<strong>优化</strong>，仍然可以用复合索引查询</p>
</li>
<li><p><strong>不要在索引列上做任何操作</strong>（计算、函数、（自动或手动）<strong>类型转换</strong>）（<strong>索引操作就失效</strong>）</p>
</li>
<li><p>存储引擎不能使用索引中范围条件右边的列（<strong>范围之后全失效</strong>！）</p>
</li>
<li><p>尽量使用覆盖索引（只访问索引的查询，索引列和查询列一致），减少select *</p>
</li>
<li><p>mysql在使用<strong>不等于</strong>（!=或&lt;&gt;）的时候无法使用索引会导致全表扫描（少用不等）</p>
</li>
<li><p>is null,is not null也无法使用索引</p>
</li>
<li><p>like以<strong>通配符开头</strong>(%abc)，mysql索引失效（最好只在右边写%）</p>
<p>如果需要用到左边%，用<strong>覆盖索引</strong>避免全表扫描（查询字段为索引中的一些或全部，不能超过）</p>
</li>
<li><p>字符串不加单引号索引失效（隐式类型转换）</p>
</li>
<li><p>用or连接时<strong>索引失效</strong>，<strong>少用or</strong></p>
</li>
</ol>
<p>如果order by中用到的字段与前面用于筛选的不连续，会有filesort。核心就在于索引是否能被连贯的使用到。</p>
<p>如索引为c1,c2,c3,c4</p>
<p>查询为where c1 order by c3,c2会有filesort</p>
<p>查询为where c1 c2 order by c3,c2不会有，因为c2被筛选了是连贯的</p>
<p>定值是常量，范围之后是失效，最终看排序，一般order by给个范围</p>
<p>group by基本需要排序，会有临时表产生</p>
<p>一般建议</p>
<ul>
<li>对于单键索引，尽量选择针对当前query过滤性更好的索引</li>
<li>选择组合索引时，当前Query过滤性最好的字段在索引字段顺序中，位置越靠前越好</li>
<li>选择组合索引时，尽量选择可以能够包含当前query中的where字句中更多字段的索引</li>
<li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</li>
</ul>
<p>最好的是全值匹配，要遵守最左前缀；索引上不要计算，范围之后会失效，like 百分放右边，不等空值还有or，索引失效</p>
<h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>先介绍谓词下推</p>
<p>如果有如下的sql语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.name, t2.name <span class="keyword">from</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> t2 <span class="keyword">on</span> t1.id=t2.id;</span><br></pre></td></tr></table></figure>

<p>这条语句的执行顺序有两种</p>
<ol>
<li>先执行表的join，再筛选需要的数据</li>
<li>先将所需要的列拿出，再执行表的join</li>
</ol>
<p>后执行join操作（join为动词）可被理解为谓词下推，减少了表连接前的数据量。</p>
<p>而索引下推</p>
<p>如果筛选条件有name,age</p>
<p>不使用索引下推</p>
<ul>
<li>先根据name列的值将所有数据拉到server层，在server层对age做过滤</li>
</ul>
<p>使用索引下推</p>
<ul>
<li>根据name，age两个字段把满足要求的数据拉到server层，取出对应的数据</li>
</ul>
<h4 id="MRR"><a href="#MRR" class="headerlink" title="MRR"></a>MRR</h4><p>Multi-Range Read，多范围查询</p>
<p>当使用非主键索引查询数据时，没有索引覆盖需要进行回表，即先查询主键值，再到主键索引中查询整行数据。</p>
<p>场景：主键为id，非主键索引为name，根据name去查询，得到的id是无序的（相对于物理顺序），这样根据无序的列表去主键B+树上进行的是随机查找。而如果在name索引树上得到无序的id后，先将id进行排序，当排序完成后在主键索引中查找就不是随机了。</p>
<h4 id="优化原则"><a href="#优化原则" class="headerlink" title="优化原则"></a>优化原则</h4><p>小表驱动大表，小的数据库驱动大的数据集。</p>
<p>EXISTS</p>
<ul>
<li>SELECT … FROM table WHERE EXISTS(subquery)</li>
</ul>
<p>语法可理解为：<strong>将主查询的数据，放到子查询中做条件验证，根据验证结果（true或false）来决定主查询数据是否得以保留</strong>，当主查询的表比子查询中表更小时效率高，若主查询中数据多，用IN效率更高。即小表驱动大表。相当于IN查询的变种。</p>
<img src="/2020/02/09/MySQL/exists.png" class title="This is an example image">

<h4 id="order-by关键字优化"><a href="#order-by关键字优化" class="headerlink" title="order by关键字优化"></a>order by关键字优化</h4><ul>
<li><p>尽量使用index方式排序，避免使用filesort</p>
<ul>
<li>Mysql支持支持两种方式的排序，Filesort和Index，Index效率高，指Mysql扫描索引本身完成排序，Filesort效率较低</li>
<li>两种情况使用Index排序<ul>
<li>order by语句使用索引最左前列</li>
<li>使用where子句与order by子句条件组合满足索引最左前列</li>
</ul>
</li>
</ul>
</li>
<li><p>尽可能在索引数据列上完成排序，按照索引建的最佳左前缀</p>
<ul>
<li><p>若不在索引上，filesort存在双路排序和单路排序</p>
<ul>
<li><p>双路排序：Mysql4.1之前采用，扫描<strong>两次</strong>磁盘</p>
</li>
<li><p>单路排序：读取后，在buffer排序，避免第二次读取数据，使用更多空间，将每一行保存进内存</p>
<p>单路总体比双路好，但存在问题，即如果sort_buffer数据比要全部取的数据小，需要多次IO</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>调优策略</p>
<ul>
<li><p>不使用select *，排序顺序最好与索引一致</p>
</li>
<li><p>增大sort_buffer_size</p>
</li>
<li><p>提高max_length_for_sort_data（提高排序查询效率）</p>
</li>
</ul>
</li>
</ul>
<img src="/2020/02/09/MySQL/orderby.png" class title="This is an example image">

<h4 id="group-by关键字优化"><a href="#group-by关键字优化" class="headerlink" title="group by关键字优化"></a>group by关键字优化</h4><ul>
<li>group by实质为先排序后分组，按照索引的最佳左前缀原则</li>
<li>当无法使用索引列，增大sort_buffer_size+max_length_for_sort_data</li>
<li>where高于having，能写在where限定条件的不要写在having</li>
</ul>
<h2 id="查询截取分析"><a href="#查询截取分析" class="headerlink" title="查询截取分析"></a>查询截取分析</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol>
<li>观察，至少跑一天，看看生产的慢sql情况</li>
<li>开启慢查询日志，设置阈值，如超过5秒钟就为慢sql，将其抓取</li>
<li>explain+慢sql分析</li>
<li>show profile</li>
<li>运维经理orDBA，进行sql数据库服务器的参数调优</li>
</ol>
<p>总结</p>
<ol>
<li>慢查询的开启并捕获</li>
<li>explain+慢sql分析</li>
<li>show profile查询sql在Mysql服务器中的细节执行细节和生命周期情况</li>
<li>SQL数据库服务器参数调优</li>
</ol>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><ul>
<li>是一种日志记录，用来记录Mysql中响应时间超过阈值的语句，具体为运行时间超过long_query_time值（默认为10秒）的sql，记录到慢查询日志中。</li>
<li>默认没有开启，需要手动开启；若不是调优需要，不建议启动，造成性能影响</li>
</ul>
<p>查看开启</p>
<p>show variables like ‘%slow_query_log%’</p>
<p>设置slow_query_log的值来开启，只对当前数据库生效，Mysql重启后失效；若要用久，需要修改配置文件my.cnf</p>
<ul>
<li>set global slow_query_log=1;</li>
</ul>
<p>查看设定时间</p>
<p>show variables like ’long_query_time%’，判断为<strong>大于</strong>的语句，而不是大于等于</p>
<p>设置阈值时间</p>
<p>set global long_query_time=3;设置3秒</p>
<p>需要重新连接或新开会话才能看到修改值</p>
<p>检验</p>
<p>可以让其休眠等待4s，这样看到效果</p>
<p>select sleep(4);</p>
<p>在慢日志中可以具体看出那条sql语句超出了阈值时间。</p>
<p>查询当前系统中有多少条慢查询记录</p>
<p>show global status like ‘%Slow_queries’;</p>
<h3 id="Show-Profile"><a href="#Show-Profile" class="headerlink" title="Show Profile"></a>Show Profile</h3><p>mysql提供的用来分析当前会话中语句执行的<strong>资源消耗</strong>情况，可以用于SQL的调优的测量。     </p>
<p>默认情况下，参数处于关闭状态，并保存15次的运行结果。</p>
<ol>
<li><p>看当前是否支持</p>
<p>show variables like ‘profiling’;默认为关闭，使用前需要开启</p>
</li>
<li><p>设置开启</p>
<p>set profiling=on;</p>
</li>
<li><p>运行sql</p>
</li>
<li><p>查看结果</p>
<p>show profiles</p>
<p>包括Query_ID，Duration，Query</p>
</li>
<li><p>诊断sql</p>
<p>show profile cpu,block io for query 上一步问题sql号码</p>
<p>给出每个步骤的具体时间</p>
</li>
<li><p>日常开发需要注意的结论</p>
<ul>
<li>converting HEAP to MyISAM 查询结果太大，内存不够用往磁盘上搬</li>
<li>Creating tmp table 创建临时表<ul>
<li>拷贝数据至临时表</li>
<li>用完再删除</li>
</ul>
</li>
<li><strong>Copying to tmp table on disk</strong> 把内存中临时表复制到磁盘，危险！！！</li>
<li>locked </li>
</ul>
</li>
</ol>
<h3 id="全局查询日志"><a href="#全局查询日志" class="headerlink" title="全局查询日志"></a>全局查询日志</h3><p>永远不要在生产环境开启此功能</p>
<p>编码启动</p>
<ul>
<li><p>set global general_log=1;</p>
</li>
<li><p>set global log_output=‘TABLE’;</p>
<p>编写的所有sql语句，会被记录到mysql库里的general_log表，用以下命令查看</p>
</li>
<li><p>select * from mysql.general_log;</p>
</li>
</ul>
<h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>锁是协调计算机多个进程或线程并发访问某一资源的机制</p>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>场景：商品一件库存，两个人同时买，谁买到</p>
<p>一定要用到<strong>事务</strong>，从库存表中取出物品数量，插入订单，付款后插入付款表信息，更新商品数量，用锁可以对有限资源进行保护，解决隔离和并发的矛盾。</p>
<h4 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h4><ul>
<li>对数据操作类型分类<ul>
<li>读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会相互影响</li>
<li>写锁（排它锁）：当前写操作没有完成前，会阻断其他写锁和读锁</li>
</ul>
</li>
<li>对数据操作粒度分类<ul>
<li>表锁（MyISAM）</li>
<li>行锁（InnoDB）</li>
</ul>
</li>
</ul>
<h3 id="三种锁"><a href="#三种锁" class="headerlink" title="三种锁"></a>三种锁</h3><h4 id="表锁（偏读）"><a href="#表锁（偏读）" class="headerlink" title="表锁（偏读）"></a>表锁（偏读）</h4><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><ul>
<li>偏向MyISAM存储引擎，开销小，加锁快；</li>
<li>无死锁；</li>
<li>锁定粒度大，发生锁冲突的概率最高，并发度最低</li>
</ul>
<h5 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h5><p>create table 表名(</p>
<p>​    列</p>
<p>)engine myisam;</p>
<p>需要指定执行引擎为myisam</p>
<h5 id="手动增加表锁"><a href="#手动增加表锁" class="headerlink" title="手动增加表锁"></a>手动增加表锁</h5><p>lock table 表名字 read(write)，表名字2 read(write)，其他；</p>
<p>show open tables;看哪些有锁</p>
<p>unlock tables;释放表锁</p>
<h5 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h5><p>加锁方</p>
<ul>
<li>可以读自己锁的表</li>
<li>不能插入或更新自己锁的表</li>
<li>不能读其他表</li>
</ul>
<p>其他方</p>
<ul>
<li>可以读被锁的表</li>
<li>修改被读锁的表，<strong>一直等待</strong>直到获得锁</li>
<li>可以读和写其他为被锁的表</li>
</ul>
<h5 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h5><p>加锁方</p>
<ul>
<li>可以读自己锁的表</li>
<li>可以改自己锁的表</li>
<li>不能读其他表</li>
</ul>
<p>其他方</p>
<ul>
<li>可以看和修改其他表</li>
<li>查看、修改被写锁的表，<strong>一直等待</strong>直到获得锁</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>MyISAM执行查询语句前，自动给涉及的所有表加读锁，在执行增删改操作前，自动给涉及的表加写锁</p>
<p>MySQL表级锁有两种模式</p>
<ul>
<li>表共享读锁（Table Read Lock）</li>
<li>表独占写锁（Table Write Lock）</li>
</ul>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>可否兼容</th>
<th>读锁</th>
<th>写锁</th>
</tr>
</thead>
<tbody><tr>
<td>读锁</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>写锁</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<ol>
<li>对MyISAM表的读操作（加读锁），不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其他进程的写操作</li>
<li>对MyISAM表的写操作（加写锁），会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其他进程的读写操作</li>
</ol>
<p>即，<strong>读锁会阻塞写，但不会阻塞其他进程读；写锁会把其他进程读和写都阻塞</strong>。</p>
<h5 id="表锁分析"><a href="#表锁分析" class="headerlink" title="表锁分析"></a>表锁分析</h5><p>show open tables;看哪些表被锁，为1的是被锁了。</p>
<p>show status like ‘tables%’;</p>
<ul>
<li>table_locks_waited：出现表级锁争用而发生等待的次数（不能立即获取锁的次数，等待一次加一），较高说明存在<strong>较严重的表级锁争用</strong>情况</li>
<li>table_locks_immediate：产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加一</li>
</ul>
<p><strong>MyISAM</strong>读写锁的调度是<strong>写优先</strong>，<strong>不适合做写为主表的引擎</strong>。<strong>写锁后，其他线程不能做任何操作，大量更新会使查询很难得到锁，从而造成永远阻塞</strong>。</p>
<h4 id="行锁（偏写）"><a href="#行锁（偏写）" class="headerlink" title="行锁（偏写）"></a>行锁（偏写）</h4><ul>
<li>偏向InnoDB引擎，开销大，加锁慢；</li>
<li>会出现死锁</li>
<li>锁定粒度最小，发生锁冲突的概率最低，并发度也最高</li>
</ul>
<p>InnoDB与MyISAM最大不同有两点</p>
<ol>
<li>支持事务（TRANSACTION）</li>
<li>采用了行级锁</li>
</ol>
<h5 id="建表-1"><a href="#建表-1" class="headerlink" title="建表"></a>建表</h5><p>create table 表名(</p>
<p>)engine=innodb;</p>
<h5 id="行锁演示"><a href="#行锁演示" class="headerlink" title="行锁演示"></a>行锁演示</h5><p>如果两个事务对同一行数据进行更新，则后更新的数据会被阻塞直到第一个事务提交，这时候更新的值为第二个事务的值。如果两个事务对不同行数据进行更新，则不会受到影响。</p>
<h5 id="无索引行锁升级为表锁"><a href="#无索引行锁升级为表锁" class="headerlink" title="无索引行锁升级为表锁"></a>无索引行锁升级为表锁</h5><p>若varchar类型的索引，更新数据时，没加单引号将索引做了类型转换，会造成索引失效，从行锁变成表锁。</p>
<p>varchar类型数据一定要加单引号！！！</p>
<h5 id="间隙锁危害"><a href="#间隙锁危害" class="headerlink" title="间隙锁危害"></a>间隙锁危害</h5><p>innodb使用间隙锁条件为在可重复读下，检索条件要有索引。</p>
<p>表中的id为1,3,4，如果行锁的条件为where id&gt;1 and id&lt;5，则应该锁的数据是id为3,4的数据，如果此时事务2要插入id=2的数据，按理不应该被锁住，但是会被锁</p>
<p>当用<strong>范围条件</strong>而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于<strong>键值在条件范围内但并不存在的记录</strong>，叫做“间隙（GAP）”，InnoDB会对这个间隙加锁，锁机制就是间隙锁（Next-Key锁）。</p>
<p>间隙锁的范围是当前查询的条件向左找最靠近检索条件的值，向右找最靠近检索条件的值。不在此范围的数据不会被锁定。</p>
<p>危害</p>
<p>因为Query执行过程中通过范围查找，会锁定整个范围内所有的索引键值，即使这个键值并不存在。</p>
<p>间隙锁有比较致命的弱点，即当锁定一个范围键值后，即使某些不存在的键值也会被无辜的锁定，而造成<strong>在锁定的时候无法插入锁定键值范围内的任何数据</strong>。在某些场景可能对性能造成很大的危害。</p>
<h5 id="如何锁定一行"><a href="#如何锁定一行" class="headerlink" title="如何锁定一行"></a>如何锁定一行</h5><p>select xxx for update锁定某一行后，其他的操作会被阻塞，直到锁定行的会话提交commit</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件 <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<p>begin开始，语句后加<code>for update</code>，最后加commit。</p>
<p>InnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的的性能损耗可能比表级锁定要高，但是在整体并发处理能力方面要远远优于MyISAM表级锁定。当系统并发量较高的时候，InnoDB的整体性能和MyISAM相比会有比较明显的优势；但InnoDB行级锁定使用不当时，可能会让InnoDB整体性能还比MyISAM更差。</p>
<h5 id="行锁分析"><a href="#行锁分析" class="headerlink" title="行锁分析"></a>行锁分析</h5><p>show status like ‘innodb_row_lock%’;</p>
<ul>
<li><p>InnoDB_row_lock_current_waits;当前正在等待锁定的数量</p>
</li>
<li><p>InnoDB_row_lock_waits：系统启动后到现在总共等待的次数</p>
</li>
</ul>
<p>若等待次数很高，等待时长不少，用<strong>show profile</strong>分析每一步消耗资源及时间</p>
<h5 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h5><ul>
<li>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁</li>
<li>合理设计索引，尽量减少锁的范围</li>
<li>尽可能减少检索条件，减少间隙锁</li>
<li>尽量控制事务大小，减少锁定资源量和时间长度</li>
<li>尽可能低级别事务隔离</li>
</ul>
<h4 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h4><ul>
<li><p>开销和加锁时间界于表锁和行锁之间</p>
</li>
<li><p>会出现死锁</p>
</li>
<li><p>锁定粒度介于表锁和行锁之间，并发度一般</p>
</li>
</ul>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>复制为将主库的DDL和DML操作通过二进制日志传递到复制服务器（从库）上，然后从库对这些日志重新执行，从而使得主库和从库数据一致。</p>
<h4 id="主从复制优点"><a href="#主从复制优点" class="headerlink" title="主从复制优点"></a>主从复制优点</h4><ul>
<li>若主库出现问题，可以快速切换到从库提供服务</li>
<li>可以在从库执行操作，降低主库的访问压力</li>
<li>可以在从库进行备份，以免备份期间影响主库的服务</li>
</ul>
<h4 id="复制解决问题"><a href="#复制解决问题" class="headerlink" title="复制解决问题"></a>复制解决问题</h4><ul>
<li><p>数据分布</p>
</li>
<li><p>负载平衡</p>
</li>
<li><p>数据备份</p>
</li>
<li><p>高可用性和容错性</p>
</li>
<li><p>实现读写分离，环节数据库压力</p>
<p>一般只对更新不频繁和对实时性要求不高的数据可以通过从库查询，实时性要求高的仍要从主库查询</p>
</li>
</ul>
<h3 id="MySQL主从复制"><a href="#MySQL主从复制" class="headerlink" title="MySQL主从复制"></a>MySQL主从复制</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。默认采用异步复制方式，数据的更新可以在远程连接上执行，不用一直访问主服务器来更新数据。</p>
<h4 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h4><h5 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h5><p>主库负责写，从库负责读，即使主库出现了锁表的情况，通过从库可以保证业务的正常进行</p>
<h5 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h5><p>数据实时备份，当系统中某个节点发生故障时，可以方便故障切换（主从切换）</p>
<h5 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h5><p>在主服务器上生成实时数据，在从服务器上分析数据，提高主服务器的性能</p>
<h4 id="复制基本原理"><a href="#复制基本原理" class="headerlink" title="复制基本原理"></a>复制基本原理</h4><img src="/2020/02/09/MySQL/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png" class title="This is an example image">

<ul>
<li>slave会从master读取binblog来进行数据同步</li>
<li>三个步骤<ol>
<li>master将改变记录到二进制日志（binary log）。记录过程叫做二进制日志文件，binary log events    </li>
<li>slave将master的binary log events拷贝到其中继日志（relay log）</li>
<li>slave重做中继日志中的事件，将改变应用到自己的数据库中，MySQL复制是异步且串行化的</li>
</ol>
</li>
</ul>
<h4 id="复制基本原则"><a href="#复制基本原则" class="headerlink" title="复制基本原则"></a>复制基本原则</h4><ul>
<li>每个slave只有一个master</li>
<li>每个slave只能有一个唯一的服务器ID</li>
<li>每个master可以有多个slave</li>
</ul>
<h4 id="一主一从常见配置"><a href="#一主一从常见配置" class="headerlink" title="一主一从常见配置"></a>一主一从常见配置</h4><p>保证主从机可以ping通，windows看ipconfig，linux看ifconfig。</p>
<ul>
<li><p>mysql版本一致且后台以服务运行</p>
</li>
<li><p>主从都配置在【mysqld】节点下，都是小写</p>
</li>
<li><p>主机修改my.ini配置文件（windows）</p>
<ol>
<li><p>【必须】主服务器唯一id   server-id=1</p>
</li>
<li><p>【必须】启用二进制日志</p>
<p>log-bin=自己本地路径/mysqlbin</p>
</li>
<li><p>【可选】启用错误日志</p>
<p>log-err=自己本地路径/mysqlerr</p>
</li>
<li><p>【可选】根目录</p>
<p>basedir=“自己本地路径”</p>
</li>
<li><p>【可选】临时目录</p>
<p>tmpdir=“自己的本地路径”</p>
</li>
<li><p>【可选】数据目录</p>
<p>datadir=“自己的本地路径/Data/”</p>
</li>
<li><p>read-only=0</p>
<p>主机，读写都可以</p>
</li>
<li><p>【可选】设置不要复制的数据库</p>
<p>binlog-ignore-db=mysql</p>
</li>
<li><p>【可选】设置需要复制的数据库</p>
<p>bonlog-do-db=需要复制的主数据库名字</p>
</li>
</ol>
</li>
<li><p>从机修改my.cnf配置文件</p>
<ul>
<li>【必须】从服务器唯一ID</li>
<li>【可选】启动二进制日志</li>
</ul>
</li>
<li><p>主机+从机重启后台mysql服务</p>
</li>
<li><p>主机从机关闭防火墙</p>
</li>
<li><p>在windows主机上建立账户并授权slave</p>
</li>
<li><p>在linux从机上配置需要复制的主机</p>
</li>
<li><p>主机新建库，新建表，insert记录，从机复制</p>
</li>
<li><p>停止服务复制</p>
<p>stop slave</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记</title>
    <url>/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>黑马程序员视频学习笔记</p>
</blockquote>
<h1 id="视频笔记"><a href="#视频笔记" class="headerlink" title="视频笔记"></a>视频笔记</h1><h2 id="面对对象"><a href="#面对对象" class="headerlink" title="面对对象"></a>面对对象</h2><h3 id="零碎"><a href="#零碎" class="headerlink" title="零碎"></a>零碎</h3><p>javac先编译，生成class文件然后java运行类，一个类中运行需要有一个主函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">pulic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>类名首字母必须大写，如果设定了CLASSPATH，则不用在类名前面加上pulic</p>
<p>Javadoc.exe可以提取java中的注释文档，在写程序的时候，注意在最前面加上注释，包括程序用途，算法说明，在没有思路的时候可以一步一步写出每一步需要实现的功能，代码只是算法功能的<strong>另一种表述</strong>。</p>
<p>若不知道错误出在哪里可以部分注释用来缩小出错范围</p>
<p>8进制是三位的二进制，用0开头，16进制是四位的二进制，用0x开头。</p>
<p>一个2进制为一个bit，一个byte字节为8个二进制位</p>
<p>整数默认<strong>int</strong> 小数默认<strong>double</strong></p>
<p>java里面+号可以表示运算符也可以表示成连接符，如Systen.out.println(a+’,’+b)；</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li><p>^异或，两边结果不同才为真，两边结果相同则为假</p>
</li>
<li><p>&amp;&amp;双与，只要左边为假，右边不运算，若想让右边参与运算，用&amp;</p>
</li>
<li><p>||双或，只要左边为真，右边不运算，若想让右边参与运算，用|</p>
<p>进行循环条件判断的时候，用&amp;&amp;和||效率会更高</p>
</li>
</ul>
<p>而对于位运算符，6&amp;3代表转换为二进制110&amp;011，则全为1则与后为1，否则为0，结果为010，所以6 &amp; 3 = 2；6|3 ，只要二进制位有一个为1则结果为1，所以6|3 = 111(2进制)=7（10进制）</p>
<p>一个数异或同一个数两次，结果还是这个数（<strong>数据加密</strong>）</p>
<p><del>6，相当于对6的每一位进行取反，6全部取反加一得到-6，所以</del>6 = -7</p>
<p>3&lt;&lt;2，表示3左移两位，即0011变为1100,3&lt;&lt;2=12，左移几位就是该数乘以2的几次方，即为&lt;&lt;可以完成2的次幂运算；而对于&gt;&gt;，右移几位就是除以2的几次幂，对于高位保持原来的数字，以保证符号不变。而对于&gt;&gt;&gt;，无论原来高位是什么，都用0来补</p>
<p>想要运算变得高效，首选位运算</p>
<p>​    三元运算符</p>
<blockquote>
<p> （条件表达式）？表达式1：表达式2；</p>
</blockquote>
<p><strong>a)</strong> <strong>判断条件表达式，结果为一个布尔值。</strong></p>
<p><strong>b) true**</strong>，运算结果为表达式<strong>**1</strong></p>
<p><strong>c) false**</strong>，运算结果为表达式<strong>**2</strong></p>
<p>​    局部代码块可以定义局部变量的生命周期</p>
<p>​    switch关键字：switch,case,break,default，可以处理的数据类型是byte,short,int,char</p>
<p>​    break 跳出当前循环，并结束此次循环</p>
<p>​    do while相比while，无论条件是否满足，至少执行一次循环内容，应用相对比较少。</p>
<p>​    for(初始化表达式；循环条件表达式；循环后的操作表达式)</p>
<p>​    其中初始化表达式只在最开始进行执行（执行一次），然后运行条件表达式判断是否循环，如果是则进入循环内执行语句，然后运行循环后的操作表达式。</p>
<h3 id="制表符"><a href="#制表符" class="headerlink" title="制表符"></a>制表符</h3><p>\t为制表符，用于将数据对齐  \n回车  \b退格  \r按下回车键</p>
<p>windows系统中，回车符由两个符号组成，为\r\n linux中回车符为\n</p>
<p>转义字符对后面的字符含义进行转义，如果想输出”，则需要使用\”，在前面加上\</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="定义函数格式"><a href="#定义函数格式" class="headerlink" title="定义函数格式"></a>定义函数格式</h4><p> 修饰符 返回值类型 函数名（参数类型 形式参数1，参数类型 形式参数2，…）</p>
<p>{</p>
<p>   执行语句；</p>
<p>   return 返回值；</p>
<p>}</p>
<p> 如果函数名字有两个以上的单词，第一个单词首字母小写，从第二个单词开始要大写，需要去区分是类还是函数。</p>
<p> 如果函数中没有返回值类型，则用void，可以省略return。</p>
<p> 函数中可以调用其他函数，但是不可以定义其他函数</p>
<p>在内存中，java内存为栈的形式，先进后出，调用的函数结束后即被清理出内存</p>
<h4 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h4><ol>
<li><p>同一个类</p>
</li>
<li><p>同名</p>
</li>
<li><p>参数个数不同or参数类型不同</p>
</li>
</ol>
<p>利用好函数的重载，同样功能的函数起一样的名字，利用传递参数的不同加以区分，同时利用之前已有的函数功能，进行调用，提高代码的复用性。</p>
<h3 id="查表法"><a href="#查表法" class="headerlink" title="查表法"></a>查表法</h3><p>查表法：在数据中出现对应关系，而且对应关系的一方是有序的数字编号，并作为角标使用，这时候就要想到数组的使用。可以将这些数据存储到数组中，根据运算的结果作为角标直接去查数组中对应的元素即可</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组的格式"><a href="#数组的格式" class="headerlink" title="数组的格式"></a>数组的格式</h4><p> 元素类型[] 数组名 = new 元素类型[元素个数或数组长度]</p>
<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC.png" class title="This is an example image">

<p>在栈中开辟内存给arr，在堆中开辟内存，产生一个实体存放每个小数组的地址，初始值为null，然后新建三个小数组实体，每个小数组的初始值为0，将每个小数组的地址赋给大数组，将null改变为三个地址，然后将arr指向大数组的地址，这样二维数组初始化完毕</p>
<p>二维数组赋值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][]arr = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">3</span>][]; arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][]arr = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h3><ol>
<li><p>成员变量定义在类中，整个类中都可以访问；局部变量定义在函数，语句，局部代码块中，只在所属的区域有效。</p>
</li>
<li><p>成员变量存在于堆内存的对象中；局部变量存在于栈内存的方法中。</p>
</li>
<li><p>成员变量随着对象的创建而存在，随着对象的消失而消失；局部变量随着所属区域的执行而存在，随着所属区域的结束而释放。</p>
</li>
<li><p>成员变量都有默认初始化值；局部变量没有默认初始化值。</p>
</li>
</ol>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>​    隐藏对象的属性和实现细节，仅对外提供公共访问方式，笔记本就是种封装</p>
<p>​    将类中变量定义为private，为了改变变量的值，必须要经过类所规定的方法（对设置的变量给予约束）</p>
<p>​    封装原则：将不需要对外提供的内容全都隐藏起来；把属性都隐藏，提供公共方法（set,get）对其访问，使得对数据可控，set一般为viod，而get返回类型和属性相同</p>
<p>​    private为权限修饰符，修饰成员，不能修饰局部。私有的内容只在本类中有效。</p>
<p>​    私有只是封装的一种体现，java中最小的封装体是函数</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>​    名称与类相同，不需要返回值，用于给对象初始化，构造创造对象时调用的函数，<strong>首字母大写</strong>，构造函数里面可以return用以结束函数，但是很少见</p>
<p>​    创建对象都必须要通过构造函数进行初始化；如果一个类中没有定义过构造函数，那么该类中会有一个默认的空参数构造函数。如果在类中定义了指定的构造函数，那么类中的默认构造函数就没有了。</p>
<p>​    当方法中的成员变量和局部变量重名，那么成员变量会变成局部变量，当方法结束调用后出栈，没有改变成员变量的值，可以用this来区分，如this.name = name。this就是<strong>所在函数所属对象的引用</strong>。简单说，哪个对象调用了this所在的函数，this就代表哪个对象。</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><p>​    如果要在构造函数中调用构造函数，不能直接用Person();，因为这句话相当于this.Person，对象还没有初始化不可被调用，这时候可用this(待传入参数)，相当于直接给这个对象进行初始化。</p>
<p>​    this可在构造函数中调用其他构造函数，但是只能定义在构造函数的第一行，因为初始化动作要先执行</p>
<p>​    只要在本类中调用了本类的对象，一般都要用this</p>
<h4 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h4><p>​    修饰数据，可实现数据共享，在对象之前出现，可以被类名调用</p>
<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><ol>
<li><p>static是一个修饰符，用于修饰成员（成员变量和成员函数）。</p>
</li>
<li><p>static修饰的成员被所有的对象共享。</p>
</li>
<li><p>static优先于对象存在，因为static的成员随着类的加载就已经存在了。</p>
</li>
<li><p>static修饰的成员多了一种调用方式，即可以直接被类名所调用，调用格式为类名.静态成员。</p>
</li>
<li><p>静态修饰的数据是共享数据，对象中存储的是特有数据。</p>
</li>
</ol>
<h5 id="成员变量（实例变量）与静态变量（类变量）的区别："><a href="#成员变量（实例变量）与静态变量（类变量）的区别：" class="headerlink" title="成员变量（实例变量）与静态变量（类变量）的区别："></a>成员变量（实例变量）与静态变量（类变量）的区别：</h5><ol>
<li>两个变量的生命周期不一样（静态变量生命周期太长，用以减少占用内存空间）</li>
</ol>
<p>随着对象的创建而存在，随着对象的回收而释放；静态变量随着类的加载而存在，随着类的消失而消失</p>
<ol start="2">
<li>调用方式不同</li>
</ol>
<p>成员变量只能被对象调用，静态变量可以被对象和类调用，不建议用对象调用</p>
<ol start="3">
<li><p>别名不同</p>
<p>成员变量也成为实例变量，静态变量成为类变量</p>
</li>
<li><p>数据存储位置不同</p>
</li>
</ol>
<p>成员变量数据存储在堆内存（堆中存储的都是实体）的对象中，所以也叫对象的特有数据。静态变量数据存储在方法区（的静态区），也叫对象的共享数据</p>
<p>​    静态变量前省略了类名，非静态变量前省略了this</p>
<h5 id="静态使用注意事项"><a href="#静态使用注意事项" class="headerlink" title="静态使用注意事项"></a>静态使用注意事项</h5><ol>
<li><p>静态方法只能访问静态成员（因为其先于对象存在，无法访问对象中存在的成员变量和函数），静态方法可直接被类名调用。非静态既可以访问静态，又可以访问非静态。</p>
</li>
<li><p>静态方法中不可使用this或者super关键字</p>
</li>
<li><p>主函数是静态的（不要在主函数中定义其他函数，要将其他函数封装在类中，在主函数中创建对象，调用对象的函数即可）</p>
</li>
</ol>
<h5 id="主函数特殊之处"><a href="#主函数特殊之处" class="headerlink" title="主函数特殊之处"></a>主函数特殊之处</h5><p>public static void main(String[],args)</p>
<ol>
<li><p>格式是固定的</p>
</li>
<li><p>被jvm所识别和调用</p>
</li>
</ol>
<p>public：因为权限是最大的</p>
<p>static: 不需要对象的，直接用主函数所属类名调用即可</p>
<p>void：主函数没有具体的返回值</p>
<p>main: 函数名，不是关键字，只是一个jvm识别的固定的名字</p>
<p>String[] args：这是主函数的参数列表，是一个数组类型的参数，而且元素都是字符串类型</p>
<p>​    主函数所留了一个args，相当于new String args[0]，留给使用者指定参数，直接java 类名 加所要传入参数</p>
<p>​    类被加载进方法区，方法区用来存放类和静态方法的代码，也加方法表，运行时候进栈存储局部变量</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%B1%BB%E8%A2%AB%E5%8A%A0%E8%BD%BD%E8%BF%9B%E6%96%B9%E6%B3%95%E5%8C%BA.png" class title="This is an example image">

<h4 id="protected关键字"><a href="#protected关键字" class="headerlink" title="protected关键字"></a>protected关键字</h4><p>​    指明“就类用户而言，这是private的，但对于任何继承于此类的导出类或其他任何位于同一个包内的类来说，它却是可以访问的”。（protected提供了包内访问权限。）</p>
<h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><p>final 关键字：</p>
<p>1、 final是一个修饰符，可以修饰类，方法，变量</p>
<p>2、 final修饰的类不可以被继承</p>
<p>3、 final修饰的方法不可以被覆盖</p>
<p>4、 final修饰的变量是一个常量，只能赋值一次变量命名与函数一样，常量所有字母都大写，单词之间用_连接）成员一旦被final ，一般会加静态 static final int x = 7;</p>
<p> public static final 全局变量</p>
<p>​    用final修饰变量原因</p>
<p>其实在程序中如果一个数据是固定的，那么直接使用这个数据就可以了，但是这样阅读性差，所以给该数据起个名称，而且这个变量名称的值不能变化，所以加上final固定。固定常量一律用final修饰</p>
<p>写法规范</p>
<p>常量所有字母都大写，多个单词，中间用_连接。</p>
<p>可能使用到final的三种情况：数据、方法和类</p>
<h5 id="final数据"><a href="#final数据" class="headerlink" title="final数据"></a>final数据</h5><p>不能改变的数据需要是基本数据类型，以final关键字表示，在对常量定义的时候，必须对其赋值。</p>
<p>​    一个既是static又是final的域只占据一段不能改变的存储空间。</p>
<p>​    对对象的引用用final修饰，使其不能指向另一个对象，但是对象本身可以被修改。</p>
<p>​    不能因为某数据是final类型就认为可以在编译时知道它的值，final指向只是不能再次指向另一个新的对象，不代表值不能被改变。</p>
<p>​    如果数据是static的，在装载时已被初始化，而不是每次创建新对象时都初始化。</p>
<p>​    允许生成空白final，即被声明为final但又未给定初值的域。必须在域的定义处或者每个构造器中用表达式对final进行赋值。（如果不在构造器处初始化空白final，会编译报错。）</p>
<h5 id="final参数"><a href="#final参数" class="headerlink" title="final参数"></a>final参数</h5><p>​    允许在参数列表中以生命的方式将参数指明为final，意味着无法在方法中更改参数引用所指向的对象。</p>
<p>​    可以读参数，却无法修改参数，主要用来向匿名内部类传递数据。</p>
<h5 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h5><p>使用final方法原因：</p>
<p>​    一：把方法锁定，以防任何继承类修改它的定义。处于设计的考虑：想要确保在继承中使方法行为保持不变，并且不会被覆盖。</p>
<p>​    二：效率。以前会为了效率，将一个方法指明为final，同意编译器将针对该方法的所有调用都转为内嵌调用。应该让编译器和jvm去处理效率的问题，只有想要明确禁止覆盖时，才将方法设置成final。</p>
<h5 id="final和private关键字"><a href="#final和private关键字" class="headerlink" title="final和private关键字"></a><strong>final和private关键字</strong></h5><p>​    类中所有的private方法都隐式地指定为是final的。“覆盖”只有在某方法是基类的接口的一部分时才会出现，即必须能将一个对象向上转型为它的基本类型并调用相同的方法。如果方法为private，它就不是基类接口的一部分。它仅是一些隐藏于类中的程序代码，只不过是具有相同名称而已。</p>
<h5 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h5><p>​    当某各类的整体定义为final时（将关键字final置于它的定义之前），就表明了不打算继承该类，也不允许其他人这么做。</p>
<p>​    在final类中可以给方法添加final修饰词，但不会增添任何意义。</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h4 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h4><ol>
<li><p>寄存器  CPU处理</p>
</li>
<li><p>本地方法区 和操作系统相关 </p>
</li>
<li><p>方法区</p>
</li>
<li><p>栈内存 存储局部变量，而且变量所属的作用域一旦结束，变量自动释，方法（函数）进栈</p>
</li>
<li><p>堆内存 存储数组（数组就是对象）和对象，凡是new建立在堆中</p>
</li>
</ol>
<p>​    堆的特点：</p>
<ol>
<li>每一个实体都有首地址值</li>
<li>堆内存中的每一个变量都有默认初始化值，根据类型的不同而不同。整数0，小数0.0或0.0f，boolean false，char ‘\u0000’相当于空格的空位</li>
<li>垃圾回收机制，由程序控制不定时清理</li>
</ol>
<h4 id="内存过程"><a href="#内存过程" class="headerlink" title="内存过程"></a>内存过程</h4><p>​    StaticDemo2这个类被加载进方法区，因为其为非静态方法，有一个this用于表示当前对象，同时还有一个默认的空构造函数，因为这个类中有非静态方法，于是static main进入静态方法区，存储相应代码。运行main函数，main进栈。加载Person.method()，jvm寻找Person.class文件，找到后将Person类加载进方法区中非静态方法中，包括Person的代码，也包括一个this，存放非静态方法Person(),show()，将静态方法method存放金静态方法区，其中也包括country这个静态变量。运行method，method进栈，输出静态变量，没有在堆中开辟空间，运行结束后弹栈。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%85%E5%AD%98%E8%BF%87%E7%A8%8B.png" class title="This is an example image">

<p>​    建立新对象p，在堆中开辟内存空间地址为0x0056，初始化name=null,age=0。然后执行Person的构造函数，构造函数进栈，this赋值为此对象地址，将name和age赋值，接下来执行this.name=name和this.age=age，将堆中对象的name和age赋值改变。初始化结束后构造函数弹栈，将p指向0x0056。执行show()，在方法区中寻找show，show进栈，有一个this所属，输出类所属的静态变量country，this所属(对象)的name和age，进行输出，结束后show弹栈。Main执行return后，main也弹栈。</p>
<h3 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h3><p>​    变量在任何方法（包括构造器）被调用前初始化。</p>
<p>​    初始化的顺序是先静态对象（如果他们未因前面的对象创建过程而被初始化），然后是“非静态”对象，然后是构造器。</p>
<p>​    静态对象会随着类的加载而初始化，之后不会再次初始化。</p>
<p>​    实例初始化在构造器之前。</p>
<p>假设有个Dog类</p>
<ol>
<li><p>即使没有显式地使用static关键字，构造器实际上也是静态方法。因此，当首次创建爱你类为Dog的对象时（构造器可以看成静态方法），或者Dog类的静态方法/静态域首次被访问时，Java解释器必须查找类路径，以定位Dog.class文件。</p>
</li>
<li><p>然后载入Dog.class（创建一个Class对象），有关静态初始化的所有动作都会执行。因此静态初始化只在Class对象首次加载的时候执行一次。</p>
</li>
<li><p>当用new Dog()创建对象的时候，首先将在堆上为Dog对象分配足够的存储空间。</p>
</li>
<li><p>这块存储空间就会被清零，这就自动地将Dog对象中的所有基本类型数据都设置成了默认值，引用被设置成null。</p>
</li>
<li><p>执行所有出现于字段定义处的初始化动作。</p>
</li>
<li><p>执行构造器。</p>
</li>
</ol>
<h3 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h3><p>静态什么时候用？</p>
<p>1、 静态变量</p>
<p>当分析对象中所具备的成员变量的值都是相同的，这时这个成员就可以被静态修饰。只要数据在对象中都是不同的，那就是对象的特有数据，必须在对象中是非静态的。如果是相同的数据，对象不需要做修改，只需要使用即可，不需要存储在对象中，定义成静态的。</p>
<p>2、 静态函数</p>
<p>函数是否用静态修饰，就参考一点，就是该函数功能是否有访问到对象的特有数据。简单点即从代码中看，该功能是否需要访问非静态的成员变量，如果需要，该功能就是非静态的；如果不需要，就可以将该功能定义成静态的。当然也可以定义为非静态，但是非静态需要被对象调用，而仅创建对象调用非静态的没有访问对象特有数据的方法，该对象的创建没有意义。</p>
<p>3、静态代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span></span><br><span class="line">&#123;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随着类的加载而执行</p>
<p>作用：用于给类进行初始化。</p>
<p>一般用于全静态变量的类</p>
<p>构造代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造代码块为在类中的代码块，不加static修饰符，用以给所有对象初始化。与构造函数区别是构造函数是给对应的对象有针对性的初始化。构造代码块为对象的通用部分，构造函数为对象的特性部分。</p>
<p>若在函数中为局部代码块，用以限制变量的周期。</p>
<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><p>强制不让创建对象</p>
<p>private ArrayToll(){}该类中的方法都是静态的，所以该类是不需要创建对象的。为了保证不让其他成员创建该类对象，可以将构造函数私有化</p>
<p>设计模式：对问题行之有效的解决方式。其实是一种思想</p>
<p>​    单例设计模式解决问题：可以保证一个类在内存中的对象唯一性</p>
<p>​    必须对多个程序使用同一个配置对象时，就需要保证该对象的唯一性</p>
<p>如何保证对象唯一性？</p>
<p>（1）   不允许其他程序用new创建该类对象</p>
<p>（2）   在该类中创建一个本类实例</p>
<p>（3）   对外提供一个方法让其他程序可以获取该对象</p>
<p>步骤</p>
<p>（1）   私有化该类的构造函数</p>
<p>（2）   通过new在本类中创建一个本类的对象</p>
<p>（3）   定义一个公有的方法，将创建的对象返回</p>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p><strong>开发更多</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类一加载，对象就已经存在了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;  </span><br><span class="line">	<span class="comment">//静态方法只能调用静态变量,为了避免用户直接访问设置权限</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Single s = <span class="keyword">new</span> Single(); </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125; </span><br><span class="line">	<span class="comment">//静态方法可以直接被类调用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 Single ss = Single.getInstance();</p>
<p>当调用getInstance()的时候，此函数进栈，将s的地址赋值给ss，然后弹栈，这样ss就指向了s所指向的对象</p>
<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><p><strong>面试更多</strong> 延迟加载形式（懒汉式）问题：如果被<strong>多线程</strong>调用，可能<strong>不能保证唯一性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类加载进来，没有对象，只有调用了getInstance方法才创建对象，延迟加载形式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single2</span> </span>&#123;   </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Single2 s = <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Single2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;   </span><br><span class="line">		<span class="keyword">if</span>(s==<span class="keyword">null</span>)</span><br><span class="line">			s = <span class="keyword">new</span> Single2();</span><br><span class="line">		 <span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>class Student <strong>extends</strong> Person</p>
<p>Student 子类  Person父类（超类，基类）</p>
<p>继承弊端：打破封装性</p>
<h4 id="继承的好处"><a href="#继承的好处" class="headerlink" title="继承的好处"></a>继承的好处</h4><ol>
<li><p>提高了代码的复用性</p>
</li>
<li><p>让类和类之间产生了关系，给第三个特征多态提供了前提</p>
</li>
</ol>
<p>java中支持单继承，不直接支持多继承，但对C++中的多继承机制进行了改良</p>
<p>单继承：一个子类只能有一个直接父类</p>
<p>多继承：一个子类可以有多个直接父类（java中不允许，进行改良）</p>
<p>​    不直接支持，因为多个父类中有相同成员，会产生调用不确定性,在java中通过“<strong>多实现</strong>”的方式来实现</p>
<p>​    java支持多层（多重）继承</p>
<p>​    C继承B，B继承A。就会出现继承体系。</p>
<h4 id="使用一个继承体系"><a href="#使用一个继承体系" class="headerlink" title="使用一个继承体系"></a>使用一个继承体系</h4><ol>
<li><p>查看该体系中的顶层类，了解该体系的基本功能</p>
</li>
<li><p>创建体系中的最子类对象，完成功能的使用</p>
</li>
</ol>
<p>在子父类中，成员的特点体现</p>
<ol>
<li>成员变量</li>
</ol>
<p>子类中与父类同名变量，值与子类相同。当本类中的成员和局部变量同名用this区分。</p>
<p>当子父类中的成员变量同名可用super区分父类。</p>
<p>this 和 super的用法很相似</p>
<p>this：代表一个本类对象的引用</p>
<p>super：代表一个父类空间</p>
<ol start="2">
<li>成员函数</li>
</ol>
<p>当子父类中出现成员函数一模一样的情况，会运行子类的函数，这种现象称为覆盖操作。</p>
<p>这是函数在子父类中的特性。</p>
<p>​    函数两个特性：</p>
<p>（1）   重载 同一个类中</p>
<p>（2）   覆盖 子类中，覆盖也称为重写，覆写。override,函数声明需要一致</p>
<p>​    覆盖注意事项</p>
<ul>
<li><p>子类方法覆盖父类方法时，子类权限必须要大于等于父类的权限</p>
</li>
<li><p>静态只能覆盖静态，或被静态覆盖</p>
<p>什么时候使用覆盖操作</p>
<p>当对一个类进行子类的扩展时，子类需要保留父类的功能声明，但是要定义子类中该功能的特有内容时，就使用覆盖功能完成</p>
</li>
</ul>
<ol start="3">
<li>构造函数</li>
</ol>
<p>在子类构造对象时，发现访问子类构造函数时，父类也运行。原因：在子类的 构造函数中第一行有一个默认的隐式语句。super()；</p>
<p>子类的实例化过程：子类中所有的构造函数默认都会访问父类中的空参数的构造函数</p>
<p>子类实例化访问父类构造函数原因：</p>
<p>​    子类继承了父类，获取到了父类中的内容（属性），所以在使用父类内容之前要先看父类是如何对自己的内容进行初始化的，所以子类在构造对象时必须访问父类的构造函数。为了完成这个必须的动作，就在子类的构造函数函数中加入了super();语句.如果父类中没有定义空参数构造函数.那么子类的构造函数必须用super明确要调用父类中哪个构造函数。同时子类构造函数中如果使用this()调用了本类构造函数时，super就没有了，因为this和super都只能定义在第一行，所以只能有一个。但是可以保证的是，子类中肯定会有其他的构造函数访问父类的构造函数。</p>
<p>​    注意：super语句必须要定义在子类构造函数的第一行，因为父类的初始化动作要先完成。</p>
<p>所有的类都有 extends Object</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%A7%E6%89%BF%E5%86%85%E5%AD%98%E5%9B%BE%E8%A7%A3.png" class title="This is an example image">

<p>继承内存图解，子类对象中继承了父类对象的num，用super关键字进行引用</p>
<p>子类中不能直接访问父类中私有的内容</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Zi.png" class title="This is an example image">

<p>运行Zi的构造函数，super()为Fu()，此时的show()被子类覆盖，运行zi show…0。通过父类super初始化父类内容时，子类的成员变量并未显示初始化，等父类super（）父类初始化完毕后，才进行子类的成员变量显示初始化。即super后num=8</p>
<h4 id="一个对象实例化过程"><a href="#一个对象实例化过程" class="headerlink" title="一个对象实例化过程"></a>一个对象实例化过程</h4><p>Person p = new Person();</p>
<ol>
<li><p>JVM会读取指定路径下的Person.class文件，并加载进内存，并会先加载Person的父类（如果有直接的父类的情况下）</p>
</li>
<li><p>在堆内存中开辟空间，分配地址</p>
</li>
<li><p>并在对象空间中，对对象的属性进行默认初始化</p>
</li>
<li><p>调用对应的构造函数，进行初始化</p>
</li>
<li><p>在构造函数中，第一行会调用父类中的构造函数进行初始化</p>
</li>
<li><p>父类初始化完毕后，再对子类的属性进行显示初始化</p>
</li>
<li><p>再进行子类构造函数的特定初始化</p>
</li>
<li><p>初始化完毕后，将地址值赋值给引用变量</p>
</li>
</ol>
<h4 id="组合与继承"><a href="#组合与继承" class="headerlink" title="组合与继承"></a>组合与继承</h4><p>​    组合：在一个类中持有另一个类的引用。</p>
<p>“is-a”（是一个）的关系是用继承表达的，而“has-a”（有一个）的关系则是用组合来表达的。</p>
<p> 判断要用组合还是继承，看是否需要从新类向基类进行向上转型，如果必须向上转型，则继承是必要的。</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>​    如果使用继承，会将父类所有方法暴露给子类，可以使用代理，可以选择只提供在成员对象中的方法的某个子集。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>abstract class Demo</p>
<p>{ abstract void show();</p>
<p>}</p>
<p>1、 方法只有声明没有实现时，该方法就是抽象方法，需要被abstract修饰。抽象方法必须定义在抽象类中，该类也必须要被abstract修饰</p>
<p>2、 抽象类不可以被实例化（不可以被new）,调用抽象方法没意义。</p>
<p>3、 抽象类必须有其子类覆盖了所有的抽象方法后，该子类才可以实例化。否则，该子类还是抽象类</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>当一个抽象类中的方法都是抽象的时候，这时可以将该抽象类用另一种形式定义和表示，就是接口 interface。</p>
<p>定义接口用的关键字不是class，是interface</p>
<p>接口中常见的成员：而且这些成员都有固定的修饰符</p>
<ol>
<li><p>全局常量 public static final</p>
</li>
<li><p>抽象方法 public abstract</p>
</li>
</ol>
<p>由此有接口中的成员都是公共的权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Demo</span></span>&#123;   </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">4</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    类与类之间是继承关系，类与接口之间是实现关系，接口与接口之前是继承关系，而且可以多继承</p>
<p>​    接口不可以实例化，只能由实现了接口的子类并覆盖了接口中所有的抽象方法后，该子类才可以实例化。否则，这个子类就是一个抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoImpl</span> <span class="keyword">implements</span> /*实现*/<span class="title">Demo</span></span>&#123;   </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在java中不直接支持多继承，因为会出现调用的不确定性。所以java将多继承机制进行了改良，在java中变成了多实现。</p>
<p>​    一个类可以有多个接口。</p>
<p>class Test implements A,Z  多实现，如果A,Z中方法名一样，也不会报错，因为A,Z中无方法体，若Test中覆盖此同名方法，则A,Z中方法会被同时覆盖，不会产生不确定性，而继承中因为存在方法体，所以不能多继承。</p>
<p>一个类在继承另一个类的时候，还可以实现多个接口。先继承，再实现接口。</p>
<p>class Test extends Q implements A,Z</p>
<p>​    <strong>接口的出现避免了单继承的局限性</strong>。接口与接口之前是继承关系，而且可以多继承</p>
<p>interface QQ extends CC,MM</p>
<h4 id="接口的特点"><a href="#接口的特点" class="headerlink" title="接口的特点"></a>接口的特点</h4><ul>
<li><p>接口是对外暴露的规则</p>
</li>
<li><p>接口是程序的功能扩展</p>
</li>
<li><p>接口的出现降低耦合性</p>
</li>
<li><p>接口可以用来多实现</p>
</li>
<li><p>类与接口之间是实现关系，而且类可以继承一个类的同时实现多个接口</p>
</li>
<li><p>接口与接口之间可以有继承关系</p>
</li>
</ul>
<h4 id="抽象类和接口的异同点"><a href="#抽象类和接口的异同点" class="headerlink" title="抽象类和接口的异同点"></a>抽象类和接口的异同点</h4><p>相同点：都是不断向上抽取而来的</p>
<p>不同点：</p>
<ol>
<li><p>抽象类需要被继承，而且只能单继承。</p>
<p>接口需要被实现，而且可以多实现</p>
</li>
<li><p>抽象类中可以定义抽象方法和非抽象方法，子类继承后可以直接使用非抽象方法。</p>
<p>接口中只能定义抽象方法，必须由子类去实现</p>
</li>
<li><p>抽象类的继承，是is a 关系。在定义该体系的基本共性内容，基本功能</p>
<p>接口的实现是like a 关系。在定义体系额外功能</p>
</li>
</ol>
<p>在不同的领域中，有不同的分析方式</p>
<p>接口类型对象指向自己的子类对象。接口类型的引用，用于接收（指向）接口的子类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">useUSB(<span class="keyword">null</span>);  </span><br><span class="line">useUSB(<span class="keyword">new</span> Upan());</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useUSB</span><span class="params">(USB u)</span> <span class="comment">//使用了多态，相当于USB u = new Upan()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u!=<span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		u.open();</span><br><span class="line">		u.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>​    在某些情况下，一个类的属性是有限而且固定的，如下面的棋子类，只有两个对象，白棋和黑棋。这种实例有限而且固定的类，在java中称为枚举类，枚举类的关键字是enum，此类中有两个枚举属性BLACK和WHITE，代表黑子与白子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//棋子类，枚举类，为构造器私有，不能直接创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  Chessman &#123;</span><br><span class="line">    BLACK(<span class="string">"●"</span>), WHITE(<span class="string">"○"</span>);</span><br><span class="line">    <span class="keyword">private</span> String chessman;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Chessman</span><span class="params">(String chessman)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.chessman = chessman;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *获取棋子类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String 黑棋或者白棋</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getChessman</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.chessman;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    此枚举的构造器权限使用private表明子类不可以通过外部创建，只能通过此类的内部创建，为了保证此对象只有黑子与白子两种类型。红色代码列出了枚举值，实际上是调用私有构造器创建此对象，等效于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Chessman BLACK = <span class="keyword">new</span> Chessman(<span class="string">"●"</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Chessman WHITE = <span class="keyword">new</span> Chessman(<span class="string">"○"</span>);</span><br></pre></td></tr></table></figure>

<p>因为BLACK与WHITE两个属性是静态的，要获取黑子或白字，可使用以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Chessman.BLACK.getChessman();</span><br><span class="line">Chessman.WHITE.getChessman();</span><br></pre></td></tr></table></figure>

<h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><p>对自己所写类添加说明文档，用javadoc</p>
<p>类的文档描述应该包括：</p>
<ol>
<li><p>这个类的作用，包含的内容</p>
</li>
<li><p>@author Hugh</p>
</li>
<li><p>@version V1.0</p>
</li>
</ol>
<p>注释格式为</p>
<p>/**</p>
<p>*/</p>
<p>对于每一个方法，描述其作用，@param arr 接收对象描述  @return 返回值描述</p>
<p>为了能使用javadoc，要将class前面加上public，这样类名和文件名必须要一致</p>
<p>使用语句为 javadoc -d myhelp(自己要放的文件名) –author –version ArrayTool.java（要查看的java文件）然后查看index网页，只提供公有权限的</p>
<p>使用时候若class文件与测试用java文件不在同一目录，使用set classpath=.;c:\myclass（相应目录）.;表示当前目录（用以编译当前测试文件），然后再设置对方所给class文件存放目录。若已经设置好对方classpath目录，则使用set classpath=.;%classpath%</p>
<p>若要清楚classpath，使用 set classpath=,查看路径为set classpath</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态：某一类事物的多种存在形态</p>
<p>用父类类型指向子类对象，猫这类事物既具备了猫的形态，又具备了动物的形态，这就是对象的多态性。一个对象对应着不同类型</p>
<p>在代码中体现：父类或接口的引用指向了其子类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal c = <span class="keyword">new</span> pig();</span><br></pre></td></tr></table></figure>

<p>多态的好处：</p>
<p>​    提高了代码的扩展性，前期定义的代码可以使用后期的内容</p>
<p>多态的弊端：</p>
<p>​    前期定义的内容不能使用（调用）后期子类的特有内容</p>
<p>多态的前提：</p>
<ol>
<li><p>必须有关系，继承，实现。</p>
</li>
<li><p>要有覆盖</p>
</li>
</ol>
<p>Animal a = new cat();//自动类型提升，猫对象提升为了动物类型，但特有功能无法访问，</p>
<p>作用为限制对特有功能的访问</p>
<p>专业讲：向上转型，将子类型隐藏，就不能使用子类型的特有方法</p>
<p>若父类中的内容被子类覆盖，调用向上转型对象的方法所实现的为子类的内容</p>
<p>若想使用特有内容，则将对象进行向下转型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cat c = (Cat)a；<span class="comment">//向下转型的目的是使用子类中的特有方法</span></span><br><span class="line">Animal a1 = <span class="keyword">new</span> dog();</span><br><span class="line">Cat c1 = (Cat)a1;<span class="comment">//  ClassCastException类型转换异常</span></span><br></pre></td></tr></table></figure>

<p>注意：对于转型，自始至终都是子类对象在做着类型的变化</p>
<p>对对象类型的判断</p>
<p>instanceof：用于判断对象的具体类型,只能用于引用数据类型判断，通常在向下转型前用于健壮性的判断。</p>
<p>if(a instanceof Cat){}</p>
<p>转型之前加入逻辑判断，加强代码的健壮性</p>
<h4 id="多态时成员的特点"><a href="#多态时成员的特点" class="headerlink" title="多态时成员的特点"></a>多态时成员的特点</h4><ol>
<li>成员变量</li>
</ol>
<p>编译时：参考引用型变量所属的类中是否有调用的成员变量，有，编译通过；没有，编译失败。</p>
<p>运行时：参考引用型变量所属的类中是否有调用的成员变量，并运行所属类中的成员变量</p>
<p>简单说：编译和运行都参考等号的左边</p>
<ol start="2">
<li>成员函数（非静态，重点）</li>
</ol>
<p>编译时：参考引用型变量所属的类中是否有调用的函数，有，编译通过；没有，编译失败。</p>
<p>运行时：参考的是对象所属的类中是否有调用的函数</p>
<p>简单说：编译看左边，运行看右边</p>
<ol start="3">
<li>静态函数</li>
</ol>
<p>编译时：参考引用型变量所属的类中是否有调用的静态方法</p>
<p>运行时：参考引用型变量所属的类中是否有调用的静态方法</p>
<p>简单说：编译和运行都参考等号的左边</p>
<p>​    其实静态方法是不需要对象的，直接类名调用即可</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类：将一个类定义在另一个类里面，对里面那个类成为内部类（内置类，嵌套类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;   </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;   </span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;print(“show”+num);&#125;</span><br><span class="line">   		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;print(“function”+num);&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主函数中编译，产生Outer.class和Outer$Inner.class文件</p>
<p>若要访问一个类中私有变量，最简单方法是在该类中定义内部类，则可以直接访问该私有变量</p>
<p>内部类访问特点</p>
<ol>
<li><p>内部类可以直接访问外部类中的成员</p>
</li>
<li><p>外部类要访问内部类，必须建立内部类的对象</p>
</li>
</ol>
<p>一般用于类的设计。分析事物时发现该事物描述中还有事物，而且该事物还在访问该事物的内容，这时把这个事物定义为内部类来描述</p>
<p>直接访问外部类中的内部类成员</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.Inner in = <span class="keyword">new</span> Outer().<span class="keyword">new</span> Inner();in.show();<span class="comment">//必须先建立外部类对象</span></span><br></pre></td></tr></table></figure>

<p>如果内部类是静态的，相当于一个外部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.Inner in = <span class="keyword">new</span> Outer.Inner();in.show();<span class="comment">//不需建立内部类对象，此静态方法中只能使用静态变量</span></span><br></pre></td></tr></table></figure>

<p>如果内部类是静态的，成员是静态的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.Inner.function();</span><br></pre></td></tr></table></figure>

<p>当内部类中定义了静态成员，该内部类必须被静态修饰，或者该成员被final修饰</p>
<p>外部类只能用public和default默认修饰符，内部类四种修饰符都可以用</p>
<p>内部类可以直接访问外部类中成员的原因：内部类持有外部类的引用，外部类名.this</p>
<p>外部类和内部类拥有同名的变量和方法时，内部类有需要进行访问外部的同名变量或方法，可以通过<strong>外部类.this.方法名/变量名</strong>进行访问</p>
<ol>
<li>成员内部类</li>
</ol>
<p>当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：</p>
<ul>
<li>外部类.this.成员变量</li>
<li>外部类.this.成员方法</li>
</ul>
<p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。</p>
<ol start="2">
<li>局部内部类</li>
</ol>
<p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。</p>
<ol start="3">
<li>匿名内部类</li>
</ol>
<p>匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p>
<ol start="4">
<li>静态内部类</li>
</ol>
<p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字<strong>static</strong>。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。<strong>只有静态内部类，才能在类中申明静态方法</strong>，普通内部类申明静态方法会报错。</p>
<h4 id="内部类问题解释"><a href="#内部类问题解释" class="headerlink" title="内部类问题解释"></a>内部类问题解释</h4><ol>
<li><p>为什么成员内部类可以无条件访问外部类的成员？</p>
<p>编译器会默认为成员内部类添加了一个指向外部类对象的引用（this）。从这里可以看出，虽然我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用，所以成员内部类中的Outter this&amp;0 指针便指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员。从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法对Outter this&amp;0引用进行初始化赋值，也就无法创建成员内部类的对象了。</p>
</li>
<li><p>为什么局部内部类和匿名内部类只能访问局部final变量？</p>
<p>如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。为了避免在内部类的方法中改变参数造成数据不一致性，局部内部类和匿名内部类中访问成员变量需要被final修饰。</p>
<p>一个类文件中，<strong>只能有一个公共的（**</strong>public<strong>**）外部类</strong>，但可以有多个(public、default、private)内部类，多个（default）外部类，private不能用来修饰外部类！</p>
</li>
</ol>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类。就是内部类的简写格式</p>
<p>​    必须有前提：内部类必须继承或者实现一个外部类或者接口</p>
<p>匿名内部类：其实就是一个匿名子类对象（因此如果父类中无此方法会报错）</p>
<p>格式： new 父类or接口 () { 子类内容 }</p>
<p>new demo()即为匿名内部类，因为是对象所以可以直接调用方法</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB.png" class title="This is an example image">

<p>注意：在匿名内部类中，要将方法权限设置为public，否则无法被实现</p>
<p>通常使用场景之一：当函数参数是接口类型时，而且接口中的方法不超过三个。可以利用匿名内部类作为实际参数进行传递 </p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Object%E7%BC%96%E8%AF%91%E5%A4%B1%E8%B4%A5.png" class title="This is an example image">

<p>new Object(){}相当于创立了子类对象，而Object obj=子类对象，相当于向上转型（多态），隐藏了子类特有属性，编译看左边，Object类中无show方法，因此会编译失败</p>
<p>对象构造：显示初始化在构造器初始化之后</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC10%E5%A4%A91.png" class title="This is an example image">

<p>new Zi()对象后，先执行Zi构造函数，默认第一行为super()，此时调用super中的show，因为子类中show被覆盖，因此输出show…，而此时num还没有被显示初始化，因此num为0.然后执行显示的初始化，这时候num为9</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC10%E5%A4%A92.png" class title="This is an example image">

<p>创立对象时，先默认初始化，即num=0，然后Zi()进栈，执行父类构造函数，show函数在子类对象中被覆盖，执行子类show，父类构造函数出栈后进行显示初始化，此时num=9，然后进行构造代码块输出化，然后才是自定义构造函数语句输出</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC10%E5%A4%A93.png" class title="This is an example image">

<p>​    首先为Fu和Zi开辟内存空间，然后执行子类的构造函数，先执行super()，Fu中super为Object，然后进行显示初始化，此时Fu中num=9，再执行父类中构造代码块初始化，因此<strong>第1个输出Fu</strong>。然后执行show()方法，因为父类中show被覆盖，所以执行子类的，而子类中还未进行显示初始化，因此子类中num=0，<strong>第2步</strong>子类show()输出<strong>zi show num=0</strong>。然后子类中父类构造函数执行完毕出栈，执行子类显示初始化，num=8，然后执行构造代码块初始化，因此<strong>第三步输出Zi</strong>.然后进行Zi类中show方法，<strong>第4步输出zi show num=8</strong>。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常：运行时期发生的不正常情况</p>
<p>java中用类的形式对不正常情况进行了描述和封装对象。描述不正常的类，成为异常类。以前正常流程代码和问题处理代码相结合，现在将正常流程代码和和问题处理代码分离，提高阅读性。</p>
<p>不同的问题用不同的类进行具体的描述，比如角标越界，空指针等。</p>
<p>​    问题很多，意味着描述的类也很多，将其共性向上抽取，形成了异常体系。最终问题（不正常情况）就分成了两大类。</p>
<p>Throwable:无论是error，还是异常，问题，问题发生就应该可以抛出，让调用者知道并处理。</p>
<p>//该体系的特点就在于Throwable及其所有的子类都具有可抛性。</p>
<p>可抛性：通过两个关键字来体现的。throws，throw，凡是可以被这两个关键字所操作的类和对象都具有可抛性。<br>|–1、一般不可处理的。Error</p>
<p>特点：是由jvm抛出的严重性的问题。这种问题发生一般不针对性处理。直接修改程序</p>
<p>|–2、可以处理的。Exception</p>
<p>​    发生错误时，对错误地方进行对象封装， throw一个新错误对象给调用者，虚拟机，然后在控制台输出，实际开发时会以日志的形式存储起来。错误地方后面的功能不予执行，因此抛出错误对象可以结束函数。</p>
<p>throw 抛出对象 throw new …某Exception()</p>
<p>​    对于角标是正数不存在，可以用角标越界表示；对于负数为角标的情况，准备用负数角标异常来表示。负数角标这种异常在java中并没有定义过，那就按照java异常的创建思想，面向对象，将负数角标进行自定义描述，并封装成对象。这种自定义的问题描述称为<strong>自定义异常</strong>。  </p>
<p>​    注意：如果让一个类成为异常类，必须要继承异常体系，因为只有成为异常体系的子类才有资格具备可抛性。才可以被两个关键字所操作。throws throw。 </p>
<p>extends RuntimeException</p>
<p>如果在函数内发生了异常，应该在函数中进行声明 throws 引用在函数声明上，throw用在函数内；调用发生异常函数，必须要处理，处理方式之一为抛出。因为继承了父类的异常体系，在重载自定义的异常构造函数时，若要进行String提示输出，可以用super(Str)来进行相关语言提示。</p>
<h4 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h4><ol>
<li><p>编译时被检测异常：只要是Exception和其子类都是，除了特殊子类RuntimeException体系。这种问题一旦出现，希望在编译时就进行检测，让这种问题有对应的处理方式。</p>
</li>
<li><p>编译时不检测异常（运行时异常）就是Exception中的RuntimeException和其子类</p>
<p>这种问题的发生无法让功能继续，运算无法进行，更多是因为调用者的原因导致的或者引发了内部状态的改变导致的。这种问题一般不处理，直接编译通过，在运行时让调用者调用时的程序强制停止，让调用者对代码进行修正。</p>
</li>
</ol>
<p>如果不需要将问题暴露，编译通过在运行时停止；若需要将问题暴露，则在编译时报错    因此自定义异常时，继承Exception或者RuntimeException</p>
<h4 id="throws和throw区别"><a href="#throws和throw区别" class="headerlink" title="throws和throw区别"></a>throws和throw区别</h4><ol>
<li><p>throws使用在函数上，throw使用在函数内</p>
</li>
<li><p>throws抛出的是异常类，可以抛出多个，用逗号隔开。throw抛出的是异常对象，一次只能抛出一个</p>
</li>
</ol>
<h4 id="异常处理的捕捉形式"><a href="#异常处理的捕捉形式" class="headerlink" title="异常处理的捕捉形式"></a>异常处理的捕捉形式</h4><p>这是可以对异常进行针对性处理的方式。</p>
<p>具体形式是：</p>
<p>try{需要被检测异常的代码}</p>
<p>catch(异常类 变量){处理异常的代码}//该变量用于接收发生的异常对象</p>
<p>finally{一定会被执行的代码}</p>
<p>这个代码块是一个整体</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC11%E5%A4%A91.png" class title="This is an example image">

<p>​    在try中放入待检测代码块（其中为局部变量），此对象调用方法抛出一个异常对象，此对象被catch捕捉，e = new异常对象，然后继续输出负数角标异常，因为问题已经被解决，因此程序可以向下运行输出over</p>
<p>​    如果输出e.getMessage()，则可以输出此异常详细信息。getMessage()为父类throwable中的方法。一般直接打印对象，输出为对象地址和哈希值，但是异常对象相当于使用e.toString()，输出为异常类名加信息。</p>
<p>​    e.printStachTrace()，将其追踪输出至标准错误流（jvm默认的异常处理机制）</p>
<p>该体系的特点：子类的后缀名都是用其父类名作为后缀，阅读性很强</p>
<p>如果有多个catch的情况，在抛出的时候throws 多个异常，然后写多个catch即可。</p>
<p>​    如果在多catch情况下，出现了父类Exception e的处理情况，一定要放在多catch的最后，不然放在最前面其他catch永远不执行(多catch下父类的catch放在最后，否则编译失败)</p>
<p>​    只要使用到了声明异常的方法，就要try</p>
<h4 id="异常处理的原则"><a href="#异常处理的原则" class="headerlink" title="异常处理的原则"></a>异常处理的原则</h4><ol>
<li><p>函数内容如果抛出需要检测的异常，那么函数上必须要声明。否则必须在函数内用try,catch捕捉，否则编译失败。</p>
</li>
<li><p>如果调用到了声明异常到的函数，要么try,catch，要么throws，否则编译失败</p>
</li>
<li><p>什么时候catch，什么时候throws</p>
<p>功能内部可以解决，用catch。解决不了用throws告诉调用者，由调用者解决。</p>
</li>
<li><p>一个功能如果抛出了多个异常，那么调用时必须有对应多个catch进行针对性的处理。</p>
</li>
</ol>
<p>内部有几个需要检测的异常就抛几个异常。抛出几个，就catch几个</p>
<p>finally是一定会被执行到的，除非在catch中用到了System.exit(1)，直接退出jvm。</p>
<p>​    finally通常用于关闭（释放）资源，如数据库查询出异常后要关闭连接，关闭连接就在finally中</p>
<p>​    没catch就没处理</p>
<p>try catch finally代码块组合特点：</p>
<ol>
<li><p>try catch finally</p>
</li>
<li><p>try catch(多个) 当没有必要资源需要释放时，可以不用定义finally</p>
</li>
<li><p>try finally 异常无法直接catch处理，但是资源需要关闭</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> show <span class="keyword">throws</span> <span class="title">Exception</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;<span class="comment">//开启资源</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> Exception();&#125;</span><br><span class="line">	<span class="keyword">finally</span>&#123;<span class="comment">//关闭资源&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常转换：捕捉一个异常，暴露出来的是另一个异常，因为此捕捉异常无法被处理，因此转换为可以被处理的异常</p>
<p>catch(MaoYanException e){</p>
<p>​           System.out.println(e.toString());</p>
<p>​           test();</p>
<p>​           //可以对电脑进行维修</p>
<p>​           //throw e;</p>
<p>​           throw new NoPlanException(“课时进度无法完成”+e.getMessage());</p>
<p>​       }</p>
<p>如果发生问题，内部解决，没有给外部抛出，就是隐藏了问题。异常的封装：解决那些内部解决的，抛出需要被外界知道的异常类信息。</p>
<h4 id="异常的注意事项"><a href="#异常的注意事项" class="headerlink" title="异常的注意事项"></a>异常的注意事项</h4><ol>
<li><p>子类在覆盖父类方法时，如果父类的方法抛出了异常，那么子类的方法只能抛出父类的异常或该异常的子类（可以不抛）</p>
</li>
<li><p>如果父类抛出多个异常，那么子类只能抛出父类异常的子集</p>
</li>
</ol>
<p>简单说，子类覆盖父类，子类只能抛出父类的异常或者子类或者子集</p>
<p>注意：如果父类的方法没有抛出异常，子类覆盖时绝对不能抛，就只能try</p>
<p>子类重写的方法可以抛出任何运行时异常（RuntimeException和ArithmeticException属于运行时异常）</p>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>Object:所有类的根类</p>
<p>Object是不断抽取而来，具备着所有对象都具备的共性内容</p>
<p>常用的共性功能:</p>
<p>boolean equals(Object obj):判断两个对象是否相等，仅当引用同一个对象才返回true，比较的也是地址</p>
<p>​    一般都会覆盖此方法，根据对象的特有内容，建立判断对象是否相同的依据</p>
<p>一般向下转型要进行健壮性判断 用instanceof进行判断，扔出异常（运行时异常）告诉用户</p>
<p>if(classA instanceof classB)</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC11%E5%A4%A92.png" class title="This is an example image">

<p>hashCode()，获得哈希地址值，直接输出对象引用=Integer.toHexString(对象.hashCode())；</p>
<p>​    可以根据对象的特性不同，输出不同的哈希值</p>
<p>比较对象equals是否相同：1、判断哈希值是否相同。2、判断内容是否相同</p>
<p>重写equals时候，一般要重写hashCode()，使得相同的对象要有相同的哈希地址值</p>
<p>getClass() 返回此Object的运行时类，即当前对象所属的字节码对象,类型为Class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span></span>&#123;<span class="comment">//字节码文件</span></span><br><span class="line">	name;名称</span><br><span class="line">    field;字段（属性、成员变量）</span><br><span class="line">    constructor;构造器</span><br><span class="line">    method;方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person p = new Person(20)；</p>
<p>​    先在堆里面产生一个Person.class字节码文件对象，再根据字节码文件对象产生Person对象</p>
<p>​    Class clazz1 = p.getClass();</p>
<p>​    可以使用clazz1.getname()即getConstructor()等方法。</p>
<p>toString()方法</p>
<p>​    输出为p.getclass().getName+”@”+Inthger.toHexString(p.hashCode())</p>
<p>如果想建立每个对象特有的字符串输出方法，就可以将toString()方法覆写</p>
<h3 id="包（package）"><a href="#包（package）" class="headerlink" title="包（package）"></a>包（package）</h3><p>对类文件进行分类管理；对类提供多层命名（名称）空间；写在程序的第一行；类名的全程是 包名.类名；包也是一种封装形式</p>
<p>在java文件第一行写package zc.Demo;</p>
<p>编译时候 javac -d . Hello.java，自动生成相应目录，然后运行java zc.Demo.Hello</p>
<p>​    如果两个java文件在不同的包下，一个需要用到另一个类，则如果直接用类名来新建对象会出错，因为类已经有包的所属，所以必须要明确其包名。记住：Demo这个名称是错的，正确名称是包名.类名 packa.Demo。如果两个java文件不在一个目录下，则编译有主函数的类时会找不到调用类，此时需要将被调用类包所在的路径设置为路径</p>
<p> set classpath=.;+路径。在包中，如果没有写public，就是被封装了。方法也不能使用默认权限，要使用public。</p>
<p>​    总结：包与包之间的类访问，被访问的包中的类必须是public的，被访问的包中的类的方法也必须是public的。</p>
<p>​    protected权限，第四种，只有在不同包中的子类才能使用，即必须要继承才能使用，直接在不同包中创建对象无法使用被保护的方法，其实也叫封装。</p>
<table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>default</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同一类中</td>
<td>ok</td>
<td>ok</td>
<td>ok</td>
<td>ok</td>
</tr>
<tr>
<td>同一包中</td>
<td>ok</td>
<td>ok</td>
<td>ok</td>
<td>no</td>
</tr>
<tr>
<td>子类中</td>
<td>ok</td>
<td>ok</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>不同包中</td>
<td>ok</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
</tbody></table>
<p>不同包中能使用的;1、public 2、不同包中子类的protected</p>
<p>使用import，导入指定包中的类，import packa.<em>；导入packa中的所有类,并不导入其中的包，如果packa下面还有包，则需要加入packa.abc.*；真实开发中不建议写</em></p>
<p>​    使用import可以导入包中的类，不用写包名.类名</p>
<p>​    导包的原则：用到哪个类就导入哪个类。</p>
<p>​    import作用：为了简化类名书写，导入的是包中的类。</p>
<p>Jar：java的压缩包，可以压缩</p>
<p>压缩命令：jar -cvf 压缩包名称.jar 被压缩包名</p>
<p>解压缩命令：jar -xvf 压缩包名称</p>
<p>​    将工具包打包为jar文件，不用解压缩，将jar文件添加到classpath下，然后变可以执行，利用java 包名.类名执行。</p>
<h3 id="外部类与内部类修饰符"><a href="#外部类与内部类修饰符" class="headerlink" title="外部类与内部类修饰符"></a>外部类与内部类修饰符</h3><p>如果类可以使用private来修饰，表示该包下的这个类不能被其它类访问，那么该类也失去了存在的意义，所以不能使用private来修饰类。</p>
<p>如果类可以使用protected来修饰，表示该类所在的包的其它类可以访问该类；该类所在的包的子包的类可以访问该类，但是包没有继承的概念，所以后一句是不对。所以用protected来修饰类也是没有意义的。</p>
<p>​    外部类的修饰权限只能是public或者包访问权限，但是内部类可以是private或者protected。</p>
<p>​    如果没能为访问权限指定一个访问修饰符，它就会默认得到包访问权限，意味着该类的对象可以由包内任何其他类来创建，在包外是不行的。相同目录下所有不明确package声明的文件，都被视作是该目录下默认包的一部分。</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>进程：正在进行中的程序（直译）</p>
<p>线程：负责进程中程序执行的一个控制单元，也称为执行路径，执行情景。</p>
<p>一个进程中可以有多个执行路径，称之为多线程。</p>
<p>一个进程中至少要有一个线程。</p>
<p>开启多个线程是为了同时运行多部分代码；每一个线程都有自己运行的内容，这个内容可以称为线程要执行的内容。</p>
<p>多线程弊端：线程太多导致运行效率低。应用线程的执行都是CPU在做着快速的切换完成的，CPU切换是随机的。</p>
<p>JVM启动时启动了多个线程，至少有2个可以分析出来。</p>
<ol>
<li>执行main函数的线程</li>
</ol>
<p>该线程的任务代码都定义在main函数中。</p>
<ol start="2">
<li>负责垃圾回收的线程</li>
</ol>
<p>​    每个对象都有finalize()方法，当垃圾回收器确定不存在该对象的更多引用时，由对象的垃圾回收器调用此方法。</p>
<h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC13%E5%A4%A91.png" class title="This is an example image">

<p>sleep(time)时间到，线程便从冻结状态变为运行状态。如果使用wait()方法，使用notify()方法才能唤醒线程。</p>
<p>运行状态：具备执行资格，具备执行权</p>
<p>冻结状态：释放执行权的同时释放执行资格</p>
<p>临时阻塞状态：具备着执行资格但是不具备执行权</p>
<p>CPU的执行资格：可以被CPU处理，在处理队列中排队</p>
<p>CPU的执行权：正在被cpu处理</p>
<p>​    如果类已经有父类，要拓展此类的功能，让其中的内容可以作为线程的任务执行，通过接口的形式完成</p>
<h4 id="创建线程方式一"><a href="#创建线程方式一" class="headerlink" title="创建线程方式一"></a>创建线程方式一</h4><p>方式一：继承Thread类</p>
<ol>
<li><p>定义一个类继承Thread类</p>
</li>
<li><p>覆盖Thread类中的run()方法。Thread类用于描述线程，因此Thread类也有对任务的描述，这个任务就是通过Thread类中的run()方法来体现，因此   run()方法就是封装自定义线程运行任务的函数。run方法中定义的是线程要运行的任务代码。</p>
</li>
<li><p>直接创建Thread的子类对象创建线程</p>
</li>
<li><p>调用start()方法，作用为启动线程，调用run()方法</p>
</li>
</ol>
<p>开启线程是为了运行指定代码，所以只有继承Thread类，并覆写run()方法，将运行的代码定义在run()方法中。</p>
<p>​    可以通过Thread的getName(0方法来获取线程的名称 Thread-编号（从0开始），线程一被创建就调用super()，被赋予编号。</p>
<p>​    Thread.currentThread().getName()，获取正在运行的线程名字，主线程的名字就是main。如果想对线程起名，可以用Thread(String name)，用super(“名字”)父类构造器来起名字。</p>
<p>​    对于多线程的内存图解，相当于main函数中开启了多条通道</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC12%E5%A4%A91.png" class title="This is an example image">

<p>​    不同的线程有不同的工作区，每个放大的进栈弹栈在单独的空间内完成，每个方法中的变量互不冲突。</p>
<p>​    只要有一个前台进程还在运行，程序就不会结束。</p>
<p>​    在异常中，会显示异常出现的具体线程，在哪个线程出异常，就显示哪个线程。</p>
<h4 id="创建线程方式二"><a href="#创建线程方式二" class="headerlink" title="创建线程方式二"></a>创建线程方式二</h4><p>方式二：实现Runnable接口</p>
<ol>
<li><p>定义类实现Runnable接口</p>
</li>
<li><p>覆盖接口中的run()方法，将线程的任务代码封装到run()方法中</p>
</li>
<li><p>通过Thread类创建对象，并将Runnable接口的子类对象作为Thread类构造函数的参数进行传递</p>
<p>原因：因为线程的任务都封装在Runnable子类对象run()方法中，所以要在线程对象创建时明确要运行的任务。</p>
</li>
<li><p>调用线程对象的start()方法启动线程</p>
</li>
</ol>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC13%E5%A4%A92.png" class title="This is an example image">

<p>​    实现Runnable接口，如果使用无参数的Thread构造方法，则run()方法不做动作，如果传入Runnable子类，则调用的是子类中的方法。如果使用继承Thread类，则此类将父类中的run()方法覆盖，也没有影响。</p>
<p>​    使用多线程的目的是讲线程任务进行执行，如果直接继承Thread，将所有的线程类中的方法继承没有必要；如果只是实现Runnable接口，则它的出现仅仅是将线程的任务进行了对象的封装。为了运行创建Thread对象并明确线程的任务。</p>
<p>​    Thread类实现Runnable接口原因，此类与其他线程类都有共性：线程方法，但是此方法不是必须的，而是额外的功能，因此被抽取成一个接口。</p>
<h4 id="实现Runnable接口的好处"><a href="#实现Runnable接口的好处" class="headerlink" title="实现Runnable接口的好处"></a>实现Runnable接口的好处</h4><ol>
<li><p>将线程的任务从线程的子类中分离出来，进行了单独的封装。按照面向对象的思想将任务封装成了对象。</p>
</li>
<li><p>避免了java单继承的局限性</p>
</li>
</ol>
<p>所以创建线程的<strong>第二种方式</strong>较为常见</p>
<p>异常：所属线程+异常名称+异常信息+异常位置</p>
<p>​    卖票程序中，如果使用继承，新建多个Thread子类对象，每个对象都有票信息，没实现信息共享。需要利用实现Runnable接口，这样只产生一个对象，将线程任务封装成对象传递给Thread类，然后新建多个Thread类对象调用start()方法，因为只有一个Runnable子类对象，因此在堆内存中只存在一个票数信息。</p>
<p>​    卖票时候会出现，一个线程获取票数准备-1，此时切到另一个线程也获取票数，此时票数仍然符合要求，也准备-1，这样会出现票数&lt;=0的情况，会出现线程安全问题。</p>
<h4 id="线程安全问题产生原因"><a href="#线程安全问题产生原因" class="headerlink" title="线程安全问题产生原因"></a>线程安全问题产生原因</h4><ol>
<li><p>多个线程在操作共享的数据。</p>
</li>
<li><p>操作共享数据的线程代码有多条。（操作共享数据代码在2行以上容易出事）</p>
</li>
</ol>
<p>当一个线程在执行操作共享数据的多条代码中，其他线程参与了运算，就会导致线程安全问题的产生。</p>
<p>​    解决思路：将多条操作共享数据的线程代码封装起来；当有线程在执行这些代码的时候，其他线程是不可以参与运算的。必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算。</p>
<h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><p>​    在java中用同步代码块可以解决这个问题。</p>
<p>格式为：</p>
<p>sysnchronized(对象){需要被同步的代码}</p>
<p>​    此对象不能每次新建 对象，不然不是同一个锁</p>
<p>同步时设置对象相当于一个标志位，所有线程要运行任务时候要先进行状态判断，如果有线程正在进行此任务则需要等待此线程任务执行完毕。后期对同步中的线程进行监视，线程要判断同步锁。</p>
<p>同步的好处：解决了线程的安全问题</p>
<p>同步的弊端：相对降低了效率，因为同步外的线程都会判断同步锁。</p>
<p>Thread.sleep()需要进行try,catch，如果此类实现了接口，则不能抛出错误，只能解决，接口的异常对象为InterruptedException</p>
<p>​    同步的前提：同步中必须有多个线程并使用同一个锁。</p>
<p>如果同步锁的对象是成员变量，一个对象堆中只有一个，可以同步；如果此对象在run()方法中定义，则每个线程栈中都有一个，则不能实现同步。</p>
<p>线程开启必须有任务</p>
<p>​    使用同步函数也能解决线程的安全问题，将函数中加上synchronized修饰符。同步函数使用的锁是this。</p>
<p>​    同步函数和同步代码块的区别：</p>
<p>同步函数的锁是固定的this，同步代码块的锁是任意的对象。建议使用同步代码块。</p>
<p>如果同步函数使用静态修饰，因为静态方法中没有this，所以此时同步代码块中的同步锁对象为该函数所属字节码文件对象，可以用getClass方法获取，也可以用类名.class表示。</p>
<p>​    获取字节码文件：</p>
<p>Class clazz = t.getClass();</p>
<p>Class clazz = Ticket.class;`</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC13%E5%A4%A93.png" class title="This is an example image">

<p>​    使用懒汉式，在第一次的时候进行实例化，如果多个线程进来，先进行s的判断，可能会初始多个对象，这时候就有多线程的安全隐患，将getInstance()方法加上synchronized修饰即可。但是这样每个线程进来都要判断同步锁，降低了效率，可以使用同步代码块，其中同步对象为Single.class。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC13%E5%A4%A94.png" class title="This is an example image">

<p>​    线程0进来，此时s==null，开启同步锁，此时进入if判断，CPU切走，然后线程1进来，进入if判断，同步锁进不去，等线程0切回来，创建一个s对象，再切回到线程1，此时因为不满足if判断，因此结束。如果再有其他线程进来，不满足最外层s==null判断，因此也不会降低效率。</p>
<p>​    加一层同步，是为了解决线程安全问题；加一层判断，是为了解决效率问题。利用双重判断来解决懒汉式的安全和效率问题，因此开发式饿汉式更好。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>常见情形一：同步的嵌套</p>
<p>设置两个状态，同步嵌套，线程A同步锁为a，b；线程B同步锁为b，a。如果两个线程进去时候一个持有锁a，另一个持有锁b，这样就会出错。</p>
<h4 id="线程间通讯"><a href="#线程间通讯" class="headerlink" title="线程间通讯"></a>线程间通讯</h4><p>线程间通讯：多个线程在处理同一资源，但是任务却不同。</p>
<p>需求：有一资源，有输入与输出的方法，要求一个输入就一个输出，这样便涉及到了多线程。</p>
<p>​    设计思路：将资源封装成对象，输出实现Runnable接口，设置循环输出资源的信息；输入实现Runnable方法，设置循环获得资源的信息。因为输入与输出为2个类，而且都要获得资源对象，如果两个分别new资源对象，这样资源没有实现共享。因此要让输入输出 操作同一个对象，可以使用单例设计，也可以采用传参的形式，对输入输出进行构造函数传入参数对象，进行参数的设置。在主函数中，先创建资源，然后创建任务，再创建线程，执行路径，最后开启线程。</p>
<p>​    实现0,1的切换，利用x%2，在输入端进行2种设置，利用x值的不同来切换，如果张三，男；李四，女。</p>
<p>​    在主函数中运行，会出现张三，女和李四，男的情况，这是因为输入在设置的时候，便进行了输出。如果直接使用同步，则无法解决，这时候要思考同步的前提：一个同步锁中是否有多个线程。不符合，因为输入线程中只有一个线程，输出线程不在同步中。如果两边同时加入同步，但是不使用同一个锁，因此还是无法解决。这时候考虑到资源对象是唯一的，使用资源对象作为锁。这样便解决了对象输出错误的问题，但是输出的结果不是一个男，一个女。是因为输入拿到资源，不会只赋值一次，便一直在赋值；输出也一样，不会只输出一次，因此一直输出最后一次赋值结果。需求的效果是一个输入完后就进行输出。</p>
<p>​    为了解决这个问题，应该在资源中加入标记，如果有数据，那么便不进行覆盖，如果没有数据，再进行输入。加入一个数据后，标志位改变，这时候要等待输出线程进行输出。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E5%A4%A91.png" class title="This is an example image">

<p>​    在输入中，如果标记位为false，则没有信息，应该写入信息，将flag置为true，唤醒output线程，如果flag为真（还有信息，没有输出），则冻结input线程。在输出中，如果标记位为true，则有信息，应该输出信息，将flag置为false，唤醒input线程，如果flag为假（没有信息，还没输入），则冻结output线程。</p>
<h4 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h4><p>涉及的方法：</p>
<ol>
<li><p>wait();让线程处于冻结状态，被wait的线程会被存储到线程池中。</p>
</li>
<li><p>notify();唤醒线程池中的一个线程（任意）。</p>
</li>
<li><p>notifyAll();唤醒线程池中的所有线程。</p>
</li>
</ol>
<p>这些方法都必须定义在同步中，因为这些方法是用于操作线程状态的方法。必须要明确到底操作的是哪个锁上的线程。</p>
<p> 其中wait()和notify()方法要有所属，应该是同步锁的对象.wait()和同步锁的对象.notify()。在哪个对象中被等待和唤醒，就用哪个线程唤醒和等待.</p>
<p> 操作线程的方法wait,notify,notifyAll定义在Object类中原因是：因为这些方法是监视器的放法，监视器其实就是锁。锁可以是任意的对象，任意的对象调用的方式一定定义在Object类中。</p>
<p> 其中wait()抛出了InterruptedException异常，要有try,catch。</p>
<p>​    然后利用面向对象的思想，将姓名性别设置为私有属性，设置专门的set和out方法来设置和获取其属性。而因为定义在了资源这一个类中，可以直接利用同步方法来实现同步，同步锁为this，然后加进去flag判断和x切换输入，转变flag并唤醒线程池中线程。其中输出直接调用out方法即可。</p>
<p>​    单生产不会出问题，但是多生产多消费出问题。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E5%A4%A92.png" class title="This is an example image">

<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E5%A4%A93.png" class title="This is an example image">

<p>​    如果t0,t1是生产，t2,t3是消费，那么第一下t0进行生产了第1只烤鸭，此时烤鸭数为2，flag=true，这是t0进入了休眠状态，此时临时阻塞状态的线程有t1,t2,t3。这时候如果t1被CPU执行到，flag=true，t1也进入休眠状态。这时候剩下t2,t3线程。t2被CPU执行到，消费烤鸭1,flag=false，唤醒线程池中的线程，这时线程池中线程有t0和t1，这时候要随机唤醒安全锁中的线程，假设t0被唤醒，这时候t2仍然有执行权，因为flag=false，t2进入休眠，此时有执行权的线程有t0与t3。假设t3抢到了CPU的执行权，因为flag=false，这时候t3也进入等待，只有t0活着。线程唤醒后直接接着执行，不用重新判断flag，因此t0生产烤鸭2。count=3，这时候flag=true。线程池中有3个线程，t0,t2,t3。这时候如果t0被唤醒，活的有t0,t1。这时候如果t0又抢到了CPU运行权，因为flag=true，t0进入休眠。因为t1不用再判断flag，因此直接生产烤鸭3，count=4。到现在为止，生产了烤鸭1,2,3，但是只消费了烤鸭1，产生了安全问题，烤鸭2没有被消费到。</p>
<p>​    原因在线程醒来后<strong>没有重新判断flag标记</strong>。因为if只判断一次标记，因此将if更改为<strong>while</strong>，结束后还会判断条件，便可以解决烤鸭没有被消费到问题。但是会出现<strong>死锁</strong>的问题。当一个烤鸭被生产，flag=true，唤醒另一个生产线程，这时候活的有t0,t1，进入while判断，因为flag均会进入等待，便没有活的线程。</p>
<p>​    解决死锁：没有唤醒对方才导致死锁。不能指定唤醒的线程，但是可以唤醒所有的线程，这样本方的继续等待，对方的进行工作。这样可以使用notifyAll()方法。</p>
<p>​    while判断标记，解决了线程获取执行权后，是否要运行！原因：if判断标记只有一次，会导致不该运行的线程运行了，出现了数据错误的情况。    </p>
<p>​    notifyAll()解决了本方线程一定会唤醒对方线程。原因：notify()只能唤醒1个线程，如果本方唤醒本方，没有意义。而且while判断标记+notify()会导致死锁。</p>
<p>​    仍然存在的问题：还会唤醒本方线程，而唤醒本方是没有意义的。这样便降低了效率。</p>
<h4 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h4><p>​    <strong>JDK1.5后</strong>。同步代码块对于锁的操作是隐式的。后期把锁封装成对象，获取锁与释放锁是锁对象最清楚，变成显示的。现在有lock()与unlock()来对锁进行操作。因此lock对synchronized进行了替代，代码进行改写。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E5%A4%A94.png" class title="This is an example image">

<p>​    之前使用synchronized依靠自定义的obj对象作为锁，现在可以利用自定义的锁对象，语法为Lock lock = new ReentrantLock();。如果代码中发生了异常，释放锁不能执行，因此释放锁一定要进行执行，放在finally中。</p>
<p>​    以前的锁是this.wait()与this.notify()，用哪个锁，就用哪个锁上的方法。因此要利用lock来使用wait()与notify()。以前如果锁是this，那么锁上只有1组方法。当锁变成对象，可以有多个锁，将监视器方法封装成Condition对象。可以将多个Condition挂在锁上。</p>
<p>​    Condition因素出Object监视器方法（ wait ， notify和notifyAll ）成不同的对象，以得到具有多个等待集的每个对象，通过将它们与使用任意的组合的效果Lock来实现。 <strong>Lock替换synchronized方法和语句的使用， Condition取代了对象监视器方法的使用</strong>。可以随时和锁进行绑定，通过lock.newCondition()获取一个Condition对象。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E5%A4%A95.png" class title="This is an example image">

<p>​    将原来的this.wait()替换成con.await()，将this.notify()替换成con.signal()，将this.notifyAll()替换成con.signalAll()。</p>
<p>​    之前只有1个监视器，对生产者消费者区分不开。因此现在可以有2个监视器，1组监视生产者，1组监视消费者（以前这么实现需要生产者与消费者分别有个锁，因为一个锁上只有1个监视器）。因此生产者上唤醒消费者，消费者上唤醒生产者。因此可以不用使用signalAll来避免死锁，只要唤醒相应的线程即可。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E5%A4%A96.png" class title="This is an example image">

<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E5%A4%A97.png" class title="This is an example image">

<p>​    生产者如果不满足，则让生产者进行等待，生产者唤醒的时候要唤醒消费者的线程。即以前只有1个线程池，但是现在有2个监视器，具有不同的线程池。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC14%E5%A4%A98.png" class title="This is an example image">

<p>​    Lock接口：出现替代了同步代码块或者同步函数。将同步的隐式锁操作变成显示锁操作。同时更为灵活，可以一个锁上挂多个监视器。</p>
<p>lock()：获取锁</p>
<p>unlock()：释放锁，通常需要定义在finally代码块中。</p>
<p>​    Condition接口：出现替代了Object中的wait notify notifyAll方法。将这些监视器方法单独进行了封装，变成Condition监视器对象，可以任意锁进行组合。</p>
<p>await():相当于wait()</p>
<p>signal():相当于notify()</p>
<p>signal()All:相当于notify()All</p>
<p><strong>判断条件一定要用while()，因为安全</strong>。</p>
<p>​    使用流程：</p>
<ol>
<li><p>上锁；</p>
</li>
<li><p>try{运行代码，判断条件使用while，满足条件，await，不满足继续进行。然后signal相应监视器}</p>
</li>
<li><p>finally{ 开锁 }</p>
</li>
</ol>
<h4 id="wait与sleep的区别"><a href="#wait与sleep的区别" class="headerlink" title="wait与sleep的区别"></a>wait与sleep的区别</h4><ol>
<li><p>wait可以指定时间也可以不指定，sleep必须指定时间。</p>
</li>
<li><p>在同步中，对cpu的执行权和锁的处理不同。</p>
<p>wait():释放执行权，<strong>释放锁</strong>。</p>
<p>sleep():释放执行权，不释放锁。</p>
</li>
</ol>
<p>不释放执行权，那么电脑就卡死了。</p>
<p>​    在同步中有执行资格不一定能执行，持有相应的锁才能执行。同步中只有一个线程能够执行，但是同步中活着的线程不一定只有一个。</p>
<h4 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h4><ol>
<li><p>stop()方法，已过时</p>
</li>
<li><p>run()方法结束</p>
</li>
</ol>
<p>如何控制线程的任务结束</p>
<p>​    任务中都有循环结构，只要控制住循环，就可以结束任务。</p>
<p>​    控制循环通常用定义标记来完成。while(flag)，然后st.setFlag()来改变标识。但是如果线程在同步中wait()释放执行权与锁，这样便没办法去读标记。</p>
<p>​    线程处于冻结状态就无法读取标记，结束方法是：interrupt()方法，将线程从冻结状态强制恢复到运行状态中来，让线程具备CPU的执行资格，会抛出中断异常。强制执行会发生InterruptedException，记得要处理。   </p>
<p>线程中常见方法</p>
<p>setDaemon(boolean on)：将该线程标记为守护（后台）线程，当所有线程都是守护线程时，jvm退出运行，必须在    线程启动前设置。后台线程与前台线程只有结束时候不一样，前台线程要设置手动结束，后台线程只要所有前台线程结束，则后台线程自动结束。如果想让一个线程依赖于其他线程，则可以设置为后台线程。</p>
<p>join()，常用于临时加入一个线程运算时，先将此对象运行完，将调用此方法的线程冻结，只有在join的方法运行结束后才恢复。</p>
<p>setPriority(优先级1-10)，设置线程运行优先级，1最低，10最高，默认为5。</p>
<p>Thread(ThreadGroup group) 设置线程组</p>
<p>yield()暂停当前线程，执行其他线程。礼让 </p>
<p>线程与匿名内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x ,<span class="number">50</span>;x++)&#123;</span><br><span class="line">			System.out.println(<span class="string">"x="</span>+x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure>

<p>开启一个匿名的线程子类对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable r = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x ,<span class="number">50</span>;x++)&#123;</span><br><span class="line">			System.out.println(<span class="string">"z="</span>+x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Thread(r).start();</span><br></pre></td></tr></table></figure>

<p>新建一个匿名的Runnable子类对象，然后新建线程对象并调用start()方法。</p>
<h3 id="方法定义完整格式"><a href="#方法定义完整格式" class="headerlink" title="方法定义完整格式"></a>方法定义完整格式</h3><p>Java中方法定义的完整格式</p>
<p>访问权限{ public | default | protected | private }[final] [static] [ synchronized]</p>
<p>返回值类型 | void 方法名称{参数类型 参数名称,…}[throws Exception1, Exception2]{</p>
<p>​    [return [返回值|返回调用处]]</p>
<p>}</p>
<h2 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h2><p>从面对对象的思想转变为<strong>使用对象</strong></p>
<h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>​    字符串是一个特殊的对象，字符串一旦初始化就不可以被改变。</p>
<p>​    有字符串常量池，池中没有就建立，池中有，直接用。因为字符串对象不可改变，因此可以实现共享</p>
<p>字符串建立的方式</p>
<ol>
<li><p>String s = “abc”; 创建一个字符串对象在常量池中</p>
</li>
<li><p>String s = new String(“abc”); 创建两个对象一个new一个字符串对象在堆内存中被new对象维护</p>
</li>
</ol>
<p>String类中的equals覆写了Object中的equals建立了String类自己的判断字符串对象是否相同的依据，其实就是比较字符串内容。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC15%E5%A4%A91.png" class title="This is an example image">

<p>​    将字节数组变成字符串，把数字进行ASII码的对应。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC15%E5%A4%A92.png" class title="This is an example image">

<p>String的构造器，可以将数组变成字符串（byte[]与char[]）,传入数字变成对应的字符</p>
<ol>
<li><p>String(byte[] bytes)；String(byte[] bytes, int offset, int length);定义起始位置，长度</p>
</li>
<li><p>String(char[] value);   String(char[] value, int offset, int count)</p>
</li>
</ol>
<p>寻找方法的思路：思考返回类型和传入类型</p>
<p>按照面向对象的思想对字符串功能进行分类</p>
<h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><p>  1.1 获取字符串中字符的个数（长度）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>  1.2 根据位置获取字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br></pre></td></tr></table></figure>

<p>  1.3 根据字符获取在字符串中第一次出现的位置(重点)我们可以根据-1，来判断该字符或者字符串是否存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> 从指定位置进行ch的查找第一次出现位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span> 找字符串的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span></span></span><br></pre></td></tr></table></figure>

<p>​    根据字符获取在字符串中最后一次出现的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> 从指定位置进行ch的查找最后一次出现位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span> 找字符串的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span></span></span><br></pre></td></tr></table></figure>

<p>  1.4 获取字符串中一部分字符串，也叫子串。<strong>包括begin,不包括end</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> 子串开始于指定beginIndex并延伸到字符索引endIndex-1 </span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> 从指定位置到结束</span></span><br></pre></td></tr></table></figure>

<h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><p>  2.1 将字符串变成字符串数组(字符串的切割)按照指定规则切割</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] split(String regex) ,不能直接用.切割，要转义成\\.，涉及到正则表达式</span><br></pre></td></tr></table></figure>

<p>  2.2 将字符串转成字符数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] toCharArray()</span><br></pre></td></tr></table></figure>

<p>  2.3 将字符串转成字节数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] getBytes() 一个中文<span class="number">2</span>字节，ascii为美国的编码表，GB2312中文的编码表最大为<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>  2.4 将字符串中的字母转成大小写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">()</span> 大写</span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">()</span> 大写</span></span><br></pre></td></tr></table></figure>

<p>  2.5 将字符串中的内容进行替换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> 没替换成功，仍然返回原来的字符串</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(String s1,String s2)</span></span></span><br></pre></td></tr></table></figure>

<p>  2.6 将字符串两端的空格去除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>  2.7 将字符串进行连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><p>  3.1 两个字符串是否相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span> 忽略大小写比较字符串是否相同</span></span><br></pre></td></tr></table></figure>

<p>  3.2 字符串中是否包含指定字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span></span></span><br></pre></td></tr></table></figure>

<p>  3.3 字符串是否以指定字符串开头，是否以指定字符串结尾</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>​     int compareTo(String anotherString) 如果参数字符串等于此字符串，则返回值0；如果此字符串按字典顺序小于字符串参数，则返回一个小于0的值；如果此字符串按字典顺序大于字符串参数，则返回一个大于0的值。</p>
<p>​    String intern()当调用intern方法时，如果池已经包含与[equals(Object)](mk:@MSITStore:D:\java学习资料\jdk api 1.8_google.CHM::/java/lang/String.html#equals-java.lang.Object-)方法确定的相当于此String对象的字符串，则返回来自池的字符串。 否则，此String对象将添加到池中，并返回对此String对象的引用。 由此可见，对于任何两个字符串s和t ， s.intern() == t.intern()是true当且仅当s.equals(t)是true 。可以将堆中的数据存到字符串池中去。</p>
<h3 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h3><p>StringBuffer:就是字符串缓冲区，用于存储数据的容器</p>
<p>特点：</p>
<ol>
<li><p>长度是可变的</p>
</li>
<li><p>可以存储不同类型的数据</p>
</li>
<li><p>最终要转成字符串进行使用</p>
</li>
<li><p>可以对字符串进行修改</p>
</li>
</ol>
<p>既然是一个容器对象，应该具备的功能有 </p>
<ol>
<li><p>添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">StringBuffer <span class="title">append</span><span class="params">(data)</span></span>;可以继续在append后面继续添加</span><br><span class="line"><span class="function">StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, <span class="keyword">char</span> c)</span> 在指定位置进行添加</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span>：包含头，不包含尾</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">deleteCharAt</span><span class="params">(<span class="keyword">int</span> index)</span> ：删除指定位置的元素</span></span><br><span class="line"><span class="function">sb.<span class="title">delete</span><span class="params">(<span class="number">0</span>, sb.length()</span>)</span>;清空缓冲区</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">StringBuffer <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCharAt</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span> ch)</span> 不返回本类对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">int</span> newLength)</span> 设置长度</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>增删改查C(create)U(update)R(read)D(delete)</strong></p>
<p>可变长度数组原理，如果长度超出，则新建一个长度与原数组相同的数组，然后将两个数组长度相加，原有的数据复制。</p>
<h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><p>jdk1.5以后出现了功能和StringBuffer一模一样的对象，就是StringBuilder。</p>
<p>不同之处，</p>
<p>StringBuilder是线程同步的,通常用于多线程</p>
<p>StringBuffer是线程不同步的。通常用于单线程，它的出现提高效率</p>
<p>StringBuilder因为没有判断锁，因此单线程使用StringBuilder，如果多线程使用StringBuffer。如果操作全部是字符串，那么就用StringBuilder</p>
<h3 id="jdk升级原则"><a href="#jdk升级原则" class="headerlink" title="jdk升级原则"></a>jdk升级原则</h3><ol>
<li><p>简化书写（可能有弊端）</p>
</li>
<li><p>提高效率（可能有弊端）</p>
</li>
<li><p>提高安全性（书写麻烦）</p>
</li>
</ol>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>8种：byte,int,short,long,double,float,char,Boolean</p>
<p>将基本数据类型包装成类</p>
<p>​    用基本数值类型和字符串做转换</p>
<p>基本数据类型包装类</p>
<p>为了方便操作数据类型值，将其封装成了对象，在对象中定义了属性和行为，丰富了该数据的操作</p>
<p>  用于描述该对象的类就称为基本数据类型包装类</p>
<p>  byte    Byte</p>
<p>  short   Short</p>
<p>  int    Integer   静态方法parseInt(String s)</p>
<p>  long    Long</p>
<p>  float   Float</p>
<p>  double   Double</p>
<p>  char    Character</p>
<p>  boolean Boolean</p>
<p>  该包装对象主要用于基本类型和字符串之间的转换</p>
<h4 id="基本类型—-gt-字符串"><a href="#基本类型—-gt-字符串" class="headerlink" title="基本类型—&gt;字符串"></a>基本类型—&gt;字符串</h4><ol>
<li><p>基本数值类型+””</p>
</li>
<li><p>用String类中的静态方法valueOf(基本数值类型)</p>
</li>
<li><p>用Integer的静态方法toString(int i, int radix)</p>
</li>
</ol>
<h4 id="字符串—-gt-基本类型"><a href="#字符串—-gt-基本类型" class="headerlink" title="字符串—&gt;基本类型"></a>字符串—&gt;基本类型</h4><ol>
<li><p>使用包装类中的静态方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">xxx <span class="title">parseXxx</span><span class="params">(<span class="string">"xxx类型的字符串"</span>)</span></span>;***最常用</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(<span class="string">"intString"</span>)</span></span>;Integer.parseInt()</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">parseLong</span><span class="params">(<span class="string">"longString"</span>)</span></span>;Long.parseInt()</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">parseBoolean</span><span class="params">(<span class="string">"booleanString"</span>)</span></span>; Boolean.parseBoolean()</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果字符串被Integer进行对象的封装。可使用另一个非静态的方法：intValue()</p>
<p>将一个Integer对象转成基本数据类型值</p>
<p>Integer j = new Integer(“123”);</p>
<p>System.out.println(j.intValue());</p>
</li>
</ol>
<h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h4><ul>
<li>十进制–&gt;其他进制</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> String Integer.toBinaryString(<span class="keyword">int</span> i);<span class="comment">//2进制</span></span><br><span class="line"><span class="keyword">static</span> String Integer.toOctalString(<span class="keyword">int</span> i);<span class="comment">//8进制</span></span><br><span class="line"><span class="keyword">static</span> String Integer.toHexString(<span class="keyword">int</span> i);<span class="comment">//16进制</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> radix)</span> 任意进制</span></span><br></pre></td></tr></table></figure>

<ul>
<li>其他进制–&gt;十进制</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s, <span class="keyword">int</span> radix)</span></span></span><br></pre></td></tr></table></figure>

<p>Integer中比较的是数值是否相同。如果用equals方法就是返回boolean，如果用compareTo方法返回的是数值，可以知道哪个比较大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">i +</span>= <span class="number">6</span>;<span class="comment">//i = new Integer(i.intvalue()+6);//i.intvalue()自动拆箱</span></span><br></pre></td></tr></table></figure>

<p>而因为i为对象，因此i可能为null，如果空的调用intvalue()方法会出错，因此在自动拆箱的时候要进行健壮性判断。</p>
<h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><p>集合类的由来</p>
<p>​    对象用于封装特有数据，对象多了就需要存储，如果对象的个数不确定，</p>
<p>​    就使用集合容器进行存储</p>
<h4 id="集合特点："><a href="#集合特点：" class="headerlink" title="集合特点："></a>集合特点：</h4><ol>
<li><p>用于存储对象的容器</p>
</li>
<li><p>集合的长度是可变的</p>
</li>
<li><p>集合中不可以存储基本数据类型</p>
</li>
</ol>
<p>集合容器因为内部的数据结构不同，有多种具体容器。</p>
<p>不断向上抽取，就形成了集合框架</p>
<p>框架的顶层Collection接口：</p>
<h4 id="Collection的常见方法："><a href="#Collection的常见方法：" class="headerlink" title="Collection的常见方法："></a>Collection的常见方法：</h4><ol>
<li>添加</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object obj)</span></span>;添加一个对象</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection coll)</span></span>;添加一堆对象</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>删除</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>;删除一个对象，利用equals方法判断</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection coll)</span></span>;删除一堆对象，将两个集合中的相同元素从调用removeAll的集合中删除</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;将集合中的元素都删掉</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object obj)</span></span>;判断是否有此对象，利用equals方法判断</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection coll)</span></span>;判断是否有一堆对象</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;判断集合中是否有元素</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;获取长度</span><br><span class="line"><span class="function">Iterator <span class="title">iterator</span><span class="params">()</span></span>;取出元素的方式：迭代器</span><br></pre></td></tr></table></figure>

<p>  该对象必须依赖于具体的容器，因为每一个容器的数据结构都不同。</p>
<p>  所以该迭代器对象是在容器中进行内部实现的。</p>
<p>  对于使用容器者而言，具体的实现不重要，只要通过容器获取到该实现的迭代器对象即可，也就是iterator方法。</p>
<ol start="5">
<li>其他</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection coll)</span></span>;取交集，取交集，保留和指定集合相同的元素，而删除不同的元素。与removeAll相反</span><br><span class="line">Object[] toArray();将集合转成数组</span><br></pre></td></tr></table></figure>

<h4 id="集合判断元素依据"><a href="#集合判断元素依据" class="headerlink" title="集合判断元素依据"></a>集合判断元素依据</h4><p>对于ArrayList这样的集合，判断元素的方式是依据equals方法，而对于HashSet这样的集合，依靠的是equals和hashCode方法</p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>取出元素的两种方法</p>
<p>Collection coll = new ArrayList();</p>
<ol>
<li><p>使用while循环，结束后it占用内存空间，开发中不推荐</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator it = coll.iterator();</span><br><span class="line">	<span class="keyword">while</span>(it.hasNext())</span><br><span class="line">		System.out.println(it.next());</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用for循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator it = coll.iterator();it.hasNext();) &#123;</span><br><span class="line">	System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>iterator是一个内部类。类比于娃娃机的夹子，娃娃机是容器，夹子是迭代器，迭代器不能直接new，只能通过容器来操作夹子，但是统一的有移动和按钮。</p>
<p>集成框架的构成</p>
<h4 id="常见集合关系图"><a href="#常见集合关系图" class="headerlink" title="常见集合关系图"></a>常见集合关系图</h4><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC16%E5%A4%A91.png" class title="This is an example image">

<p>虚线框都是接口</p>
<p>Collection</p>
<pre><code>|--List: 有序，(存入和存出的数据一致)，元素都有索引(角标)，元素可以重复。</code></pre><p>​     |–Set: 元素不能重复，无序。</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List特有的常见方法:有一个共性特点就是都可以<strong>操作角标</strong></p>
<ol>
<li><p>添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(index,collection)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">remove</span><span class="params">(index)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">set</span><span class="params">(index,element)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object)</span></span>;</span><br><span class="line"><span class="function">List <span class="title">subList</span><span class="params">(from,to)</span></span>;包含头不包含尾</span><br></pre></td></tr></table></figure>

<p>List集合是可以完成对元素的增删改查</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一般集合的取出方式</span></span><br><span class="line">Iterator it = list.iterator();   </span><br><span class="line">	<span class="keyword">while</span>(it.hasNext())</span><br><span class="line">		System.out.println(it.next());</span><br><span class="line">	<span class="comment">//list特有的取出方式</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;list.size();x++)</span><br><span class="line">		System.out.println(<span class="string">"get:"</span>+list.get(x));</span><br></pre></td></tr></table></figure>

<p>当迭代器与集合同时操作元素，就会产生异常，这样是并发操作。</p>
<p>在迭代过程中不要使用集合操作元素，容易出现异常</p>
<p>可以使用Iterator接口的子接口ListIterator来完成迭代中对元素进行更多的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListIterator it = list.listIterator();<span class="comment">//获取列表迭代器对象</span></span><br><span class="line">		<span class="comment">//它可以实现在迭代过程中完成对元素的增删改查</span></span><br><span class="line">		<span class="comment">//注意：只有List集合具有该迭代功能。</span></span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			Object obj = it.next();</span><br><span class="line">			<span class="keyword">if</span>(obj.equals(<span class="string">"abc2"</span>))</span><br><span class="line">				it.set(<span class="string">"abc9"</span>);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>ListIterator listIterator()从头返回列表迭代器</p>
<p>ListIterator listIterator(int index)从指定位置返回列表迭代器</p>
<p>不仅有hasNext()和next()，还有hasPrevious()和previous()方法</p>
<p>List接口中比较常用的有：<strong>ArrayList</strong>，<strong>LinkList</strong>。</p>
<p>List</p>
<p>​    |–Vector:内部是数组数据结构，是同步的。效率低。增删、查询都很慢！</p>
<p>​    |–ArrayList:内部是数组数据接口，是不同步的。替代了Vector。查询的速度快。</p>
<p>​    |–LinkedList:内部是链表数据结构，是不同步的。增删元素的速度很快。</p>
<p>​    数组增删慢的原因是增加删除一个元素，该元素之后的内存空间均要发生变化，而查询快是因为内存空间是连续的。而链表存储是不连续的，而链表的增删只需要将此对象的地址存给上一个对象或者将此对象所存的下一个对象的地址存入上一个对象即可完成。查询慢是因为要遍历链表才能完成查询，而链表存储空间不是连续的（作为List的子类也有下标索引）。</p>
{% asset_img 第16天2.png This is an example image %}

<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(element)</span> 在链表的开头加入指定的元素</span></span><br><span class="line"><span class="function"><span class="title">getFirst</span><span class="params">()</span> <span class="comment">//获取第一个元素但不删除</span></span></span><br><span class="line"><span class="function"><span class="title">removeFirst</span><span class="params">()</span>)</span>;<span class="comment">//获取第一个元素并删除，remove()会改变长度</span></span><br></pre></td></tr></table></figure>

<h5 id="遍历链表的一种方式"><a href="#遍历链表的一种方式" class="headerlink" title="遍历链表的一种方式"></a>遍历链表的一种方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!link.isEmpty())&#123;<span class="comment">//判断是否为空，为空则为真</span></span><br><span class="line">			System.out.println(link.removeLast());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Linkedist常用方法与1-6改进"><a href="#Linkedist常用方法与1-6改进" class="headerlink" title="Linkedist常用方法与1.6改进"></a>Linkedist常用方法与1.6改进</h5><p>添加</p>
<p>​    addFirst();</p>
<p>​    addLast();</p>
<p><strong>jdk1.6</strong></p>
<p>​    offerFirst();</p>
<p>​    offerLast();</p>
<p>  获取</p>
<pre><code>getFirst();//获取但不移除。如果链表为空，抛出NoSuchElementException

getLast();</code></pre><p> <strong>jdk1.6</strong></p>
<p>​    peekFirst();//获取但不移除。如果链表为空，返回null</p>
<p>​    peekLast();</p>
<p>移除</p>
<p>​    removeFirst();//获取并移除。如果链表为空，抛出NoSuchElementException</p>
<p>​    removeLast();</p>
<p>  <strong>jdk1.6</strong></p>
<p>​    pollFirst();//获取并移除。如果链表为空，返回null</p>
<p>​    pollLast();</p>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>默认新建ArrayList对象的时候，开辟的空间为10。</p>
<p>((Person)it.next()).getName()+”::”+((Person) it.next()).getAge());</p>
<p>//不能直接调用Person的方法，因为此时被提升为了Object，父类中没有此方法,可以使用强制类型转换。如果不给it.next加括号， 那么因为.优先级太高而没有先完成强制转换。</p>
<p>如果在循环中多次调用it.next，那么会出错，因为next一直在往下走。 </p>
<p>  因此如果使用自定义对象，一直要使用强制类型转换，才能获取该对象的特有方法。直接打印it.next()，出现的是类名加哈希值，因为该对象没有覆写toString()方法。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC17%E5%A4%A91.png" class title="This is an example image">

<p>内存图解，集合中存储的均为堆内存对象的引用，迭代器取出元素，也是使用的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList al = <span class="keyword">new</span> ArrayList();</span><br><span class="line">al.add(<span class="number">5</span>);<span class="comment">//al.add(new Integer(5))</span></span><br><span class="line">add()方法不能接受基本数据类型，但是在jdk1<span class="number">.4</span>后可以使用自动装箱。</span><br></pre></td></tr></table></figure>

<p>  当基本数据类型赋值给引用数据类型的时候，会发生自动装箱。因为集合中需要添加对象，直接用数字相当于对5进行了Integer装箱。当引用数据类型与基本数据类型做运算，会发生自动拆箱。</p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><h4 id="枚举-1"><a href="#枚举-1" class="headerlink" title="枚举"></a>枚举</h4><p>使用element方法获取枚举。</p>
<p>Vector中有枚举接口Enumeration，功能与Iterator一样，但是Iterator名称更简单。</p>
<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p>Set:元素不可重复，是无序。</p>
<p>  Set接口中的方法和Collection一致。</p>
<p>|–<strong>HashSet</strong>:内部数据结构是哈希表，是不同步的。</p>
<ul>
<li><p>保证集合元素的唯一性</p>
</li>
<li><p>是通过对象的hashCode和equals方法来完成对象的唯一性的。</p>
</li>
<li><p>如果对象的hashCode值不同，那么不用判断equals方法，就直接存储到哈希表中。</p>
</li>
<li><p>如果对象的hashCode值相同，那么要再次判断对象的equals方法是否为true。</p>
</li>
<li><p>如果为true，视为相同元素，不存。如果 为false，视为不同元素，进行存储。</p>
<pre><code>  **记住：如果元素要存储到HashSet集合中，必须覆盖hashCode方法和equals方法**。

一般情况下，如果定义的类会产生很多对象，比如学生，人，书，通常都要覆盖equals，hashCode方法。

建立对象判断是否相同的依据。</code></pre></li>
</ul>
<p>|–<strong>TreeSet</strong>:可以对Set集合中的元素排序。是不同步的。</p>
<p>​        判断元素唯一性的方式:就是根据比较方法的返回结果是否为0，是0，就是相同元素，不存。</p>
<pre><code>TreeSet对元素进行排序的**方式一**:</code></pre><ul>
<li><p>让<strong>元素自身具备比较功能</strong>，元素就需要实现Comparable接口，覆盖compareTo方法。</p>
</li>
<li><p>如果不要按照对象中具备的自然顺序排序。如果对象中不具备自然顺序。怎么办？</p>
<p> TreeSet对元素进行排序的<strong>方式二</strong>:</p>
</li>
<li><p>让集合自身具备比较功能。定义一个类实现Comparator接口，覆盖compare方法。</p>
</li>
<li><p>将该类对象作为参数传递给TreeSet集合的构造函数。</p>
</li>
<li><p>比较器发开中更为常用，如果有比较器和类自己的compareTo方法，优先使用比较器。</p>
</li>
</ul>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>优化过的数组，根据存的元素的特点来获取其数组中的位置。查找的时候，根据这个元素再计算其对应的位置值，然后直接取出即可。算法为哈希算法。hashCode()为计算对象的哈希值，自定义对象可以覆盖方法。</p>
{% asset_img 第17天2.png This is an example image %}

<p>如自定义哈希算法，根据ab的特点算出一个值，再将值%数组长度，必定会得到数组长度之内的一个值，这样就可以获取到ab的位置。当要寻找ab的时候，再计算ab的哈希值，这样直接在相应的位置去寻找即可。</p>
<p>​    Set的获取只能使用迭代器。</p>
<p>​    哈希算法提高了数组的查询效率，但是不能重复。</p>
<h4 id="哈希表确定元素是否相同"><a href="#哈希表确定元素是否相同" class="headerlink" title="哈希表确定元素是否相同"></a>哈希表确定元素是否相同</h4><ol>
<li><p>判断的是两个元素的哈希值是否相同。如果相同，再判断两个对象的内容是否相同。</p>
</li>
<li><p>判断哈希值相同，其实判断的是对象的hashCode()方法。判断内容相同，用的是equals()方法。</p>
</li>
</ol>
<p>注意：如果哈希值不同，是不需要判断equals的。</p>
<p>哈希值一样，但是对象不一样，称之为哈希冲突。如果冲突则顺延或者串联。在相同位置挂一个出来。</p>
<p>当存入的是自定义对象时候，需要覆写hashCode方法和equals方法。如果是字符串则调用字符串的hashCode()，如果是数字，则乘上一个常数。进行比较的时候，首先判断位置是否相同，然后向下转型之前进行健壮性判断，然后比较对应的信息。为了便于输出信息，可以覆写对象的toString方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="keyword">this</span>+<span class="string">"......hashCode"</span>);</span><br><span class="line">	<span class="keyword">return</span> name.hashCode()+age*<span class="number">27</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>==obj)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Person))</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();<span class="comment">//健壮性判断</span></span><br><span class="line">	Person p = (Person)obj;<span class="comment">//向下转型	</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name.equals(p.name)&amp;&amp; <span class="keyword">this</span>.age==p.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哈希集合中判断元素是否相同的依据是hashCode方法和equals方法。</p>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p>哈希表和链表实现了Set接口，具有可预测的迭代次序。 这种实现不同于HashSet，它维持于所有条目的运行双向链表。 该链表定义了迭代排序，它是将元素插入集合（插入顺序 ） 的顺序 。</p>
<p>​    怎么样存就怎么取出来。</p>
<p>​    如果要<strong>唯一而且要有序</strong>，就用LinkedHashSet。</p>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>如果要存入自定义对象，需要此对象<strong>实现Comparable接口</strong>并<strong>覆盖compareTo方法</strong>。</p>
<h4 id="二叉树图解"><a href="#二叉树图解" class="headerlink" title="二叉树图解"></a>二叉树图解</h4>{% asset_img 第17天3.png This is an example image %}

<p>​    28进来不用比较，21进来比28小放在左边，29进来比28大放在右边。25比28小进左边，比21大生叉放在21右边，以此类推。</p>
<p>​    节点的特点：最多持有3个引用，左、右、父。二叉树为了提高效率，会在每次添加新元素时候进行二分查找。</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型:</p>
<p>  jdk1.5后出现的安全机制。</p>
<p>好处:</p>
<ol>
<li><p>将运行时期的问题ClassCastException转到了编译时期。</p>
</li>
<li><p>避免了强制转换的麻烦。</p>
</li>
</ol>
<p>&lt;&gt;:什么时候用？当操作的引用数据类型不确定的时候，就使用&lt;&gt;，将要操作的引用数据类型传入即可。</p>
<p>​     其实&lt;&gt;就是一个用于接收具体引用数据类型的参数范围。</p>
<p>在程序中，只要用到了带有&lt;&gt;的类或者接口，就要明确传入的具体引用数据类型。</p>
<p>泛型技术是给编译期使用的技术，用于编译时期。确保了类型的安全。</p>
<p>运行时，会将泛型去掉，生成的class文件中是不带泛型的，这个称为泛型的擦除。</p>
<p>擦除的原因：为了去兼容运行时的类加载器。</p>
<p>泛型的补偿:在运行时，通过获取元素的类型进行转换动作，不用使用者再强制</p>
<p>泛型中不能使用基本数据类型，只能传入引用数据类型。</p>
<p>Comparable接口上定义了泛型，指定进行比较的参数类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = <span class="keyword">this</span>.age - p.age;</span><br><span class="line">		<span class="keyword">return</span> temp==<span class="number">0</span>?<span class="keyword">this</span>.name.compareTo(p.name):temp;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>​    如果不指定，默认为Object，而且在compareTo方法中还要向下转型。</p>
<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>在jdk1.5后，使用泛型来接收类中要操作的引用数据类型。</p>
<p>泛型类，什么时候用？当类中的操作的引用数据类型不确定的时候，就使用泛型来表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tool</span>&lt;<span class="title">Q</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Q q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>&lt;W&gt; <span class="keyword">void</span> <span class="title">show</span><span class="params">(W str)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"show"</span>+str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将泛型定义在方法上，W为类型名称，待传入，而W要进行声明。</p>
<p>​    当方法静态时，不能访问类上定义的泛型，如果静态方法使用泛型，只能将<strong>泛型定义在方法上</strong>。</p>
<p>泛型一定要放在<strong>返回值的前面</strong>，<strong>修饰符的后面</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;Y&gt;<span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(Y obj)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"method"</span>+obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用泛型，则有些对象才有的方法则不能使用，但是部分方法可以使用，即Object中的方法必定可以使用</p>
<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>实现一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterImp</span> <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InterImp in = <span class="keyword">new</span> InterImp();</span><br><span class="line">in.show(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>

<p>实现二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterImp2</span>&lt;<span class="title">Q</span>&gt; <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">Q</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Q q)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"show"</span>+q);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InterImp2&lt;Integer&gt; in2 = <span class="keyword">new</span> InterImp2&lt;Integer&gt;();</span><br><span class="line">in2.show(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><p>泛型的通配符:?未知类型。</p>
<p>当不能明确传入泛型的类型时候使用。仅在类型不明确并不对这类型操作来表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCollection</span><span class="params">(Collection&lt;?&gt; al)</span> </span>&#123;</span><br><span class="line">		Iterator&lt;?&gt; it = al.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			System.out.println(it.next());</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;Q&gt;<span class="function"><span class="keyword">void</span> <span class="title">printCollection</span><span class="params">(Collection&lt;Q&gt; al)</span> </span>&#123;</span><br><span class="line">		Iterator&lt;Q&gt; it = al.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			System.out.println(it.next());</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是比较麻烦 </p>
<h4 id="泛型限定"><a href="#泛型限定" class="headerlink" title="泛型限定"></a>泛型限定</h4><p>只能有一部分类型能进来</p>
<p>可以对类型进行限定</p>
<p>? <strong>extends</strong> E:接收E类型或者E的子类型对象。上限！    </p>
<p>? <strong>super</strong> E:接收E类型或者E的父类型，下限！</p>
<p>迭代器的泛型和获取迭代器集合的泛型一致。</p>
<p><strong>泛型上限</strong>：</p>
<p>如果有不同的集合，分别创建Person类的子类，一个方法要接收Person类子类的集合，不能直接接收Collection<Person>，因为Person为一具体类型。</Person></p>
<p>  一般两边泛型类型要一致。这样要如果限定只能接收某一对象的子类，可以使用</p>
<p><strong>&lt;? extends Person&gt;</strong>，即只接收Person或者Person的子类。这样<strong>可以直接新建Person类对象</strong>。</p>
<p><strong>泛型下限</strong>:</p>
<p>使用&lt;? super Student&gt;，只能接收学生类及其父类</p>
<p>addAll(Collection&lt;? extends E&gt; e)原因，可以接收该集合类型及子类类型，提高了拓展性和安全性。一般只要写了E就可以接收该类的集合对象，但是为了能接收其子类对象，增加了泛型的上限。</p>
<p><strong>使用情况：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">addAll(Collection&lt;? extends E&gt; e)</span><br><span class="line">		ArrayList&lt;Person&gt; al1 = <span class="keyword">new</span> ArrayList&lt;Person&gt;();		</span><br><span class="line">		ArrayList&lt;Student&gt; al2 = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line">		al1.addAll(al2);</span><br></pre></td></tr></table></figure>

<p>一般存储元素的时候都使用上限，因为这样取出都是按照上限类型来运算的，不会出现类型安全隐患。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span><br><span class="line">		TreeSet&lt;Person&gt; al1 = <span class="keyword">new</span> TreeSet&lt;Person&gt;(<span class="keyword">new</span> CompByName());</span><br><span class="line">		TreeSet&lt;Student&gt; al2 = <span class="keyword">new</span> TreeSet&lt;Student&gt;(<span class="keyword">new</span> CompByName());</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompByName</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = o1.getName().compareTo(o2.getName());</span><br><span class="line">		<span class="keyword">return</span> temp==<span class="number">0</span>?o1.getAge()-o2.getAge():temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>学生的集合中，比较器可以用学生的也可以用父类的，因为其使用的方法源于父类。</p>
<p>  通常<strong>对集合中的元素取出操作</strong>时，可以使用下限。存什么类型，我可以用其类型和父类类型来进行接收。</p>
<p>包含containsAll(Collection&lt;?&gt;coll)为什么用？</p>
<p>  因为Collection的原理为equals，任何对象都具有其方法，因此接收的集合类型可以是任意类型，因此用?来进行接收。只要全部使用Object方法，因此就可以使用?。</p>
<h3 id="集合框架查询技巧"><a href="#集合框架查询技巧" class="headerlink" title="集合框架查询技巧"></a>集合框架查询技巧</h3><p>需要唯一吗？</p>
<p>需要：Set</p>
<p>​    需要指定顺序吗？</p>
<p>​           需要：TreeSet</p>
<p>​           不需要：HashSet</p>
<p>​           但是想要一个和存储一致的顺序（有序）：LinkedHashSet</p>
<p>不需要：List</p>
<p>​    需要频繁增删吗？</p>
<p>​           需要：LinkedList</p>
<p>​           不需要：ArrayList</p>
<p>如何记住每一个容器的结构和所属体系呢？</p>
<p>看名字！</p>
<p>List:</p>
<p>​        |–ArrayList</p>
<p>​        |–LinkedList</p>
<p>Set:</p>
<p>​        |–HashSet</p>
<p>​        |–TreeSet</p>
<p>后缀名就是该集合所属的体系。</p>
<p>前缀名就是该集合的数据结构。</p>
<p>看到arrays：就要想到数组，就要想到查询快，有角标。</p>
<p>看到link：就要想到链表，就要想到增删快，就要想到add get remove+first  last的方法</p>
<p>看到hash：就要想到哈希表，就要想到唯一性，就要想到元素需要覆盖hashCode方法和equals方法。</p>
<p>看到tree：就要想到二叉树，就要想到排序，就要想到两个 接口Comparable，Comparator（比较器）</p>
<p>而且这些通常这些常用的集合容器都是不同步的。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map:一次添加一对元素。Collection:一次添加一个元素。</p>
<p>Map也称为双列集合，Collection称为单列集合。</p>
<p>其实Map集合中存储的是键值对。Map集合中必须保证键的唯一性。</p>
<p>常用方法:</p>
<ol>
<li><p>添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">value <span class="title">put</span><span class="params">(key,value)</span></span>;返回前一个和key关联的值，如果没有返回<span class="keyword">null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;清空map集合</span><br><span class="line"><span class="function">value <span class="title">remove</span><span class="params">(key)</span></span>;根据指定的key删除这个键值对</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">value <span class="title">get</span><span class="params">(key)</span></span>;通过键获取值，如果没有该键，返回<span class="keyword">null</span>。</span><br><span class="line">				当然可以通过返回<span class="keyword">null</span>,来判断是否包含指定键。</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;获取键值对的个数。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="取出Map中所有元素"><a href="#取出Map中所有元素" class="headerlink" title="取出Map中所有元素"></a>取出Map中所有元素</h4><p>方式一：取出丈夫，再取出妻子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line"><span class="comment">//取出Map中的所有元素</span></span><br><span class="line"><span class="comment">//原理，通过keySet方法获取map中所有的键所在的Set集合，再通过Set的迭代器获取到每一个键。</span></span><br><span class="line"><span class="comment">//再对每一个键获取其对应的值即可。</span></span><br><span class="line">Set&lt;Integer&gt; keySet = map.keySet();</span><br><span class="line">Iterator&lt;Integer&gt; it = keySet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	Integer key = it.next();</span><br><span class="line">	String value = map.get(key);</span><br><span class="line">	System.out.println(key+<span class="string">":"</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

{% asset_img 第18天1.png This is an example image %}

<p>首先利用keySet()方法将Map中的键映射到Set集合中，然后通过迭代器可以得到每一个键key，再利用Map的get(key)方法得到每一个键对应的值。</p>
<p>其中被注释的两句相当于下面一句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//		Set&lt;Student&gt; keyset = hm.keySet();</span></span><br><span class="line"><span class="comment">//		Iterator&lt;Student&gt; it = keyset.iterator();</span></span><br><span class="line">		Iterator&lt;Student&gt; it = hm.keySet().iterator();</span><br></pre></td></tr></table></figure>

<p>方式二：得到结婚证书</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 通过Map转成Set就可以迭代，找到了另一个方法	entrySet.</span></span><br><span class="line"><span class="comment">		 * 该方法将键和值的映射关系作为对象存储到了Set集合中，而这个映射关系的类型就是Map.Entry类型(结婚证)</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">		Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = entrySet.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			Map.Entry&lt;Integer, String&gt; me = it.next();</span><br><span class="line">			Integer key = me.getKey();</span><br><span class="line">			String value = me.getValue();</span><br><span class="line">			System.out.println(key+<span class="string">":"</span>+value);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>​    通过entrySet()方法将键值的映射投射到Set集合中，其中将键和值封装成一个对象。</p>
{% asset_img 第18天2.png This is an example image %}

<p>其中上面两句相当于下面一句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//		Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entrySet = map.entrySet();</span></span><br><span class="line"><span class="comment">//		Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = entrySet.iterator();</span></span><br><span class="line">	Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = map.entrySet().iterator();</span><br></pre></td></tr></table></figure>

<p>只获取value值</p>
<p>Collection values();返回value所有值的Collection集合</p>
<h3 id="Map常用的子类"><a href="#Map常用的子类" class="headerlink" title="Map常用的子类"></a>Map常用的子类</h3><p>​    |–Hashtable:内部结构是哈希表，是同步的。不允许null作为键，不允许null作为值。</p>
<p>​    |–Properties:用来存储键值对型的配置文件的信息。可以和IO技术相结合。</p>
<p>​    |–HashMap:内部结构是哈希表，不是同步的。允许null作为键，允许null作为值。</p>
<p>​    |–TreeMap:内部结构是二叉树，不是同步的。可以对Map集合中的键进行排序。 </p>
<p>HashSet是HashMap的一个实例。</p>
<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>​    可以将存储的元素有序输出，即存入什么顺序，取出什么顺序。</p>
<h4 id="Map应用"><a href="#Map应用" class="headerlink" title="Map应用"></a>Map应用</h4><p>  Map集合在有映射关系时可以优先考虑</p>
<p>​    键值关系多，往Map里面存储，不一定需要有序编号，只是建立对象间的关系。</p>
<p>​    Map中的值也可以是集合，如List,Set</p>
<p>​    在查表法中的应用较为多见</p>
<h3 id="集合框架工具类"><a href="#集合框架工具类" class="headerlink" title="集合框架工具类"></a>集合框架工具类</h3><h4 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a>Collections类</h4><p>Collections:是集合框架的工具类，里面的方法都是静态的，<strong>操作集合</strong>。</p>
<p>1、 排序</p>
<p>自然顺序排序</p>
<p>Collections sort(List) </p>
<p>​    如果只对一种类型进行排序，那么就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mySort</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size()-<span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; list.size(); j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(list.get(i).compareTo(list.get(j))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">					String temp = list.get(i);</span><br><span class="line">					list.set(i, list.get(j));</span><br><span class="line">					list.set(j,temp);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>如果想对任意类型的集合进行排序，那么需要使用泛型，可以使用&lt;?&gt;或<T>，但是要对泛型的类型进行限制，因此变成</T></p>
<p>  <strong>public</strong> <strong>static</strong> <T><strong>void</strong> mySort(List<T> list)</T></T></p>
<p>  但是排序中用到了compareTo方法，只有实现了此接口才具有，因此对T进行限定，必须是Comparable接口的子类，则变成</p>
<p><strong>public</strong> <strong>static</strong> &lt;T <strong>extends</strong> Comparable<T>&gt; <strong>void</strong> mySort(List<T> list)</T></T></p>
<p>  而Comparable也要指出泛型的类型，可以使用T。为了提高拓展性，为了可以让T的父类也能接收T，因此Comparable的泛型使用&lt;? super T&gt;，即可以使用T或者T的父类进行接收，因此最终变成</p>
<p><strong>public</strong> <strong>static</strong> &lt;T <strong>extends</strong> Comparable&lt;? <strong>super</strong> T&gt;&gt; <strong>void</strong> mySort(List<T> list)</T></p>
<p>  指定顺序排序</p>
<p><strong>static</strong> <T> <strong>void</strong> sort(List<T> list, Comparator&lt;? <strong>super</strong> T&gt; c) </T></T></p>
<p>  可以使用自定期的比较器进行排序，泛型使用&lt;? super T&gt;是为了让子类能使用父类的比较器，因为可以用父类对象来接收子类。</p>
<p>  <strong>static</strong> <T> <strong>void</strong> sort(List<T> list, Comparator&lt;? <strong>super</strong> T&gt; c) </T></T></p>
<p>  sort还可以利用比较器进行排序。原理是增加一个比较器，然后比较的方法使用比较器中的compare方法，获取元素利用List集合中的get()方法。这时候就不要求List具备比较方法，为了可以用父类对象接收被比较元素，使用&lt;? super T&gt;。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  &lt;T&gt;<span class="function"><span class="keyword">void</span> <span class="title">mySort</span><span class="params">(List&lt;T&gt; list,Comparator&lt;? <span class="keyword">super</span> T&gt; comp)</span></span>&#123;<span class="comment">//不需要list具备比较功能 </span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size()-<span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; list.size(); j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(comp.compare(list.get(i), list.get(j))&gt;<span class="number">0</span>)&#123;<span class="comment">//调用比较器的compare方法，返回一个int值</span></span><br><span class="line">					Collections.swap(list, i, j);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>1.1交换顺序</p>
<p><strong>static</strong> <strong>void</strong> swap(List&lt;?&gt; list, <strong>int</strong> i, <strong>int</strong> j) </p>
<p>1.2折半查找</p>
<p>需要先对元素进行自然排序或者比较器排序后才能使用</p>
<p><strong>static</strong> <T> <strong>int</strong> binarySearch(List&lt;? <strong>extends</strong> Comparable&lt;? <strong>super</strong> T&gt;&gt; list, T key) </T></p>
<p> 如果返回-2，负数表示没有找到，-2为-1减去1，意思是如果插入进去要在角标1处插入元素。减一的目的是避免插入点为0时候不知道是没有找到还是这个点在角标为0的地方。</p>
<p> 可以按照比较器排序然后索引。</p>
<p><strong>public</strong> <strong>static</strong> <T> <strong>int</strong> binarySearch(List&lt;? <strong>extends</strong> T&gt; list,T key,</T></p>
<p>​    Comparator&lt;? <strong>super</strong> T&gt; c)  </p>
<p>2、 求最大值</p>
<p><strong>static</strong> &lt;T <strong>extends</strong> Object &amp; Comparable&lt;? <strong>super</strong> T&gt;&gt; T max(Collection&lt;? <strong>extends</strong> T&gt; coll)</p>
<p>也可以使用比较器进行取最大值。</p>
<p><strong>static</strong> <T> T max(Collection&lt;? <strong>extends</strong> T&gt; coll, Comparator&lt;? <strong>super</strong> T&gt; comp) </T></p>
<p>3、 比较器反向</p>
<p>如果要将一个集合中的元素反向输出，使用TreeSet实现，要加载比较器重新实现，原理如下，其实就是将o1,o2进行互换。</p>
<p>​    TreeSet<String> ts = <strong>new</strong> TreeSet<String>(<strong>new</strong> Comparator<String>() {</String></String></String></p>
<p>​      //匿名内部类</p>
<p>​      @Override</p>
<p>​      <strong>public</strong> <strong>int</strong> compare(String o1, String o2) {</p>
<p>​       <strong>int</strong> temp = o2.compareTo(o1);</p>
<p>​       <strong>return</strong> temp;</p>
<p>​      }</p>
<p>​    });</p>
<p>这样就可以实现反向输出，但是比较麻烦</p>
<p>  <strong>static</strong> <T> Comparator<T> reverseOrder() </T></T></p>
<p>  <strong>static</strong> <T> Comparator<T> reverseOrder(Comparator<T> cmp) //将已有的比较器进行逆转 </T></T></T></p>
<p>实际演示：</p>
<p>TreeSet<String> ts = <strong>new</strong> TreeSet<String>(Collections.<em>reverseOrder</em>());</String></String></p>
<p>  如果自己有比较器，就将比较器输入进去</p>
<p>TreeSet<String> ts = <strong>new</strong> TreeSet<String>(Collections.<em>reverseOrder</em>(<strong>new</strong> ComparatorByLength()));</String></String></p>
<p>反转集合中的元素</p>
<p>  <strong>static</strong> <strong>void</strong> reverse(List&lt;?&gt; list) </p>
<p>4、 初始化集合</p>
<p>用指定元素替代集合中所有元素。</p>
<p> <strong>static</strong> <T> <strong>void</strong> fill(List&lt;? <strong>super</strong> T&gt; list, T obj) </T></p>
<p>5、 随机集合元素</p>
<p>使用默认的随机源随机排列指定的列表</p>
<p> <strong>static</strong> <strong>void</strong> shuffle(List&lt;?&gt; list) </p>
<p>使用指定的随机源随机排列指定的列表</p>
<p><strong>static</strong> <strong>void</strong> shuffle(List&lt;?&gt; list, Random rnd) </p>
<p>就是扑克牌的洗牌。或者掷骰子，只取第一个即可。</p>
<p>6、 枚举的转换</p>
<p>返回指定集合的枚举</p>
<p><strong>static</strong> <T> Enumeration<T> enumeration(Collection<T> c) </T></T></T></p>
<p>返回一个数组列表，其中包含由枚举返回的顺序由指定的枚举返回的元素。</p>
<p><strong>static</strong> <T> ArrayList<T> list(Enumeration<T> e) </T></T></T></p>
<p>7、 <strong>同步！！！！重点</strong></p>
<p>如果要在多线程中使用集合，则自己在集合中加锁，Collections工具类中提供有synchronizedxxx方法，如：</p>
<p><strong>static</strong> <T> Collection<T> synchronizedCollection(Collection<T> c) </T></T></T></p>
<p>返回由指定集合支持的同步（线程安全）集合。 </p>
<p><strong>static</strong> <T> List<T> synchronizedList(List<T> list) </T></T></T></p>
<p>返回由指定列表支持的同步（线程安全）列表。 </p>
<p><strong>static</strong> &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) </p>
<p>返回由指定地图支持的同步（线程安全）映射。</p>
<p>具体的实现原理为</p>
<p>给非同步的集合加锁</p>
<p>List list = new ArrayList();//非同步的</p>
<p>list = MyCollections.synList(list);//返回一个同步的List</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCollections</span></span>&#123;<span class="comment">//将非同步集合变为同步集合</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title">synList</span><span class="params">(List list)</span></span>&#123;<span class="comment">//静态方法</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyList(list);<span class="comment">//多态</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span> <span class="keyword">implements</span> <span class="title">List</span></span>&#123;<span class="comment">//私有内部类，实现List接口</span></span><br><span class="line">	<span class="comment">//目的是实现以后MyList就是List的一个子类，将所有的方法进行覆盖，使得可以同步。具体实现还是调用其具体的方式，只是加锁而已。</span></span><br><span class="line">	<span class="comment">//然后返回自定义的加锁后的集合</span></span><br><span class="line">	<span class="keyword">private</span> List list;<span class="comment">//持有要操作的集合引用</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">	MyList(List list)&#123;<span class="comment">//构造器传入要操作的集合引用</span></span><br><span class="line">		<span class="keyword">this</span>.list = list;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">			<span class="keyword">return</span> list.add(obj);<span class="comment">//具体方法还是调用操作集合自身的方法，只是加锁而已！！！</span></span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">			<span class="keyword">return</span> list.remove(obj);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只是加锁，只是加锁，只是加锁，具体实现方式还是调用其自身的方式。</p>
<p>8、 转数组</p>
<p>集合转成数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用的就是Collection接口中的toArray()方法</span><br><span class="line">	集合转成数组可以对集合中的元素操作的方法进行限定。不允许对其进行增删。</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * toArray方法需要传入一个指定类型的数组。</span></span><br><span class="line"><span class="comment">		 * 长度该如何定义呢？</span></span><br><span class="line"><span class="comment">		 * 如果长度小于集合的size，那么该方法会创建一个同类型并和集合相同size的数组</span></span><br><span class="line"><span class="comment">		 * 如果长度大于集合的size，那么该方法就会使用指定的数组，存储集合中的元素，其他位置默认为null。</span></span><br><span class="line"><span class="comment">		 * 所以建议，最后长度就定为，集合的size。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		String[] arr = list.toArray(<span class="keyword">new</span> String[list.size()]);</span><br><span class="line">		System.out.println(Arrays.toString(arr));<span class="comment">//数组打印调用toString方法</span></span><br></pre></td></tr></table></figure>

<h4 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h4><p>操作数组的工具类</p>
<p>Arrays:集合框架的工具类。里面的方法都是静态的。</p>
<p>1、 二分查找</p>
<p><strong>static</strong> <strong>int</strong> binarySearch(<strong>byte</strong>[] a, <strong>byte</strong> key) </p>
<p><strong>static</strong> <strong>int</strong> binarySearch(<strong>byte</strong>[] a, <strong>int</strong> fromIndex, <strong>int</strong> toIndex, <strong>byte</strong> key)</p>
<p>基本数据类型数组大多都能二分查找，除了boolean</p>
<p>2、 复制</p>
<p>复制全部长度的数组</p>
<p><strong>static</strong> <strong>boolean</strong>[] copyOf(<strong>boolean</strong>[] original, <strong>int</strong> newLength) </p>
<p>复制指定范围的数组</p>
<p><strong>static</strong> <strong>boolean</strong>[] copyOfRange(<strong>boolean</strong>[] original, <strong>int</strong> from, <strong>int</strong> to) </p>
<p>8种基本数据类型数组都能复制 </p>
<p>3、 比较</p>
<p>比较两个数组彼此是否相同，需要传入两个参数，不是Object中的比较。如果两个数组都包含相同数量的元素，则两个数组被认为是相等的，并且两个数组中所有对应的元素对都相等。 换句话说，如果两个数组以相同的顺序包含相同的元素，则它们是相等的。 另外，如果两者都是null ，则两个数组引用被认为是相等的 。</p>
<p> <strong>static</strong> <strong>boolean</strong> equals(<strong>char</strong>[] a, <strong>char</strong>[] a2) </p>
<p>深度比较，不仅比较数组中的对象，还比较对象中的内容</p>
<p>  <strong>static</strong> <strong>boolean</strong> deepEquals(Object[] a1, Object[] a2) </p>
<p>4、 替换</p>
<p>将数组中的全部元素替换为指定元素</p>
<p> <strong>static</strong> <strong>void</strong> fill(<strong>char</strong>[] a, <strong>char</strong> val) </p>
<p>将数组中指定范围的元素替换为指定元素</p>
<p> <strong>static</strong> <strong>void</strong> fill(<strong>char</strong>[] a, <strong>int</strong> fromIndex, <strong>int</strong> toIndex, <strong>char</strong> val) </p>
<p>5、 排序</p>
<p> <strong>static</strong> <strong>void</strong> sort(<strong>char</strong>[] a) </p>
<p>对指定范围的数组进行排序</p>
<p><strong>static</strong> <strong>void</strong> sort(<strong>char</strong>[] a, <strong>int</strong> fromIndex, <strong>int</strong> toIndex)</p>
<p>  对对象进行自然顺序的排序</p>
<p> <strong>static</strong> <strong>void</strong> sort(Object[] a)  </p>
<p>  对泛型数组进行排序</p>
<p> <strong>static</strong> <T> <strong>void</strong> sort(T[] a, Comparator&lt;? <strong>super</strong> T&gt; c)</T></p>
<p>6、 toString</p>
<p>  返回指定数组的字符串表现形式，如果想直接输出字符串，就调用toString</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">char</span>[] a)</span>   </span></span><br><span class="line"><span class="function">	<span class="comment">//toString的经典实现</span></span></span><br><span class="line"><span class="function">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myToString</span><span class="params">(<span class="keyword">int</span>[]a)</span></span>&#123;</span><br><span class="line">		<span class="comment">//健壮性判断</span></span><br><span class="line">		<span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">        <span class="keyword">int</span> iMax = a.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (iMax == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line">        <span class="comment">//利用StringBuilder来增加字符串</span></span><br><span class="line">        StringBuilder b = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        b.append(<span class="string">'['</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;<span class="comment">//中间省略了条件判断，提高了效率</span></span><br><span class="line">            b.append(a[i]);</span><br><span class="line">            <span class="comment">//只要一到末尾，就添加反括号结束</span></span><br><span class="line">            <span class="keyword">if</span> (i == iMax)</span><br><span class="line">                <span class="keyword">return</span> b.append(<span class="string">']'</span>).toString();</span><br><span class="line">            b.append(<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>7、 转成集合</p>
<p>将数组转成List集合</p>
<p>该方法作为基于数组和基于集合的API之间的桥梁，与Collection.toArray()相[结合](mk:@MSITStore:D:\java学习资料\jdk api 1.8_google.CHM::/java/util/Collection.html#toArray–) 。</p>
<p><strong>public</strong> <strong>static</strong> <T> List<T> asList(T… a)</T></T></p>
<p>重点:List asList(数组)将数组转成集合。</p>
<p>好处：可以使用集合的方法操作数组的元素。</p>
<p>注意：数组的长度是固定的，所以 对于集合的增删方法是不可以使用的。如add,remove,clear。否则会发生UnsupportedOperationException</p>
<p>可以使用contains,indexOf,indexOfLast,set等方法，只要不改变数组的长度即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如果数组中的元素是对象，那么转成集合时，直接将数组中的元素作为集合中的元素进行集合存储。</span></span><br><span class="line"><span class="comment">* 如果数组中的元素是基本数据类型，那么会将该数组作为集合中的元素进行存储。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">31</span>,<span class="number">11</span>,<span class="number">51</span>,<span class="number">61</span>&#125;;</span><br><span class="line">		List&lt;<span class="keyword">int</span>[]&gt; list = Arrays.asList(arr);</span><br><span class="line">	存储的是一个数组，因此list.size()=<span class="number">1</span>。如果想要将数组中的元素存进去，写：</span><br><span class="line">		Integer[] arr2 = &#123;<span class="number">31</span>,<span class="number">11</span>,<span class="number">51</span>,<span class="number">61</span>&#125;;</span><br><span class="line">		List&lt;Integer&gt; list2 = Arrays.asList(arr2);</span><br></pre></td></tr></table></figure>

<h3 id="jdk1-5新特性"><a href="#jdk1-5新特性" class="headerlink" title="jdk1.5新特性"></a>jdk1.5新特性</h3><h4 id="foreach语句"><a href="#foreach语句" class="headerlink" title="foreach语句"></a>foreach语句</h4><p>简化书写，底层利用的迭代器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * foreach语句：</span></span><br><span class="line"><span class="comment"> * 格式</span></span><br><span class="line"><span class="comment"> * for(类型 变量 : Collection集合|数组)</span></span><br><span class="line"><span class="comment"> * &#123;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//迭代器可以对元素迭代时候进行操作</span></span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 只用于遍历或迭代</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span>(String s : list)&#123; <span class="comment">//简化书写</span></span><br><span class="line">	System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i: arr)&#123;</span><br><span class="line">	System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历Map集合，要将map转成单列的Set</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以使用高级for遍历map集合吗？不能直接用，但是可以将map转成单列的set，就可以用了。</span></span><br><span class="line">		Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,String&gt;();</span><br><span class="line">		<span class="keyword">for</span>(Integer key : map.keySet())&#123;</span><br><span class="line">			String value = map.get(key);</span><br><span class="line">			System.out.println(key+<span class="string">"::"</span>+value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(Map.Entry&lt;Integer, String&gt; me : map.entrySet())&#123;</span><br><span class="line">			Integer key = me.getKey();</span><br><span class="line">			String value = me.getValue();</span><br><span class="line">			System.out.println(key+<span class="string">"::"</span>+value);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 函数的可变参数</span></span><br><span class="line"><span class="comment">	 * 其实就是一个数组，但是接受的是数组的元素。</span></span><br><span class="line"><span class="comment">	 * 自动将这些元素封装成数组，简化了调用者的书写。	</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 注意：可变参数类型必须定义在参数列表的结尾处。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">newAdd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span>... arr)</span></span></span><br></pre></td></tr></table></figure>

<p>如果使用普通的数组接收，流程为先创建数组，然后将数组传入要调用的方法，即</p>
<p>​    <strong>int</strong>[] arr = {1,4,2,1};</p>
<p>​    <strong>int</strong> sum3 = <em>add</em>(arr);</p>
<p>而如果使用可变参数，则变成</p>
<p>​    <strong>int</strong> sum4 = <em>newAdd</em>(5,1,3,2,1);</p>
<p>简化了书写，但是可变参数不能放在第一个（有两个以上变量时），而数组可以。</p>
<h4 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h4><p><strong>import</strong> <strong>static</strong> java.util.Collections.<em>sort</em>;//静态导入，其实导入的是类中的静态成员</p>
<p>以前要写Collections.sort();</p>
<p>现在写sort();</p>
<hr>
<h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><p>​    不能被实例化，方法通常为静态的。</p>
<p>out：“标准”输出流</p>
<p>in：“标准”输入流</p>
<p>1、 获取系统时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> l1 = <span class="number">1549696253272l</span>;</span><br><span class="line">System.out.println(l1/<span class="number">1000</span>/<span class="number">60</span>/<span class="number">60</span>/<span class="number">24</span>);<span class="comment">//换算成天</span></span><br><span class="line"><span class="keyword">long</span> l2 = System.currentTimeMillis();</span><br><span class="line">System.out.println(l2-l1);<span class="comment">//计算时间差</span></span><br></pre></td></tr></table></figure>

<p>2、 获取系统信息</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取系统的属性信息，并存储到Properties集合中，键和值都是字符串类型</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * properties集合中存储的都是String类型的键和值。</span></span><br><span class="line"><span class="comment">		 * 最好使用它自己的存储和取出的方法来完成元素的操作。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Properties prop = System.getProperties();<span class="comment">//获取所有的键值对信息，返回Properties对象</span></span><br><span class="line">		Set&lt;String&gt; nameSet = prop.stringPropertyNames();<span class="comment">//返回一组键的集合</span></span><br><span class="line">		<span class="keyword">for</span>(String name : nameSet)&#123;</span><br><span class="line">			String value = prop.getProperty(name);<span class="comment">//由键获取值</span></span><br><span class="line">			System.out.println(name+<span class="string">"::"</span>+value);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h4 id="跨平台使用技巧"><a href="#跨平台使用技巧" class="headerlink" title="跨平台使用技巧"></a>跨平台使用技巧</h4><p>不同平台一些符号不一样，在jvm加载的时候会获取系统信息，因此可以将这些不同平台的符号定义为一个全局常量，然后根据系统信息获取</p>
<p>  //获取换行符号</p>
<p><strong>private</strong> <strong>static</strong> <strong>final</strong> String <strong>LINE_SEPERATOR</strong> = System.<em>getProperty</em>(“line.separator”);</p>
<p>也可以自己给系统设置属性信息。</p>
<h3 id="Runtime类（单例设计）"><a href="#Runtime类（单例设计）" class="headerlink" title="Runtime类（单例设计）"></a>Runtime类（单例设计）</h3><p>​    应用程序不能创建自己的Runtime类实例，可以 通过getRuntime()方法获取当前运行时。单例设计的模式。</p>
<h4 id="开启一个程序进程"><a href="#开启一个程序进程" class="headerlink" title="开启一个程序进程"></a>开启一个程序进程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Runtime:没有构造方法摘要，说明该类不可以创建对象。</span></span><br><span class="line"><span class="comment">		 * 又发现还有非静态的方法，说明该类应该提供静态的返回该类对象的方法。</span></span><br><span class="line"><span class="comment">		 * 而且只有一个，说明Runtime类使用了单例设计模式。 </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Runtime r = Runtime.getRuntime();</span><br><span class="line">		<span class="comment">//execute:执行。xxx.exe</span></span><br><span class="line">		<span class="comment">//可以调用本地程序去执行空格后面的文件，需要格式对应</span></span><br><span class="line">		Process p = r.exec(<span class="string">"D:\\迅雷影音\\XMP\\V5.4.0.6151\\Bin\\XMP.exe c:\\lalaland.rmvb"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="杀死子进程"><a href="#杀死子进程" class="headerlink" title="杀死子进程"></a>杀死子进程</h4><p>只能杀死由Runtime r开启的进程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Process p = r.exec(<span class="string">"notepad.exe"</span>);</span><br><span class="line">p.destroy();</span><br></pre></td></tr></table></figure>

<h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><p>PI : double类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Math:提供了操作数学运算的方法。都是静态的。</span></span><br><span class="line"><span class="comment"> * 常用的方法:</span></span><br><span class="line"><span class="comment"> * abs()，求绝对值</span></span><br><span class="line"><span class="comment"> * ceil():返回大于参数的最小整数</span></span><br><span class="line"><span class="comment"> * floor():返回小于参数的最大整数</span></span><br><span class="line"><span class="comment"> * round():返回四舍五入的整数</span></span><br><span class="line"><span class="comment"> * max(int a,int b):求两个数中的大数</span></span><br><span class="line"><span class="comment"> * min(int a,int b):求两个数中的小数</span></span><br><span class="line"><span class="comment"> * pow(double a,double b):返回幂值，即a的b次方</span></span><br><span class="line"><span class="comment"> * random():随机数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="comment">//将随机苏转变为1-10之间的整数，应用：骰子</span></span><br><span class="line">	<span class="keyword">double</span> d = Math.ceil(<span class="number">10</span>*Math.random());</span><br><span class="line">	<span class="keyword">double</span> d = (<span class="keyword">int</span>)(Math.random()*<span class="number">10</span>+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><p>获取随机数还可以使用Random对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">			Random r = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="comment">//			double d = (int)(r.nextDouble()*6+1);</span></span><br><span class="line">			<span class="keyword">int</span> d = r.nextInt(<span class="number">6</span>)+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><p>在类的所有方法Date接受或返回年，月，日，小时，分钟和秒值，以下表述中使用：</p>
<ul>
<li><p>y年代表整数y - 1900 。 </p>
</li>
<li><p>一个月由0到11的整数表示; 0是1月，1是2月，等等; 11月12日。 </p>
</li>
<li><p>日期（月的一天）以通常的方式从1到31的整数表示。 </p>
</li>
<li><p>一小时由0到23之间的整数表示。因此，从午夜到凌晨1点的时间是小时0，从中午到下午1点的小时是12小时。 </p>
</li>
<li><p>分钟一般以0〜59的整数表示。 </p>
</li>
<li><p>秒由0到61的整数表示; 值60和61仅发生在闰秒上，甚至仅在实际上正确跟踪闰秒的Java实现中发生。 由于目前引入闰秒的方式，在同一分钟内不会发生两个闰秒，但是本规范遵循ISO C的日期和时间约定。</p>
</li>
</ul>
<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>Date()</p>
<p>Date(long mills)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();<span class="comment">//将当前日期和时间封装成Date对象</span></span><br><span class="line">System.out.println(date);<span class="comment">//Sat Feb 09 18:46:03 CST 2019	</span></span><br><span class="line">Date date2 = <span class="keyword">new</span> Date(<span class="number">1549709125956l</span>);<span class="comment">////将指定毫秒值封装成Date对象</span></span><br></pre></td></tr></table></figure>

<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>比较两个日期</p>
<p>  <strong>int</strong> compareTo(Date anotherDate) </p>
<p>测试此日期是否在指定日期之后。</p>
<p>  <strong>boolean</strong> after(Date when) </p>
<p>测试此日期是否在指定日期之前。 </p>
<p>  <strong>boolean</strong> before(Date when)</p>
<p><strong>日期与毫秒转换</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 日期对象和毫秒值之间的转换</span></span><br><span class="line"><span class="comment"> * 毫秒值--&gt;日期对象:</span></span><br><span class="line"><span class="comment"> * 1、通过Date对象的构造方法完成 new Date(timeMills);</span></span><br><span class="line"><span class="comment"> * 2、还可以通过setTime(long time)设置。</span></span><br><span class="line"><span class="comment"> * 	 因为可以通过日期对象的方法对该日期中的各个字段（年月日等）进行操作。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 日期对象--&gt;毫秒值</span></span><br><span class="line"><span class="comment"> * 1、getTime()方法	</span></span><br><span class="line"><span class="comment"> * 	因为可以通过具体的数值进行运算。</span></span><br><span class="line"><span class="comment"> * 	</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h3><p>​    对日期进行格式化，不能直接创建对象，需要使用DateFormat.getInstance()，在其中加入其字段，可以使用规定的格式，如默认的，LONG等。如果想要使用自定义的格式，就需要new其子类，SimpleDateFormat。</p>
<h4 id="对日期对象进行格式化"><a href="#对日期对象进行格式化" class="headerlink" title="对日期对象进行格式化"></a>对日期对象进行格式化</h4><p>工厂：生产对象的地方</p>
<p>将日期对象—-&gt;日期格式的字符串</p>
<p>返回String，使用DateFormat方法（或其子类），接收Date对象</p>
<p>使用的是<strong>DateFormat类</strong>中的<strong>format方法</strong></p>
<p>即DateFormat.getDateInstance()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		Date date = <span class="keyword">new</span> Date();</span><br><span class="line">		<span class="comment">//获取日期格式对象，具备着默认的风格。</span></span><br><span class="line"><span class="comment">//		DateFormat dateFormat = DateFormat.getDateInstance();//2019-2-11</span></span><br><span class="line">		<span class="comment">//可以指定风格 FULL LONG SHORT等可以指定风格</span></span><br><span class="line"><span class="comment">//		DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.FULL);//2019年2月11日 星期一</span></span><br><span class="line">		DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.LONG);<span class="comment">//2019年2月11日 </span></span><br><span class="line"><span class="comment">//		DateFormat dateFormat2 = DateFormat.getDateTimeInstance();//2019-2-11 11:11:21</span></span><br><span class="line">		<span class="comment">//指定日期和时间格式。2019年2月11日 上午11时20分04秒</span></span><br><span class="line">		DateFormat dateFormat2 = DateFormat.getDateTimeInstance(DateFormat.LONG,DateFormat.LONG);</span><br><span class="line">		<span class="comment">//结果应该是String格式，格式器最清楚，应该要输入日期对象</span></span><br><span class="line">		String str_data = dateFormat.format(date);</span><br><span class="line">		String str_data_time = dateFormat2.format(date);</span><br><span class="line">		System.out.println(str_data);<span class="comment">//2019-2-11</span></span><br><span class="line">		System.out.println(str_data_time);<span class="comment">//2019-2-11 11:11:21</span></span><br></pre></td></tr></table></figure>

<p>自定义日期时间格式</p>
{% asset_img 第20天1.png This is an example image %}

<p>范例：在指定格式的时候使用字符串，具体的规则见上表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		<span class="comment">//风格是自定义的的解决方式，使用DateFormat的子类</span></span><br><span class="line">		DateFormat dateFormat3 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy--MM--dd"</span>);</span><br><span class="line">		String str_data_own = dateFormat3.format(date);</span><br><span class="line">		System.out.println(str_data_own);</span><br><span class="line">将日期格式的字符串--&gt;日期对象</span><br><span class="line">返回Date对象，使用DateFormat方法（或其子类），接收String</span><br><span class="line">使用的是DateFormat类中的parse方法</span><br><span class="line"><span class="comment">//		String str_date = "2012-4-19";//使用默认格式</span></span><br><span class="line">		String str_date = <span class="string">"2012年4月19日"</span>;</span><br><span class="line">		String str = <span class="string">"2011---8---27"</span>;</span><br><span class="line">		DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.LONG);</span><br><span class="line">		<span class="comment">//如果要使用自定义的风格，则使用DateFormat子类</span></span><br><span class="line">		DateFormat dateFormat2 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy---MM---dd"</span>);</span><br><span class="line">		Date date2 = dateFormat2.parse(str);</span><br><span class="line">		System.out.println(date2);</span><br><span class="line">		Date date = dateFormat.parse(str_date);</span><br><span class="line">		System.out.println(date);</span><br></pre></td></tr></table></figure>

<h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><p>通过Calendar.getInstance来获取其对象</p>
<p>使用的是键值对</p>
<h4 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h4><p>1、 get()获取时间</p>
<p>2、 add()指定时间的偏移</p>
<p>3、 set()设置时间</p>
<h4 id="日期显示"><a href="#日期显示" class="headerlink" title="日期显示"></a>日期显示</h4><p>使用get方法，其中月份、星期要进行转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Calendar c = Calendar.getInstance();</span><br><span class="line">		showDate(c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showDate</span><span class="params">(Calendar c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> year = c.get(Calendar.YEAR);</span><br><span class="line">		<span class="keyword">int</span> month = c.get(Calendar.MONTH)+<span class="number">1</span>;<span class="comment">//月份从0开始</span></span><br><span class="line">		<span class="keyword">int</span> day = c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">		<span class="keyword">int</span> week = c.get(Calendar.DAY_OF_WEEK);<span class="comment">//星期日是第一天,即1为星期日</span></span><br><span class="line">		System.out.println(year+<span class="string">"年"</span>+month+<span class="string">"月"</span>+day+<span class="string">"日"</span>+getWeek(week));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getWeek</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		String[] weeks =&#123;<span class="string">" "</span>,<span class="string">"星期日"</span>,<span class="string">"星期一"</span>,<span class="string">"星期二"</span>,<span class="string">"星期三"</span>,<span class="string">"星期四"</span>,<span class="string">"星期五"</span>,<span class="string">"星期六"</span>&#125;;</span><br><span class="line">		<span class="keyword">return</span> weeks[i];<span class="comment">//因为是一一对应的角标，所以可以利用数组。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="日期设置"><a href="#日期设置" class="headerlink" title="日期设置"></a>日期设置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置指定日期</span></span><br><span class="line">c.set(<span class="number">2019</span>,<span class="number">10</span>, <span class="number">14</span>);</span><br><span class="line"><span class="comment">//在指定日期上偏移</span></span><br><span class="line">c.add(Calendar.MONTH, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>​    可以先设置时间，然后再利用add进行日期偏移，可以知道每一年哪个月有多少天，即设置那一年，然后将set设置为目标月的下一个月，然后偏移量为日期-1即可，再获取天数即可以。注意月份是从0开始！！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showDays</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">		Calendar c= Calendar.getInstance();</span><br><span class="line">		<span class="comment">//设置指定日期</span></span><br><span class="line">		c.set(year,<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//在指定日期上偏移</span></span><br><span class="line">		c.add(Calendar.DAY_OF_MONTH, -<span class="number">1</span>);</span><br><span class="line">		showDate(c);		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>如果要获取昨天的时分秒，直接将日期偏移量设置为日期偏移-1即可。</p>
<h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><p>​    记得关流，除非是System.in或者System.out</p>
<p>​    IO流用来处理设备之间的数据传输，Java对数据的传输通过流的方式，Java用于操作流的的对象都在IO包中。</p>
<p>流按操作数据分为两种：字节流与字符流。流按流向分为：输入流（将硬盘中的数据读入内存），输出流（将内存中的数据写入硬盘）。</p>
<h4 id="输入流与输出流"><a href="#输入流与输出流" class="headerlink" title="输入流与输出流"></a>输入流与输出流</h4><p>相对于内存设备而言。</p>
<p>将外设中的数据读取到内存中：输入。</p>
<p>将内存中的数据写入到外设中：输出。</p>
<p>构造函数可以接收文件对象，也可以接收字符串，接收文件对象使用更多。</p>
<h4 id="字符流的由来"><a href="#字符流的由来" class="headerlink" title="字符流的由来"></a>字符流的由来</h4><p>其实就是：字节流读取文字字节数据后，不直接操作而是先查指定的编码表。获取对应的文字。再对这个文字进行操作。</p>
<h4 id="IO流基类"><a href="#IO流基类" class="headerlink" title="IO流基类"></a>IO流基类</h4><p>字节流的两个顶层父类：</p>
<p>1，InputStream 2，OutputStream</p>
<p>字符流的两个顶层父类</p>
<p>1，Reader 2,Writer</p>
<p>这些体系的子类都以父类名作为后缀。</p>
<p>而子类名的前缀就是该对象的功能。</p>
<p>从熟悉的文字开始字符流。</p>
<h4 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h4><p>操作文本文件对象</p>
<p>构造函数中加入true表示续写。</p>
<p>//需求：将一些文字存储到硬盘一个文件中。</p>
<p>记住：如果要操作文字数据，建议优先考虑字符流。</p>
<p>而且要将数据从内存写到硬盘上，要使用字符流中的输出流：Writer</p>
<p>硬盘的数据基本体现是文件，希望可以找到一个可以操作文件的Writer</p>
<p>找到了FileWriter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">			<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LINE_SEPARATOR = System.getProperty(<span class="string">"line.separator"</span>);</span><br><span class="line">		<span class="comment">//创建一个可以往文件中写入字符数据的字符输出流对象</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 既然 是往一个文件中写入文件数据，那么在创建对象时，就必须明确该文件（用于存储数据的目的地）</span></span><br><span class="line"><span class="comment">		 * 如果文件不存在，则会自动创建。</span></span><br><span class="line"><span class="comment">		 * 如果文件存在，则会被覆盖。</span></span><br><span class="line"><span class="comment">		 * 如果构造函数中加入true，可以实现对文件进行续写</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"demo.txt"</span>,<span class="keyword">true</span>);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 调用Writer对象中的write(string)方法，写入数据。	</span></span><br><span class="line"><span class="comment">		 * 其实数据写入到临时存储缓冲区。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//调用系统本地的换行</span></span><br><span class="line">		fw.write(<span class="string">"abcde"</span>+LINE_SEPARATOR+<span class="string">"hahaa"</span>);</span><br><span class="line">		fw.write(<span class="string">"xixi"</span>);</span><br><span class="line">		 <span class="comment">//进行刷新，将数据直接写入到目的地中。可以用多次flush</span></span><br><span class="line"><span class="comment">//		fw.flush();</span></span><br><span class="line">		<span class="comment">//关闭流，关闭资源。在关闭前会先调用flush刷新缓冲区中的数据到目的地。</span></span><br><span class="line">		<span class="comment">//关闭后不能够再写入</span></span><br><span class="line">		fw.close(); 	</span><br><span class="line">	<span class="comment">//fw.write("ah");//会报错</span></span><br></pre></td></tr></table></figure>

<h4 id="IO异常处理"><a href="#IO异常处理" class="headerlink" title="IO异常处理"></a>IO异常处理</h4><p>因为流对象一般会抛出异常，因此一般在try外面创建对象，在try里面创建具体的引用。</p>
<p>因为关闭一定要执行，因此close放在finally中，其中close也需要进行处理。为了不出现空指针异常，需要去判断fw，只有在不为空的时候，才进行流关闭操作。</p>
<p>  即变量定外面，new在里面，finally close在里面，不要忘记判断null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileWriter fw = <span class="keyword">null</span>;<span class="comment">// 流对象在try外面进行创建</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	fw = <span class="keyword">new</span> FileWriter(<span class="string">"k:\\demo.txt"</span>);<span class="comment">// 在try里面进行创建引用</span></span><br><span class="line">	fw.write(<span class="string">"abcde"</span> + LINE_SEPARATOR + <span class="string">"hahaa"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	System.out.println(e.toString());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (fw != <span class="keyword">null</span>)<span class="comment">//一定要加入判断，不然会出现空指针异常 </span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			fw.close();<span class="comment">// 需要单独进行处理</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"关闭失败"</span>);</span><br><span class="line">		&#125; <span class="comment">// 没有声明，因此在外面进行声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h4><p><strong>读取方式1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需求：读取一个文本文件，将读取到的字符打印到控制台。</span></span><br><span class="line">		<span class="comment">//1、创建读取字符数据的流对象</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 在创建读取流对象时，必须要明确被读取的文件，一定要确定该文件是存在的。</span></span><br><span class="line"><span class="comment">		 * 用一个读取流关联一个已存在文件</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"demo.txt"</span>);</span><br><span class="line">		<span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((ch=fr.read())!=-<span class="number">1</span>)</span><br><span class="line">			System.out.println((<span class="keyword">char</span>)ch);</span><br></pre></td></tr></table></figure>

{% asset_img 第20天2.png This is an example image %}

<p>读取时候如果读到了末尾，会使用-1标识符，如果继续读则还是-1。</p>
<p><strong>读取方式2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"demo.txt"</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用read(char[])读取文件文本数据</span></span><br><span class="line"><span class="comment"> * 先创建字符数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];<span class="comment">//长度最好是1024的整数倍</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len=fr.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">	System.out.println(<span class="keyword">new</span> String(buf,<span class="number">0</span>,len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

{% asset_img 第20天3.png This is an example image %}

<p>这种读取方式，由于后两次读的数量不一样，因此会对第一次读取的数组进行覆盖。</p>
<h4 id="复制文件一"><a href="#复制文件一" class="headerlink" title="复制文件一"></a>复制文件一</h4><p>读取一个便写一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 需求：将C盘的一个文本文件复制到d盘。</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> * 1，需要读取源</span></span><br><span class="line"><span class="comment"> * 2，将读到的源数据写入目的地</span></span><br><span class="line"><span class="comment"> * 3，既然是操作文本数据，使用字符流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyTextTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//1，读取一个已有的文本文件，使用字符读取流，和文本相关联。</span></span><br><span class="line">		FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"IO流_2.txt"</span>);</span><br><span class="line">		<span class="comment">//2，创建一个目的，用于存储读到的数据。</span></span><br><span class="line">		FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"copytext_1.txt"</span>);</span><br><span class="line">		<span class="comment">//3，频繁的读写操作。</span></span><br><span class="line">		<span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((ch=fr.read())!=-<span class="number">1</span>)&#123;<span class="comment">//只要是读，就使用循环，然后while两层括号，判断是否等于-1</span></span><br><span class="line">			fw.write(ch);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4，关闭流资源。</span></span><br><span class="line">		fw.close();</span><br><span class="line">		fr.close();		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="复制文件二"><a href="#复制文件二" class="headerlink" title="复制文件二"></a>复制文件二</h4><p>使用缓冲来读取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyTextTest_2</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">		FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			fr = <span class="keyword">new</span> FileReader(<span class="string">"IO流_2.txt"</span>);</span><br><span class="line">			fw = <span class="keyword">new</span> FileWriter(<span class="string">"copytest_2.txt"</span>);</span><br><span class="line">			<span class="comment">//创建一个临时容器，用于缓存读取到的字符</span></span><br><span class="line">			<span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[BUFFER_SIZE];</span><br><span class="line">			<span class="comment">//定义一个变量定义读取到的字符数（其实就是往数组里装的字符个数）</span></span><br><span class="line">			<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>((len=fr.read(buf))!=-<span class="number">1</span>)&#123;<span class="comment">//while里面两个括号，判断长度是否为-1即可</span></span><br><span class="line">				fw.write(buf, <span class="number">0</span>, len);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;<span class="comment">//关流前需要判断</span></span><br><span class="line">			<span class="keyword">if</span>(fw!=<span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					fw.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"读写失败"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">if</span>(fr!=<span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					fr.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"读写失败"</span>);</span><br><span class="line">				&#125;		</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="复制文件图解"><a href="#复制文件图解" class="headerlink" title="复制文件图解"></a>复制文件图解</h4>{% asset_img 第21天1.png This is an example image %}

<p>待读取的文件为源，使用流来读取，对应代码为FileReader fr = new FileReader(“demo.txt”)，要写入文件，使用流来写入，对应代码为FileWriter fw = new FileWriter (“test.txt”)。而两个流之间没有直接关系，需要使用缓冲区来作为中转，为了将读入流与缓冲区关联，使用fr.read(buf)；为了将写出流与缓冲区关联，使用fw.write(buf,0,len)。为了将流中的文件写出到输出源中，要使用fw.flush或者fw.close，flush可以多次刷新，而close只能使用一次。</p>
<h4 id="字符流缓冲区"><a href="#字符流缓冲区" class="headerlink" title="字符流缓冲区"></a>字符流缓冲区</h4><p>对应类：</p>
<p>BufferedWriter</p>
<p>BufferedReader</p>
<p>缓冲区的出现提高了对数据的读写效率。缓冲区要结合流才可以使用。在流的基础上对流的功能进行了增强。</p>
<p>进缓冲区写入后一定要刷新！！！</p>
<p>字符流缓冲区</p>
<p>BufferedWriter</p>
<p>特有方法：newLine()换行写入</p>
<p>​    写完记得要刷新flush()</p>
<p>BufferedReader</p>
<p>特有方法：readLine()按行读入</p>
<p>​      判断标志不为-1，而是null。使用String类型接收read。</p>
<p><strong>写入</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LINE_SEPARATOR = System.getProperty(<span class="string">"line.separator"</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"demo.txt"</span>);</span><br><span class="line">		<span class="comment">//为了提高写入的效率。使用了字符流的缓冲区。</span></span><br><span class="line">		<span class="comment">//创建了一个字符写入流的缓冲区对象，并和指定要被缓冲的流对象相关联。</span></span><br><span class="line">		BufferedWriter bufw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line">		<span class="comment">//写入缓冲区的写入方法将数据先写入到缓冲区中</span></span><br><span class="line"><span class="comment">//		bufw.write("abcde"+LINE_SEPARATOR+"dsd");</span></span><br><span class="line"><span class="comment">//		bufw.write("xxixiix");</span></span><br><span class="line"><span class="comment">//		bufw.newLine();</span></span><br><span class="line"><span class="comment">//		bufw.write("heheh");</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=<span class="number">4</span>;x++)&#123;</span><br><span class="line">			bufw.write(<span class="string">"abcde"</span>+x);</span><br><span class="line">			bufw.newLine();<span class="comment">//换行</span></span><br><span class="line">			bufw.flush();<span class="comment">//写一次就刷新一次</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//使用缓冲区的刷新方法将数据刷目的地中</span></span><br><span class="line"><span class="comment">//		bufw.flush();</span></span><br><span class="line">		<span class="comment">//关闭缓冲区。其实关闭的就是被缓冲的流对象</span></span><br><span class="line">		bufw.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>读取</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"buf.txt"</span>);	</span><br><span class="line">		BufferedReader bufr = <span class="keyword">new</span> BufferedReader(fr);<span class="comment">//缓冲区关联流</span></span><br><span class="line">		String line = <span class="keyword">null</span>;<span class="comment">//判断变量</span></span><br><span class="line">		<span class="comment">//按行读取</span></span><br><span class="line">		<span class="keyword">while</span>((line=bufr.readLine())!=<span class="keyword">null</span>)&#123;<span class="comment">//如果读取的不为空，则输出</span></span><br><span class="line">			System.out.println(line);</span><br><span class="line">		&#125;</span><br><span class="line">		bufr.close();</span><br></pre></td></tr></table></figure>

<p>读取中缓冲区的read方法对父类方法进行了覆写</p>
{% asset_img 第21天2.png This is an example image %}

<p>readLine原理：缓冲区从磁盘中使用父类read(buf)方法拿出数据到内存中，从内存中取出字符比较快，使用的是覆盖过的read方法，将取出的数据放在临时容器中，根据文本的行特点，判断是否为换行符，临时容器中存储的是一行的数据，不包含换行符，然后转换成字符串进行输出。</p>
<p>readLine方法使用了读取缓冲区的read方法，将读取到的字符进行缓冲并判断换行标记，将标记前的缓存数据变成字符串返回。</p>
<p>​    <strong>临时容器</strong>可以使用<strong>StringBuilder</strong>。因为最终返回的是字符串。</p>
<p><strong>按行读取</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>((line=bufr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">	bufw.write(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用：可以按行来读取，因为返回的为String类型的变量，就可以使用String中的方法，如判断该行是否包含某一字符串。</p>
<h4 id="复制文件三"><a href="#复制文件三" class="headerlink" title="复制文件三"></a>复制文件三</h4><p>使用缓冲区来实现文件的读写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"buf.txt"</span>);</span><br><span class="line">BufferedReader bufr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"buf_copt.txt"</span>);</span><br><span class="line">BufferedWriter bufw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line"><span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((ch=bufr.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">	bufw.write(ch);</span><br><span class="line">&#125;</span><br><span class="line">bufw.close();</span><br><span class="line">bufr.close();</span><br></pre></td></tr></table></figure>

<h4 id="复制文件四"><a href="#复制文件四" class="headerlink" title="复制文件四"></a>复制文件四</h4><p>使用缓冲区按行读取，为了换行使用newLine，一定要<strong>flush</strong>!!!</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"buf.txt"</span>);</span><br><span class="line">BufferedReader bufr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"buf_copt.txt"</span>);</span><br><span class="line">BufferedWriter bufw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>((line=bufr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">	bufw.write(line);</span><br><span class="line">	bufw.newLine();</span><br><span class="line">	bufw.flush();</span><br><span class="line">&#125;</span><br><span class="line">bufw.close();</span><br><span class="line">bufr.close();</span><br></pre></td></tr></table></figure>

<h4 id="装饰设计模式"><a href="#装饰设计模式" class="headerlink" title="装饰设计模式"></a>装饰设计模式</h4><p>装饰设置模式：</p>
<p>  对一组对象的功能进行增强时，就可以使用该模式进行问题的解决。</p>
<p>装饰和继承都能实现一样的特点，进行功能的拓展增强。</p>
<p>区别：</p>
<p>首先有一个继承体系</p>
<p>Writer</p>
<pre><code>|--TextWriter:用于操作文本

|--MediaWriter:用于操作媒体</code></pre><p>想到对操作的动作进行效率的提高。按照面向对象，可以通过继承对具体的进行功能的拓展。</p>
<p>效率的提高需要加入缓冲技术</p>
<p>Writer</p>
<pre><code>|--TextWriter:用于操作文本</code></pre><p>​            |–BufferTextWriter:加入了缓冲技术的操作文本的对象</p>
<pre><code>|--MediaWriter:用于操作媒体

      |--BufferMediaWriter:加入了缓冲技术的操作媒体的对象</code></pre><p>到这里就可以了，但这样做存在问题。</p>
<p>如果这个体系进行功能拓展，又多了流对象。那么这个流要提高效率是否也要产生子类？</p>
<p>是，会发现只为提高功能进行的继承，导致继承体系越来越臃肿。不够灵活。</p>
<p>重新思考问题</p>
<p>既然加入的都是同一种技术–缓冲。</p>
<p>前一种是让缓冲和具体的对象相结合。可以将缓冲进行单独的封装，哪个对象需要缓冲， 就将哪个对象和缓冲关联。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  Buffer(TextWriter w)</span><br><span class="line"></span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  Buffer(MediaWriter w)</span><br><span class="line"></span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>太麻烦，直接操作父类，利用多态.但是要使用Writer方法，继承即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferWriter</span> <span class="keyword">extends</span> <span class="title">Writer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  Buffer(Writer w)</span><br><span class="line"></span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Writer</p>
<pre><code>|--TextWriter:用于操作文本

|--MediaWriter:用于操作媒体

|--BufferWriter:用于提高效率</code></pre><p>装饰比继承<strong>灵活</strong>。</p>
<p>特点：<strong>装饰类和被装饰类都必须所属同一个接口或者父类</strong>。</p>
<h4 id="LineNumber"><a href="#LineNumber" class="headerlink" title="LineNumber"></a>LineNumber</h4><p>获取行号</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"IO流_2.txt"</span>);</span><br><span class="line">		LineNumberReader lnr = <span class="keyword">new</span> LineNumberReader(fr);</span><br><span class="line">		String line = <span class="keyword">null</span>;</span><br><span class="line">		lnr.setLineNumber(<span class="number">20</span>);</span><br><span class="line">		<span class="keyword">while</span>((line=lnr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			System.out.println(lnr.getLineNumber()+<span class="string">":"</span>+line);</span><br><span class="line">		&#125;</span><br><span class="line">		lnr.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><p>基本操作与字符流相同。但是它不仅可以操作字符，还可以操作其他媒体文件。</p>
<p>字节流一般不用flush，除非用到了缓冲区。</p>
<p>​    不要用字符流操作媒体文件，无法被解析。因为查表查不到。</p>
<p><strong>输出流OutputStream</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo_write</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//1、创建字节输出流对象，用于操作文件</span></span><br><span class="line">		FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"bytedemo.txt"</span>);</span><br><span class="line">		<span class="comment">//2、写数据。直接写入到目的地中。</span></span><br><span class="line">		fos.write(<span class="string">"abcdefg"</span>.getBytes());</span><br><span class="line">		fos.close();<span class="comment">//关闭资源动作要完成。</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输入流InputStream</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo_read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//1、创建一个读取流对象和指定的文件关联</span></span><br><span class="line">		FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"bytedemo.txt"</span>);</span><br><span class="line">		<span class="comment">//创建一个大小刚刚好的缓冲区</span></span><br><span class="line">		<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[fis.available()];<span class="comment">//慎用！！！</span></span><br><span class="line">		fis.read(buf);</span><br><span class="line">		System.out.println(<span class="keyword">new</span> String(buf));</span><br><span class="line">		<span class="comment">//利用缓冲区读取</span></span><br><span class="line">		<span class="comment">//建议使用这种读取数据的方式。</span></span><br><span class="line"><span class="comment">//		byte[] buf = new byte[1024];</span></span><br><span class="line"><span class="comment">//		int len = 0;</span></span><br><span class="line"><span class="comment">//		while((len=fis.read(buf))!=-1)&#123;</span></span><br><span class="line"><span class="comment">//			System.out.println(new String(buf,0,len));</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		<span class="comment">//一次读取一个字节。	</span></span><br><span class="line"><span class="comment">//		int ch = 0;</span></span><br><span class="line"><span class="comment">//		while((ch=fis.read())!=-1)&#123;</span></span><br><span class="line"><span class="comment">//			System.out.println((char)ch);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		fis.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="键盘录入"><a href="#键盘录入" class="headerlink" title="键盘录入"></a>键盘录入</h4><p>Windows中回车是两个字符，’\r’对应数字13，’\n’对应数字10。因此如果读取回车符号会得到13与10。</p>
<p>默认的输入与输出设备均<strong>不用关流</strong>，如果关了则不能再次获取，除非重启设备。</p>
<p>​    将系统输入与字节流进行关流，然后调用字节流的方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream in = System.in;</span><br><span class="line"><span class="keyword">int</span> ch = in.read();<span class="comment">//检测到流末尾或者异常的时候，一直阻塞。一直等待读取到数据。阻塞式方法。</span></span><br><span class="line">System.out.println(<span class="string">"ch:"</span>+ch);</span><br></pre></td></tr></table></figure>

<p>集合的清空为clear，StringBuilder的为delete</p>
<p><strong>获取键盘数据</strong></p>
<p>获取键盘录入数据，转为大写，利用over结束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readKey2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//一直读入键盘输入的值</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 获取用户键盘录入的数据，并将数据变成大写显示在控制台上。</span></span><br><span class="line"><span class="comment">		 * 如果用户输入的是over，结束键盘录入。</span></span><br><span class="line"><span class="comment">		 * 思路：</span></span><br><span class="line"><span class="comment">		 * 1，因为键盘录入只读取一个字节，要判断是否是over，需要将读取到的字节拼成字符串</span></span><br><span class="line"><span class="comment">		 * 2，那就需要一个容器。StrignBuilder。</span></span><br><span class="line"><span class="comment">		 * 3，在用户回车之前，将录入的数据变成字符串判断即可。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//1，创建容器</span></span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//2，获取键盘读取流</span></span><br><span class="line">		InputStream in = System.in;</span><br><span class="line">		<span class="comment">//3，定义变量记录读取到的字节，并循环获取</span></span><br><span class="line">		<span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((ch=in.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="comment">//在存储之前需要判断是否是换行标记，因为换行标记不存</span></span><br><span class="line">			<span class="keyword">if</span>(ch==<span class="string">'\r'</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(ch==<span class="string">'\n'</span>)&#123;</span><br><span class="line">				<span class="comment">//如果换行，需要判断</span></span><br><span class="line">				String temp = sb.toString();<span class="comment">//将缓冲的字符变成字符串	</span></span><br><span class="line">				<span class="keyword">if</span>(<span class="string">"over"</span>.equals(temp))</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">//不是over就输出</span></span><br><span class="line">				System.out.println(temp.toUpperCase());</span><br><span class="line">				<span class="comment">//输出完以后，将缓冲区清空，不然会将之前的也存进去</span></span><br><span class="line">				<span class="comment">//集合的清空为clear，StringBuilder的为delete。</span></span><br><span class="line">				sb.delete(<span class="number">0</span>, sb.length());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果不加else，那么回车后仍然会添加元素，则将'\n'添加进去了。因为不是回车符才进行添加。一定要加else</span></span><br><span class="line">			<span class="keyword">else</span>	</span><br><span class="line">			<span class="comment">//将读取到的字节存储到StringBuilder中。</span></span><br><span class="line">			sb.append((<span class="keyword">char</span>)ch);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>​    会发现使用到的判断跟BufferedReader中的readLine方法很接近。因此想利用readLine来做。</p>
<h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><p>InputStreamReader ：字节到字符的桥梁。解码。</p>
<p>OutputStreamWriter：字符到字节的桥梁。编码。</p>
<p>​    BufferedReader中有readline方法，如果要使用到BufferedRead方法，需要传入的是字符流对象，但是如果想让字节流也是用其方法，需要将字节流转变为字符流。</p>
<p>​    可以使用<strong>InputSreamReader</strong>。需要考虑编码的问题。在字符流对象中。将字<strong>节流变成字符流</strong></p>
<p>从名字判断。<strong>后缀为父类，前缀为功能</strong>。</p>
<p>因此可以将上面的代码改写，直接获取一行字符串即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字节流</span></span><br><span class="line">		InputStream in = System.in;</span><br><span class="line">		<span class="comment">//将字节转成字符的桥梁，转换流。</span></span><br><span class="line">		InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line">		<span class="comment">//字符流，为字符装饰流。</span></span><br><span class="line">		BufferedReader bufr = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">		String line = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span>((line=bufr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="string">"over"</span>.equals(line))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			System.out.println(line.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符与字节的区别</p>
<p>读取汉字的时候，一个汉字字符为2个字节，如果用字节读就会读2次，然后将2个字节对应成数字单独输出；如果是字符流，那么会一下子读2个，只读1次，然后查表找对应的字符。</p>
<blockquote>
<p>字节-&gt;字符，解码。因为从看不懂的变成看得懂的。使用IuputStreamReader</p>
<p>字符-&gt;字节，编码。因为从看的懂的变成看不懂的。使用OutputStreamWriter</p>
</blockquote>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC22%E5%A4%A91.png" class title="This is an example image">

<p>示意图：从键盘输入到控制台输出</p>
<p>字节流从键盘拿数据，变成字符流使用字符流装饰类来提高效率，因此数据就读取到了缓冲区中，然后从缓冲区中写数据到字符输出流，数据到了字符输出流，目的地是out.控制台，需要将字符流转换成字节流，然后进行输出字节数据。</p>
<h4 id="键盘录入到控制台输出"><a href="#键盘录入到控制台输出" class="headerlink" title="键盘录入到控制台输出"></a>键盘录入到控制台输出</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">键盘录入到控制台输出</span><br><span class="line">		<span class="comment">//键盘录入</span></span><br><span class="line">		<span class="comment">//将键盘字节流转换为字符流装饰类提高效率，背下来！！！</span></span><br><span class="line">		BufferedReader bufr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		<span class="comment">//控制台输出</span></span><br><span class="line">		BufferedWriter bufw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">		String line = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span>((line=bufr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="string">"over"</span>.equals(line))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			bufw.write(line);<span class="comment">//逐行写入</span></span><br><span class="line">			bufw.newLine();<span class="comment">//换行</span></span><br><span class="line">			bufw.flush();<span class="comment">//使用缓冲区记得要刷新</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重点代码"><a href="#重点代码" class="headerlink" title="重点代码"></a>重点代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//键盘录入</span></span><br><span class="line">BufferedReader bufr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line">BufferedWriter bufw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br></pre></td></tr></table></figure>

<h4 id="流操作规律"><a href="#流操作规律" class="headerlink" title="流操作规律"></a>流操作规律</h4><p>之所以要弄清楚这个规律，是因为流对象太多，开发时不知道用哪个对象合适。</p>
<p>想要知道开发时用到哪些对象，只要通过四个明确即可。</p>
<p>1， 明确源和目的（汇）</p>
<p>​    源：  InputStream     Reader</p>
<p>​    目的：OutputStream  Writer</p>
<p>2， 明确数据是否是纯文本数据</p>
<p>​    源：是纯文本：Reader</p>
<p>​                       否：InputStream</p>
<p>​    目的：是纯文本：Writer</p>
<p>​                       否：OutputStream</p>
<p>到这里就可以明确需求中具体要用哪个体系。</p>
<p>3， 明确具体的设备。</p>
<p>​    源设备：</p>
<p>​            硬盘：File</p>
<p>​            键盘：System.in</p>
<p>​            内存：数组</p>
<p>​            网络：Socket流</p>
<p>​    目的设备：</p>
<pre><code>硬盘：File</code></pre><p>​            控制台：System.out</p>
<p>​            内存：数组</p>
<p>​            网络：Socket流</p>
<p>4， 是否需要其他额外功能。</p>
<p>​    1， 是否需要高效（缓冲区）？</p>
<p>​        是，就加上buffer。</p>
<p>​    2， 是否需要转换</p>
<p>​        是</p>
<pre><code>源：InputStreamReader 字节流-&gt;字符流

目的：OutputStreamWriter 字符流-&gt;字节流</code></pre><hr>
<p>需求1：复制一个文本文件。</p>
<p>  1，明确源和目的。</p>
<p>​        源：InputStream  Reader</p>
<p>​        目的：OutputStream Writer  </p>
<p>  2，是否是纯文本？</p>
<p>​        是！</p>
<pre><code>源：Reader</code></pre><p>​        目的：Writer</p>
<p>  3，明确具体设备</p>
<p>​        源：</p>
<p>​              硬盘：File</p>
<p>​        目的：</p>
<p>​              硬盘：File</p>
<p>​        FileReader fr = new FileReader(“a.txt”);</p>
<pre><code>FileWriter fw = new FileWriter(&quot;b.txt&quot;);</code></pre><p>  4，需要额外功能吗？</p>
<p>​        需要，需要高效。</p>
<p>​    BufferedReader bufr = new BufferedReader(new FileReader(“a.txt”));</p>
<p>​    BufferedWriter bufw = new BufferedWriter(new FileWriter(“b.txt”));</p>
<hr>
<p>需求2：读取键盘读入信息，并写入到一个文件中。</p>
<p>  1，明确源和目的。</p>
<p>​        源：InputStream  Reader</p>
<p>​        目的：OutputStream Writer </p>
<p>  2，是否是纯文本呢？</p>
<pre><code>是</code></pre><p>​              源：Reader</p>
<p>​          目的 ：Writer</p>
<p>  3，明确设备</p>
<pre><code>源：</code></pre><p>​              键盘：System.in</p>
<p>​        目的</p>
<p>​              硬盘：File</p>
<p>​    InputStream in = System.in;</p>
<p>​    FileWriter fw = new FileWriter(“b.txt”);</p>
<p>​    这样做可以完成，但是麻烦。将读取的字节数据转成字符串，再由字符流操作。</p>
<p>  4，需要额外功能吗？</p>
<p>​    需要，转换。将字节流转换成字符流。因为明确的源是Reader，这样操作文本数据最便捷。</p>
<p>​    所以要将已有的字节流转成字符流。使用字节–&gt;字符。InputStreamReader</p>
<p>​    InputStreamReader isr = new InputStreamReader(System.in);</p>
<p>​    FileWriter fw = new FileWriter(“b.txt”);</p>
<p>​    还需要功能吗？</p>
<p>​    需要：想高效</p>
<p>​    BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));</p>
<p>​    BufferedWriter bufw = new BufferedWriter(new FileWriter(“b.txt”));</p>
<hr>
<p>需求3：将一个文本文件数据显示在控制台上</p>
<p>  1，明确源和目的。</p>
<p>​        源：InputStream  Reader</p>
<p>​        目的：OutputStream Writer </p>
<p>  2，是否是纯文本呢？</p>
<p>​        是</p>
<p>​              源：Reader</p>
<p>​              目的 ：Writer</p>
<p>  3，明确具体设备</p>
<pre><code>源：</code></pre><p>​              硬盘：File</p>
<p>​        目的：</p>
<p>​              控制台：System.out</p>
<p>​    FileReader fr = new FileReader(“a.txt”);</p>
<p>​    OutputStream out = System.out;//对象类型是PrintStream</p>
<p>  4，需要额外功能吗？</p>
<p>​    需要，转换。</p>
<p>​    FileReader fr = new FileReader(“a.txt”);</p>
<p>​    OutputStreamWriter osw = new OutputStreamWriter(System.out);</p>
<p>​    需要，高效。</p>
<p>​    BufferedReader bufr = new BufferedReader(new FileReader(“a.txt”));</p>
<p>​    BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));</p>
<hr>
<p>需求4：读取键盘录入数据，显示在控制台上</p>
<p>  1，明确源和目的。</p>
<p>​        源：InputStream  Reader</p>
<pre><code>目的：OutputStream Writer </code></pre><p>  2，是否是纯文本呢？</p>
<p>​        是</p>
<p>​              源：Reader</p>
<p>​              目的 ：Writer</p>
<p>  3，明确设备</p>
<pre><code>源：</code></pre><p>​              键盘：System.in</p>
<pre><code>目的：</code></pre><p>​              控制台：System.out   </p>
<p>​    InputStream in = System.in;</p>
<p>​    OutputStream out = System.out;</p>
<p>  4，明确额外功能？</p>
<p>​    需要转换，因为都是字节流，但是操作的却是文本数据。</p>
<p>​    所以使用字符流操作起来更方便。</p>
<p>​    InputStreamReader isr = new InputStreamReader(System.in);</p>
<p>​    OutputStreamWriter osw = new OutputStreamWriter(System.out);</p>
<p>​    为了将其高效操作。</p>
<p>​    BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));</p>
<p>   BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));</p>
<h4 id="转换流的编码解码"><a href="#转换流的编码解码" class="headerlink" title="转换流的编码解码"></a>转换流的编码解码</h4><p>GBK中一个中文对应2个字节，在UTF-8编码中，一个中文对应3个字节。</p>
<p>需求5：将一个中文字符串数据按照指定的编码表写入到一个文本文件中</p>
<p>  1，目的。OutputStream Writer</p>
<p>  2，是纯文本，Writer</p>
<p>  3，设备：硬盘File</p>
<p>  FileWriter fw = new FileWriter(“a.txt”);</p>
<p>  fw.write(“你好”);</p>
<p>  注意：既然需求中已经<strong>明确了指定编码表的动作</strong>。</p>
<p>  那就<strong>不可以使用FileWriter</strong>，因为FileWriter内部是使用<strong>默认的本地码表</strong>。</p>
<p>  只能使用其父类，OutputStreamWriter。</p>
<p>  OutputStreamWriter接收一个<strong>字节输出流</strong>对象，既然是操作文件，那么对象应该是FileOutputStream</p>
<p>  OutputStreamWriter = osw = new OutputStreamWriter(new FileOutputStream(“a.txt”),<strong>charsetNam</strong>e);</p>
<p>  需要高效不？</p>
<p>  BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(“a.txt”),charsetName));</p>
<p>什么时候使用转换流呢？</p>
<p>  1，源或者目的对应的<strong>设备是字节流</strong>，但是<strong>操作的却是文本数据</strong>，可以使用转换流作为<strong>桥梁</strong>，提高对文本操作的便捷。</p>
<p>2，一旦操作文本涉及到具体的<strong>指定编码表</strong>，必须使用转换流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字节流加码表变成字符流。</span></span><br><span class="line">		OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"gbk_3.txt"</span>),<span class="string">"GBK"</span>);<span class="comment">//字符转字节，传入字节流</span></span><br><span class="line">		FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"gbk_1.txt"</span>);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 这两句代码的功能是等同的。</span></span><br><span class="line"><span class="comment">		 * FileWriter：其实就是转换流指定了本机默认码表的体现，而且这个转换流的子类对象，可以方便操作文本文件。</span></span><br><span class="line"><span class="comment">		 * 	简单说：操作文件的字节流+本机默认的编码表。</span></span><br><span class="line"><span class="comment">		 * 	这是按照默认码表来操作文件的便捷类。</span></span><br><span class="line"><span class="comment">		 * 如果操作文本文件需要明确具体的编码，FileWriter就不行了。必须用转换流。</span></span><br><span class="line"><span class="comment">		 */</span></span><br></pre></td></tr></table></figure>

<h4 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h4><p>当想把<strong>数据保持原样</strong>，使用打印流最方便。按照需求使用，如果要保证文件的大小，使用之前的输出流，如果要保持数据原样，使用打印流。打印流只负责<strong>目的</strong>。</p>
<p>PrintWriter与PrintStream</p>
<p><strong>PrintStream</strong></p>
<p>System.out类型就为PrintStream类型。PrintStream为其他输出流添加了功能，使他们能够方便的打印各种数据值表现形式。<strong>不抛出IO异常</strong>。在需要写入<strong>字符</strong>而不是写入字节的情况下，应该使用PrintWriter。</p>
<p>1，提供了打印的放法，可以对多种数据类型值打印。并保持数据的表示形式。</p>
<p>2，它不抛IO异常。</p>
<p>构造函数，接收三种类型的值</p>
<p>1， 字符串路径</p>
<p>2， File对象</p>
<p>3， 字节输出流</p>
<p><strong>write</strong>只写<strong>最低8位</strong>，print将值变为字符串再打印，保持<strong>原样</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入int为32位，只保留后8位，将前24位截取，这样在记事本中表现为a</span></span><br><span class="line">		out.write(<span class="number">97</span>);<span class="comment">//记事本中打开为a</span></span><br><span class="line">		<span class="comment">//print原理为将要打印的值变为字符串，保持原样将数据打印到目的地</span></span><br><span class="line">		out.print(<span class="number">97</span>);</span><br></pre></td></tr></table></figure>

<p><strong>PrintWriter</strong></p>
<p>之后用的很多，服务端所用的就为PrintWriter。</p>
<p>构造函数参数：</p>
<p>1， 字符串路径</p>
<p>2， File对象</p>
<p>3， 字节输出流</p>
<p>4， 字符输出流</p>
<p>直接用println方法写入数据</p>
<p><strong>public</strong> PrintWriter(OutputStream out,<strong>boolean</strong> autoFlush)</p>
<p><strong>public</strong> PrintWriter(Writer out, <strong>boolean</strong> autoFlush)</p>
<p>如果传入true，println,printf,format方法将刷新缓冲区。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		<span class="comment">//读键盘</span></span><br><span class="line">		BufferedReader bufr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		<span class="comment">//输出到控制台</span></span><br><span class="line"><span class="comment">//		PrintWriter out = new PrintWriter(System.out,true);</span></span><br><span class="line">		<span class="comment">//如果想要写入到文件中，如果直接使用字符串路径则不能自动刷新，这样使用流对象封装即可。</span></span><br><span class="line">		PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">"out.txt"</span>),<span class="keyword">true</span>);</span><br><span class="line">		String line = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span>((line=bufr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="comment">//如果不定义结束标记，则无法结束。</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="string">"over"</span>.equals(line))</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//自定义结束标记</span></span><br><span class="line">			out.println(line.toUpperCase());</span><br><span class="line">			<span class="comment">//缓冲区记得刷新。</span></span><br><span class="line"><span class="comment">//			out.flush();</span></span><br><span class="line">		&#125;</span><br><span class="line">		out.close();</span><br><span class="line">		bufr.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="序列流"><a href="#序列流" class="headerlink" title="序列流"></a>序列流</h4><p>SequenceInputStream</p>
<p>序列流只负责源。</p>
<p>​    将多个输入流合并为一个流。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC22%E5%A4%A96.png" class title="This is an example image">

<p>将最后一个流的-1作为整个流的-1。</p>
<p>SequenceInputStream(Enumeration&lt;? <strong>extends</strong> InputStream&gt; e) </p>
<p>  初始化新创建 SequenceInputStream通过记住参数，它必须是一个 Enumeration产生对象，它们的运行时类型是 InputStream 。   </p>
<p>  构造器有两种，一种是传入参数为两个字节输入流，一个是字节输入流的枚举。而Vector中有枚举，直接使用Vecor效率太低于是使用ArrayList。但是只能获取迭代器，这样便想到去new一个迭代器，需要去实现其方法，因为与迭代器只有名称不一样，因此可以利用获取的迭代器方法来实现枚举。如果用匿名内部类来实现，而内部类使用临时变量，此临时变量需要被final修饰。但是这样比较麻烦，于是想到去Collections集合工具类中找方法，此方法返回枚举，接收集合对象，可以使用集合对象的方法，于是可以使用</p>
<p>​    Enumeration<FileInputStream> en = Collections.<em>enumeration</em>(集合);</FileInputStream></p>
<p>这样可以有一种思路，即相同功能对象可以利用另一个的方法来实现自身，而不用自己去实现。</p>
<h4 id="文件切割"><a href="#文件切割" class="headerlink" title="文件切割"></a>文件切割</h4><p>​    要切几个文件用几个输出流。</p>
<p>​    如果要将文件存入指定路径，可以将路径与文件后缀名封装成文件对象，因为文件对象的构造器中可以加入文件对象。</p>
<h4 id="文件合并"><a href="#文件合并" class="headerlink" title="文件合并"></a>文件合并</h4><p>​    如果要将多个文件写入同一个文件或者将文件碎片合并到一个文件，要用到序列流。序列流需要用到枚举，而枚举可以通过集合获取到。先将字节输入流存入ArrayList集合，然后用Collections工具类获取集合的枚举。这样从序列流中将数据写入到指定的路径下。如果要指定路径+文件后缀名，可以new File(dir,”1.mp3”);</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h4 id="操作对象（装饰类）"><a href="#操作对象（装饰类）" class="headerlink" title="操作对象（装饰类）"></a>操作对象（装饰类）</h4><p>ObjectInputStream与ObjectOutputStream，操作对象的流。</p>
<p>​    把对象生命周期延迟，存储在硬盘上实现持久化。把对象从堆内存存储在了硬盘上。</p>
<p><strong>ObjectOutputStream</strong></p>
<p>为了实现额外功能，相当于装饰类，将字节流对象关联。</p>
<p>序列化的条件为：</p>
<ol>
<li>要存储的对象必须实现Serializable接口</li>
<li>该类的所有属性要是可序列化的。如果有一个属性是不需要可序列化的，该属性需要注明是瞬态的，使用<code>transient</code>关键字说明</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeObj</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//基础的输出流没办法存储对象，因此需要装饰类。将输出流传入对象输出流即可。</span></span><br><span class="line">		<span class="comment">//后缀名使用object</span></span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"obj.object"</span>));</span><br><span class="line">		<span class="comment">//对象序列化。被序列化的对象必须实现Serializable接口</span></span><br><span class="line">		oos.writeObject(<span class="keyword">new</span> Person(<span class="number">30</span>, <span class="string">"小强"</span>));</span><br><span class="line">		<span class="comment">//关流</span></span><br><span class="line">		oos.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ObjectInputStream</strong></p>
<p>​    ObjectInputStream对以前使用ObjectOutputStream写入的基本数据和对象进行<strong>反序列化</strong>。只能读ObjectOutputStream写入的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对象读取流，因为是增强功能因此要传入字节输入流。</span></span><br><span class="line">		ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"obj.object"</span>));</span><br><span class="line">		<span class="comment">//需要有读出对象的class文件才能获得对象。</span></span><br><span class="line">		<span class="comment">//对象的反序列化。</span></span><br><span class="line">		Person p = (Person)ois.readObject();</span><br><span class="line">		System.out.println(p.getName()+<span class="string">":"</span>+p.getAge());</span><br><span class="line">		ois.close();<span class="comment">//关流</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>因为一次只能读一个对象，因此如果想多读几个对象，可使用以下方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">		Person p = (Person) ois.readObject();</span><br><span class="line">		System.out.println(p.getName() + <span class="string">":"</span> + p.getAge());</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (EOFException e) &#123;</span><br><span class="line">	</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	ois.close();<span class="comment">// 关流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h4><p>如果用原来的class文件，用更改后的类来接收，会报错，异常为InvalidClassException。</p>
<p>类实现Serializable接口，Serializable为标记接口，序列化运行时使用称为<code>serialVersionUID</code>的版本号与每个可序列化类相关联。该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。如果接收者加载类的ID号与发送者的类的<strong>版本号不同</strong>，反序列化会导致InvalidClassException。</p>
<p>因此Serializable用于给被序列化的类加入ID号。用于判断类和对象是否是同一个版本。如果可序列化类未显示声明serialVersionUID，则序列化运行时将基于该类的各个方面计算该类的默认serialVersionUID。强烈建议所有可序列化都<strong>显示声明</strong><code>serialVersionUID</code>值，因为计算默认ID对类的详细信息有较高的敏感性，根据编译期的不同可能千差万别。</p>
<p>一个可序列化的类可以通过声明一个名为”serialVersionUID”的字段来显式地声明它自己的serialVersionUID，该字段必须是static，final和long类型</p>
<p>  <strong>private</strong> <strong>static</strong> <strong>final</strong> <strong>long</strong> serialVersionUID = 9527L;</p>
<p>  <strong>只要ID号一样，就算类文件变化了，那就依然可以读出</strong>，在服务器上可能会用到。</p>
<h4 id="无法被写入的属性-static-transient"><a href="#无法被写入的属性-static-transient" class="headerlink" title="无法被写入的属性(static transient)"></a>无法被写入的属性(static transient)</h4><p><strong>静态修饰</strong></p>
<p>如果类中某一属性被静态修饰，则堆内存中没有此属性，因此无法被写入到对象中。对象输出流只能写入非静态的属性和非瞬态的。</p>
<p>原因：</p>
<ul>
<li>静态优先与非静态加载到内存中，被static修饰的成员变量不能被序列化，序列化的都是对象</li>
</ul>
<p><strong>transient关键字</strong></p>
<p>​    短暂的，暂时的。如果某一属性不是公用的，不能被static修饰，但是又不想写到对象中，可以使用transient关键字。</p>
<p><strong>非静态数据不想被序列化</strong>可以使用这个关键字修饰。</p>
<h4 id="序列化集合"><a href="#序列化集合" class="headerlink" title="序列化集合"></a>序列化集合</h4><p>若要将对象存储在集合中，再进行序列化，需要将可序列化的对象存入集合，然后用序列化流的写Object方法写入，再用反序列化流的读Object方法读，要注意的是，方法为writeObject()和readObject()！！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//用集合存储对象，并以对象流的方式存入数据，再将其读取出来</span></span><br><span class="line">    <span class="comment">//1、定义集合，将对象存入</span></span><br><span class="line">    ArrayList&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">1</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Person(<span class="string">"张二"</span>,<span class="number">2</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Person(<span class="string">"张一"</span>,<span class="number">3</span>));</span><br><span class="line">    <span class="comment">//2、将对象流关联输出文件字节流</span></span><br><span class="line">    ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"test.txt"</span>)));</span><br><span class="line">    <span class="comment">//3、将集合序列化至指定地方</span></span><br><span class="line">    os.writeObject(list);</span><br><span class="line">    <span class="comment">//4、创建反序列化流，从指定地方读取</span></span><br><span class="line">    ObjectInputStream oj = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>));</span><br><span class="line">    <span class="comment">//5、从反序列化流中读取对象</span></span><br><span class="line">    Object o = oj.readObject();</span><br><span class="line">    ArrayList&lt;Person&gt; list2 = (ArrayList&lt;Person&gt;)o;</span><br><span class="line">    <span class="comment">//6、遍历集合，读取数据</span></span><br><span class="line">    <span class="keyword">for</span> (Person person : list2) &#123;</span><br><span class="line">        System.out.println(person.name+<span class="string">" "</span>+person.age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7、释放资源</span></span><br><span class="line">    os.close();</span><br><span class="line">    oj.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p>​    IO流只能操作文件中的数据。</p>
<p>而File类用来将文件或者文件夹封装成对象，方便对文件与文件夹的属性信息进行操作。</p>
<p>File对象可以作为参数传递给流的构造函数。</p>
<h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以将一个已存在的，或者不存在的文件或目录封装成File对象。</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">File file2 = <span class="keyword">new</span> File(<span class="string">"d:\\"</span>,<span class="string">"a.txt"</span>);<span class="comment">//从父路径名字符串和子路径名字符串创建新的 File实例</span></span><br><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"d:\\"</span>);<span class="comment">//加两个反斜杠才能正常读出</span></span><br><span class="line">File f3 = <span class="keyword">new</span> File(f,<span class="string">"a.txt"</span>);<span class="comment">//从父抽象路径名和子路径名字符串创建新的 File实例</span></span><br></pre></td></tr></table></figure>

<p>不同的操作系统分隔符不一样。之前在系统类中使用字段file.separator获取分隔符。现在使用File.separator来获取分隔符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为了系统兼容，使用System.getProperty("file.separator")</span></span><br><span class="line">		String sep = System.getProperty(<span class="string">"file.separator"</span>);<span class="comment">//之前写法</span></span><br><span class="line">		String newsep = File.separator;</span><br><span class="line">		File f4 = <span class="keyword">new</span> File(<span class="string">"d:\\"</span>+newsep+<span class="string">"a.txt"</span>);</span><br><span class="line">		System.out.println(f4);</span><br></pre></td></tr></table></figure>

<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p><strong>获取修改时间</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作用：判断修改时间，加载修改后的新文件</span></span><br><span class="line">		<span class="keyword">long</span> time = file.lastModified();<span class="comment">//最后修改时间</span></span><br><span class="line">		<span class="comment">//将毫秒值转变为Date对象</span></span><br><span class="line">		Date date = <span class="keyword">new</span> Date(time);</span><br><span class="line">		<span class="comment">//日期格式化对象</span></span><br><span class="line">		DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG,DateFormat.LONG);</span><br><span class="line">		<span class="comment">//将日期对象转成String，用format方法。</span></span><br><span class="line">		String str_time = dateFormat.format(date);</span><br></pre></td></tr></table></figure>

<p>File对象的常用方法</p>
<p>1，<strong>获取</strong></p>
<p>  1.1获取文件名称 </p>
<p>​    String getName();</p>
<p>  1.2获取文件路径 </p>
<p>​    String getPath();</p>
<p>String getAbsolutePath();</p>
<p>  1.3获取文件大小 </p>
<p>​     long length();</p>
<p>  1.4获取文件修改时间 </p>
<p>​     long lastModified()得到毫秒值</p>
<p>2，<strong>创建与删除</strong></p>
<p>  如果文件或目录存在就不会创建。</p>
<p>  delete慎用，删除成功无法从回收站中找回。</p>
<p>  delete无法删除原因：</p>
<p>​    文件夹中有目录；正在被流使用</p>
<p>   2.1 文件创建 </p>
<p>​     boolean createNewFile();</p>
<p>​    和输出流不一样，如果文件不存在，则创建；如果文件存在，则不创建。</p>
<p>   2.2 文件删除</p>
<p>​     boolean delete();</p>
<p>   2.3 文件夹创建</p>
<p>​     boolean mkdir();//make directory</p>
<p>​     boolean mkdirs();//创建多级目录文件夹</p>
<p>   2.4 文件夹删除</p>
<p>​     boolean delete();//如果文件夹中有目录无法删除</p>
<p>​    如果是多级目录下的文件，则只删掉最子集的目录，前面的父目录无法删掉。</p>
<p>3，<strong>判断</strong>(很实用)</p>
<p>  在判断是否为文件或者是否是目录之前，要判断其是否存在。</p>
<p>​     boolean exists();//是否存在</p>
<p>​     boolean isFile();//是否是文件</p>
<p>​     boolean isDirectory();//是否是目录</p>
<p>4，<strong>重命名</strong></p>
<p>   需要有2个File，第二个File为命名后的文件位置</p>
<p>​     Boolean renameTo(File file);</p>
<p>   相当于剪切操作，可以从一个盘符移动到另一个。先关联两个文件，然后用文件去调用方法</p>
<p>​     File f1 = new File(“d:\1.jpg”);</p>
<p>​     File f3 = new File(“d:\1\2.jpg”);</p>
<p>​     boolean b2 = f1.renameTo(f3);</p>
<p>​     System.out.println(“文件剪切是否成功”+b2);</p>
<p>5，<strong>系统根目录和容量获取</strong></p>
<p>​     static Files[] listRoots();//获取系统中所有盘符，静态方法</p>
<p>​     long getFreeSpace();//获取可用容量</p>
<p>​     long getTotalSpace();//获取总容量</p>
<p>​     long getUsableSpace();//获取虚拟机可用容量</p>
<p>6，<strong>获取目录内容及文件名过滤器</strong></p>
<p>实现<strong>FilenameFilter</strong>接口。使用<strong>list</strong>方法。</p>
<p>使用list只能获取当前目录下的<strong>名称</strong>。</p>
<p>​     String[] list();</p>
<p>String[] list(FilenameFilter filter) </p>
<blockquote>
<p>获取当前目录下的文件以及文件夹的名称，包含隐藏文件</p>
<p>调用list方法的File对象中封装的必须是目录。否则会发生空指针异常</p>
<p>如果访问的是系统级目录，也会发生空指针异常</p>
<p> 如果目录存在，但是没有内容，会返回一个数组，但是长度为0</p>
</blockquote>
<p>文件名过滤器：过滤文件名</p>
<p>调用list(FilenameFilter)，调用list方法时候需要传入指定的过滤器对象，过滤器需要实现accept方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"d:\\"</span>);</span><br><span class="line">		String[] names = file.list(<span class="keyword">new</span> FilterByName());</span><br><span class="line">过滤器</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterByName</span> <span class="keyword">implements</span> <span class="title">FilenameFilter</span> </span>&#123;</span><br><span class="line">	<span class="comment">//实现FilenameFilter接口</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">		System.out.println(dir+<span class="string">":"</span>+name);</span><br><span class="line">		<span class="keyword">return</span> name.endsWith(<span class="string">".zip"</span>);<span class="comment">//判断以什么结尾。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC22%E5%A4%A92.png" class title="This is an example image">

<p>过滤器原理，先调用list方法获取指定路径下的全部目录，将 其存进数组，遍历数组，只要符合FilenameFilter.accept(dir,name)条件的，就进行存储，如accept方法可使用name.endsWith(指定文件格式)。</p>
<p>​    如果需要对过滤器传入参数，需要对过滤器添加构造函数，过滤器持有一个私有的字符串变量，通过构造函数来获取字符串变量，然后accept方法进行判断。</p>
<p>7，<strong>获取目录下文件对象及过滤</strong></p>
<p>实现FileFilter接口。使用listFiles方法</p>
<p>File[] listFiles() </p>
<p>返回一个抽象路径名数组，表示由该抽象路径名表示的目录中的文件。 </p>
<p>File[] listFiles(FileFilter filter) </p>
<p>返回一个抽象路径名数组，表示由此抽象路径名表示的满足指定过滤器的目录中的文件和目录。 </p>
<p>File[] listFiles(FilenameFilter filter) </p>
<p>返回一个抽象路径名数组，表示由此抽象路径名表示的满足指定过滤器的目录中的文件和目录。</p>
<p>文件类型过滤器</p>
<p>  如可以过滤非隐藏文件</p>
<h4 id="深度遍历文件夹"><a href="#深度遍历文件夹" class="headerlink" title="深度遍历文件夹"></a>深度遍历文件夹</h4><p>思路：</p>
<p>1、 将待深度遍历的目录关联File对象</p>
<p>2、 使用自定义方法来获取其所有子目录及文件</p>
<p>3、 方法怎么弄呢？首先要获取该目录下所有文件数组，遍历此数组，如果是目录则使用自定义功能继续遍历，如果不是目录则将文件名输出。这样便实现了遍历输出。</p>
<p>4、 但是这样不美观，因此需要记录下每个目录的层级信息。不能直接在方法中定义一个数，因为每次调用方法都会将这个数重置，那么需要在递归时传递给下一次递归。则进入下一次递归后将层级++,便实现了层级信息的记录。</p>
<p>5、 那么要如何美观输出呢？每多一个层级，就多一点空格，因为不知有多少字符串，所以使用StringBuilder来实现可变字符串，依靠层级数信息来添加空格信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//1，将File与待深度遍历目录关联</span></span><br><span class="line">		File dir = <span class="keyword">new</span> File(<span class="string">"d:\\test"</span>);</span><br><span class="line">		<span class="comment">//调用自定义方法，获取所有子目录及文件	</span></span><br><span class="line">		listAll(dir,<span class="number">0</span>);<span class="comment">//需要在递归时传入当前层级数。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listAll</span><span class="params">(File dir,<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//输入当前目录的名字，为了层级结构增加level以美观输出。</span></span><br><span class="line">		System.out.println(getSpace(level)+dir.getName());</span><br><span class="line">		level++;<span class="comment">//每次进一次目录，层级加一</span></span><br><span class="line">		<span class="comment">//获取指定目录下当前所有的文件夹或者对象</span></span><br><span class="line">		<span class="comment">//因为需要对数组中文件操作，所以使用listFiles()方法。</span></span><br><span class="line">		File[] files = dir.listFiles();</span><br><span class="line">		<span class="comment">//遍历文件数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;files.length;x++)&#123;</span><br><span class="line">			<span class="comment">//是目录就继续遍历，递归。</span></span><br><span class="line">			<span class="keyword">if</span>(files[x].isDirectory())&#123;</span><br><span class="line">				listAll(files[x],level);<span class="comment">//传入待遍历目录及层数</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果不是目录就进行打印</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="comment">//同样为了美观层级输出使用自定义功能</span></span><br><span class="line">				System.out.println(getSpace(level)+files[x].getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//清晰显示每层的层级结构，因为字符串数组可变，使用StringBuilder。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSpace</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//只有在目录或文件前使用|--</span></span><br><span class="line">		sb.append(<span class="string">"|--"</span>);</span><br><span class="line">		<span class="comment">//每多一层目录加一个|  。</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;level;x++)&#123;</span><br><span class="line">			sb.insert(<span class="number">0</span>,<span class="string">"|  "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归：函数自身直接或间接调用自身。</p>
<p>一个功能在被重复使用并每次使用时参与运算的结果和上一次调用有关。这时可以用递归来解决问题。</p>
<p>注意：</p>
<p>  1，递归一定要明确条件，否则容易栈溢出。即最小收敛情况。</p>
<p>  2，注意一下递归的次数。太多次容易栈溢出。超过栈内存就会报错。</p>
<p>递归中单独定义变量，每次调用方法，各个方法都会持有该变量的引用，如果想让此变量被下一次递归使用，则要作为参数传递给下一次。</p>
<h4 id="二进制转换"><a href="#二进制转换" class="headerlink" title="二进制转换"></a><strong>二进制转换</strong></h4><p>调用时候最先出栈的先输出，因此先输出1%2，然后3%2，最后6%2，因此结果是110.如果toBin()在输出下面，那就是011,因为先输出6%2，3%2，1%2。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toBin</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			toBin(num/<span class="number">2</span>);</span><br><span class="line">			System.out.println(num%<span class="number">2</span>);	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="求和"><a href="#求和" class="headerlink" title="求和"></a><strong>求和</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(num==<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> num+getSum(num-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC22%E5%A4%A93.png" class title="This is an example image">

<p>递归图解：运行sum(5),sum(4),sum(3),sum(2),sum(1)，然后sum(1)出栈，返回1，sum(2)出栈，返回2+1，sum(3)出栈，返回3+3，sum(4)出栈，返回4+6，sum(5)出栈，返回5+10。</p>
<h3 id="Properties集合"><a href="#Properties集合" class="headerlink" title="Properties集合"></a>Properties集合</h3><p>Map</p>
<pre><code>|--Hashtable</code></pre><p>​            |–Properties:</p>
<p>Properties集合：</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>1，该集合中的键和值都是字符串类型。</p>
<p>2，集合中的数据可以保存在流中(store)，或者从流中获取(load)。</p>
<p>通常该集合用于操作以键值对形式存在的配置文件。</p>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><p>1，存储</p>
<p>单个存储</p>
<p>  Object setProperty(String key, String value); </p>
<p>  也可以用来覆盖，键相等，值覆盖 </p>
<p>  使用的是Hashtable的put方法</p>
<p>2，获取</p>
<p>  单个获取</p>
<p>  String getProperty(String key); </p>
<p>  全部获取（转为Set集合）</p>
<p>  Set<String> stringPropertyNames() </String></p>
<p>  返回此属性列表中的一组键，其中键及其对应的值为字符串，包括默认属性列表中的不同键，如果尚未从主属性列表中找到相同名称的键。 </p>
<p>3，与流对象关联</p>
<p>  public void list(PrintStream out);将此属性列表打印到指定的输出流。 此方法对调试非常有用。 </p>
<p>4，持久化存储</p>
<p>  可以关联字节流或字符流，comment为相关注释，不要写中文。</p>
<p>  void store(OutputStream out, String comments);</p>
<p>  void store(Writer writer, String comments)   </p>
<p>5，获取输入流</p>
<p>  <strong>void</strong> load(InputStream inStream) </p>
<p>​    从输入字节流读取属性列表（键和元素对）。</p>
<p>  <strong>void</strong> load(Reader reader) </p>
<p>​    以简单的线性格式从输入字符流读取属性列表（关键字和元素对）。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Properties集合的存和取</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">propertiesDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//创建一个Properties集合</span></span><br><span class="line">		Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">		<span class="comment">//存储元素</span></span><br><span class="line">		prop.setProperty(<span class="string">"zhangsan"</span>, <span class="string">"30"</span>);</span><br><span class="line">		prop.setProperty(<span class="string">"lisi"</span>, <span class="string">"31"</span>);</span><br><span class="line">		prop.setProperty(<span class="string">"zhaoliu"</span>, <span class="string">"28"</span>);</span><br><span class="line">		<span class="comment">//修改元素，键相等，值覆盖</span></span><br><span class="line">		prop.setProperty(<span class="string">"zhangsan"</span>, <span class="string">"26"</span>);</span><br><span class="line">		<span class="comment">//取出所有元素</span></span><br><span class="line">		Set&lt;String&gt; names = prop.stringPropertyNames();<span class="comment">//获取键值集合</span></span><br><span class="line">		<span class="keyword">for</span>(String name:names)&#123;</span><br><span class="line">			String value = prop.getProperty(name);</span><br><span class="line">			System.out.println(name+<span class="string">":"</span>+value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="获取系统信息"><a href="#获取系统信息" class="headerlink" title="获取系统信息"></a>获取系统信息</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取系统的键值信息</span></span><br><span class="line">		Properties prop = System.getProperties();</span><br><span class="line">		<span class="comment">//只能打印，不能获取</span></span><br><span class="line">		prop.list(System.out);</span><br></pre></td></tr></table></figure>

<h5 id="模拟load方法"><a href="#模拟load方法" class="headerlink" title="模拟load方法"></a>模拟load方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 模拟load方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myLoad</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">	Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">	<span class="comment">//字符流装饰类，用以提高效率</span></span><br><span class="line">	BufferedReader bufr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"info.txt"</span>));</span><br><span class="line">	<span class="comment">//按行读取</span></span><br><span class="line">	String line = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">while</span>((line=bufr.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="comment">//因为开头包含注释信息，均以#开头，因此不存。</span></span><br><span class="line">		<span class="keyword">if</span>(line.startsWith(<span class="string">"#"</span>))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		String[] arr = line.split(<span class="string">"="</span>);</span><br><span class="line">		prop.setProperty(arr[<span class="number">0</span>], arr[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将集合打印到控制台输出。</span></span><br><span class="line">	prop.list(System.out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="从文件中获取配置信息"><a href="#从文件中获取配置信息" class="headerlink" title="从文件中获取配置信息"></a>从文件中获取配置信息</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">//集合中的数据来自于一个文件</span></span><br><span class="line"><span class="comment">//注意：必须要保证该文件中的数据是键值对</span></span><br><span class="line"><span class="comment">//需要使用到读取流</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"info.txt"</span>);</span><br><span class="line"><span class="comment">//使用load方法</span></span><br><span class="line">prop.load(fis);</span><br><span class="line">prop.list(System.out);<span class="comment">//打印到指定的输出流</span></span><br></pre></td></tr></table></figure>

<h4 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h4><p>简单配置用Properties，复杂配置使用XML。相当于标签。</p>
<p>简单配置</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC22%E5%A4%A94.png" class title="This is an example image">

<p>复杂配置</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC22%E5%A4%A95.png" class title="This is an example image">

<p>XML使用起来更为清晰。</p>
<h3 id="IO流其他类"><a href="#IO流其他类" class="headerlink" title="IO流其他类"></a>IO流其他类</h3><h4 id="RandomAccessFile（多线程写入）"><a href="#RandomAccessFile（多线程写入）" class="headerlink" title="RandomAccessFile（多线程写入）"></a>RandomAccessFile（多线程写入）</h4><p>随机访问文件。看到这个类的名字，纠结。父类为Object。不是IO体系中的子类。此类的实例支持对随机访问文件的读取和写入。随机访问文件的行为类似存储在文件系统中的一个大型byte数组。</p>
<p>​    利用seek方法修改指针位置，即可实现在指定位置的随机读写。一般要求数据有规律。</p>
<p>​    应用：利用多线程，对同一个文件分段同时写入数据。多线程写入。</p>
<p>特点：</p>
<p>1， 该对象既能读，又能写。</p>
<p>2， 该对象内部维护了一个大型byte数组，并通过指针可以操作数组中的元素。</p>
<p>3， 可以通过getFilePointer方法获取指针的位置，和通过seek方法设置指针的位置。</p>
<p>4， 其实该对象就是字节输入流和输出流进行了封装。</p>
<p>5， 该对象的源或者目的只能是文件。通过构造函数就可以看出。</p>
<p>6，如果文件不存在，则创建；如果文件存在，不创建。</p>
<p>构造方法</p>
<p>  RandomAccessFile(File file, String mode) 创建一个随机访问文件流，从File参数指定的文件读取，并可选地写入。 </p>
<p>  RandomAccessFile(String name, String mode) 创建随机访问文件流，以从中指定名称的文件读取，并可选择写入文件。</p>
<p>mode的含义</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC22%E5%A4%A97.png" class title="This is an example image">

<p>局限性：<strong>目的只能是文件</strong>，不能是其他输出流。</p>
<p>write(byte b)，如果传入String类型，需要用getBytes()方法转成字节。</p>
<p>​    按字节写入，如果传入一个比较大的int类型数，会被截断。</p>
<p><strong>读写方法</strong></p>
<p><strong>void</strong> write(<strong>byte</strong>[] b) 从指定的字节数组写入 b.length个字节到该文件，从当前文件指针开始。 </p>
<p><strong>void</strong> writeInt(<strong>int</strong> v) 将 int写入文件为四个字节，高字节为首。 </p>
<p><strong>int</strong> read(<strong>byte</strong>[] b) 从该文件读取最多 b.length个字节的数据到一个字节数组。 </p>
<p><strong>int</strong> readInt() 从该文件读取一个带符号的32位整数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用RandomAccessFile对象写入一些人员信息，比如姓名和年龄。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">		<span class="comment">//可以读也可以写</span></span><br><span class="line">		RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"ranacc.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">		raf.write(<span class="string">"张三"</span>.getBytes());</span><br><span class="line">		raf.writeInt(<span class="number">97</span>);</span><br><span class="line">		raf.write(<span class="string">"小强"</span>.getBytes());</span><br><span class="line">		raf.writeInt(<span class="number">99</span>);</span><br><span class="line">		raf.close();<span class="comment">//关流</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"ranacc.txt"</span>, <span class="string">"r"</span>);<span class="comment">//只读即可</span></span><br><span class="line">		<span class="comment">//通过seek设置指针的位置。</span></span><br><span class="line">		raf.seek(<span class="number">1</span>*<span class="number">8</span>);<span class="comment">//随机的读取，只要指定指针的位置即可</span></span><br><span class="line">		<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">		raf.read(buf);</span><br><span class="line">		<span class="comment">//将字节数组变成字符串</span></span><br><span class="line">		String name = <span class="keyword">new</span> String(buf);</span><br><span class="line">		<span class="keyword">int</span> age = raf.readInt();</span><br><span class="line">		System.out.println(<span class="string">"name:"</span>+name);</span><br><span class="line">		System.out.println(<span class="string">"age:"</span>+age);</span><br><span class="line">		System.out.println(raf.getFilePointer());</span><br><span class="line">		<span class="comment">//关流</span></span><br><span class="line">		raf.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>随机读写</strong></p>
<p>​    通过seek方法可以随时设置指针的位置，可以实现随机的读取，只要指定指针的位置即可。</p>
<p>​    因为数据都在byte数组里面存着，因此如果某位置有数据，因此如果再从0写入，会将原来的数据进行覆盖。因此可以修改数据。</p>
<p>​    再设置seek方法，将数据写在想要的位置即可。</p>
<h4 id="管道流"><a href="#管道流" class="headerlink" title="管道流"></a>管道流</h4><p>​    PipedInputStream和PipedOutputStream。</p>
<p>​    将两个流关流，只读指定流的数据。</p>
<p>​    输入输出可以直接进行连接，通过结合<strong>多线程</strong>使用。</p>
<p>管道输入流应连接到管道输出流; 管道输入流然后提供写入管道输出流的任何数据字节。通常，一个线程从PipedInputStream对象读取数据，并且其他线程将数据写入相应的PipedOutputStream 。 不建议尝试从单个线程使用这两个对象，因为它可能会使线程死锁。 管道输入流包含一个缓冲区，在读取操作中将读取操作与限制内的操作相分离。 如果向连接的管道输出流提供数据字节的线程不再存在， 则称管道为broken 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipedStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//创建管道流。</span></span><br><span class="line">		PipedInputStream input = <span class="keyword">new</span> PipedInputStream();</span><br><span class="line">		PipedOutputStream output = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">		<span class="comment">//管道流连接，使用初始化或者connect</span></span><br><span class="line">		input.connect(output);</span><br><span class="line">		<span class="comment">//不能使用单线程，因为读为阻塞任务，容易死锁。</span></span><br><span class="line">		<span class="comment">//开启线程，将线程任务传入</span></span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Input(input)).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Output(output)).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> PipedInputStream in;</span><br><span class="line">	Input(PipedInputStream in)&#123;</span><br><span class="line">		<span class="keyword">this</span>.in = in;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//异常不能往外抛</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">			<span class="keyword">int</span> len = in.read(buf);</span><br><span class="line">			String s = <span class="keyword">new</span> String(buf,<span class="number">0</span>,len);</span><br><span class="line">			System.out.println(<span class="string">"s="</span>+s);</span><br><span class="line">			in.close();<span class="comment">//关流</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Output</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> PipedOutputStream out;</span><br><span class="line">	Output(PipedOutputStream out)&#123;</span><br><span class="line">		<span class="keyword">this</span>.out = out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">			out.write(<span class="string">"hi，管道来了"</span>.getBytes());</span><br><span class="line">			out.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="操作基本数据类型（装饰类）"><a href="#操作基本数据类型（装饰类）" class="headerlink" title="操作基本数据类型（装饰类）"></a>操作基本数据类型（装饰类）</h4><p>​    DataInputStream与DataOutputStream。</p>
<p>​    用于操作<strong>基本数据类型</strong>。如果使用修改版UTF-8写入，则只有此流对应的方法才为你那个读入。</p>
<p>数据输入流允许应用程序以独立于机器的方式从基础输入流读取原始Java数据类型。 应用程序使用数据输出流来写入稍后可以被数据输入流读取的数据。</p>
<p>普通的write会将整数只保留后8位。</p>
<p>为装饰类，需要传入相应的字节输入流与字节输出流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeDate</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"data.txt"</span>));</span><br><span class="line">		<span class="comment">//UTF-8修改版，用转换流也读不了，只有这个流可以</span></span><br><span class="line">		dos.writeUTF(<span class="string">"你好"</span>);</span><br><span class="line">		dos.close();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readDate</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		DataInputStream dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"data.txt"</span>));</span><br><span class="line">		String str = dis.readUTF();</span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="操作字节数组（源、目的为内存）"><a href="#操作字节数组（源、目的为内存）" class="headerlink" title="操作字节数组（源、目的为内存）"></a>操作字节数组（源、目的为内存）</h5><p>​    一般操作的<strong>数据不大</strong>。</p>
<p>​    ByteArrayInputStream与ByteArrayOutputStream</p>
<p>​    源和目的都是<strong>内存</strong>。没有调用底层资源、</p>
<p>ByteArrayOutputStream该类实现了将数据写入字节数组的输出流。 当数据写入缓冲区时，<strong>缓冲区会自动增</strong>长。 可以使用toByteArray()和<strong>toString()</strong>检索数据。 </p>
<p><strong>关闭</strong>ByteArrayOutputStream<strong>没有任何效果</strong>。 在关闭流之后，仍可以调用此类中的方法，而不生成IOException 。 </p>
<p>A ByteArrayInputStream包含一个内部缓冲区，其中包含可以从流中读取的字节。 内部计数器跟踪由read方法提供的下一个字节。</p>
<p>关闭一个ByteArrayInputStream没有任何效果。 该流中的方法可以在流关闭后调用，而不生成IOException 。</p>
<p>输入流<strong>源就是数组</strong>。</p>
<h5 id="操作字符数组"><a href="#操作字符数组" class="headerlink" title="操作字符数组"></a>操作字符数组</h5><p>CharArrayReader与CharArrayWriter</p>
<p>源为字符数组。</p>
<h5 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h5><p>​    StringReader与StringWriter</p>
<p>​    源为字符串。</p>
<h3 id="编码表"><a href="#编码表" class="headerlink" title="编码表"></a>编码表</h3><p>​    编码表：将各个国家的文字用数字表示，并一一对应，形成一张表。</p>
<p>常见的编码表</p>
<p><strong>ASCII</strong>：美国标准信息交换码。</p>
<p>​    用一个字节的7位可以表示</p>
<p><strong>ISO8859-1</strong>：拉丁码表。欧洲码表</p>
<p>​    用一个字节的8位表示，兼容ASCII码表。</p>
<p><strong>GB2312</strong>：中国的中文编码表。</p>
<p><strong>GBK</strong>：中国的中文编码表升级，融合了更多的中文文字符号。</p>
<p><strong>Unicode</strong>：国际标准码，融合了多种文字。</p>
<p>​    所有文字都用两个字节表示，Java语言使用的就是unicode</p>
<p><strong>UTF-8</strong>：最多用三个字节来表示一个字符。Unicode to其他，如果可以用一个字节装下（ASCII码）用一个，两个装的下用两个，三个装的下用三个。</p>
<h4 id="编码解码"><a href="#编码解码" class="headerlink" title="编码解码"></a>编码解码</h4><h5 id="简单编码解码"><a href="#简单编码解码" class="headerlink" title="简单编码解码"></a>简单编码解码</h5><p>利用getBytes(编码名)和new String(byte[] b,编码名)来分别实现编码和解码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 字符串--&gt;字节数组：编码。</span></span><br><span class="line"><span class="comment">		 * 字节数组--&gt;字符串：解码。</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 你好：GBK：-60 -29 -70 -61</span></span><br><span class="line"><span class="comment">		 * 	负数因为一个中文2个字节，而这个字节是很大，以1打头，因此是负数。</span></span><br><span class="line"><span class="comment">		 * 你好：utf-8：-28 -67 -96 -27 -91 -67 </span></span><br><span class="line"><span class="comment">		 * 	六个字节，一个汉字用3个字节表示</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//如果是char类型，使用unicode码完成</span></span><br><span class="line">		<span class="comment">//字符串编码按照本地的编码来</span></span><br><span class="line">		String str = <span class="string">"你好"</span>;</span><br><span class="line">		<span class="comment">//编码</span></span><br><span class="line">		<span class="keyword">byte</span>[] buf = str.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">		<span class="comment">//解码</span></span><br><span class="line">		String s1 = <span class="keyword">new</span> String(buf,<span class="string">"UTF-8"</span>);</span><br><span class="line">		System.out.println(s1);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="编码解码问题"><a href="#编码解码问题" class="headerlink" title="编码解码问题"></a>编码解码问题</h5><p>​    如果编码编错了，解不出来。如果编对了，解错了，有可能有救。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC24%E5%A4%A91.png" class title="This is an example image">

<p>当你好用GBK编码，获得4个数，用iso8859-1解码，获取4个未知字符，再利用iso8859-1对四个未知字符进行编码，获取4位数字，然后利用GBK进行解码，获得你好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串编码按照本地的编码来</span></span><br><span class="line">		String str = <span class="string">"你好"</span>;</span><br><span class="line">		<span class="comment">//编码</span></span><br><span class="line">		<span class="keyword">byte</span>[] buf = str.getBytes(<span class="string">"gbk"</span>);</span><br><span class="line">		<span class="comment">//解码</span></span><br><span class="line">		String s1 = <span class="keyword">new</span> String(buf,<span class="string">"iso8859-1"</span>);</span><br><span class="line">		System.out.println(s1);</span><br><span class="line">		<span class="comment">//获取源字节</span></span><br><span class="line">		<span class="keyword">byte</span>[] buf2 = s1.getBytes(<span class="string">"iso8859-1"</span>);</span><br><span class="line">		String s2 = <span class="keyword">new</span> String(buf2,<span class="string">"GBK"</span>);</span><br><span class="line">		System.out.println(s2);</span><br></pre></td></tr></table></figure>

<p>一种应用</p>
<p>  当数据从本地提交到服务器，在服务器先解码然后以流的形式传回，但是不是中文编码，因此先用服务器自己的编码表再编码一次，然后用GBK解码，就可以得到想要的信息。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC24%E5%A4%A92.png" class title="This is an example image">

<p>如果使用utf-8先解码再编码，很有可能会解码失败，因为使用GBK获取的数字在utf-8中找不到对应的码，因此会变成未知字符，此时码已经发生了变化，因此就无法被还原。而使用iso8859-1可以还原是因为里面没有用到中文而且都是单字节编码。</p>
<h5 id="UTF-8编码"><a href="#UTF-8编码" class="headerlink" title="UTF-8编码"></a>UTF-8编码</h5><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC24%E5%A4%A93.png" class title="This is an example image">

<p>一个字节时，打头位固定为1,2个字节时，前几位也为固定位。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC24%E5%A4%A94.png" class title="This is an example image">

<p>当字节流读数据，读到第一个字节开头为110，然后读第二个字节开头为10，马上去查表。然后读到0，读一个字节就去查表。然后毒药1110，再读10，再读10，然后去查表。</p>
<p>​    一个字节，打头为0；两个字节，打头为2个1，三个字节，打头为3个1。</p>
<h5 id="联通问题"><a href="#联通问题" class="headerlink" title="联通问题"></a>联通问题</h5><p>​    联通在记事本中打开为乱码。解码出了问题。因为联通写入记事本，默认的是使用UTF-8存入，解码的时候也使用UTF-8。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	String str = <span class="string">"联通"</span>;</span><br><span class="line">	<span class="comment">//联通的GBK编码与UTF-8的编码规则相冲突。</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 11000001</span></span><br><span class="line"><span class="comment">	 * 10101010</span></span><br><span class="line"><span class="comment">	 * 11001101</span></span><br><span class="line"><span class="comment">	 * 10101000</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">byte</span>[] buf = str.getBytes();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">byte</span> b:buf)</span><br><span class="line">		System.out.println(Integer.toBinaryString(b&amp;<span class="number">255</span>));<span class="comment">//取单字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="网络模型概述"><a href="#网络模型概述" class="headerlink" title="网络模型概述"></a>网络模型概述</h4><p>OSI（Open System Interconnection开放系统互联）参考模型</p>
<p>TCP/IP模型</p>
<p>七层模型</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC26%E5%A4%A91.png" class title="This is an example image">

<p><strong>1层物理层</strong>：主要定义物理设备标准，如<strong>网线</strong>的接口类型、光纤的接口类型、各种<strong>传输介质</strong>的传输速率等。它的主要作用是<strong>传输比特流</strong>（就是1、0转化为电流强弱来进行传输，到大目的后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做<strong>比特</strong>。</p>
<p><strong>2层数据链路层</strong>：主要将从物理层接收的数据进行<strong>MAC地址</strong>（网卡的地址，每个网卡<strong>唯一</strong>）的封装与解封装。常把这一层的数据叫做<strong>帧</strong>。这一层工作的设备是<strong>交换机</strong>（实现互联），数据通过交换机来传输。</p>
<p><strong>3层网络层</strong>：主要将从下层接收到的数据进行<strong>IP地址</strong>（例192.168.0.1）的封装与解封装。看数据到底发向哪一台主机。在这一层工作的设备是<strong>路由器</strong>（数据包方向的定义），常把这一层的数据叫做<strong>数据包</strong>。</p>
<p><strong>4层传输层</strong>：定义了一些传输数据的<strong>协议</strong>和<strong>端口号</strong>（WWW端口80等），如：<strong>TCP</strong>（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），<strong>UDP</strong>（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做<strong>段</strong>。</p>
<p><strong>5会话层</strong>：通过传输层（端口号：传输端口与接收端口）<strong>建立数据传输的通路</strong>。主要在你的系统之间发起会话或者接收会话请求（设备之间需要互相认识，可以使IP也可以是MAC或者是主机名）</p>
<p><strong>6表示层</strong>：主要是进行对接收的数据进行<strong>解释</strong>、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转成人能识别的东西（如图片、声音等））。</p>
<p><strong>7应用层</strong>：主要是一些<strong>终端的应用</strong>（应用软件），比如FTP（各种文件下载），WEB（IE浏览），QQ之类的（可以把它理解成我们在电脑屏幕上可以看到的东西，就是终端应用）。</p>
<p>对数据加上每一层的标识，便于解析。逐层包装标识（<strong>封包</strong>），逐层解析（<strong>拆包</strong>）。</p>
<p>七层模型过于繁琐，因此有了TCP/IP参考模型。</p>
<p>1主机至网络层：物理层+数据链路层。（交换机为一部分）</p>
<p>2<strong>网际层</strong>：网络层</p>
<p>3<strong>传输层</strong>：原传输层（<strong>重要</strong>）</p>
<p>5   应用层：会话层+表示层+应用层。（Java Web开发）</p>
<h4 id="网络通讯要素"><a href="#网络通讯要素" class="headerlink" title="网络通讯要素"></a>网络通讯要素</h4><p>​    IP地址</p>
<p>​    端口号</p>
<p>​    传输协议</p>
<h5 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h5><p>​    IPV4：有4段，一段的最大值为一个Byte，即2^8，0-255。最大值为255。</p>
<p>​    IPV6：融入了字母。因为地址够用，因此很多设备都可以拥有独立的IP地址，物联网的时代。</p>
<p>IP地址：<strong>InetAddress</strong></p>
<p>​    网络中设备的表示</p>
<p>​    不易记忆，可用主机名</p>
<p>​    本地回环地址：127.0.0.1 主机名：localhost 用于在没有互联网时<strong>本机访问本机</strong>。如果ping本机地址有问题，网卡可能出问题了。<strong>测试网卡</strong>。</p>
<h5 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a><strong>InetAddress</strong></h5><p>​    存在于网际层。</p>
<p>​    可以通过主机名称或者主机地址字符串获得ip对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取本地主机IP地址对象</span></span><br><span class="line">		InetAddress ip = InetAddress.getLocalHost();</span><br><span class="line">		<span class="comment">//获取其他主机的IP地址对象</span></span><br><span class="line">		ip = InetAddress.getByName(<span class="string">"172.21.21.196"</span>);</span><br><span class="line">		ip = InetAddress.getByName(<span class="string">"DESKTOP-L0U8999"</span>);</span><br><span class="line">		ip = InetAddress.getByName(<span class="string">"www.baidu.com"</span>);</span><br><span class="line">		<span class="comment">//获取IP地址更多</span></span><br><span class="line">		System.out.println(ip.getHostAddress());</span><br><span class="line">		System.out.println(ip.getHostName());</span><br></pre></td></tr></table></figure>

<p>IP地址太多记不住，给主机命名，记住名字即可。</p>
<p>com一般属于商业化组织，营利性；org属于非营利性。</p>
<p>cn标识所属国家类别。</p>
<p>IP地址与名字有对应关系，互联网上公共的服务器中存放着IP地址和名称的对应关系。叫做<strong>域名解析DNS</strong>，机器叫域名解析服务器（记住了IP地址）。不指定DNS解析地址，宽带服务商解析，信息发给他，他再发给DNS服务器。</p>
<p>  现在一个IP地址可能分配给多台主机使用。</p>
<p>  如果想提高解析速度，可以在本机中创建域名解析列表。即<strong>host</strong>文件，本地域名解析列表。域名解析最先走的为本地解析列表，如果解析失败再走互联网的解析。自己可以创建对应名称来访问本机，其他人使用此host文件中的域名或地址无法访问到本主机，因为其机器上没有此列表。如果想在局域网中所有人都可以使用此解析列表，可以在某台主机上使用DNS解析软件，然后其他主机的DNS解析地址指向此主机即可。</p>
<p>  如果想屏蔽某些网站，可以将其域名与本地ip地址127.0.0.1关联，这样可以屏蔽公共解析，指向本地解析。</p>
<p>IP地址：192.168.1.1</p>
<p>子网掩码：255.255.255.0</p>
<p>子网掩码前3个均为255，代码IP地址前三位均为网络位，最后一位为IP地址位。从0-255,0代表网络位，不可用，因此1-254可用，255不属于IP地址而是广播地址。如果发到192.168.1.255，代表把消息发到192.168.1.0网络上所有存活的机器上。</p>
<h5 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h5><p>逻辑端口，给应用程序分配数字标识。</p>
<p>​    用于标识进程的逻辑地址，不同进程的标识。</p>
<p>​    有效端口：0<del>65535（2^16），其中0</del>1024系统使用或保留端口。</p>
<p>禁用端口：可以防止某些应用程序禁用互联网。</p>
<h5 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h5><p>​    通讯规则</p>
<p>​    常见协议：TCP，UDP</p>
<p>UDP</p>
<p>数据报文协议</p>
<p>​    将数据及源和目的封装成数据包中，<strong>不需要建立连接</strong></p>
<p>​    每个数据报的大小限制在<strong>64k</strong>内</p>
<p>​    因无连接，是<strong>不可靠</strong>协议</p>
<p>​    不需要建立连接，<strong>速度快</strong></p>
<p>如QQ聊天，视频通讯。</p>
<p>TCP</p>
<p>传输控制协议。</p>
<p>​    建立连接，形成传输数据的通道</p>
<p>​    在连接中进行<strong>大数据量</strong>传输</p>
<p>​    通过<strong>三次握手</strong>完成连接，是可靠协议</p>
<p>​    必须建立连接，<strong>效率会稍低</strong></p>
<p>下载数据</p>
<h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p>插座，套接字</p>
<p>socket就是为网络服务提供的一种机制</p>
<p>通信的两端都有Socket</p>
<p>网络通信其实就是Socket间的通信</p>
<p>数据在两个Socket间通过IO传输。</p>
<h4 id="UDP传输"><a href="#UDP传输" class="headerlink" title="UDP传输"></a>UDP传输</h4><ul>
<li><p>DatagramSocket与DatagramPacket</p>
</li>
<li><p>建立发送端，接收端</p>
</li>
<li><p>建立数据包</p>
</li>
<li><p>调用Socket的发送接收方法</p>
</li>
<li><p>关闭Socket</p>
</li>
</ul>
<p>发送端与接收端是两个独立的运行程序</p>
<p>DtagramSocket：表示用于<strong>发送</strong>和<strong>接收</strong>数据报包的套接字。</p>
<p>​    可以直接new对象，有发送和接收数据包的方法。</p>
<p>DatagramPacket：表示数据报包数据报包实现无连接包投递服务。不对包投递做出保障。</p>
<p>​    构造时有的是发送的，有的是接收的。发送的数据包有目的地址，接收不需要。带有IP对象的均为用来发送的。发送多接收少。</p>
<p>UDP发送端与接收端哪个先连接都可以。</p>
<p>发送端指定的端口为接收端的端口，而接收端获取的端口为发送端的端口。</p>
<p>发送端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 创建UDP传输的发送端</span></span><br><span class="line"><span class="comment">		 * 思路：</span></span><br><span class="line"><span class="comment">		 * 1，建立UDP的Socket服务。</span></span><br><span class="line"><span class="comment">		 * 2，将要发送的数据封装到数据包中。</span></span><br><span class="line"><span class="comment">		 * 3，通过UDP的Socket服务将数据包发送出去</span></span><br><span class="line"><span class="comment">		 * 4，关闭Socket服务。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//1，UDP的Socket服务。使用DatagramSocket对象。</span></span><br><span class="line">		DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">8888</span>);<span class="comment">//明确发送端的端口号</span></span><br><span class="line">		<span class="comment">//2，将要发送的数据封装到数据包中。</span></span><br><span class="line">		String str = <span class="string">"中午吃什么？"</span>;</span><br><span class="line">			<span class="comment">//使用DatagramPacket将数据封装到该对象包中</span></span><br><span class="line">		<span class="keyword">byte</span>[] buf = str.getBytes();</span><br><span class="line">		<span class="comment">//将地址改为接收端的IP地址即可</span></span><br><span class="line">		DatagramPacket dp =</span><br><span class="line">				<span class="keyword">new</span> DatagramPacket(buf, buf.length, InetAddress.getLocalHost(), <span class="number">10000</span>);</span><br><span class="line">		<span class="comment">//3，通过UDP的Socket服务将数据包发送出去，使用send方法。</span></span><br><span class="line">		ds.send(dp);</span><br><span class="line">		<span class="comment">//4，关闭资源</span></span><br><span class="line">		ds.close();</span><br></pre></td></tr></table></figure>

<p>接收端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 建立UDP接收端的思路。</span></span><br><span class="line"><span class="comment">		 * 1，建立UDP的Socket服务，因为是要接收数据，必须要明确一个端口号。</span></span><br><span class="line"><span class="comment">		 * 2，创建数据包，用于存储接收到的数据。方便用数据包对象的方法解析这些数据。</span></span><br><span class="line"><span class="comment">		 * 3，使用Socket服务的receive方法将接收到的数据存储到数据包中。</span></span><br><span class="line"><span class="comment">		 * 4，通过数据包的方法解析数据包中的数据。</span></span><br><span class="line"><span class="comment">		 * 5，关闭资源。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//1，建立UDP的Socket服务</span></span><br><span class="line">		DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">10000</span>);<span class="comment">//明确接收的端口号</span></span><br><span class="line">		<span class="comment">//2，创建数据包</span></span><br><span class="line">		<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line">		<span class="comment">//3，使用接收方法将数据存储到数据包中</span></span><br><span class="line">		ds.receive(dp);<span class="comment">//阻塞式的。</span></span><br><span class="line">		<span class="comment">//4，通过数据包对象的方法，解析其中的数据，比如，地址，端口，数据内容。</span></span><br><span class="line">		String ip = dp.getAddress().getHostAddress();<span class="comment">//IP地址对象的字符串表示</span></span><br><span class="line">		<span class="keyword">int</span> port = dp.getPort();<span class="comment">//获得端口，发送端的端口</span></span><br><span class="line">		String text = <span class="keyword">new</span> String(dp.getData(),<span class="number">0</span>,dp.getLength());<span class="comment">//只取有效数据</span></span><br><span class="line">		System.out.println(ip+<span class="string">":"</span>+port+<span class="string">":"</span>+text);</span><br><span class="line">		<span class="comment">//5，关闭资源</span></span><br><span class="line">		ds.close();</span><br></pre></td></tr></table></figure>

<h4 id="TCP传输"><a href="#TCP传输" class="headerlink" title="TCP传输"></a>TCP传输</h4><ul>
<li><p>Socket和ServerSocket</p>
</li>
<li><p>建立客户端和服务器端</p>
</li>
<li><p>建立连接后，通过Socket中的IO流进行数据的传输</p>
</li>
<li><p>关闭Socket</p>
</li>
</ul>
<p>同样，客户端与服务器端是两个独立的应用程序。</p>
<p>Socket类实现客户端套接字。ServerSocket类实现服务器套接字。</p>
<p>客户端向服务端发送信息建立通道，通道建立后服务器端向客户端发送信息。</p>
<p>客户端一般初始化时要指定对方的IP地址和端口，IP地址可以是IP对象，也可以是IP对象字符串表现形式。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC26%E5%A4%A92.png" class title="This is an example image">

<p>建立通道后，信息传输通过Socket流，为底层建立好的，又有输入和输出，想要获取输入或输出流对象，找Socket来获取。为字节流。getInputStream()和getOutputStream()方法来获取输入流和输出流。</p>
<p>  服务端获取到客户端Socket对象，通过其对象与Cilent进行通讯。</p>
<p>  客户端的输出对应服务端的输入，服务端的输出对应客户端的输入。</p>
<p>  TCP必须<strong>先开服务端</strong>。</p>
<p>  如果名称为out,in的视为Socket流，如果不是就是一般流。</p>
<p>  tcp使用的时候可能会出现两端都在等待的情况，原因可能是数据没有发送出去。最大原因在于有阻塞式方法。</p>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端发数据到服务端</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * TCP传输，客户端建立的过程</span></span><br><span class="line"><span class="comment">		 * 1，创建TCP客户端Socket服务，使用的是Socket对象。</span></span><br><span class="line"><span class="comment">		 * 		建议该对象一创建就明确目的地。要连接的主机。</span></span><br><span class="line"><span class="comment">		 * 2，如果连接建立成功，说明数据传输通道已建立。</span></span><br><span class="line"><span class="comment">		 * 		该通道就是Socket流，是底层建立好的。既然是流，说明这里既有输入，又有输出。</span></span><br><span class="line"><span class="comment">		 * 		想要输入或者输出流对象，可以找Socket来获取。</span></span><br><span class="line"><span class="comment">		 * 		可以通过getInputStream()和getOutputStream()方法来获取两个字节流。</span></span><br><span class="line"><span class="comment">		 * 3，使用输出流，将数据写出。</span></span><br><span class="line"><span class="comment">		 * 4，关闭资源。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//创建客户端Socket服务</span></span><br><span class="line">		Socket socket = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(), <span class="number">10002</span>);</span><br><span class="line">		<span class="comment">//获取Socket流中的输出流</span></span><br><span class="line">		OutputStream out = socket.getOutputStream();</span><br><span class="line">		<span class="comment">//使用输出流，将指定的输出写出去</span></span><br><span class="line">		out.write(<span class="string">"TCP演示，哥们又来了！"</span>.getBytes());</span><br><span class="line">		<span class="comment">//关闭资源</span></span><br><span class="line">		socket.close();</span><br></pre></td></tr></table></figure>

<p><strong>服务端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务端接收客户端发送过来的数据，并打印在控制台上。</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 建立TCP服务端的思路</span></span><br><span class="line"><span class="comment">		 * 1，创建服务端Socket服务，通过ServerSocket对象。</span></span><br><span class="line"><span class="comment">		 * 2，服务端必须对外提供一个端口，否则客户端无法连接。</span></span><br><span class="line"><span class="comment">		 * 3，获取连接过来的客户端对象。</span></span><br><span class="line"><span class="comment">		 * 4，通过客户端对象获取Socket流，读取客户端发来的数据。</span></span><br><span class="line"><span class="comment">		 * 5，关闭资源。关客户端，关服务端。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//1，创建服务端对象</span></span><br><span class="line">		ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">10002</span>);</span><br><span class="line">		<span class="comment">//2，获取连接过来的客户端对象</span></span><br><span class="line">		Socket s = ss.accept();<span class="comment">//阻塞式</span></span><br><span class="line">		String ip = s.getInetAddress().getHostAddress();<span class="comment">//获取IP地址</span></span><br><span class="line">		<span class="comment">//3，通过Socket对象获取输入流，要读取客户端发来的数据</span></span><br><span class="line">		InputStream in = s.getInputStream();</span><br><span class="line">		<span class="comment">//读取数据，自定义缓冲区</span></span><br><span class="line">		<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len = in.read(buf);</span><br><span class="line">		String text = <span class="keyword">new</span> String(buf, <span class="number">0</span>, len);</span><br><span class="line">		System.out.println(ip+<span class="string">":"</span>+text);</span><br><span class="line">		<span class="comment">//关闭客户端</span></span><br><span class="line">		s.close();</span><br><span class="line">		ss.close();<span class="comment">//一般服务器端不关闭</span></span><br></pre></td></tr></table></figure>

<p><strong>服务端与客户端交互</strong></p>
<p>服务器接收到数据后，利用客户端的Socket对象的输出流写入数据，客户端利用Socket流的输入流进行数据接收。</p>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取服务端返回的数据，使用Socket读取流。</span></span><br><span class="line">		InputStream in = socket.getInputStream();</span><br><span class="line">		<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len = in.read(buf);</span><br><span class="line">		String text = <span class="keyword">new</span> String(buf, <span class="number">0</span>, len);</span><br><span class="line">		System.out.println(<span class="string">"客户端收到反馈:"</span>+text);</span><br></pre></td></tr></table></figure>

<p><strong>服务端</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用客户端Socket对象的输出流给客户端返回数据</span></span><br><span class="line">		OutputStream out = s.getOutputStream();</span><br><span class="line">		out.write(<span class="string">"收到"</span>.getBytes());</span><br></pre></td></tr></table></figure>

<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC27%E5%A4%A91.png" class title="This is an example image">

<p>服务器端原理，<strong>并发访问</strong>，只有一个端口对外提供，当进来一个客户端Socket，阻塞，新建线程去执行，线程任务就是读写操作。然后再进来一个客户端，再利用新线程去执行，为了避免线程过多，一个线程结束后就结束线程。把连接进来的客户端封装在线程中。</p>
<h4 id="常见客户端与服务端"><a href="#常见客户端与服务端" class="headerlink" title="常见客户端与服务端"></a>常见客户端与服务端</h4><p>最常见客户端：</p>
<p>​    浏览器：IE。</p>
<p>最常见的服务器：</p>
<p>​    服务器：Tomcat。</p>
<p>http：应用层协议，超文本传输控制协议。文字带颜色，大小，图片带声音。使用语言为html。</p>
<p>定义了web浏览器与服务器的通信规则。浏览器中有解析http协议的解析引擎。</p>
<p>FTP：文件传输协议</p>
<p>Web服务器默认端口：80</p>
<p>Tomcat服务器对外提供接口。interface <strong>Servlet</strong>。必须直接或间接实现。Tomcat对外提供Web资源访问。</p>
<p>访问服务器：http://主机名:8080/myweb</p>
<p>​    会自动去webapps下去寻找。</p>
<p>​    服务器必须对外提供可访问资源，即Web应用程序。webapps下存放的为web资源。</p>
<h4 id="客户端和服务端原理"><a href="#客户端和服务端原理" class="headerlink" title="客户端和服务端原理"></a>客户端和服务端原理</h4><p>了解原理：</p>
<p>1， 自定义服务端，使用已有的客户端IE，了解一下客户端给服务器端发了什么请求。</p>
<p>发送的请求是</p>
<p>GET / HTTP/1.1 <strong>请求行</strong> <strong>请求方式 /myweb/1,html 请求的资源路径 http协议版本(1.0或者1.1,1.1更常用)请求方式包括GET,POST</strong></p>
<p><strong>请求消息头</strong> <strong>属性名：属性值（键值对）</strong></p>
<p>Accept: </p>
<p><strong>服务器可以支持的app</strong></p>
<p>text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8</p>
<p><strong>支持的语言</strong></p>
<p>Accept-Language: zh-Hans-CN,zh-Hans;q=0.8,en-US;q=0.5,en;q=0.3</p>
<p>Upgrade-Insecure-Requests: 1</p>
<p><strong>用户信息，系统版本</strong></p>
<p>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36 Edge/18.17763</p>
<p><strong>支持的压缩方式，服务器发送信息时将信息压缩，客户端解压缩</strong></p>
<p>Accept-Encoding: gzip, deflate</p>
<p><strong>访问的主机</strong></p>
<p>Host: 127.0.0.1:9090</p>
<p>Connection: Keep-Alive</p>
<p>请求头和请求体之间有<strong>空行</strong></p>
<p>请求体：可能会有注册信息等。</p>
<p>2， 自定义浏览器</p>
<p>服务端发回应答消息</p>
<p>HTTP/1.1 403 Forbidden <strong>应答行</strong>，http的协议版本 <strong>应答状态码</strong> 应答状态<strong>描述信息</strong></p>
<p><strong>200</strong>代表成功，描述信息OK  <strong>404</strong> not found 找不到页面 </p>
<p><strong>应答消息属性信息</strong>。属性名：属性值</p>
<p>Server: bfe</p>
<p>Date: Tue, 05 Mar 2019 15:26:23 GMT</p>
<p><strong>最后修改时间</strong>，带着信息访问，如果修改日期一致本地缓存界面与服务器端一样，发新的状态码。</p>
<p>Last-Modified:一堆日期</p>
<p><strong>发送字节数</strong></p>
<p>Content-Length: 0</p>
<p><strong>收到数据类型</strong></p>
<p>Content-Type: text/plain; charset=utf-8</p>
<p>Connection: close</p>
<p>//有一行空行</p>
<p><strong>应答体</strong></p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC27%E5%A4%A92.png" class title="This is an example image">

<p>处理请求并给予应答。</p>
<p>可以网页输入http://主机名:指定端口号，即可以访问自定义的服务端。</p>
<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>协议解析对象</p>
<p>​    浏览器向服务器发送<strong>http请求信息</strong>，然后浏览器发送<strong>应答消息头</strong>和应答体。浏览器中只显示应答体，而应答消息头被浏览器解析引擎解析。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC27%E5%A4%A93.png" class title="This is an example image">

<p>可以使用URL对象对应答消息头进行解析。URL底层挂的是URLConnection</p>
<p>​    类URL代表一个<strong>统一资源定位符</strong>，是指向互联网“资源”的<strong>指针</strong>。资源可以是简单的文件或目录，也可以是对更为复杂的对象的引用，例如对数据库或搜索引擎的查询。</p>
<p>​    URI<strong>统一资源标识符引用</strong>。</p>
<p>​    每个URL都是URI，但不一定每个URI都是URL。URI还包括个子类URN，统一资源名称。mailto、news和isbnURI都是URN的示例。</p>
<p>​    URL对象可以直接解析URL地址。getProtocol()，获取协议。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取信息</span></span><br><span class="line">		System.out.println(url.getProtocol());<span class="comment">//协议</span></span><br><span class="line">		System.out.println(url.getHost());<span class="comment">//主机</span></span><br><span class="line">		System.out.println(url.getPort());<span class="comment">//端口</span></span><br><span class="line">		System.out.println(url.getFile());<span class="comment">//文件名，会带有name参数</span></span><br><span class="line">		System.out.println(url.getPath());<span class="comment">//路径，只负责到文件</span></span><br><span class="line">		System.out.println(url.getQuery());<span class="comment">//参数信息，？后的部分</span></span><br></pre></td></tr></table></figure>

<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC27%E5%A4%A94.png" class title="This is an example image">

<p>InputStream openStream()<strong>打开此URL的连接</strong>并返回一个用于从该连接<strong>读入的InputStream</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只输出应答体，不输出应答消息头</span></span><br><span class="line">		InputStream in = url.openStream();</span><br><span class="line">		<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len = in.read(buf);</span><br><span class="line">		String text = <span class="keyword">new</span> String(buf, <span class="number">0</span>, len);</span><br><span class="line">		System.out.println(text);</span><br><span class="line">		in.close();</span><br><span class="line">		<span class="comment">//URL不用关闭</span></span><br></pre></td></tr></table></figure>

<p>其中openStream()底层使用的是openConnection().getInputStream()</p>
<h4 id="URLConnection"><a href="#URLConnection" class="headerlink" title="URLConnection"></a>URLConnection</h4><p>URL连接器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取url对象的URL连接器，将连接封装成了对象：java中内置的可以解析的具体协议的对象+socket</span></span><br><span class="line">		URLConnection conn = url.openConnection();</span><br></pre></td></tr></table></figure>

<p>conn打印结果如下</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC27%E5%A4%A95.png" class title="This is an example image">

<p>​    前面http地址为http底层实现。</p>
<p>String <strong>getHeaderField</strong>(String ) 获取相关属性，</p>
<p>如使用String value = conn. getHeaderField(“Content-Type”)，获取内容类型，然后用相关的解析器去解析。</p>
<p>可以获取输入和输出流，因此相当于使用了Socket，但是加入了协议。</p>
<p>URL中openStream原理为先获取连接，然后获取流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取url对象的URL连接器，将连接封装成了对象</span></span><br><span class="line">		URLConnection conn = url.openConnection();</span><br><span class="line">		InputStream in = conn.getInputStream();</span><br></pre></td></tr></table></figure>

<p>因此以后浏览器就不用使用Socket，而是使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str_url = <span class="keyword">new</span> String(<span class="string">"http://192.168.1.100:8080/myweb/1.html?name=lisi"</span>);</span><br><span class="line">		URL url = <span class="keyword">new</span> URL(str_url);<span class="comment">//抛出无法解析URL</span></span><br><span class="line">		<span class="comment">//只输出应答体，不输出应答消息头</span></span><br><span class="line">		InputStream in = url.openStream();</span><br></pre></td></tr></table></figure>

<h4 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h4><p>1，C/S      Client/Server</p>
<p>​    特点：</p>
<p>该结构的软件，客户端和服务端都需要编写。</p>
<p>​        开发成本较高，维护较为麻烦。</p>
<p>​        可能会出现版本差异</p>
<p>​    好处：</p>
<p>​       客户端在本地可以分担一部分运算。</p>
<p>网络游戏就是客户端，因为很多数据存储在本地，位置坐标实时与主机交换。</p>
<p>2，B/S      Browser/Server</p>
<p>​    特点：</p>
<p>​        该结构的软件，只开发服务器端，不开发客户端，因为客户端直接由浏览器取代。</p>
<p>​        开发成本相对低，维护更为简单。</p>
<p>​    缺点：</p>
<p>​       所有运算都在服务器端完成。</p>
<hr>
<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><h4 id="概述与应用场景"><a href="#概述与应用场景" class="headerlink" title="概述与应用场景"></a>概述与应用场景</h4><p>反射中涉及到的对象均在java.lang.reflect包中。Constructoe,Filed,Method。</p>
<p>​    AccessibleObject类是Field、Method、和Constructor对象的基类。它提供了将反射的对象标记为在使用时取消Java语言访问控制检查的能力。</p>
<p>java反射机制是在运行状态中，对于任意一个类(class文件)，都能够知道这个类的所有属性和方法；</p>
<p>对于任意一个对象，都能够调用它的任意一个方法和属性。</p>
<p>这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p><strong>动态获取类中信息</strong>，就是java的反射机制。</p>
<p>可以理解为对类的解剖。</p>
<p>软件的功能扩展利用对外提供接口实现。</p>
<p>​    一个类实现了软件对外暴露的接口，会在程序的配置文件中写入，程序读取此配置文件，会去寻找接口实现类的class文件。如果找到则加载此文件，并获取该文件里所有内容。拿到字节码文件就可以新建对象，因为其中有构造函数。</p>
<p>​    如果想要对指定名称的字节码文件加载并获取其中的内容并调用。</p>
<p>实现方法：这时使用到了<strong>反射</strong>技术。</p>
<p>优点：极大的提高了程序的扩展性。</p>
<p>Tomcat提供的接口为Servlet，服务器端脚本程序片段。将实现接口的类名称写入配置文件，软件便可以动态加载此类中的内容。利用的是反射技术。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC28%E5%A4%A91.png" class title="This is an example image">

<p>​    需要<strong>接口</strong>+<strong>配置文件</strong>。</p>
<p>​    学习框架：框架作用，配置文件怎么用，常用对象的用法。</p>
<p>​    反射技术提高了扩展技术，用起来简单（用户只面对配置文件）。</p>
<h4 id="细节和Class对象"><a href="#细节和Class对象" class="headerlink" title="细节和Class对象"></a>细节和Class对象</h4><p>​    传参通过配合文件完成。</p>
<p>​    拿到类以后，获取指定类中的信息。</p>
<p>​    反射的过程：由Class类来完成</p>
<p>Class类用来表述二进制字节码文件。可以new对象，提供获取到字节码文件中的内容，如名称、字段、构造函数、一般函数。该类就可以获得字节码文件中的<strong>所有内容</strong>。反射就是依靠该类来完成的。</p>
<p>​    想要对一个类文件进行解剖，只要获取到该类的<strong>字节码文件对象</strong>即可。</p>
<h4 id="获取Class对象的三种方式"><a href="#获取Class对象的三种方式" class="headerlink" title="获取Class对象的三种方式"></a>获取Class对象的三种方式</h4><p>要想对字节码文件进行解剖，必须要有字节码文件对象。如何获取其对象？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 获取字节码对象的方式：</span></span><br><span class="line"><span class="comment">	 * 方式一，Object中的getClass()方法</span></span><br><span class="line"><span class="comment">	 * 想要用这种方式必须要明确具体的类并创建对象。</span></span><br><span class="line"><span class="comment">	 * 麻烦！！！</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">		Person p = <span class="keyword">new</span> Person();</span><br><span class="line">		Class clazz = p.getClass();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 方式二：</span></span><br><span class="line"><span class="comment">	 * 	任何数据类型都具备一个静态的属性.class来获取其对应的Class对象</span></span><br><span class="line"><span class="comment">	 * 相对简单，但是还是要明确用到类中的静态成员</span></span><br><span class="line"><span class="comment">	 * 还是不够扩展</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">		Class clazz = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 方式三：</span></span><br><span class="line"><span class="comment">	 * 只要通过给定的类的字符串名称就可以获取该类，更为扩展</span></span><br><span class="line"><span class="comment">	 * 可以用Class类中的方法完成</span></span><br><span class="line"><span class="comment">	 * 该方法就是forName()</span></span><br><span class="line"><span class="comment">	 * 这种方式只要有名称即可，更为方便，扩展性更强</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">		<span class="comment">//需要带着包名</span></span><br><span class="line">		String className = <span class="string">"cn.zc.bean.Person"</span>;</span><br><span class="line">		Class clazz = Class.forName(className);</span><br></pre></td></tr></table></figure>

<h4 id="获取Class中的构造函数"><a href="#获取Class中的构造函数" class="headerlink" title="获取Class中的构造函数"></a>获取Class中的构造函数</h4><p>获得空参的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//早期：new的时候，先根据被new的类的名称找寻该类的字节码文件，并加载进内存，</span></span><br><span class="line">		<span class="comment">//	  并创建该字节码文件对象，并接着创建该字节文件的对应的Person对象 </span></span><br><span class="line"><span class="comment">//		cn.zc.bean.Person p = new cn.zc.bean.Person();</span></span><br><span class="line">		<span class="comment">//现在：</span></span><br><span class="line">		String name = <span class="string">"cn.zc.bean.Person"</span>;</span><br><span class="line">		<span class="comment">//找寻该名称类文件，并加载进内存，并产生Class对象</span></span><br><span class="line">		Class clazz = Class.forName(name);</span><br><span class="line">		<span class="comment">//如何产生该类的对象呢？</span></span><br><span class="line">		<span class="comment">//如果没有public公共构造函数，会出错。</span></span><br><span class="line">		<span class="comment">//如果是private构造函数，则不能访问，报错。</span></span><br><span class="line">		Object obj = clazz.newInstance();</span><br></pre></td></tr></table></figure>

<p>如果想要获得要输入参数的对象，则要获取构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//		cn.zc.bean.Person p = new cn.zc.bean.Person("小强", 39);</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 当获取指定名称对应的类中所体现的对象时，</span></span><br><span class="line"><span class="comment">		 * 而该对象初始化不使用空参数构造函数该怎么办？</span></span><br><span class="line"><span class="comment">		 * 既然是通过指定的构造函数进行对象的初始化，</span></span><br><span class="line"><span class="comment">		 * 所以应该先获取到该构造函数。通过字节码文件对象即可完成。</span></span><br><span class="line"><span class="comment">		 * 该方法是getConstructor(...parameterTypes)</span></span><br><span class="line"><span class="comment">		 * 获取到所有的公有构造函数</span></span><br><span class="line"><span class="comment">		 * getDeclaredConstructors获取所有权限的构造函数</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		String name = <span class="string">"cn.zc.bean.Person"</span>;</span><br><span class="line">		<span class="comment">//找寻该名称类文件，并加载进内存，并产生Class对象</span></span><br><span class="line">		Class clazz = Class.forName(name);</span><br><span class="line">		<span class="comment">//传进参数类型对应的class</span></span><br><span class="line">		Constructor constructor = clazz.getConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">		<span class="comment">//通过该构造器对象的newInstance方法进行对象的初始化</span></span><br><span class="line">		Object obj = constructor.newInstance(<span class="string">"小明"</span>,<span class="number">38</span>);</span><br></pre></td></tr></table></figure>

<h4 id="获取Class中的字段"><a href="#获取Class中的字段" class="headerlink" title="获取Class中的字段"></a>获取Class中的字段</h4><p>如果字段是私有的，则不能直接访问，需要先取消权限检查，称为暴力访问，不建议使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取字节码文件中的字段</span></span><br><span class="line"><span class="comment"> * 直接get加对应的，获得的均为公共的</span></span><br><span class="line"><span class="comment"> * 如果是所有的则是Declared。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getFieldDemo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Class clazz = Class.forName(<span class="string">"cn.zc.bean.Person"</span>);</span><br><span class="line">	Field field = <span class="keyword">null</span>;<span class="comment">//clazz.getField("age");//只能获取公有的，包含父类</span></span><br><span class="line">	field = clazz.getDeclaredField(<span class="string">"age"</span>);<span class="comment">//只获取本类，但包含私有</span></span><br><span class="line">	<span class="comment">//对私有字段的访问取消权限检查。暴力访问。</span></span><br><span class="line">	field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">	Object obj = clazz.newInstance();</span><br><span class="line">	field.set(obj, <span class="number">89</span>);<span class="comment">//设置字段的值</span></span><br><span class="line">	Object o = field.get(obj);<span class="comment">//属性要被对象调用//如果不改权限，无效访问异常，因为是私有的</span></span><br><span class="line">	System.out.println(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取Class中的方法"><a href="#获取Class中的方法" class="headerlink" title="获取Class中的方法"></a>获取Class中的方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 获取指定Class中的所有公共函数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMethodDemo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class clazz = Class.forName(<span class="string">"cn.zc.bean.Person"</span>);</span><br><span class="line">		Method[] methods = clazz.getMethods();<span class="comment">//获取的都是公有的方法，包含父类</span></span><br><span class="line">		methods = clazz.getDeclaredMethods();<span class="comment">//只获取本类中所有方法，包含私有</span></span><br><span class="line">		<span class="keyword">for</span>(Method method : methods)&#123;</span><br><span class="line">			System.out.println(method);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//获取指定的不带参数方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMethodDemo_2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class clazz = Class.forName(<span class="string">"cn.zc.bean.Person"</span>);</span><br><span class="line">		<span class="comment">//必须指定方法名和列表	</span></span><br><span class="line">		Method method = clazz.getMethod(<span class="string">"show"</span>, <span class="keyword">null</span>);<span class="comment">//获取空参数一般方法</span></span><br><span class="line"><span class="comment">//		Object obj = clazz.newInstance();//获取空参数对象</span></span><br><span class="line">		<span class="comment">//获取有参数的对象</span></span><br><span class="line">		Constructor constructor = clazz.getConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">		Object obj = constructor.newInstance(<span class="string">"小明"</span>,<span class="number">37</span>);</span><br><span class="line">		method.invoke(obj, <span class="keyword">null</span>);</span><br><span class="line">		Field field = clazz.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line">		field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">		System.out.println(field.get(obj));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取指定的带参数方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMethodDemo_3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class clazz = Class.forName(<span class="string">"cn.zc.bean.Person"</span>);</span><br><span class="line">		<span class="comment">//必须指定方法名和列表	</span></span><br><span class="line">		Method method = clazz.getMethod(<span class="string">"paraMethod"</span>, String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;<span class="comment">//获取空参数一般方法</span></span><br><span class="line">		Object obj = clazz.newInstance();</span><br><span class="line">		method.invoke(obj, <span class="string">"小强"</span>,<span class="number">89</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="反射演示"><a href="#反射演示" class="headerlink" title="反射演示"></a>反射演示</h4><p>  想要不修改主函数，只通过修改配置文件来让不同的设备运行。程序要对外暴露一个接口PCI，要实现开和关的方法，设备要实现此接口。</p>
<p>  关键：对外暴露接口，加载配置文件，新功能实现此接口，获取到Class对应的对象，将此接口对象传入相应的方法，其他的就很简单了。</p>
<p>思路：</p>
<p>1、 将配置文件关联到文件对象，新建Properties对象，新建流将文件中数据load进Properties中。</p>
<p>2、 遍历键值对，逐个获取到类名。根据类名获取到Class文件</p>
<p>3、 因为所有的设备对象都实现了PCI接口，因此可以利用Class获取到的空参对象强转为PCI类型</p>
<p>4、 将此PCI设备传进主板的使用PCI方法，即可。将流关闭</p>
<p>主函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Mainboard mb = <span class="keyword">new</span> Mainboard();</span><br><span class="line">		mb.run();</span><br><span class="line">		<span class="comment">//每次添加一个设备都需要修改代码传递一个新创建的对象</span></span><br><span class="line"><span class="comment">//		mb.usePCI(new SoundCard());</span></span><br><span class="line">		<span class="comment">//能不能不修改代码就可以完成这个动作</span></span><br><span class="line">		<span class="comment">//不用new来完成，而是直接获取其Class文件，在内部实现创建对象的动作</span></span><br><span class="line">		File configFile = <span class="keyword">new</span> File(<span class="string">"pci.properties"</span>);</span><br><span class="line">		Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">		FileInputStream fis = <span class="keyword">new</span> FileInputStream(configFile);</span><br><span class="line">		prop.load(fis);<span class="comment">//把流中的数据加载到键值对中</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;prop.size();x++)&#123;</span><br><span class="line">			String pciName = prop.getProperty(<span class="string">"pci"</span>+(x+<span class="number">1</span>));</span><br><span class="line">			Class clazz = Class.forName(pciName);<span class="comment">//用Class去加载这个pci子类</span></span><br><span class="line">			PCI p = (PCI)clazz.newInstance();<span class="comment">//要有空参构造参数</span></span><br><span class="line">			mb.usePCI(p);</span><br><span class="line">		&#125;</span><br><span class="line">		fis.close();		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置文件</strong></p>
<p>pci1=cn.zc.reflect.test.SoundCard</p>
<p>pci2=cn.zc.reflect.test.NetCard</p>
<p><strong>接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PCI</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>主板</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mainboard</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"main borad run..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">usePCI</span><span class="params">(PCI p)</span> </span>&#123;<span class="comment">//PCI p = new SoundCard();</span></span><br><span class="line">		<span class="keyword">if</span> (p ! = <span class="keyword">null</span>) &#123;</span><br><span class="line">			p.open();</span><br><span class="line">			p.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>正确表达的字符串。</p>
<p>正则表达式用于操作字符串数据。</p>
<p>通过一些特定的符号来体现的。</p>
<p>  所以为了掌握正则表达式，必须要学习一些符号。</p>
<p>  虽然简化了，但是阅读性差。</p>
<h4 id="常见的规则"><a href="#常见的规则" class="headerlink" title="常见的规则"></a>常见的规则</h4><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC28%E5%A4%A92.png" class title="This is an example image">

<p><strong>字符类</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[abc] 字符串某一位必须是a或b或c，只能是三者中一个</span><br><span class="line">[^abc] 任何字符，除了abc</span><br><span class="line">[a-zA-Z]所有大小写字母</span><br><span class="line">[a-d[m-p]] a到b或m到p: [a-dm-p]并集</span><br><span class="line">[a-z&amp;&amp;[def]]d,e或f，交集</span><br><span class="line">[a-z&amp;&amp;[^bc]]a到z，除了b和c:[ad-z]（减去）</span><br><span class="line">[a-z&amp;&amp;[^m-p]]a到z，而非m到p:[a-lq-z]（减去）</span><br></pre></td></tr></table></figure>

<p><strong>预定义字符类</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.  任何字符（与行结束可能匹配也可能不匹配）</span><br><span class="line">\d 数字：[0-9]</span><br><span class="line">\D 非数字：[^0-9]</span><br><span class="line">\s 空白字符：[ \t\n\x0B\f\r]</span><br><span class="line">\S 非空白字符：[^\s]</span><br><span class="line">\w 单词字符：[a-zA-Z_0-9]大小写字母，数字，下划线</span><br><span class="line">\W 非单词字符：[^\w]</span><br></pre></td></tr></table></figure>

<p><strong>边界匹配器</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^  行的开头</span><br><span class="line">$  行的结尾</span><br><span class="line">\b 单词边界，即两个单词中间的位置</span><br><span class="line">\B 非单词边界</span><br><span class="line">\A 输入的开头</span><br><span class="line">\G 上一个匹配的结尾</span><br><span class="line">\Z 输入的结尾，仅用于最后的结束符（如果有的话）</span><br><span class="line">\z 输入的结尾</span><br></pre></td></tr></table></figure>

<p><strong>Greedy数量词</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X? X,一次或一次也没有，至多一次</span><br><span class="line">X* X，零次或多次，有没有都可</span><br><span class="line">X+ X，一次或多次，不能为0次</span><br><span class="line">X&#123;n&#125;  X,恰好n次</span><br><span class="line">X&#123;n,&#125; X，至少n次</span><br><span class="line">X&#123;n,m&#125; X，至少n次，但不会超过m次</span><br></pre></td></tr></table></figure>

<h4 id="常见的功能"><a href="#常见的功能" class="headerlink" title="常见的功能"></a>常见的功能</h4><p>​    Pattern类指定为字符串的正则表达式必须首先被编译为此类的实例（将正则表达式封装成对象）。然后可将得到的模式（正则规则）用于创建Matcher对象（匹配器），依照正则表达式，该对象可以与任意字符序列匹配。执行匹配所涉及的所有状态都驻留在匹配器中，所以多个匹配器可以共享同一模式。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AC%AC28%E5%A4%A93.png" class title="This is an example image">

<p>String类中这些关于正则的方法底层调用的是正则对象的方法，不过String类直接使用比较简单点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 正则表达式对字符串的常见操作：</span></span><br><span class="line"><span class="comment">		 * 1，匹配</span></span><br><span class="line"><span class="comment">		 * 		其实使用的是String类中的matches()方法</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 2，切割</span></span><br><span class="line"><span class="comment">		 * 		其实使用的就是String类中的split()方法</span></span><br><span class="line"><span class="comment">		 * 3，替换</span></span><br><span class="line"><span class="comment">		 * 		其实使用的是String类中的replaceAll()方法</span></span><br><span class="line"><span class="comment">		 * 4，获取</span></span><br><span class="line"><span class="comment">		 * 		只能使用正则对象、匹配器对象来完成</span></span><br><span class="line"><span class="comment">		 * 		包名为java.util.regex</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 匹配</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">functionDemo_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//匹配手机号码是否正确</span></span><br><span class="line">		String tel = <span class="string">"158000o1111"</span>;</span><br><span class="line">		<span class="comment">//首个为1，第二位为固定，其他是0-9</span></span><br><span class="line">		String regex = <span class="string">"1[3589]\\d&#123;9&#125;"</span>;</span><br><span class="line">		<span class="keyword">boolean</span> b = tel.matches(regex);</span><br><span class="line">		System.out.println(tel+<span class="string">":"</span>+b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 切割</span></span><br><span class="line"><span class="comment">	 * 组：((A)(B(C)))，按照左括号数组。组1A(B(c))，组2A，组3B(C),组4C</span></span><br><span class="line"><span class="comment">	 * 组零代表整个表达式</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">functionDemo_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//		String str = "zhangsan         xiaoqiang              zhaoliu";</span></span><br><span class="line"><span class="comment">//		String[] names = str.split(" +");//至少出现一次</span></span><br><span class="line"><span class="comment">//		String str = "zhangsan.xiaoqiang.zhaoliu";</span></span><br><span class="line"><span class="comment">//		String[] names = str.split("\\.");//.是特殊符号，需要加上\\.，将其转义	</span></span><br><span class="line">		String str = <span class="string">"zhangsanttttxiaoqiangmmmmmmmmmmzhaoliu"</span>;</span><br><span class="line">		<span class="comment">//使用叠词来切割，因为叠词的第一个为任意，第二个与第一个一样而且不止一个</span></span><br><span class="line">		<span class="comment">//因此将第一个任意的封装为组，第二个使用此组，使用1，转义变成\\1不止一个用+</span></span><br><span class="line">		String[] names = str.split(<span class="string">"(.)\\1+"</span>);<span class="comment">//正则中用小括号封装，组，从1开始，用编号代表组</span></span><br><span class="line">		<span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">			System.out.println(name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 替换</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">functionDemo_3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String str = <span class="string">"zhangsanttttxiaoqiangmmmmmmmmmmzhaoliu"</span>;</span><br><span class="line">		<span class="comment">//第二个中要使用第一个正则表达式中的内容，使用$加组号</span></span><br><span class="line">		str = str.replaceAll(<span class="string">"(.)\\1+"</span>, <span class="string">"$1"</span>);</span><br><span class="line">		System.out.println(str);</span><br><span class="line">		String tel = <span class="string">"15800001111"</span>;<span class="comment">//158****1111</span></span><br><span class="line">		<span class="comment">//将前三位和后四位进行分组，然后这两个组不变，中间的4位变成****</span></span><br><span class="line">		tel = tel.replaceAll(<span class="string">"(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)"</span>, <span class="string">"$1****$2"</span>);<span class="comment">//将不匹配的替换掉</span></span><br><span class="line">		System.out.println(tel);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 获取</span></span><br><span class="line"><span class="comment">	 * 1，将正则规则进行对象的封装</span></span><br><span class="line"><span class="comment">	 * Pattern p = Pattern.compile("a*b");//规则，a没有或多次+b</span></span><br><span class="line"><span class="comment">	 * 2，通过正则对象的matcher方法与字符串关联。获取要对字符串操作的匹配器对象Matcher。</span></span><br><span class="line"><span class="comment">	 * Matcher m = p.matcher("aaaaab");</span></span><br><span class="line"><span class="comment">	 * 3，通过Matcher匹配器对象的方法对字符串进行操作。</span></span><br><span class="line"><span class="comment">	 * boolean b = m.matches();</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">functionDemo_4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String str = <span class="string">"daa jia hao,ming tian bu fang jia!"</span>;</span><br><span class="line">		String regex = <span class="string">"\\b[a-z]&#123;3&#125;\\b"</span>;<span class="comment">//单词前后需要要有单词边界</span></span><br><span class="line">		<span class="comment">//1，将正则封装成对象</span></span><br><span class="line">		Pattern p = Pattern.compile(regex);</span><br><span class="line">		<span class="comment">//2，通过正则对象获取匹配器对象</span></span><br><span class="line">		Matcher m = p.matcher(str);<span class="comment">//将字符串关联</span></span><br><span class="line">		<span class="comment">//3，使用Matcher对象的方法对字符串进行操作</span></span><br><span class="line">		<span class="comment">//既然要获取三个字母组成的单词</span></span><br><span class="line">		<span class="comment">//查找。find()</span></span><br><span class="line">		System.out.println(str);</span><br><span class="line">		<span class="keyword">while</span>(m.find())&#123;</span><br><span class="line">			<span class="comment">//先找再获取</span></span><br><span class="line">			System.out.println(m.group());<span class="comment">//获取匹配的子序列</span></span><br><span class="line">			System.out.println(m.start()+<span class="string">":"</span>+m.end());<span class="comment">//可以拿到indexOf，即位置</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相关题目整理"><a href="#相关题目整理" class="headerlink" title="相关题目整理"></a>相关题目整理</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="a-与-a区别"><a href="#a-与-a区别" class="headerlink" title="a++与++a区别"></a>a++与++a区别</h3><p>a=3 b = a++ 和b = ++a</p>
<p>若是单个语句，则没有太大区别，若是在运算当中，则</p>
<p>a++，先将a的值用temp存储，然后进行a = a+1，然后存下原来的temp，及若b = a++,</p>
<p>b = 3，a =4；若b = ++a，则b = 4,a = 4</p>
<p>若为i = 3,i = i++，则i= 3，因为存储的是temp的值，+=，-=，*=，/=.为左=左加右，左=左减右，以此类推</p>
<h3 id="short-s-4-，s-4与s-s-4的区别"><a href="#short-s-4-，s-4与s-s-4的区别" class="headerlink" title="short s = 4 ，s += 4与s = s + 4的区别"></a>short s = 4 ，s += 4与s = s + 4的区别</h3><p>s += 4为赋值运算，在底层做了自动的强制转换，编译成功，s = s + 4没有自动转换，精度损失，编译不会通过</p>
<h3 id="两个数互换位置，不使用第三个数"><a href="#两个数互换位置，不使用第三个数" class="headerlink" title="两个数互换位置，不使用第三个数"></a>两个数互换位置，不使用第三个数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = a ^ b  </span><br><span class="line">b = a ^ b  </span><br><span class="line">a = a ^ b</span><br></pre></td></tr></table></figure>

<h3 id="用三元运算符取两个整数中大的"><a href="#用三元运算符取两个整数中大的" class="headerlink" title="用三元运算符取两个整数中大的"></a>用三元运算符取两个整数中大的</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x,y</span><br><span class="line"><span class="keyword">int</span> max = x&gt;y?x:y;</span><br></pre></td></tr></table></figure>

<h3 id="if-与-switch的比较"><a href="#if-与-switch的比较" class="headerlink" title="if 与 switch的比较"></a>if 与 switch的比较</h3><p>if :</p>
<ol>
<li><p>对具体的值进行判断。</p>
</li>
<li><p>对区间判断。</p>
</li>
<li><p>对运算结果是boolean类型的表达式进行判断。</p>
</li>
</ol>
<p>switch</p>
<ol>
<li><p>对具体的值进行判断</p>
</li>
<li><p>值的个数是固定的。</p>
</li>
</ol>
<p>对于几个固定的值判断，建议使用switch进行判断，因为switch语句将具体的答案加载进内存，<strong>效率相对较高</strong></p>
<h3 id="while和for循环区别"><a href="#while和for循环区别" class="headerlink" title="while和for循环区别"></a>while和for循环区别</h3><p>for循环结束后，控制循环变量被释放，无法被再次利用，而while中的变量可以。如果不使用此变量，用for较好，节省内存空间；若要用到变量，则用while较好。</p>
<h3 id="直接打印数组名"><a href="#直接打印数组名" class="headerlink" title="直接打印数组名"></a>直接打印数组名</h3><p>直接打印数组名出来的符号什么意思，如[I@c17164</p>
<p>@分隔符，右边c17164是在当前操作系统下计算出的数组地址，如windows下用哈希算法计算出来的地址位置，左边[表示数组，I表示Int类型</p>
<h3 id="数组异常"><a href="#数组异常" class="headerlink" title="数组异常"></a>数组异常</h3><p>使用数组带来的问题</p>
<p>1、 当访问到数组中不存在的角标，会出现ArrayIndexOutOfBoundsException</p>
<p>2、 当引用型变量没有任何实体指向时，还在用其操作，会出现NullPointerException</p>
<hr>
<h3 id="面对对象-1"><a href="#面对对象-1" class="headerlink" title="面对对象"></a>面对对象</h3><p>如何理解面对对象</p>
<p>（1）   符合现在人们思维的习惯（2）使复杂的事情变得简单化（3）让我们从程序的执行者变成指挥者。面向对象的三个特征：封装，继承，多态</p>
<h3 id="类与对象之间的关系"><a href="#类与对象之间的关系" class="headerlink" title="类与对象之间的关系"></a>类与对象之间的关系</h3><p>类：事物的描述</p>
<p>对象：该类事物的实例，在java中通过new来创建</p>
<h3 id="构造函数与一般函数区别"><a href="#构造函数与一般函数区别" class="headerlink" title="构造函数与一般函数区别"></a>构造函数与一般函数区别</h3><p>构造函数对象创建时就会调用与之对应的构造函数对对象进行初始化，而一般函数对象创建后需要该函数功能时才调用；构造函数对象创建时，会调用只调用一次；一般函数对象创建后可以被调用多次。</p>
<h3 id="什么时候定义构造函数"><a href="#什么时候定义构造函数" class="headerlink" title="什么时候定义构造函数"></a>什么时候定义构造函数</h3><p>在描述事物时，该事物一存在就已具备的一些内容，这些内容定义在构造函数中。可以以重载形式进行运行，定义不同的构造函数</p>
<h3 id="若有静态代码块、构造代码块、构造函数，三个执行顺序"><a href="#若有静态代码块、构造代码块、构造函数，三个执行顺序" class="headerlink" title="若有静态代码块、构造代码块、构造函数，三个执行顺序"></a>若有静态代码块、构造代码块、构造函数，三个执行顺序</h3><p>静态代码块随着类的加载而执行，最先执行。如果有对象，构造代码块执行，然后构造函数执行。如果有继承，先运行父类构造函数。</p>
<h3 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h3><ol>
<li>抽象类中有构造函数吗？</li>
</ol>
<p>有，用于给子类对象进行初始化</p>
<ol start="2">
<li>抽象类可以不定义抽象方法吗？</li>
</ol>
<p>可以，但是很少见，目的是不让该类创建对象。AWT的适配器对象就是这种类</p>
<p>通常这个类中的方法有方法体，但是却没有内容</p>
<ol start="3">
<li>抽象关键字不可以和哪些关键字共存？</li>
</ol>
<p>private不行，抽象类需要被子类覆盖 ; static不行，抽象类本身不需创建对象</p>
<p>final 不行，抽象类需要被子类覆盖</p>
<ol start="4">
<li>抽象类和一般类的异同点</li>
</ol>
<p>相同点：抽象类和一般类都是用来描述事物的，都在内部定义了成员。</p>
<p>不同点：</p>
<ul>
<li><p>一般类有足够的信息描述事物。抽象类描述事物的信息有可能不足。</p>
</li>
<li><p>一般类中不能定义抽象方法，只能定义非抽象方法。抽象类中可以定义抽象方法，同时也可以定义非抽象方法。</p>
</li>
<li><p>一般类可以被实例化。抽象类不可以被实例化。</p>
</li>
</ul>
<ol start="5">
<li><p>抽象类一定是父类吗？</p>
<p>是的，需要子类覆盖方法后才可以对子类实例化。</p>
</li>
</ol>
<h3 id="this关键字含义，final特点"><a href="#this关键字含义，final特点" class="headerlink" title="this关键字含义，final特点"></a>this关键字含义，final特点</h3><p>this关键字：调用本类属性，调用本类方法，使用本类构造器，本类对象的引用</p>
<p>final：final是一个修饰符，可以修饰类，方法，变量；final修饰的类不可以被继承；final修饰的方法不可以被覆盖；final修饰的变量是一个常量，只能赋值一次变量命名与函数一样，常量所有字母都大写</p>
<h3 id="main输出1"><a href="#main输出1" class="headerlink" title="main输出1"></a>main输出1</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%801.png" class title="This is an example image">

<p>如果用单|，要判断左边跟右边，这时候j=0+4，但是如果是||，左边满足，那么右边直接被屏蔽，那么j仍然等于4。输出4.</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String比较"><a href="#String比较" class="headerlink" title="String比较"></a>String比较</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stringDemo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		String s = <span class="string">"abc"</span>;</span><br><span class="line">		<span class="comment">//s = "nba";</span></span><br><span class="line">		String s1 = <span class="string">"abc"</span>;</span><br><span class="line">		System.out.println(s==s1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stringDemo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String s = <span class="string">"abc"</span>;</span><br><span class="line">		String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">		System.out.println(s==s1);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>​    第一个为真，第二个为假。第一种创建String方式为在常量池中创建对象，可以共享，而new在堆内存中进行创建。</p>
<p>​    如果要比较对象的内容，用equals()，而String类将Object中的比较方法进行覆写，普通的equals()比较地址，而字符串比较内容。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/String1.png" class title="This is an example image">

<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/String2.png" class title="This is an example image">

<p>结果一个为5，一个为41，原因下面将4变成了4字符串。第三种方式也可以实现输出41，更简洁。</p>
<h3 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h3><p>{“nba”,abc”,”cba”,”zz”,”qq”,”haha”}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">思路：</span><br><span class="line"><span class="number">1</span>、对数组排序。可以用选择，冒泡都行。</span><br><span class="line"><span class="number">2</span>、<span class="keyword">for</span>嵌套和比较，以及换位</span><br><span class="line"><span class="number">3</span>、问题：以前排的是整数，比较用的是比较运算符，现在是字符串对象</span><br><span class="line">	  字符串对象比较，对象中提供了用于字符串对象比较的功能。</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest_1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String[] arr = &#123; <span class="string">"nba"</span>, <span class="string">"abc"</span>, <span class="string">"cba"</span>, <span class="string">"zz"</span>, <span class="string">"qq"</span>, <span class="string">"haha"</span> &#125;;</span><br><span class="line">		print(arr);</span><br><span class="line">		System.out.println();</span><br><span class="line">		sortString(arr);</span><br><span class="line">		print(arr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			System.out.print(arr[i] + <span class="string">"\t"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String[] sortString(String[] arr) &#123;</span><br><span class="line">		String s;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (arr[i].compareTo(arr[j]) &gt; <span class="number">0</span>) &#123;<span class="comment">//字符串比较用compareTo()方法</span></span><br><span class="line">					swap(arr,i,j);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(String[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		String temp = arr[j];</span><br><span class="line">		arr[j] = arr[i];</span><br><span class="line">		arr[i] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一个子串在整串中出现的次数"><a href="#一个子串在整串中出现的次数" class="headerlink" title="一个子串在整串中出现的次数"></a>一个子串在整串中出现的次数</h3><p>“nbaernbatynbauinbaopnba”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">思路：</span><br><span class="line"><span class="number">1</span>、要找的子串是否存在，如果存在，获取其出现的位置，可以使用indexOf()完成</span><br><span class="line"><span class="number">2</span>、如果找到了，那么记录出现的位置并在剩余的字符串中继续查找该子串，剩余字符串的</span><br><span class="line">起始位是出现位置+子串长度</span><br><span class="line"><span class="number">3</span>、以此类推，通过循环完成查找，如果找不到就是-<span class="number">1</span>，并对每次找到用计数器记录</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest_2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String str = <span class="string">"nbaernbatnbaynbauinbaopnba"</span>;</span><br><span class="line">		String key = <span class="string">"nba"</span>;</span><br><span class="line">		<span class="keyword">int</span> count = getKeyStringCount_2(str,key);</span><br><span class="line">		System.out.println(<span class="string">"count="</span>+count);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getKeyStringCount_2</span><span class="params">(String str, String key)</span> </span>&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 思路：</span></span><br><span class="line"><span class="comment">		 * 不新增字符串，而是改变每次查找的位置，其中起始位为上一次找到的位置加上key的长度</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((index=str.indexOf(key, index))!=-<span class="number">1</span>)&#123;</span><br><span class="line">			index += key.length();</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取子串在整串中出现的次数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getKeyStringCount</span><span class="params">(String str, String key)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//1、定义计数器</span></span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//2、定义变量，记录key出现的位置</span></span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((index = str.indexOf(key))!=-<span class="number">1</span>)&#123;</span><br><span class="line">			str = str.substring(index+key.length());</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两个字符串中最大相同的子串"><a href="#两个字符串中最大相同的子串" class="headerlink" title="两个字符串中最大相同的子串"></a>两个字符串中最大相同的子串</h3><p>“qwerabcdtyuiop”</p>
<p>“xcabcdvbn”</p>
<h2 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h2><h3 id="什么时候定义继承"><a href="#什么时候定义继承" class="headerlink" title="什么时候定义继承"></a>什么时候定义继承</h3><p>当类与类之间存在着所属关系的时候，就定义继承。xxx是yyy的一种，xxx extends yyy</p>
<p>继承就是不断向上抽离的过程，如果A和B部分功能相同，可以将相同功能进行抽离，变成父类。</p>
<h3 id="子类实例化访问父类构造函数原因"><a href="#子类实例化访问父类构造函数原因" class="headerlink" title="子类实例化访问父类构造函数原因"></a>子类实例化访问父类构造函数原因</h3><p>子类继承了父类，获取到了父类中的内容（属性），所以在使用父类内容之前要先看父类是如何对自己的内容进行初始化的，所以子类在构造对象时必须访问父类的构造函数。为了完成这个必须的动作，就在子类的构造函数函数中加入了super();语句.如果父类中没有定义空参数构造函数.那么子类的构造函数必须用super明确要调用父类中哪个构造函数同时子类构造函数中如果使用this()调用了本类构造函数时，super就没有了，因为this和super都只能定义在第一行，所以只能有一个。但是可以保证的是，子类中肯定会有其他的构造函数访问父类的构造函数。</p>
<h3 id="main输出题目1"><a href="#main输出题目1" class="headerlink" title="main输出题目1"></a>main输出题目1</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%A7%E6%89%BF1.png" class title="This is an example image">

<p>A 可以，因为覆盖了 </p>
<p>B不可以，权限不够 </p>
<p>C可以，子类特有方法</p>
<p>D 不可以，调用的不确定项 </p>
<p>E不可以，静态只能覆盖静态</p>
<h2 id="多态-1"><a href="#多态-1" class="headerlink" title="多态"></a>多态</h2><h3 id="main输出题目1-1"><a href="#main输出题目1-1" class="headerlink" title="main输出题目1"></a>main输出题目1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> 讲课()&#123;</span><br><span class="line">        System.out.println(“讲课”);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">void</span> 钓鱼()&#123;</span><br><span class="line">        System.out.println(“钓鱼”);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> 讲课()&#123;</span><br><span class="line">        System.out.println(“Java”);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">void</span> 看电影()&#123;</span><br><span class="line">        System.out.println(“看电影”);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line">main函数中</span><br><span class="line">	Fu a = <span class="keyword">new</span> Zi();</span><br><span class="line">a.讲课()；<span class="comment">//所输出为Java，因为在子类中对父类进行了覆盖</span></span><br><span class="line">a.钓鱼(); <span class="comment">//所输出为钓鱼，因为在子类中对父类进行了继承</span></span><br><span class="line">a.看电影():<span class="comment">//不能调用，需要进行向下转型</span></span><br><span class="line">Zi b = (Zi)a；</span><br><span class="line">b.看电影();<span class="comment">//所输出为看电影</span></span><br></pre></td></tr></table></figure>

<h3 id="main输出题目2"><a href="#main输出题目2" class="headerlink" title="main输出题目2"></a>main输出题目2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">	print(“Fu”);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        print(Fu method)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">4</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">	print(“Zi”);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        print(Zi method)&#125;</span><br><span class="line">&#125;</span><br><span class="line">main函数中</span><br><span class="line">	Fu f = <span class="keyword">new</span> Zi();	</span><br><span class="line">	输出f.num</span><br><span class="line">	f.show()</span><br><span class="line">	f.method()</span><br><span class="line">	结果为<span class="number">3</span>，Zi，Fu method</span><br></pre></td></tr></table></figure>

<h3 id="main输出题目3"><a href="#main输出题目3" class="headerlink" title="main输出题目3"></a>main输出题目3</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%80%813.png" class title="This is an example image">

<p>结果为A B</p>
<p>​    因为f.show()调用父类方法，被子类覆盖，输出A，然后进行for循环判断，输出B，返回false，因为为双与，因此直接短路，循环结束。所以总输出结果为A B。</p>
<h3 id="main输出题目4"><a href="#main输出题目4" class="headerlink" title="main输出题目4"></a>main输出题目4</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%80%814.png" class title="This is an example image">

<p>输出B C 7。使用多态，在子类的构造函数中第一行为super()，因此输出B，此时i=0，然后i+2=2，然后输出C，i+5=7。因此最后结果为B C 7。</p>
<h3 id="main输出题目5"><a href="#main输出题目5" class="headerlink" title="main输出题目5"></a>main输出题目5</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%80%815.png" class title="This is an example image">

<p>输出：4 5 showZi showZi</p>
<h3 id="main输出题目6"><a href="#main输出题目6" class="headerlink" title="main输出题目6"></a>main输出题目6</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%80%816.png" class title="This is an example image">

<p>执行子类构造函数，默认第一行为super()，因为父类中没有空参的构造函数，只有有参的构造函数，因此super()不能被执行，编译失败。</p>
<h3 id="main输出题目7"><a href="#main输出题目7" class="headerlink" title="main输出题目7"></a>main输出题目7</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E6%80%817.png" class title="This is an example image">

<p>因为父类中方法与此类不一样，覆盖失败，编译报错。调用的不确定性。</p>
<h3 id="多态时成员的特点-1"><a href="#多态时成员的特点-1" class="headerlink" title="多态时成员的特点"></a>多态时成员的特点</h3><p>1.成员变量</p>
<p>编译时：参考引用型变量所属的类中是否有调用的成员变量，有，编译通过；没有，编译失败。</p>
<p>运行时：参考引用型变量所属的类中是否有调用的成员变量，并运行所属类中的成员变量</p>
<p>简单说：<strong>编译和运行都参考等号的左边</strong></p>
<p>2.成员函数（<strong>非静态</strong>，<strong>重点</strong>）</p>
<p>编译时：参考引用型变量所属的类中是否有调用的函数，有，编译通过；没有，编译失败。</p>
<p>运行时：参考的是对象所属的类中是否有调用的函数</p>
<p>简单说：<strong>编译看左边，运行看右边</strong></p>
<p>3.静态函数</p>
<p>编译时：参考引用型变量所属的类中是否有调用的静态方法</p>
<p>运行时：参考引用型变量所属的类中是否有调用的静态方法</p>
<p>简单说：<strong>编译和运行都参考等号的左边</strong></p>
<p>​    其实静态方法是不需要对象的，直接类名调用即可</p>
<h2 id="内部类-1"><a href="#内部类-1" class="headerlink" title="内部类"></a>内部类</h2><h3 id="内部类可以直接访问外部类中成员的原因"><a href="#内部类可以直接访问外部类中成员的原因" class="headerlink" title="内部类可以直接访问外部类中成员的原因"></a>内部类可以直接访问外部类中成员的原因</h3><p>内部类持有外部类的引用，外部类名.this</p>
<p>​    从内部类在局部位置上只能访问局部中被final修饰的局部变量</p>
<h3 id="main输出1-1"><a href="#main输出1-1" class="headerlink" title="main输出1"></a>main输出1</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%85%E9%83%A8%E7%B1%BB1.png" class title="This is an example image">

<p>在主函数中，若直接new Inner()对象会失败，因为<strong>静态方法中不允许有非静态成员</strong>，相当于this.new Inner()，而static中不允许出现this，此时需要将class Inner修改成 static class Inner</p>
<h3 id="main输出2"><a href="#main输出2" class="headerlink" title="main输出2"></a>main输出2</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%85%E9%83%A8%E7%B1%BB2.png" class title="This is an example image">

<p>new Object(){}相当于创立了子类对象，而Object obj=子类对象，匿名内部类这个子类对象被向上转型（多态）为Object类型，隐藏了子类特有属性，这样就不能使用子类特有的方法。编译看左边，Object类中无show方法，因此会编译失败</p>
<h3 id="main输出3"><a href="#main输出3" class="headerlink" title="main输出3"></a>main输出3</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%85%E9%83%A8%E7%B1%BB3.png" class title="This is an example image">

<p>编译失败，因为内部类中如果定义了静态成员，该内部类必须被静态修饰，或者该成员变量被final修饰。因为内部类相当于外部类的成员，必须在外部类的对象创建以后进行，java虚拟机要求所有的静态变量要在对象创建之前完成，因为如果非静态内部类中有静态变量，就要先加载非静态方法，再加载静态成员，与JVM矛盾。</p>
<p>​    但是可以在非静态内部类中定义静态常量（静态常量一定要有一个编译期常量），如果变量被static final修饰，字面常量会在编译阶段确定，称为编译期常量，不需要加载类的字节码文件，即编译期常量不会导致类加载，因此静态常量在非静态内部类中是合法的。（编译期常量折叠：编译期在编译阶段通过语法分析计算出常量表达式的具体值）。但是如果将y改成Math.randm()，会报错，因为这个需要运行确定。</p>
<p>​    总结：<strong>非静态内部类中不能拥有静态成员变量/方法，但是可以有静态的编译期常量，不能使用非编译期常量</strong>。</p>
<h3 id="main输出4"><a href="#main输出4" class="headerlink" title="main输出4"></a>main输出4</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%85%E9%83%A8%E7%B1%BB4.png" class title="This is an example image">

<p>A正确，在外部类访问内部类，必须要建立内部类的对象。</p>
<p>B 错误，因为主函数是静态方法，只能调用静态成员，所以内部类必须是静态的。</p>
<p>C错误，格式错误，应该是new Demo().new Inner();</p>
<p>D 格式正确，但是要求内部类是静态的。</p>
<h3 id="main输出5"><a href="#main输出5" class="headerlink" title="main输出5"></a>main输出5</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%85%E9%83%A8%E7%B1%BB5.png" class title="This is an example image">

<p>调用show()方法，不能直接show()，因为是非静态的，需要对象调用,new Demo().show();</p>
<p>然后传一个匿名对象进去，实现func()方法。</p>
<img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%85%E9%83%A8%E7%B1%BB5-2.png" class title="This is an example image">

<h2 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h2><h3 id="main输出1-2"><a href="#main输出1-2" class="headerlink" title="main输出1"></a>main输出1</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A31.png" class title="This is an example image">

<p>编译失败，因为编译看左边，运行看右边，而因为接口A中没有func方法，所以编译会报错。a所属的A接口中没有func()方法。</p>
<h3 id="main输出2-1"><a href="#main输出2-1" class="headerlink" title="main输出2"></a>main输出2</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8E%A5%E5%8F%A32.png" class title="This is an example image">

<p>编译失败，A a = get()；相当于A a = new B()；相当于把B对象封装，因为A中没有test()方法，因此编译报错。</p>
<h2 id="异常-1"><a href="#异常-1" class="headerlink" title="异常"></a>异常</h2><h3 id="main输出1-3"><a href="#main输出1-3" class="headerlink" title="main输出1"></a>main输出1</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BC%82%E5%B8%B81.png" class title="This is an example image">

<p>找main函数入口，执行show()方法,此方法进栈，抛出异常被catch，因此进入catch，输出B，finally一定会被执行，输出C，问题被解决了，输出D。因此结果为B C D。</p>
<h3 id="main输出2-2"><a href="#main输出2-2" class="headerlink" title="main输出2"></a>main输出2</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BC%82%E5%B8%B82.png" class title="This is an example image">

<p>throw异常下面的语句无法被执行，因为抛出异常就进入catch捕获异常。因此输出A是句废话，编译失败。与main输出1不一样，main输出1<strong>将异常封装</strong>，方法下面的语句还有可能被执行到。</p>
<p>throw 语句下面不要加其他语句，必然要跳转！！！</p>
<h3 id="main输出3-1"><a href="#main输出3-1" class="headerlink" title="main输出3"></a>main输出3</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BC%82%E5%B8%B83.png" class title="This is an example image">

<p>多catch时，父类的catch放在最下面，因此编译会失败。</p>
<h3 id="main输出4-1"><a href="#main输出4-1" class="headerlink" title="main输出4"></a>main输出4</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BC%82%E5%B8%B84.png" class title="This is an example image">

<p>134</p>
<p>13423</p>
<p>​    原因：foo(0)，不等于1，Output=1，然后执行finally，output=13，正常结束，output=134，然后输出134；执行foo(1)，一次是满足条件，丢出异常，output=1342（因为Output为静态变量，一直存在，因此始终操作的是同一变量），然后执行return，但是因为finally一定被执行（除非退出jvm），因此output=13423</p>
<h2 id="多线程-1"><a href="#多线程-1" class="headerlink" title="多线程"></a>多线程</h2><h3 id="实现死锁"><a href="#实现死锁" class="headerlink" title="实现死锁"></a>实现死锁</h3><p>死锁的代码：利用同步的嵌套</p>
<p>run方法中封装线程任务，设置两个同步的嵌套，一个为同步锁a,b；另一个为同步锁b,a；然后设定同步锁对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> flag;</span><br><span class="line">	<span class="comment">//设置构造函数，可以直接初始化参数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.flag = flag;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//设置同步的嵌套</span></span><br><span class="line">		<span class="keyword">if</span>(flag)&#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">				<span class="keyword">synchronized</span>(MyLock.obja)&#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName()+<span class="string">"if的obja"</span>);</span><br><span class="line">						<span class="keyword">synchronized</span>(MyLock.objb)&#123;</span><br><span class="line">							System.out.println(Thread.currentThread().getName()+<span class="string">"if的objb"</span>);</span><br><span class="line">					&#125;	</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">				<span class="keyword">synchronized</span>(MyLock.objb)&#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName()+<span class="string">"else的objb"</span>);</span><br><span class="line">						<span class="keyword">synchronized</span>(MyLock.obja)&#123;</span><br><span class="line">							System.out.println(Thread.currentThread().getName()+<span class="string">"else的obja"</span>);</span><br><span class="line">					&#125;	</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设立同步锁对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object obja = <span class="keyword">new</span> Object();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object objb = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Test a = <span class="keyword">new</span> Test(<span class="keyword">true</span>);</span><br><span class="line">		Test b = <span class="keyword">new</span> Test(<span class="keyword">false</span>);</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(a);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(b);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试题1"><a href="#面试题1" class="headerlink" title="面试题1"></a>面试题1</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B1.png" class title="This is an example image">

<p>错误在第一行，此run()方法为子类特有方法，Test实现了Runnable接口，但是没有覆盖Run()方法，应该被abstract修饰</p>
<h3 id="面试题2"><a href="#面试题2" class="headerlink" title="面试题2"></a>面试题2</h3><img src="/2020/01/14/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B2.png" class title="This is an example image">

<p>​    判断Thread自身run()和runnable的run方法优先级，应该输出subThread run。</p>
<p>​    Thread实现了自己的run方法，因此直接执行下边的run()方法，只有在下边的run()未实现时，才会寻找到上边的Runnable的run方法，并执行，这就是优先级顺序。</p>
<p>​    因为应该以<strong>子类的任务</strong>为主(new Thread中的run方法)，如果子类没有覆写run方法，那么则以<strong>任务对象</strong>为主，如果没有任务对象，则以<strong>Thread</strong>原有run方法为主</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux使用</title>
    <url>/2020/01/14/Linux%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Linux下安装jdk8"><a href="#Linux下安装jdk8" class="headerlink" title="Linux下安装jdk8"></a>Linux下安装jdk8</h2><h3 id="卸载Linux自带OpenJDK"><a href="#卸载Linux自带OpenJDK" class="headerlink" title="卸载Linux自带OpenJDK"></a>卸载Linux自带OpenJDK</h3><p>切换到root权限</p>
<blockquote>
<p>su root</p>
</blockquote>
<p> 使用java -version看OpenJDK信息，然后查询系统自带java相关文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep java</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>命令说明：</p>
<p>rpm 　管理套件</p>
<p>-qa 　使用询问模式，查询所有套件</p>
<p>grep　　查找文件里符合条件的字符串</p>
<p>java 　查找包含java字符串的文件</p>
<p> 除noarch外，删除其他java文件</p>
<blockquote>
<p>rpm -e –nodeps java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64</p>
</blockquote>
<p>命令介绍</p>
<p>rpm 　　　管理套件</p>
<p>-e　　　　　删除指定的套件</p>
<p>–nodeps　　不验证套件档的相互关联性</p>
<p> 当输入java -version，没有找到命令，代表删除成功。</p>
<hr>
<h3 id="下载JDK"><a href="#下载JDK" class="headerlink" title="下载JDK"></a>下载JDK</h3><p>历史版本下载地址：　　<a href="http://www.oracle.com/technetwork/java/javase/archive-139210.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/archive-139210.html</a></p>
<p> 通过浏览器下载会默认下载到当前登陆用户的下载目录，下载位置为“当前用户/下载/jdk-8u211-linux-x64.tar.gz”。</p>
<p> cd 下载，然后使用</p>
<blockquote>
<p>ls -al 展示本目录下所有文件</p>
</blockquote>
<p> 为了查看当前目录路径，可以使用</p>
<blockquote>
<p>pwd 查看当前目录路径</p>
</blockquote>
<hr>
<h3 id="复制JDK"><a href="#复制JDK" class="headerlink" title="复制JDK"></a>复制JDK</h3><h4 id="备份JDK"><a href="#备份JDK" class="headerlink" title="备份JDK"></a>备份JDK</h4><p> 将压缩包复制一份到/usr/local/src/作备份，输入命令</p>
<blockquote>
<p>cp jdk-8u211-linux-x64.tar.gz /usr/local/src</p>
</blockquote>
<p>命令说明：</p>
<p>cp　　　　　　　　　　　　　　 复制文件或目录</p>
<p>jdk-8u211-linux-x64.tar.gz　　　　文件名</p>
<p>/user/local/src　　　　　　　　　 要复制的目标目录</p>
<h4 id="创建java文件夹"><a href="#创建java文件夹" class="headerlink" title="创建java文件夹"></a>创建java文件夹</h4><p> 在usr目录下创建一个文件夹，名为java</p>
<blockquote>
<p>mkdir java</p>
</blockquote>
<p> 然后将文件拷贝至/usr/java</p>
<blockquote>
<p>cp jdk-8u211-linux-x64.tar.gz /usr/java</p>
</blockquote>
<hr>
<h3 id="解压缩JDK"><a href="#解压缩JDK" class="headerlink" title="解压缩JDK"></a>解压缩JDK</h3><h4 id="在java目录下解压JDK压缩文件"><a href="#在java目录下解压JDK压缩文件" class="headerlink" title="在java目录下解压JDK压缩文件"></a>在java目录下解压JDK压缩文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf jdk-8u144-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>

<p>命令介绍：</p>
<p>tar　　　　　　备份文件</p>
<p>-zxvf　　　　　</p>
<p>-z　　　　　　 　　　　　　　 通过gzip指令处理备份文件</p>
<p>-x　　　　　　　　　　　　　　 从备份文件中还原文件</p>
<p>-v　　　　　　　　　　　　　　 显示指令执行过程</p>
<p>-f　　　　　　 　　　　　　　　 指定备份文件</p>
<p>jdk-8u211-linux-x64.tar.gz　　　　文件名</p>
<h4 id="删除JDK压缩包"><a href="#删除JDK压缩包" class="headerlink" title="删除JDK压缩包"></a>删除JDK压缩包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -f jdk-8u211-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>

<p>命令解释：</p>
<p>rm　　　　删除文件或目录</p>
<p>-f　　　　 强制删除文件或目录</p>
<hr>
<h3 id="配置JDK环境变量"><a href="#配置JDK环境变量" class="headerlink" title="配置JDK环境变量"></a>配置JDK环境变量</h3><h4 id="编辑全局变量"><a href="#编辑全局变量" class="headerlink" title="编辑全局变量"></a>编辑全局变量</h4><p>命令行键入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<p>命令说明：</p>
<p>vim　　　　　　文本编辑</p>
<p>/etc/profile　　　全局变量文件</p>
<p>进入文本编辑状态下，光标走到文件最后一行，键盘按下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i</span><br></pre></td></tr></table></figure>

<p> 进入插入状态：</p>
<p>在文本的最后一行粘贴如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i</span><br></pre></td></tr></table></figure>

<p>注意JAVA_HOME=/usr/java/jdk1.8.0_211 为你自己的目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#java environment</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_211</span><br><span class="line">export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;jre&#x2F;lib&#x2F;rt.jar:$&#123;JAVA_HOME&#125;&#x2F;lib&#x2F;dt.jar:$&#123;JAVA_HOME&#125;&#x2F;lib&#x2F;tools.jar</span><br><span class="line">export PATH&#x3D;$PATH:$&#123;JAVA_HOME&#125;&#x2F;bin</span><br></pre></td></tr></table></figure>

<p>【注】：CentOS6上面的是JAVAHOME，CentOS7是{JAVA_HOME}</p>
<p> 复制完成后，在键盘敲下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ESC</span><br><span class="line">shift+q</span><br></pre></td></tr></table></figure>

<p> 进入EX模式，敲下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x</span><br></pre></td></tr></table></figure>

<p> 保存并退出。</p>
<hr>
<h3 id="检验环境变量是否生效"><a href="#检验环境变量是否生效" class="headerlink" title="检验环境变量是否生效"></a>检验环境变量是否生效</h3><h4 id="让刚刚设置的环境变量生效"><a href="#让刚刚设置的环境变量生效" class="headerlink" title="让刚刚设置的环境变量生效"></a>让刚刚设置的环境变量生效</h4><p>键入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<p>source /etc/profile或 . /etc/profile</p>
<h4 id="检查是否配置成功"><a href="#检查是否配置成功" class="headerlink" title="检查是否配置成功"></a>检查是否配置成功</h4><p>键入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>pwd 查看当前目录路径</li>
<li>ls -al 展示本目录下所有文件</li>
</ul>
<h3 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h3><ul>
<li>mkdir dir 创建文件夹</li>
</ul>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul>
<li>cp 复制文件</li>
</ul>
<p>cp　　　　　　　　　　　　　　 复制文件或目录</p>
<p>jdk-8u211-linux-x64.tar.gz　　　　完整文件名</p>
<p>/user/local/src　　　　　　　　　 要复制的目标目录</p>
<ul>
<li>rm 删除文件</li>
</ul>
<p>rm　　　　删除文件或目录</p>
<p>-f　　　　 强制删除文件或目录</p>
<ul>
<li>tar 备份，解压缩文件</li>
</ul>
<p>tar　　　　　　备份文件</p>
<p>-zxvf　　　　　</p>
<p>-z　　　　　　 　　　　　　　 通过gzip指令处理备份文件</p>
<p>-x　　　　　　　　　　　　　　 从备份文件中还原文件</p>
<p>-v　　　　　　　　　　　　　　 显示指令执行过程</p>
<p>-f　　　　　　 　　　　　　　　 指定备份文件</p>
<p>jdk-8u211-linux-x64.tar.gz　　　　文件名</p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><h4 id="编辑全局变量-1"><a href="#编辑全局变量-1" class="headerlink" title="编辑全局变量"></a>编辑全局变量</h4><p>vim /etc/profile</p>
<p>i 插入</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown使用</title>
    <url>/2019/12/29/markdown%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="markdown在hexo中使用"><a href="#markdown在hexo中使用" class="headerlink" title="markdown在hexo中使用"></a>markdown在hexo中使用</h1><h2 id="markdown工具"><a href="#markdown工具" class="headerlink" title="markdown工具"></a>markdown工具</h2><h3 id="个人使用工具：Typora"><a href="#个人使用工具：Typora" class="headerlink" title="个人使用工具：Typora"></a>个人使用工具：<strong>Typora</strong></h3><ol>
<li>基于Windows下载</li>
<li>偏好设置 </li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><p>​    博客部署至远端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hexo deploy -g</span><br></pre></td></tr></table></figure>

<p>​    将hexo文件夹源代码（写作所在文件夹）push至github仓库</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m “message”</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h2><p>引用自博客</p>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_30734435/article/details/98497054" target="_blank" rel="noopener">https://blog.csdn.net/weixin_30734435/article/details/98497054</a></p>
</blockquote>
<h4 id="更改配置文件"><a href="#更改配置文件" class="headerlink" title="更改配置文件"></a>更改配置文件</h4><p>​    在根目录下配置文件<code>_config.yml</code> 中有 <code>post_asset_folder:false改为true</code>。这样在建立文件时，<code>Hexo</code>会自动建立一个与文章同名的文件夹，这样就可以把与该文章相关的所有资源（图片）都放到那个文件夹里方便后面引用。</p>
<h4 id="安装git插件"><a href="#安装git插件" class="headerlink" title="安装git插件"></a>安装git插件</h4><blockquote>
<p>npm install <a href="https://github.com/7ym0n/hexo-asset-image" target="_blank" rel="noopener">https://github.com/7ym0n/hexo-asset-image</a> –save</p>
</blockquote>
<h4 id="在插入图片处增加代码"><a href="#在插入图片处增加代码" class="headerlink" title="在插入图片处增加代码"></a>在插入图片处增加代码</h4><p><a href="https://hexo.io/zh-cn/docs/asset-folders" target="_blank" rel="noopener">官方文档</a>给出了解决方式，使用代码为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure>

<p>​    将example.jpg修改为所需要的文件名称和后缀即可，其中<strong>This is an example image</strong>是图片描述。</p>
<h4 id="显示效果"><a href="#显示效果" class="headerlink" title="显示效果"></a>显示效果</h4><img src="/2019/12/29/markdown%E4%BD%BF%E7%94%A8/%E4%BC%A0%E5%9B%BE%E7%89%87%E6%96%B9%E6%B3%95.png" class title="This is an example image">

<h3 id="标题前不加数字"><a href="#标题前不加数字" class="headerlink" title="标题前不加数字"></a>标题前不加数字</h3><p>​    在标题前面加数字，hexo使用Next模板后，会自动根据多级标题加上相应数字生成目录，如果人为在多级标题前面加入数字，体验感并不好。</p>
<h1 id="markdown语法记录"><a href="#markdown语法记录" class="headerlink" title="markdown语法记录"></a>markdown语法记录</h1><p>引用自知乎，将一些常用命令进行记录</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/90561228" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/90561228</a></p>
</blockquote>
<h2 id="字体编辑"><a href="#字体编辑" class="headerlink" title="字体编辑"></a>字体编辑</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>​    有6级标题可选，分别为按下Ctrl+1~6。</p>
<h3 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">快捷键：Ctrl+数字  或 Ctrl+加减号  或  ### （几个#表示几级标题，同上）</span><br></pre></td></tr></table></figure>

<h3 id="字体加粗"><a href="#字体加粗" class="headerlink" title="字体加粗"></a>字体加粗</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">快捷键：Ctrl+b</span><br><span class="line">示 例：**加粗内容**</span><br></pre></td></tr></table></figure>

<p>​    加粗前：字体；加粗后<strong>字体</strong></p>
<h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">快捷键：ctrl+i</span><br><span class="line">示 例：*斜体*</span><br></pre></td></tr></table></figure>

<p>​    斜体前：斜体；斜体后<em>斜体</em></p>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">快捷键：alt+shift+5</span><br><span class="line">示 例：~~删除的内容~~</span><br></pre></td></tr></table></figure>

<p>​    删除前：删除；删除后：<del>删除</del></p>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">快捷键：Ctrl+u</span><br><span class="line">示 例：&lt;u&gt;下划线内容&lt;&#x2F;u&gt;</span><br></pre></td></tr></table></figure>

<p>​    下划前：下划；下划后：<u>下划</u></p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：这块有个脚注[^脚注]</span><br><span class="line">     [^脚注]:填写脚注的内容</span><br><span class="line">示例：有一个github网址[^1]</span><br><span class="line">     [^1]:https:&#x2F;&#x2F;github.com&#x2F;</span><br></pre></td></tr></table></figure>

<p>​    无脚注；有脚注<a href="https://github.com/" target="_blank" rel="noopener">^1</a></p>
<h3 id="灰色背景"><a href="#灰色背景" class="headerlink" title="灰色背景"></a>灰色背景</h3><p>加之前：Github，加之后<code>Github</code>，具体为大写锁定后按1左边的键。</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：数字+英文小数点(.)+空格</span><br><span class="line">示例：1. list1</span><br><span class="line">     2. list2</span><br></pre></td></tr></table></figure>

<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：- +空格 或 * + 空格</span><br><span class="line">示例： - list1</span><br><span class="line">      - list2</span><br></pre></td></tr></table></figure>

<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h3 id="插入代码块"><a href="#插入代码块" class="headerlink" title="插入代码块"></a>插入代码块</h3><p>快捷键：shift+3个~</p>
<h3 id="插入数学公式"><a href="#插入数学公式" class="headerlink" title="插入数学公式"></a>插入数学公式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：$$ + enter</span><br><span class="line">示例：$$ + enter后输入11+12，结果如下所示</span><br></pre></td></tr></table></figure>

<p>$$<br>11+12<br>$$</p>
<h3 id="插入引用"><a href="#插入引用" class="headerlink" title="插入引用"></a>插入引用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：&gt; + 空格</span><br><span class="line">示例：&gt; + 空格后，输入 引用的内容，结果如下所示</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是一个引用</p>
</blockquote>
<h3 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操 作:Ctrl+k弹出后，输入 [输入标题名](输入链接地址) 即可</span><br><span class="line">示 例1：[百度一下，你就知道](https:&#x2F;&#x2F;www.baidu.com&#x2F;)</span><br><span class="line">示 例2：这是 [百度一下，你就知道](https:&#x2F;&#x2F;www.baidu.com&#x2F; &quot;百度&quot;) 的链接.  </span><br><span class="line">示 例3：这是 [github][1] 的链接.  </span><br><span class="line">       [1]: https:&#x2F;&#x2F;github.com&#x2F; &quot;github&quot;</span><br><span class="line">ps：按住ctrl点击链接可直接打开</span><br></pre></td></tr></table></figure>

<p><a href="https://www.baidu.com/" target="_blank" rel="noopener">百度一下，你就知道</a></p>
<p>这是<a href="https://www.baidu.com/" target="_blank" rel="noopener" title="百度">百度一下，你就知道</a> 的链接</p>
<h3 id="插入注释"><a href="#插入注释" class="headerlink" title="插入注释"></a>插入注释</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：[^文字]：文字</span><br><span class="line">示例：[^1]：文献1</span><br></pre></td></tr></table></figure>

<p>​    <a href="hughzc.github.io">^2</a> : 个人博客地址</p>
<h3 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">快捷键：ctrl+t</span><br><span class="line">示 例：按完快捷键后，弹出下图，选择对应的行和列，点击确定即可。</span><br></pre></td></tr></table></figure>
<p>弹出下图的选项</p>
<img src="/2019/12/29/markdown%E4%BD%BF%E7%94%A8/%E8%A1%A8%E6%A0%BC.png" class title="This is an example image">



<table>
<thead>
<tr>
<th>1</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="普通markdown插入图片"><a href="#普通markdown插入图片" class="headerlink" title="普通markdown插入图片"></a>普通markdown插入图片</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：直接拖动  或 ctrl+shift+i(相对路径地址)</span><br><span class="line">示例：![](C:\1.jpg)</span><br></pre></td></tr></table></figure>

<p>​    如果是在hexo中插入图片，需要使用代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入分隔符"><a href="#插入分隔符" class="headerlink" title="插入分隔符"></a>插入分隔符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：--- + enter  或者 *** + enter</span><br></pre></td></tr></table></figure>

<p>这是条分割线</p>
<hr>
<h3 id="插入目录"><a href="#插入目录" class="headerlink" title="插入目录"></a>插入目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作：[toc]+enter</span><br></pre></td></tr></table></figure>







]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
