<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://hughzc.github.io').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="JVMJVM介绍Java Virtual Machine，JVM运行在操作系统上，与硬件没有直接的交互。 JVM体系结构概览  JVM包括2个子系统和2个组件，2个子系统为类加载器和执行引擎，2个组件是运行时数据区和本地接口。 整个流程为，编译期将Java代码转为字节码，类加载器将字节码加载进运行数据区中的方法区中，执行引擎来进行解析为系统指令，交由CPU执行，需要调用其他语言的本地接口来实现功能">
<meta property="og:type" content="article">
<meta property="og:title" content="jvm">
<meta property="og:url" content="https://hughzc.github.io/2020/03/21/jvm/index.html">
<meta property="og:site_name" content="未名的奇妙旅程">
<meta property="og:description" content="JVMJVM介绍Java Virtual Machine，JVM运行在操作系统上，与硬件没有直接的交互。 JVM体系结构概览  JVM包括2个子系统和2个组件，2个子系统为类加载器和执行引擎，2个组件是运行时数据区和本地接口。 整个流程为，编译期将Java代码转为字节码，类加载器将字节码加载进运行数据区中的方法区中，执行引擎来进行解析为系统指令，交由CPU执行，需要调用其他语言的本地接口来实现功能">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hughzc.github.io/2020/03/21/jvm/jvm%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/21/jvm/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/21/jvm/%E6%A0%88%E5%B8%A7.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/21/jvm/%E6%96%B0%E7%94%9F%E5%85%BB%E8%80%81.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/21/jvm/%E6%B0%B8%E4%B9%85%E5%8C%BA.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/21/jvm/%E5%A0%86%E5%8F%82%E6%95%B0.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/21/jvm/%E5%A0%86%E5%8F%82%E6%95%B02.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/21/jvm/%E5%A0%86%E4%BF%A1%E6%81%AF.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/21/jvm/OOM.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/21/jvm/%E6%94%B6%E9%9B%86%E5%99%A8.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/21/jvm/%E5%B9%B4%E8%BD%BB1.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/21/jvm/%E5%B9%B4%E8%BD%BB2.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/21/jvm/%E8%80%81%E5%B9%B41.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/21/jvm/cms.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/21/jvm/gc.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/21/jvm/vmoom.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/21/jvm/mainoom.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/21/jvm/sboom.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/21/jvm/%E5%80%BCoom.png">
<meta property="article:published_time" content="2020-03-21T03:41:02.000Z">
<meta property="article:modified_time" content="2020-03-25T14:33:03.884Z">
<meta property="article:author" content="未名Hugh">
<meta property="article:tag" content="jvm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hughzc.github.io/2020/03/21/jvm/jvm%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png">

<link rel="canonical" href="https://hughzc.github.io/2020/03/21/jvm/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>jvm | 未名的奇妙旅程</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">未名的奇妙旅程</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">怕什么真理无穷，进一寸有一寸的欢喜</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hughzc.github.io/2020/03/21/jvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="未名Hugh">
      <meta itemprop="description" content="技术博客，Java，并发编程，算法">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="未名的奇妙旅程">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          jvm
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-21 11:41:02" itemprop="dateCreated datePublished" datetime="2020-03-21T11:41:02+08:00">2020-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-25 22:33:03" itemprop="dateModified" datetime="2020-03-25T22:33:03+08:00">2020-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/jvm/" itemprop="url" rel="index">
                    <span itemprop="name">jvm</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="JVM介绍"><a href="#JVM介绍" class="headerlink" title="JVM介绍"></a>JVM介绍</h2><p>Java Virtual Machine，JVM运行在操作系统上，与硬件没有直接的交互。</p>
<h3 id="JVM体系结构概览"><a href="#JVM体系结构概览" class="headerlink" title="JVM体系结构概览"></a>JVM体系结构概览</h3><img src="/2020/03/21/jvm/jvm%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" class title="This is an example image">

<p>JVM包括2个子系统和2个组件，2个子系统为类加载器和执行引擎，2个组件是运行时数据区和本地接口。</p>
<p>整个流程为，编译期将Java代码转为字节码，类加载器将字节码加载进运行数据区中的方法区中，执行引擎来进行解析为系统指令，交由CPU执行，需要调用其他语言的本地接口来实现功能。</p>
<p>亮色：所有线程共享，存在垃圾回收；</p>
<p>灰色：线程私有，不存在垃圾回收。</p>
<p>分为3层来学习。</p>
<p>先是类装载器与执行引擎。</p>
<a id="more"></a>

<h3 id="类装载器ClassLoader"><a href="#类装载器ClassLoader" class="headerlink" title="类装载器ClassLoader"></a>类装载器ClassLoader</h3>

<h4 id="介绍（是什么）"><a href="#介绍（是什么）" class="headerlink" title="介绍（是什么）"></a>介绍（是什么）</h4><p>负责加载class文件，class文件在文件<strong>开头有特定的文件标识</strong>（cafe babe），将class文件字节码内容加载到内存中，并将这些内容转换成<strong>方法区</strong>中的运行时数据结构，且ClassLoader只负责class文件的<strong>加载</strong>，至于其是否可以运行，由Execution Engine决定。</p>
<p>Car.class由ClassLoader装载进内存，Car Class装载进方法区，一个模板Car Class，可以产生多个实例。类装载器有多个，有以下几类</p>
<h4 id="种类（有哪些）"><a href="#种类（有哪些）" class="headerlink" title="种类（有哪些）"></a>种类（有哪些）</h4><p><strong>虚拟机自带的加载器</strong></p>
<ul>
<li><strong>启动类</strong>加载器（Boostrap）C++写的</li>
<li><strong>扩展类</strong>加载器（Extension）Java写的 </li>
<li><strong>应用程序类</strong>加载器（AppClassLoader）Java也叫系统类加载器，加载当前应用的classpath的所有类</li>
</ul>
<p><strong>用户自定义加载器</strong></p>
<p>Java.lang.ClassLoader的子类，用户可以定义类的加载方式</p>
<p>为了获取到Class文件，有三种方式</p>
<p>1、Object类中的getClass()方法</p>
<p>2、类的class属性，如Object.class</p>
<p>3、Class中的方法，Class.forName(String className)</p>
<p>获取到Class文件后，通过getClassLoader()可以获取到ClassLoader。</p>
<p>如果类是系统自带的，为Boostrap加载器，启动时便加载进了内存，打印出来为null；如果为自定义的类，打印出来为AppClassLoader。lib/ext包下的文件为拓展包。</p>
<p>自定义类为Person，获取到其Class文件，打印其classLoader及父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">System.out.println(clazz.getClassLoader().getParent().getParent());</span><br><span class="line">System.out.println(clazz.getClassLoader().getParent());</span><br><span class="line">System.out.println(clazz.getClassLoader());</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">null</span></span><br><span class="line">sun.misc.Launcher$ExtClassLoader@<span class="number">16</span>d3586</span><br><span class="line">sun.misc.Launcher$AppClassLoader<span class="meta">@dad</span>5dc</span><br></pre></td></tr></table></figure>

<img src="/2020/03/21/jvm/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.png" class title="This is an example image">

<h4 id="双亲委派（怎么用）"><a href="#双亲委派（怎么用）" class="headerlink" title="双亲委派（怎么用）"></a>双亲委派（怎么用）</h4><p>简单来说先从父类寻找，找到了就用，找不到再找子类。类加载从Boostrap至Extension再到AppClassLoader。</p>
<p>如果自定义一个java.lang包下的String类，默认会在Boostrap的ClassLoader中先找这个类，但是在rt.jar包中的String没有自定义写的main方法，因此会报错。</p>
<p>设立目的是不让自己写的类污染Java自带的类，<strong>保障沙箱安全</strong>。</p>
<p>详细介绍为：当一个类收到了<strong>类加载请求</strong>，首先<strong>不会尝试自己去加载此</strong>类，而是将这个请求<strong>委托给父类去完成</strong>，每一个层次类加载器都如此，因此所有的加载请求都应该传送到启动类加载器中，只有当父类加载器反馈自己无法完成这个请求时（在其加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。</p>
<h4 id="沙箱安全（什么用）"><a href="#沙箱安全（什么用）" class="headerlink" title="沙箱安全（什么用）"></a>沙箱安全（什么用）</h4><p>保证了使用不同的类加载器，最终都是委托给<strong>顶层的启动类加载器进行加载</strong>，可以保障得到的类的安全性。</p>
<p>执行引擎负责解释命令，提交给操作系统执行。</p>
<h4 id="类装载的执行过程"><a href="#类装载的执行过程" class="headerlink" title="类装载的执行过程"></a>类装载的执行过程</h4><ol>
<li>加载：根据查找路径找到相应的class文件然后导入</li>
<li>验证：检查加载的class文件的正确性（CafeBaBe）</li>
<li>准备：给类中的静态变量分配内存空间</li>
<li>解析：虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用可理解为一个标识，在直接饮用中直接指向内存的地址</li>
<li>初始化：对静态变量和静态代码块执行初始化过程</li>
</ol>
<h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><ul>
<li>执行方法区</li>
<li>修改程序计数器中的行号</li>
<li>开辟线程执行GC</li>
</ul>
<h3 id="本地接口"><a href="#本地接口" class="headerlink" title="本地接口"></a>本地接口</h3><p>Java底层调用的方法为native方法，由<strong>本地方法接口</strong>提供，为了将其装载进内存并与普通方法区别，装载进特殊的栈中，即<strong>本地方法栈</strong>中（Native Method Stack）。方法具体的实现交给本地方法库。native是关键字，有声明，无实现。</p>
<p>本地接口的作用是融合不同编程语言为Java调用，在内存中专门开辟了区域处理标记为native方法，具体做法为Native Method Stack栈中登记native方法，在Execution Engine执行时加载<strong>本地方法库</strong>。目前该方法使用越来越少。</p>
<h3 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h3><p>记录了方法之间的调用与执行情况。该程序接下来要去哪。</p>
<p>每个线程都有程序计数器，是线程私有的，指向方法区中的方法字节码（<strong>正在执行的代码行号</strong>），此值被<strong>执行引擎</strong>赋值。内存空间很小，几乎可忽略（不存在GC），<strong>是当前线程所执行的字节码的行号指示器</strong>。若执行的为Native方法，计数器是空。不会发生内存溢出（OutOfMemory=OOM）错误。</p>
<p>便于执行<strong>线程的上下文切换</strong>，如果没有程序计数器，当切换到这个线程的时候，便不知道该执行哪行代码。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>供线程共享的运行时内存区域，<strong>存储每一个类的结构信息</strong>（模板）。如运行时常量池（Runtime Constant Pool），字段和方法数据，构造函数和普通方法的字节码内容。</p>
<p>常量+静态变量+类信息。方法区中静态变量存储的是堆中对象的地址。</p>
<p>上面讲的是<strong>规范</strong>，不同虚拟机中实现不一样，最典型的为永久代（PermGen Space）和元空间（Metaspace）。</p>
<p>实例变量存在堆中，与方法区无关。</p>
<p>由字节码执行引擎去执行。</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈管运行，堆管存储。</p>
<p>栈（先进后出），队列（先进先出）。</p>
<p>栈也叫栈内存，主管Java程序的运行，栈在线程创建时创建，栈的生命周期跟随线程，对于栈不存在垃圾回收问题。是线程私有的。<strong>8种基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存中分配</strong>。</p>
<p>栈帧：当一个方法入栈时，在栈中为其单独开辟一个空间，叫做栈帧，存放方法中的局部变量等。栈的数据结构为先进后出，结构与程序运行特点相符，先执行的方法后结束。</p>
<img src="/2020/03/21/jvm/%E6%A0%88%E5%B8%A7.png" class title="This is an example image">

<p>栈帧中有4部分</p>
<ul>
<li><p><strong>局部变量表</strong>：为局部变量开辟地址存储；对象地址（引用）</p>
</li>
<li><p><strong>操作数栈</strong>：存储操作数运算时需要的临时变量</p>
<p>常量的计算，给局部变量赋值，从局部变量表中取值运算</p>
</li>
<li><p><strong>动态链接</strong>：符号引用转为符号引用（加载中的解析？）</p>
</li>
<li><p><strong>方法出口</strong>：指向此方法结束后应该跳转的方法出口</p>
</li>
</ul>
<h4 id="栈的存储"><a href="#栈的存储" class="headerlink" title="栈的存储"></a>栈的存储</h4><p>栈帧中主要存储3类数据</p>
<ul>
<li><strong>本地变量</strong>（Local Varibles）：输入参数和输出参数及方法内的变量</li>
<li>栈操作（Operand Stack）：记录出栈、入栈的操作</li>
<li>栈帧数据（Frame Data）：包括类文件、方法等等</li>
</ul>
<h4 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h4><p>每个方法执行的同时都会创建一个一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。方法从调用到执行完毕的过程就对应着一个栈帧在虚拟机中入栈到出栈的过程。</p>
<p>栈的大小和具体的jvm实现相关，通常在256k-756k之间，<strong>约等于1Mb左右</strong>。</p>
<p>可以通过-Xss:设定每个线程虚拟机栈的大小，一般256k足够，会影响并发线程数的大小</p>
<p>Exception in Thread “main” java.lang.StackOverflowError</p>
<p>是Error错误，</p>
<p>Error与Exception父类为Throwable。</p>
<ul>
<li>如果线程请求栈的深度超过了虚拟机所允许的深度，报StackOverflowError</li>
<li>虚拟机栈可以动态扩展，如果扩展到无法申请足够的内存，会报OOM</li>
</ul>
<h4 id="栈-堆-方法区的交互"><a href="#栈-堆-方法区的交互" class="headerlink" title="栈+堆+方法区的交互"></a>栈+堆+方法区的交互</h4><p>HotSpot使用指针的方式来访问对象，栈中存放引用变量reference，存储对象的地址，Java堆中存放访问类元数据的地址（对象实例数据），方法区中存放对象类型数据。</p>
<h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><p>浅拷贝：增加一个指针指向已经存在的内存地址</p>
<p>深拷贝：增加一个指针且申请一个新的内存，使这个指针指向新的内存</p>
<h4 id="堆与栈的区别"><a href="#堆与栈的区别" class="headerlink" title="堆与栈的区别"></a>堆与栈的区别</h4><ul>
<li>物理地址：<strong>堆的物理地址分配不连续</strong>，<strong>栈的物理地址分配连续</strong></li>
<li>内存：堆因为不连续，分配内存在运行期间确定，大小不固定，一般远大于栈；栈为连续，分配内存在编译时确定，大小固定</li>
<li>存放内容：堆中存放对象的<strong>实例</strong>和<strong>数组</strong>，更关注数据的存储；栈中存放<strong>局部变量</strong>，<strong>对象引用</strong>，更关注方法运行</li>
<li>可见度：堆是所有线程共享的，栈是线程私有的，生命周期与线程相同</li>
</ul>
<p>静态变量放在方法区，静态对象放在堆中</p>
<h4 id="new对象发生的事情"><a href="#new对象发生的事情" class="headerlink" title="new对象发生的事情"></a>new对象发生的事情</h4><p>Student s = new Student()；</p>
<ol>
<li>加载Student.class进内存</li>
<li>在栈空间为s开辟空间</li>
<li>在堆空间为学生对象开辟空间</li>
<li>学生对象初始化</li>
<li>将对象地址赋值给s</li>
</ol>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>逻辑上三部分：新生+老年+元空间（7为永久代），物理上为新生+养老</p>
<ol>
<li>新生代（New）<ul>
<li>伊甸园区（Eden Space）</li>
<li>幸存者零区(Servivor 0 space)</li>
<li>幸存者一区(Servivor 1 space)</li>
</ul>
</li>
<li>老年代(Old，Tenure)</li>
<li><strong>元空间</strong>(Perm)</li>
</ol>
<p>一个jvm实例只存在一个堆内存，大小可调。类加载读取了类文件后，需要把类、方法 、常变量放到堆内存中。</p>
<p>Java7之前为<strong>永久代</strong>，Java8后为<strong>元空间</strong>。</p>
<h4 id="堆new对象流程"><a href="#堆new对象流程" class="headerlink" title="堆new对象流程"></a>堆new对象流程</h4><p>新建对象在Eden区，当一直new对象，<strong>Eden区达到阈值</strong>，进行<strong>MinorGC</strong>=轻GC，Eden区基本清空，第一次幸存后的对象移动到<strong>幸存者0区</strong>，也叫S0=from区。当S0满了再进行垃圾回收，从S0到S1=to区，S0与S1进行一次交换（<strong>from和to区，名称不是固定的，每次GC后会交换，谁空谁是to</strong>）。<strong>养老区满了</strong>，开启Major GC（Full GC），Major GC多次，老年代空间执行了Major GC后仍无法新建对象，报OOM异常。</p>
<p>如果出现java.lang.OutOfMemoryError:Java heap space异常，说明Java虚拟机堆内存不够，原因有</p>
<ol>
<li><strong>Java虚拟机的堆内存设置不够，可以通过参数-Xms，-Xmx调整</strong></li>
<li><strong>代码中创建了大量大对象，并且长时间不能被垃圾收集器手机（存在引用）</strong></li>
</ol>
<img src="/2020/03/21/jvm/%E6%96%B0%E7%94%9F%E5%85%BB%E8%80%81.png" class title="This is an example image">

<p><strong>新生代1/3</strong>堆空间，<strong>老年代2/3堆</strong>空间。新生代中，Eden8/10空间，From和To各1/10（<strong>8:1:1</strong>）。</p>
<h4 id="MinorGC（复制-gt-清空-gt-互换）"><a href="#MinorGC（复制-gt-清空-gt-互换）" class="headerlink" title="MinorGC（复制-&gt;清空-&gt;互换）"></a>MinorGC（复制-&gt;清空-&gt;互换）</h4><ol>
<li>eden、From复制到To，年龄+1</li>
</ol>
<p>当Eden区满的时候触发第一次GC，将活着的对象拷贝进From区，当Eden区再次触发GC的时候，扫描Eden区和From区，将这两个区域进行垃圾回收，经过这次回收后还存活的对象，直接复制到To区，（若有对象达到老年的标准，则复制到老年区），将这些对象的年龄+1。<strong>分代年龄</strong>记录在<strong>对象头</strong>的MarkWord中。</p>
<ol start="2">
<li>清空eden、from</li>
</ol>
<p>清空eden和from中的对象</p>
<ol start="3">
<li>from和to互换</li>
</ol>
<p>from和to互换，原to成为下一次的from，部分对象来from与to区域间来回复制，若交换15次（由JVM参数MaxTenuringThreashold决定，默认15）还活着进入老年代。</p>
<h4 id="永久代（jdk7前）"><a href="#永久代（jdk7前）" class="headerlink" title="永久代（jdk7前）"></a>永久代（jdk7前）</h4><p>方法区和堆一样，是线程共享的内存区域，虽然JVM规范将方法区描述为堆的一个逻辑部分，但其有别名为Non-Heap（非堆），目的是和堆分开。</p>
<p>堆HotSpot，很多开发者习惯将方法区称之为永久代，但严格本质上说二者不同，或者说使用永久代来实现方法区而已，永久代是方法区（相当于一个接口）的实现。jdk1.7中将原本在永久代的字符串常量池移走。</p>
<img src="/2020/03/21/jvm/%E6%B0%B8%E4%B9%85%E5%8C%BA.png" class title="This is an example image">

<p>永久存储区是一个常驻内存区域，用于存放jdk自身携带的Class，Interface的元数据，存储的是运行环境必须的信息，被装载进此区域的数据不会被GC，关闭JVM才会释放此空间的内存。</p>
<h4 id="堆参数调整"><a href="#堆参数调整" class="headerlink" title="堆参数调整"></a>堆参数调整</h4><img src="/2020/03/21/jvm/%E5%A0%86%E5%8F%82%E6%95%B0.png" class title="This is an example image">

<p>上面为jdk7的堆的图，逻辑上分为3块，但物理上堆只包括新生与老年。</p>
<p>调整物理上堆的参数</p>
<ul>
<li>-Xms：初始大小start</li>
<li>-Xmx：最大大小max</li>
</ul>
<p>调整新生代的参数</p>
<ul>
<li>-Xmn：new区，一般不调</li>
</ul>
<img src="/2020/03/21/jvm/%E5%A0%86%E5%8F%82%E6%95%B02.png" class title="This is an example image">

<p>Minor GC针对年轻代，Major GC针对老年代。</p>
<p>JDK8将永久代取消，改为<strong>元空间</strong>。</p>
<p>永久代与元空间区别在于：</p>
<ul>
<li>永久代使用JVM的堆内存</li>
<li><strong>元空间不在虚拟机中而是使用本机物理内存</strong></li>
</ul>
<p>默认情况下元空间大小仅受<strong>本地内存</strong>限制。类的元数据放入native memory，字符串池和类的静态变量放入java堆中，这样可以加载多少类的元数据不再由MaxPermSize控制，而是由系统的实际可用空间来控制。</p>
<table>
<thead>
<tr>
<th>-Xms</th>
<th>设置初始分配大小，默认为物理内存的“1/64”</th>
</tr>
</thead>
<tbody><tr>
<td>-Xmx</td>
<td>最大分配内存，默认为物理内存的“1/4”</td>
</tr>
<tr>
<td>-XX:+PrintGCDetails</td>
<td>输出详细的GC处理日志</td>
</tr>
<tr>
<td>-XX:NewRatio=4</td>
<td>设置年轻代与老年代的比例为1:4</td>
</tr>
<tr>
<td>-XX:SurvivorRatio=8</td>
<td>设置新生代Eden和Survivor区比例为8:2</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold</td>
<td>从年代到到老年代经过GC次数阈值，默认15</td>
</tr>
</tbody></table>
<p>将运行时数据区区（方法区、堆、栈、计数器、本地方法栈）抽象为Runtime类，其实例通过getRun()方法获取。</p>
<p>其设计为单例设计模式中的<strong>饿汉式</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Runtime</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数阅览为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取CPU核数</span></span><br><span class="line">      System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">      <span class="comment">//返回Java虚拟机试图使用的最大内存量</span></span><br><span class="line">      <span class="keyword">long</span> maxMemory = Runtime.getRuntime().maxMemory();</span><br><span class="line">      <span class="comment">//返回Java虚拟机中的内存总量</span></span><br><span class="line">      <span class="keyword">long</span> totalMemory = Runtime.getRuntime().totalMemory();</span><br><span class="line">      System.out.println(<span class="string">"MAX_MEMORY="</span>+maxMemory+<span class="string">"字节、"</span>+(maxMemory/(<span class="keyword">double</span>)<span class="number">1024</span>/<span class="number">1024</span>)+<span class="string">"MB"</span>);</span><br><span class="line">      System.out.println(<span class="string">"TOTAL_MEMORY="</span>+totalMemory+<span class="string">"字节、"</span>+(totalMemory/(<span class="keyword">double</span>)<span class="number">1024</span>/<span class="number">1024</span>)+<span class="string">"MB"</span>);</span><br></pre></td></tr></table></figure>

<p>实际中需要将<strong>初始内存和最大内存设置为相同</strong>，避免内存不稳定产生停顿。</p>
<h3 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h3><p>调优的目的：减少full gc，减少stop-the-world时间。</p>
<p>让朝生夕死的对象，尽量在年轻代被minor gc，而少在老年代被full gc。方法之一为调整年轻代与老年代的内存分配比例。</p>
<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><h2 id="Java内存泄漏"><a href="#Java内存泄漏" class="headerlink" title="Java内存泄漏"></a>Java内存泄漏</h2><p>内存泄漏指的是不被使用的对象或内存一直占据着内存，理论上来说Java有GC垃圾回收，即不再被使用的对象会被垃圾回收，从内存中清除。</p>
<p>但即使这样也会存在内存泄漏，长生命周期的对象持有者短生命周期对象的引用，虽然短生命周期的对象不再需要，但因为场面生命周期的对象持有着他的引用而导致不能被回收。</p>
<h2 id="GC收集日志信息"><a href="#GC收集日志信息" class="headerlink" title="GC收集日志信息"></a>GC收集日志信息</h2><p>在IDEA中，使用Configuration中的VM options来配置</p>
<p>注意：-Xms与数字1024m中间没有空格，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms:<span class="number">1024</span>m -Xmx:<span class="number">1024</span>m -XX:+PrintGCDetails</span><br></pre></td></tr></table></figure>

<img src="/2020/03/21/jvm/%E5%A0%86%E4%BF%A1%E6%81%AF.png" class title="This is an example image">

<p>可以看到堆由年轻代，老年代与MetaSpace（元空间）组成。</p>
<h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"java"</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    str += str + <span class="keyword">new</span> Random().nextInt(<span class="number">88888888</span>) + <span class="keyword">new</span> Random().nextInt(<span class="number">999999999</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后设置-Xms10m -Xmx10m，得到如下结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>

<img src="/2020/03/21/jvm/OOM.png" class title="This is an example image">

<p>可以看到先GC，后Full GC。</p>
<p>XX:+PrintGCDatails</p>
<h3 id="日志解读"><a href="#日志解读" class="headerlink" title="日志解读"></a>日志解读</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: <span class="number">2595</span>K-&gt;<span class="number">320</span>K(<span class="number">3072</span>K), <span class="number">0.0023459</span> secs] <span class="number">2595</span>K-&gt;<span class="number">743</span>K(<span class="number">9920</span>K), <span class="number">0.0024277</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br></pre></td></tr></table></figure>

<p>具体意思是：这次GC因为分配失败，发生在新生代，GC前内新生代内存占用2595k，GC后内存占用320k，新生代总共大小3072k（设置的10M的1/3），GC前堆内存占用2595k，GC后堆内存占用743k，JVM堆内存共有9920k，共耗时0.0024277秒，后面为用户、系统、实际耗时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [Tenured: 4684K-&gt;4580<span class="title">K</span><span class="params">(<span class="number">6848</span>K)</span>, 0.0037896 secs] 4684K-&gt;4580<span class="title">K</span><span class="params">(<span class="number">9920</span>K)</span>, [Metaspace: 2106K-&gt;2106<span class="title">K</span><span class="params">(<span class="number">4480</span>K)</span>], 0.0038318 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br></pre></td></tr></table></figure>

<p>具体意思是：回收前老年代4684k，回收后4580k，老年代总内存大小为6848k。 JVM堆内存公有9920k。</p>
<p>规律：【名称：GC前内存大小-&gt;GC后内存占用（该区总内存大小）</p>
<p>System.gc()显式调用系统的GC，并不是马上回收。一般不要用！</p>
<h2 id="GC介绍"><a href="#GC介绍" class="headerlink" title="GC介绍"></a>GC介绍</h2><p>GC为垃圾回收机制（分代收集算法）</p>
<ul>
<li>次数上频繁收集年轻代</li>
<li>次数上较少收集老年代</li>
<li>基本不动元空间</li>
</ul>
<p>JVM在GC时，大部分回收的是年轻代，GC按照回收的区域分为普通GC（minor GC）和全局GC（major GC or Full GC）。</p>
<h3 id="Minor-GC和Full-GC区别"><a href="#Minor-GC和Full-GC区别" class="headerlink" title="Minor GC和Full GC区别"></a>Minor GC和Full GC区别</h3><ul>
<li>普通GC（Minor GC）：只针对年轻代区域，因为大多数Java对象存活率不高，因此Minor GC非常频繁，一般回收速度也较快</li>
<li>全局GC（Full GC）：发生在老年代的垃圾回收机制，出现了Major GC，经常会伴随至少一次的Minor GC（不绝对）。<strong>Major GC的速度一般比Minor GC慢10倍以上</strong>。</li>
</ul>
<h3 id="对象可达性分析"><a href="#对象可达性分析" class="headerlink" title="对象可达性分析"></a>对象可达性分析</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><ul>
<li>判断对象的引用数量</li>
<li>每个对象实例有引用计数器，被引用+1，完成引用-1</li>
<li>任何引用为0的对象实例可被垃圾回收</li>
<li>优点：效率高</li>
<li>缺点：维护引用计数器，无法解决相互引用，主流JM并未使用</li>
</ul>
<h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><p>判断对象的引用链是否可达来决定对象是否被回收，从图论引入。从名为GC Roots的对象作为起始点，从这些节点向下搜索，搜素走过的路径就是引用链，若一个节点与GC Roots间没有引用链，则被判断为不可达的。</p>
<p>从Root开始，将所有可达的对象进行标记，标记完后不可达的对象就是垃圾。</p>
<p>可以用作GC Root的对象</p>
<ul>
<li><p>虚拟机栈中引用的对象</p>
<p>如方法中引用到的对象</p>
</li>
<li><p>方法区中的常量引用的对象</p>
<p>方法区中定义的常量为对象地址，被保存的对象可以是root</p>
</li>
<li><p>方法区中类静态属性引用的对象</p>
</li>
<li><p>本地方法栈中Native方法引用的对象</p>
</li>
<li><p>活跃现成的引用对象</p>
</li>
</ul>
<h2 id="4大算法"><a href="#4大算法" class="headerlink" title="4大算法"></a>4大算法</h2><ol>
<li><p>引用计数法（微软的COM/ActionScript3/Python）</p>
<p>对象的引用为0时回收</p>
<ul>
<li>需要维护引用计数器，且计数器本身有一定消耗；</li>
<li>较难处理循环引用。</li>
<li>JVM实现一般不采用这种方式</li>
</ul>
</li>
<li><p>复制算法（Copying）</p>
<p>用在<strong>年轻代</strong>中，Minor GC，复制-交换-清除，前提是大部分对象可以被清除</p>
<p>-XX:MaxTenuringThreshold-设置对象在新生代中存活次数，默认15</p>
<p>优点：<strong>不会产生内存碎片</strong>，速度快</p>
<p>缺点：</p>
<ul>
<li><strong>浪费一半空间</strong></li>
<li>若对象存活率很高，复制非常花时间（老年代对象存活率高，不适合用）</li>
</ul>
</li>
<li><p>标记清除（Mark-Sweep）</p>
<p><strong>老年代</strong>一般是标记清除或标记清除与与标记整理（压缩）的混合实现</p>
<p>分为标记和清除两个阶段，先标记出要回收的对象，然后统一回收这些对象</p>
<p>优点：不需要额外空间</p>
<p>缺点：</p>
<ul>
<li>两次扫描，<strong>耗时严重</strong></li>
<li>会产生<strong>内存碎片</strong></li>
</ul>
</li>
<li><p>标记压缩（Mark-Compact）</p>
<p><strong>老年代</strong>一般是标记清除或标记清除与与标记整理（压缩）的混合实现</p>
<p>也叫标记清除压缩</p>
<p>标记和标记清除一样，压缩，再次扫描，往一段滑动存活对象</p>
<p>优点：没有内存碎片</p>
<p>缺点：需要移动对象的成本，效率不高</p>
<p>可以结合标记清除与标记压缩，进行多次标记清除GC后，再进行标记压缩</p>
</li>
</ol>
<p>没有最好的算法，根据不同代的特点用不同的垃圾收集算法。即<strong>分代收集算法</strong>。</p>
<p>内存效率：复制算法&gt;标记清除算法&gt;标记压缩算法（简单比较时间复杂度，实际不一定）</p>
<p>内存整齐度：复制算法=标记压缩算法&gt;标记清除算法</p>
<p>内存利用率：标记压缩算法=标记清除算法&gt;复制算法</p>
<h2 id="常见垃圾收集器"><a href="#常见垃圾收集器" class="headerlink" title="常见垃圾收集器"></a>常见垃圾收集器</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>介绍垃圾收集器前需要介绍两个常见概念，stop the world和Safepoint，与垃圾收集器的工作过程相关</p>
<h4 id="Stop-the-World"><a href="#Stop-the-World" class="headerlink" title="Stop-the-World"></a>Stop-the-World</h4><ul>
<li>JVM由于要执行GC，需要将应用程序停止</li>
<li>所有的GC算法中都会发生</li>
<li>多数GC优化通过减少stop-the-world时间来提升性能，达到高吞吐量、少停顿的特点</li>
</ul>
<p>为什么要stop the world？</p>
<p>若没有stop-the-world，可能之前可达的对象因为应用程序的继续进行而变成浮动的不可达对象，这样需要重新进行标记，增加了GC算法的难度，降低程序性能，因此使用stop-the-point，可以减少GC算法复杂度。</p>
<h4 id="Safepoint"><a href="#Safepoint" class="headerlink" title="Safepoint"></a>Safepoint</h4><p>在GC时，程序不是随便停止，而是在Safepoint停止</p>
<ul>
<li><p>分析过程中对象引用关系不发生变化的点</p>
</li>
<li><p>产生的地方：方法调用，循环跳转，异常跳转等</p>
</li>
<li><p>安全点数量得适中</p>
<p>太少会让GC等太久，太多会增加程序运行的负担</p>
</li>
</ul>
<h3 id="常见收集器"><a href="#常见收集器" class="headerlink" title="常见收集器"></a>常见收集器</h3><img src="/2020/03/21/jvm/%E6%94%B6%E9%9B%86%E5%99%A8.png" class title="This is an example image">

<p>图中为常见的JVM收集器，用实线相连代表可以搭配使用</p>
<h3 id="年轻代常见收集器"><a href="#年轻代常见收集器" class="headerlink" title="年轻代常见收集器"></a>年轻代常见收集器</h3><h4 id="Serial收集器（-XX-UseSerialGC，复制算法）"><a href="#Serial收集器（-XX-UseSerialGC，复制算法）" class="headerlink" title="Serial收集器（-XX:+UseSerialGC，复制算法）"></a>Serial收集器（-XX:+UseSerialGC，复制算法）</h4><p>最基本也最悠久的，单线程，进行垃圾收集时<strong>停止所有工作线程</strong></p>
<p>Client模式下年轻代默认的</p>
<img src="/2020/03/21/jvm/%E5%B9%B4%E8%BD%BB1.png" class title="This is an example image">

<h4 id="ParNew收集器（-XX-UseParNewGC，复制算法）"><a href="#ParNew收集器（-XX-UseParNewGC，复制算法）" class="headerlink" title="ParNew收集器（-XX:+UseParNewGC，复制算法）"></a>ParNew收集器（-XX:+UseParNewGC，复制算法）</h4><p>多线程收集，多核下比Serial有优势</p>
<p>在Server模式下非常重要，与Serial一样均可配合CMS使用</p>
<img src="/2020/03/21/jvm/%E5%B9%B4%E8%BD%BB2.png" class title="This is an example image">

<h4 id="Paraller-Scavenge-XX-UseParallelGC，复制算法"><a href="#Paraller-Scavenge-XX-UseParallelGC，复制算法" class="headerlink" title="Paraller Scavenge(-XX:+UseParallelGC，复制算法)"></a>Paraller Scavenge(-XX:+UseParallelGC，复制算法)</h4><p>前面两个更关注系统的停顿时间，此收集器更关注系统的吞吐量（执行用户线程时间/CPU总执行时间），适合后台运算不需要太多交互的情况</p>
<p>多核下执行有优势，Server下默认的年轻代收集器</p>
<p>不能与CMS搭配使用，因为框架不兼容</p>


<h3 id="老年代常见收集器"><a href="#老年代常见收集器" class="headerlink" title="老年代常见收集器"></a>老年代常见收集器</h3><h4 id="SerialOld（-XX-UseSerialOldGC，标记整理算法）"><a href="#SerialOld（-XX-UseSerialOldGC，标记整理算法）" class="headerlink" title="SerialOld（-XX:+UseSerialOldGC，标记整理算法）"></a>SerialOld（-XX:+UseSerialOldGC，标记整理算法）</h4><p>Serial GC的老年代版本，单线程收集</p>
<p><strong>Client</strong>模式下默认的老年代收集器 </p>
<img src="/2020/03/21/jvm/%E8%80%81%E5%B9%B41.png" class title="This is an example image">

<h4 id="ParellerOld（-XX-UseParellerOldGC，标记整理算法）"><a href="#ParellerOld（-XX-UseParellerOldGC，标记整理算法）" class="headerlink" title="ParellerOld（-XX:+UseParellerOldGC，标记整理算法）"></a>ParellerOld（-XX:+UseParellerOldGC，标记整理算法）</h4><p>多线程，吞吐量优先，配合ParallerScavenge使用</p>
<h4 id="CMS（-XX-UseConcMarkSweepGC，标记清除算法）"><a href="#CMS（-XX-UseConcMarkSweepGC，标记清除算法）" class="headerlink" title="CMS（-XX:+UseConcMarkSweepGC，标记清除算法）"></a>CMS（-XX:+UseConcMarkSweepGC，标记清除算法）</h4><p>Concurrent Mark Sweep收集器，适用于程序对停顿比较敏感的情况，号称“<strong>最短用户停顿时间</strong>”，适合用在互联网站或者B/S系统服务器上。</p>
<img src="/2020/03/21/jvm/cms.png" class title="This is an example image">

<ul>
<li><strong>初始标记</strong>：标记处GC Roots直接关联到的对象，速度较快，<strong>需要停顿</strong></li>
<li>并发标记：进行GC Roots Tracing，标记出全部的垃圾对象，与应用线程一起</li>
<li>并发预清理：查找执行并发标记阶段从年轻代晋升至老年代对象，减少重新标记工作</li>
<li><strong>重新标记</strong>：修正并发标记期间对象变化情况，<strong>需要停顿</strong>，较慢</li>
<li>并发清除：标记清除算法清除标记</li>
<li>并发重置：重置CMS收集器的数据结构</li>
</ul>
<p>问题是不压缩存活对象，有碎片化问题。</p>
<h4 id="堆内存垃圾收集G1（-XX-UseG1GC，复制-标记整理算法）"><a href="#堆内存垃圾收集G1（-XX-UseG1GC，复制-标记整理算法）" class="headerlink" title="堆内存垃圾收集G1（-XX:+UseG1GC，复制+标记整理算法）"></a>堆内存垃圾收集G1（-XX:+UseG1GC，复制+标记整理算法）</h4><p>用于年轻代与老年代，为了替代CMS。JDK9默认。</p>
<ul>
<li>并行和并发的：采用多个CPU缩短stop-the-world停顿时间，与用户线程并发执行</li>
<li>分代收集：采用不同方式处理新建对象和存活一段时间对象收集</li>
<li>空间整合：基于标记整理，解决了碎片化问题</li>
<li>可预测的停顿：让使用者指定停顿时间</li>
</ul>
<p>将整个Java堆内存划分为多个region，年轻代与老年代不再物理隔离。</p>
<h2 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h2><h3 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a>VisualVM</h3><p>在IDEA的插件中安装VisualVM，在VisualVM中依照官网给的插件网址更新插件下载url，安装Visual GC插件。</p>
<p>可以看到具体的GC情况。</p>
<img src="/2020/03/21/jvm/gc.png" class title="This is an example image">

<p>可以看到具体的GC次数，每个区域剩余的空间。</p>
<img src="/2020/03/21/jvm/vmoom.png" class title="This is an example image">

<p>可以具体看到，在Eden区发生了20次GC，在Old区发生了11次GC，老年代Full GC次数更少，但是消耗的时间更长，老年代内存占用达到了73%，然后发生了OOM</p>
<p>为了具体分析OOM异常，可以在run，VM设置中加上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:\dump</span><br></pre></td></tr></table></figure>

<p>这样会在指定的路径生成OOM异常后的dump文件，文件名为</p>
<p>java_pid12332.hprof</p>
<p>指明了是java的12332进程出现的。</p>
<p>然后在VisualVM中，装载此文件，打开如下</p>
<img src="/2020/03/21/jvm/mainoom.png" class title="This is an example image">

<p>可以看到是主线程中发生了OOM异常，点进去看到</p>
<img src="/2020/03/21/jvm/sboom.png" class title="This is an example image">

<p>发现是StringBuilder中的添加方法出现了问题，进一步点进去分析</p>
<img src="/2020/03/21/jvm/%E5%80%BCoom.png" class title="This is an example image">

<p>可以看到具体的出问题的变量值，这样便可以找到相应的位置，去进行修改。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="强引用、软引用、弱引用、虚引用"><a href="#强引用、软引用、弱引用、虚引用" class="headerlink" title="强引用、软引用、弱引用、虚引用"></a>强引用、软引用、弱引用、虚引用</h3><p>不同的引用下GC不同</p>
<p>设置：-Xms:10m -Xmx:10m -XX:+PrintGCDetails</p>
<h4 id="强引用（Strong-Reference）"><a href="#强引用（Strong-Reference）" class="headerlink" title="强引用（Strong Reference）"></a>强引用（Strong Reference）</h4><ul>
<li><p>最普遍的引用：Object o = new Object();</p>
</li>
<li><p>抛出OOM异常程序也不会回收具有强引用的对象</p>
</li>
<li><p>将对象设置为null来弱化引用，使其被回收，或等待其生命周期结束</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"java"</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">   str += str + <span class="keyword">new</span> Random().nextInt(<span class="number">88888888</span>) + <span class="keyword">new</span> Random().nextInt(<span class="number">999999999</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: <span class="number">2669</span>K-&gt;<span class="number">0</span>K(<span class="number">3072</span>K), <span class="number">0.0007536</span> secs][Tenured: <span class="number">5998</span>K-&gt;<span class="number">4663</span>K(<span class="number">6848</span>K), <span class="number">0.0019593</span> secs] <span class="number">5998</span>K-&gt;<span class="number">4663</span>K(<span class="number">9920</span>K), [Metaspace: <span class="number">2106</span>K-&gt;<span class="number">2106</span>K(<span class="number">4480</span>K)], <span class="number">0.0027569</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"></span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span> [Tenured: 4663K-&gt;4559<span class="title">K</span><span class="params">(<span class="number">6848</span>K)</span>, 0.0024536 secs] 4663K-&gt;4559<span class="title">K</span><span class="params">(<span class="number">9920</span>K)</span>, [Metaspace: 2106K-&gt;2106<span class="title">K</span><span class="params">(<span class="number">4480</span>K)</span>], 0.0024861 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>

<p>会报OOM异常，先GC，最后Full GC，不能将强引用的对象强制回收</p>
<h4 id="软引用（Soft-Reference）"><a href="#软引用（Soft-Reference）" class="headerlink" title="软引用（Soft Reference）"></a>软引用（Soft Reference）</h4><ul>
<li>对象处在有用但非必须的状态</li>
<li>当<strong>内存空间不足</strong>，GC会回收该引用的对象的内存</li>
<li>可以用来实现内存敏感的高速缓存</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"java"</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    SoftReference&lt;String&gt; str2 = <span class="keyword">new</span> SoftReference&lt;String&gt;(str + <span class="keyword">new</span> Random().nextInt(<span class="number">88888888</span>) + <span class="keyword">new</span> Random().nextInt(<span class="number">999999999</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: <span class="number">2752</span>K-&gt;<span class="number">0</span>K(<span class="number">3072</span>K), <span class="number">0.0002984</span> secs] <span class="number">3327</span>K-&gt;<span class="number">575</span>K(<span class="number">9920</span>K), <span class="number">0.0003464</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br></pre></td></tr></table></figure>

<p>可以看到，没有老年代的GC信息。</p>
<p>不会报OOM异常，会一直GC，没有Full GC。</p>
<h4 id="弱引用（Weak-Reference）"><a href="#弱引用（Weak-Reference）" class="headerlink" title="弱引用（Weak Reference）"></a>弱引用（Weak Reference）</h4><ul>
<li>非必须引用的对象，比软引用更弱</li>
<li>GC时会被回收（无论当前线程是否紧缺）</li>
<li>被回收的概率也不大，因为GC线程优先级较低</li>
<li>适用于偶尔被使用且不影响垃圾回收的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;String&gt; str2 = <span class="keyword">new</span> WeakReference&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>

<h4 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h4><ul>
<li>不会决定对象的生命周期</li>
<li>任何时候都可能被垃圾收集器回收</li>
<li>跟踪对象被垃圾收集器回收的活动，起哨兵作用</li>
<li>必须和引用队列ReferenceQueue联合使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"java"</span>;</span><br><span class="line">ReferenceQueue&lt;String&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">PhantomReference&lt;String&gt; pr = <span class="keyword">new</span> PhantomReference&lt;&gt;(str,queue);</span><br></pre></td></tr></table></figure>

<p>通过判断队列中是否加入了虚引用来了解被引用的对象是否被GC。</p>
<h3 id="对象何时进入老年代"><a href="#对象何时进入老年代" class="headerlink" title="对象何时进入老年代"></a>对象何时进入老年代</h3><p>一般新建对象时发生在Eden区，但是某些情况对象会进入到老年代</p>
<ol>
<li><p>新建大对象（需要大量连续内存空间的对象，如很长的字符串或数组）直接进入老年代</p>
</li>
<li><p>长期存活对象进入老年代（默认对象年龄为15进入,如静态常量）</p>
</li>
<li><p>survivor区空间不足（相同年龄的所有对象大小总和大于Survivor空间<strong>一半</strong>)</p>
<p>一些朝生夕死对象，因为survivor区域设置不足，而直接放入老年代，而频繁进行full gc，这种情况可以调大年轻代空间，改变年轻代与老年代比例。-XX:NewRatio，调小。</p>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/jvm/" rel="tag"># jvm</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/06/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/" rel="prev" title="哈夫曼树">
      <i class="fa fa-chevron-left"></i> 哈夫曼树
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM"><span class="nav-number">1.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM介绍"><span class="nav-number">1.1.</span> <span class="nav-text">JVM介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM体系结构概览"><span class="nav-number">1.1.1.</span> <span class="nav-text">JVM体系结构概览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类装载器ClassLoader"><span class="nav-number">1.1.2.</span> <span class="nav-text">类装载器ClassLoader</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#介绍（是什么）"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">介绍（是什么）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#种类（有哪些）"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">种类（有哪些）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双亲委派（怎么用）"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">双亲委派（怎么用）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#沙箱安全（什么用）"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">沙箱安全（什么用）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类装载的执行过程"><span class="nav-number">1.1.2.5.</span> <span class="nav-text">类装载的执行过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行引擎"><span class="nav-number">1.1.3.</span> <span class="nav-text">执行引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本地接口"><span class="nav-number">1.1.4.</span> <span class="nav-text">本地接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PC寄存器"><span class="nav-number">1.1.5.</span> <span class="nav-text">PC寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法区"><span class="nav-number">1.1.6.</span> <span class="nav-text">方法区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈"><span class="nav-number">1.1.7.</span> <span class="nav-text">栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#栈的存储"><span class="nav-number">1.1.7.1.</span> <span class="nav-text">栈的存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#栈运行原理"><span class="nav-number">1.1.7.2.</span> <span class="nav-text">栈运行原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#栈-堆-方法区的交互"><span class="nav-number">1.1.7.3.</span> <span class="nav-text">栈+堆+方法区的交互</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#深拷贝与浅拷贝"><span class="nav-number">1.1.7.4.</span> <span class="nav-text">深拷贝与浅拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆与栈的区别"><span class="nav-number">1.1.7.5.</span> <span class="nav-text">堆与栈的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#new对象发生的事情"><span class="nav-number">1.1.7.6.</span> <span class="nav-text">new对象发生的事情</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆"><span class="nav-number">1.1.8.</span> <span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#堆new对象流程"><span class="nav-number">1.1.8.1.</span> <span class="nav-text">堆new对象流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MinorGC（复制-gt-清空-gt-互换）"><span class="nav-number">1.1.8.2.</span> <span class="nav-text">MinorGC（复制-&gt;清空-&gt;互换）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#永久代（jdk7前）"><span class="nav-number">1.1.8.3.</span> <span class="nav-text">永久代（jdk7前）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆参数调整"><span class="nav-number">1.1.8.4.</span> <span class="nav-text">堆参数调整</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调优"><span class="nav-number">1.1.9.</span> <span class="nav-text">调优</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GC"><span class="nav-number">2.</span> <span class="nav-text">GC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java内存泄漏"><span class="nav-number">2.1.</span> <span class="nav-text">Java内存泄漏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC收集日志信息"><span class="nav-number">2.2.</span> <span class="nav-text">GC收集日志信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OOM"><span class="nav-number">2.2.1.</span> <span class="nav-text">OOM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#日志解读"><span class="nav-number">2.2.2.</span> <span class="nav-text">日志解读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC介绍"><span class="nav-number">2.3.</span> <span class="nav-text">GC介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Minor-GC和Full-GC区别"><span class="nav-number">2.3.1.</span> <span class="nav-text">Minor GC和Full GC区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象可达性分析"><span class="nav-number">2.3.2.</span> <span class="nav-text">对象可达性分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#引用计数法"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">引用计数法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可达性分析"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">可达性分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4大算法"><span class="nav-number">2.4.</span> <span class="nav-text">4大算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见垃圾收集器"><span class="nav-number">2.5.</span> <span class="nav-text">常见垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#相关概念"><span class="nav-number">2.5.1.</span> <span class="nav-text">相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Stop-the-World"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">Stop-the-World</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Safepoint"><span class="nav-number">2.5.1.2.</span> <span class="nav-text">Safepoint</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见收集器"><span class="nav-number">2.5.2.</span> <span class="nav-text">常见收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#年轻代常见收集器"><span class="nav-number">2.5.3.</span> <span class="nav-text">年轻代常见收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Serial收集器（-XX-UseSerialGC，复制算法）"><span class="nav-number">2.5.3.1.</span> <span class="nav-text">Serial收集器（-XX:+UseSerialGC，复制算法）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ParNew收集器（-XX-UseParNewGC，复制算法）"><span class="nav-number">2.5.3.2.</span> <span class="nav-text">ParNew收集器（-XX:+UseParNewGC，复制算法）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Paraller-Scavenge-XX-UseParallelGC，复制算法"><span class="nav-number">2.5.3.3.</span> <span class="nav-text">Paraller Scavenge(-XX:+UseParallelGC，复制算法)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#老年代常见收集器"><span class="nav-number">2.5.4.</span> <span class="nav-text">老年代常见收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SerialOld（-XX-UseSerialOldGC，标记整理算法）"><span class="nav-number">2.5.4.1.</span> <span class="nav-text">SerialOld（-XX:+UseSerialOldGC，标记整理算法）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ParellerOld（-XX-UseParellerOldGC，标记整理算法）"><span class="nav-number">2.5.4.2.</span> <span class="nav-text">ParellerOld（-XX:+UseParellerOldGC，标记整理算法）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS（-XX-UseConcMarkSweepGC，标记清除算法）"><span class="nav-number">2.5.4.3.</span> <span class="nav-text">CMS（-XX:+UseConcMarkSweepGC，标记清除算法）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆内存垃圾收集G1（-XX-UseG1GC，复制-标记整理算法）"><span class="nav-number">2.5.4.4.</span> <span class="nav-text">堆内存垃圾收集G1（-XX:+UseG1GC，复制+标记整理算法）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用软件"><span class="nav-number">2.6.</span> <span class="nav-text">常用软件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#VisualVM"><span class="nav-number">2.6.1.</span> <span class="nav-text">VisualVM</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见问题"><span class="nav-number">2.7.</span> <span class="nav-text">常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#强引用、软引用、弱引用、虚引用"><span class="nav-number">2.7.1.</span> <span class="nav-text">强引用、软引用、弱引用、虚引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#强引用（Strong-Reference）"><span class="nav-number">2.7.1.1.</span> <span class="nav-text">强引用（Strong Reference）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#软引用（Soft-Reference）"><span class="nav-number">2.7.1.2.</span> <span class="nav-text">软引用（Soft Reference）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#弱引用（Weak-Reference）"><span class="nav-number">2.7.1.3.</span> <span class="nav-text">弱引用（Weak Reference）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚引用（PhantomReference）"><span class="nav-number">2.7.1.4.</span> <span class="nav-text">虚引用（PhantomReference）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象何时进入老年代"><span class="nav-number">2.7.2.</span> <span class="nav-text">对象何时进入老年代</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="未名Hugh"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">未名Hugh</p>
  <div class="site-description" itemprop="description">技术博客，Java，并发编程，算法</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">未名Hugh</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.6.0
  </div>
-->

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共166.5k字</span>
</div>
        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>