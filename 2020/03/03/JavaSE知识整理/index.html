<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/file-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/file.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://hughzc.github.io').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","width":320,"display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="Java基础根据网上博客和黑马的一些资料，整理了下面的JavaSE的知识点  https://blog.csdn.net/ThinkWon/article/details/104390612 《黑马程序员Java学习》">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE知识整理">
<meta property="og:url" content="https://hughzc.github.io/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="未名的奇妙旅程">
<meta property="og:description" content="Java基础根据网上博客和黑马的一些资料，整理了下面的JavaSE的知识点  https://blog.csdn.net/ThinkWon/article/details/104390612 《黑马程序员Java学习》">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hughzc.github.io/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/list%E4%B8%8Eset.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/%E9%93%BE%E8%A1%A8hash.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/%E7%BA%A2%E9%BB%91%E6%A0%91hash.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/hash%E6%95%A3%E5%88%97.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%9B%BE.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/segment.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/%E6%96%B0con.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/BIO.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/NIO.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/NIO2.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/AIO.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/poll.png">
<meta property="og:image" content="https://hughzc.github.io/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/epoll.png">
<meta property="article:published_time" content="2020-03-03T14:00:20.000Z">
<meta property="article:modified_time" content="2020-05-01T08:53:33.072Z">
<meta property="article:author" content="未名Hugh">
<meta property="article:tag" content="JavaSE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hughzc.github.io/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/list%E4%B8%8Eset.png">

<link rel="canonical" href="https://hughzc.github.io/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>JavaSE知识整理 | 未名的奇妙旅程</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">未名的奇妙旅程</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">怕什么真理无穷，进一寸有一寸的欢喜</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hughzc.github.io/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="未名Hugh">
      <meta itemprop="description" content="技术博客，Java，并发编程，算法">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="未名的奇妙旅程">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaSE知识整理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-03 22:00:20" itemprop="dateCreated datePublished" datetime="2020-03-03T22:00:20+08:00">2020-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-01 16:53:33" itemprop="dateModified" datetime="2020-05-01T16:53:33+08:00">2020-05-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaSE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaSE</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>37k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 ≈</span>
              <span>34 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><p>根据网上博客和黑马的一些资料，整理了下面的JavaSE的知识点</p>
<blockquote>
<p><a href="https://blog.csdn.net/ThinkWon/article/details/104390612" target="_blank" rel="noopener">https://blog.csdn.net/ThinkWon/article/details/104390612</a></p>
<p>《黑马程序员Java学习》</p>
</blockquote>
<a id="more"></a>

<h2 id="Java基本语法、特性"><a href="#Java基本语法、特性" class="headerlink" title="Java基本语法、特性"></a>Java基本语法、特性</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="Java有哪些数据类型"><a href="#Java有哪些数据类型" class="headerlink" title="Java有哪些数据类型"></a>Java有哪些数据类型</h4><p>Java中数据类型分为基础数据类型与引用数据类型</p>
<ul>
<li>基础数据类型<ul>
<li>数值型<ul>
<li>整数类型，<strong>默认int</strong><ul>
<li>byte：1字节</li>
<li>short：2字节</li>
<li>int：4字节</li>
<li>long：8字节</li>
</ul>
</li>
<li>浮点数类型，<strong>默认double</strong><ul>
<li>float：4字节</li>
<li>double：8字节</li>
</ul>
</li>
</ul>
</li>
<li>字符型<ul>
<li>char：2字节，用单引号括</li>
</ul>
</li>
<li>布尔型<ul>
<li>boolean：1字节，只有2个值</li>
</ul>
</li>
</ul>
</li>
<li>引用数据类型<ul>
<li>类(class)</li>
<li>接口(interface)</li>
<li>数组([])</li>
</ul>
</li>
</ul>
<h4 id="float与double"><a href="#float与double" class="headerlink" title="float与double"></a>float与double</h4><p>float f = 1.1;会报错吗？</p>
<p>会，1.1默认为double，这里相当于向下转型，造成精度损失，需要更改为float f = 1.1f或者float f = (float)1.1</p>
<h4 id="short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><a href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗" class="headerlink" title="short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗"></a>short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗</h4><p>s1 = s1+1有错，因为1为int类型，不能将int隐式的转换为低精度的short，所以需要类型转换。</p>
<p>s1 += 1，这里相当于强制类型转换，s1 = (short)(s1 + 1)，使用 ++ 或者 += 相当于执行了类型转换</p>
<h4 id="Math-round-11-5-等于多少？Math-round-11-5-等于多少"><a href="#Math-round-11-5-等于多少？Math-round-11-5-等于多少" class="headerlink" title="Math.round(11.5) 等于多少？Math.round(-11.5)等于多少"></a>Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</h4><p>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加 0.5 然后进行下取整。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="最有效率的方式计算2乘以8"><a href="#最有效率的方式计算2乘以8" class="headerlink" title="最有效率的方式计算2乘以8"></a>最有效率的方式计算2乘以8</h4><p>2 << 3，左移几位相当于2乘以几次方，位运算效率最高。</p>
<p>而<code>>></code>表示右移，右移几位就是除以2的几次幂，高位保持原来的数字，而对于<code>>>></code>，无论高位是什么，用<code>0</code>来补齐，因此是无符号位右移。</p>
<h4 id="计算-6"><a href="#计算-6" class="headerlink" title="计算~6"></a>计算~6</h4><p><code>~6</code>相当于对6逐位取反，6全部取反+1得到-6，<code>~6=-7</code></p>
<h4 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&和&&的区别"></a>&和&&的区别</h4><p>&运算符的作用是</p>
<ol>
<li>按位与 ，num1&num2相当于将每个数的二进制位相与</li>
<li>逻辑与运算，boolean f1 & f2，两个同时为真返回真</li>
</ol>
<p>而&&是短路的与运算，boolean f1 & f2，如果左边的f1为假，则直接返回假，屏蔽了f2，逻辑或（|）与短路运算符（||）作用也类似。</p>
<h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="switch的作用类型"><a href="#switch的作用类型" class="headerlink" title="switch的作用类型"></a>switch的作用类型</h4><p>在JDK5之前，switch(expr)中的expr只能是基础数据类型中的byte、short、int、char，在JDK5引入了枚举类型enum，在JDK7后，可以为字符串String，但长整形long不可以。因此总的为byte、short、int、char、enum、String。</p>
<h4 id="break-continue-return-的区别及作用"><a href="#break-continue-return-的区别及作用" class="headerlink" title="break ,continue ,return 的区别及作用"></a>break ,continue ,return 的区别及作用</h4><p>break：结束当前的循环体，不再执行此循环</p>
<p>continue：跳出本次循环，继续执行下一个循环</p>
<p>return：结束当前的方法，直接返回</p>
<h4 id="在-Java-中，如何跳出当前的多重嵌套循环"><a href="#在-Java-中，如何跳出当前的多重嵌套循环" class="headerlink" title="在 Java 中，如何跳出当前的多重嵌套循环"></a>在 Java 中，如何跳出当前的多重嵌套循环</h4><p>给外面的循环定义一个标签，在需要跳出的地方使用break 循环名即可</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">loop1:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">10</span>; i++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < <span class="number">10</span>; j++) {</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">break</span> loop1;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><h4 id="四种访问修饰符及区别"><a href="#四种访问修饰符及区别" class="headerlink" title="四种访问修饰符及区别"></a>四种访问修饰符及区别</h4><p>用访问修饰符来保护对类、变量、方法和构造方法的访问，支持四种访问权限。</p>
<ul>
<li>public：对所有类可见，使用对象为类、接口、变量、方法</li>
<li>default：默认的，在一个包中可见，使用对象为类、接口、变量、方法</li>
<li>protected：对同一个包内和子类可见。使用对象为内部类，变量，方法，不能修饰外部类</li>
<li>private：在同一个类内可见。使用对象为变量，方法，不能修饰外部类</li>
</ul>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">同一类中</th>
<th align="center">同一包中</th>
<th align="center">子类中</th>
<th align="center">不同包中</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">default</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="static作用"><a href="#static作用" class="headerlink" title="static作用"></a>static作用</h4><ol>
<li>创建独立于具体对象的域变量或者方法，随类而加载，可以直接用类名调用</li>
<li>形成静态代码块优化程序性能。在类被加载时，按照static块出现顺序执行，只加载一次，可以将只需要进行一次的初始化操作放在static中</li>
</ol>
<h4 id="static特点"><a href="#static特点" class="headerlink" title="static特点"></a>static特点</h4><ol>
<li>static是一个修饰符，修饰成员（成员变量和成员函数）</li>
<li>static修饰的成员被所有对象共享</li>
<li>static优先于对象存在，随类的第一次使用而加载，且只加载一次</li>
<li>static修饰的成员多了一种调用方式，即直接被类名调用</li>
<li>static变量值在类加载时分配空间，以后创建类对象时不会重新分配，可以对其任意赋值</li>
</ol>
<h4 id="static应用场景"><a href="#static应用场景" class="headerlink" title="static应用场景"></a>static应用场景</h4><ol>
<li>修饰成员变量</li>
<li>修饰成员方法</li>
<li>静态代码块</li>
<li>修饰类（只能修饰内部类即静态内部类）</li>
<li>静态导包</li>
</ol>
<h4 id="static注意事项"><a href="#static注意事项" class="headerlink" title="static注意事项"></a>static注意事项</h4><ol>
<li>静态方法只能访问静态成员，静态方法可直接被类名调用，非静态既可以访问静态，又可以访问非静态</li>
<li>静态 方法中不能出现this与static</li>
<li>主函数是静态的，不要在主函数中创建其他函数</li>
</ol>
<h4 id="方法调用顺序"><a href="#方法调用顺序" class="headerlink" title="方法调用顺序"></a>方法调用顺序</h4><p>父类静态代码块->子类静态代码块->子类静态方法->父类非静态代码块->父类构造方法->子类非静态代码块->子类构造方法</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="final作用"><a href="#final作用" class="headerlink" title="final作用"></a>final作用</h4><p>用于修饰类、属性和方法</p>
<ul>
<li><p>被final修饰的<strong>类不可以被继承</strong></p>
<p>关键字final置于定义前</p>
</li>
<li><p>被final修饰的<strong>方法不可以被重写</strong></p>
<p>防止任何继承类修改其定义，处于设计的考虑</p>
</li>
<li><p>被final修饰的变量不可以被改变，<strong>不可变的是变量的引用</strong>，而不是引用指向的内容（针对对象）</p>
<p>一般会加静态，全局变量。固定常量一律用final修饰。<strong>不能改变的数据类型需要是基本数据类型</strong>，对常量定义时需要对其赋值。对对象的引用表明此引用不能指向另一个对象，但对象本身可以被修改。</p>
</li>
</ul>
<p>允许在参数列表中以声明的方式将参数指定为final，意味着无法在方法中更改参数引用所指向的对象。可以读参数，无法改参数，主要用来<strong>向匿名内部类传递数据</strong>。</p>
<h4 id="final-finally-finalize区别"><a href="#final-finally-finalize区别" class="headerlink" title="final finally finalize区别"></a>final finally finalize区别</h4><ul>
<li>final可以修饰类、方法、变量，修饰类表明该类不能被继承，修饰方法表明该方法不能被重写，修饰变量表明该变量为常量不能重新被赋值，但若修饰的是对象的引用，不可变的是引用。</li>
<li>finally一般作用在try-catch代码块中，处理异常时将一定要执行的方法放在finally中，表示不管是否出现异常，该代码块都一定会执行（存在try语句，在try语句中没有执行System.exist(0)），一般放关闭资源的代码。</li>
<li>finalize是Object类的方法，一般由垃圾回收器调用，当调用Syetem.gc()的时候，由垃圾回收器调用finalize()，回收垃圾，是一个对象是否可回收的最后判断，最后的自救机会，但只有一次。</li>
</ul>
<h3 id="this与super"><a href="#this与super" class="headerlink" title="this与super"></a>this与super</h3><h4 id="this关键字使用"><a href="#this关键字使用" class="headerlink" title="this关键字使用"></a>this关键字使用</h4><p>this的含义：代表本类对象引用，可以理解成<strong>指向对象本身的一个指针</strong>。</p>
<p>this的用法</p>
<ol>
<li><p>普通的直接引用，this相当于当前对象本身</p>
</li>
<li><p>构造函数中，形参与成员变量重名，用this区分</p>
</li>
<li><p>在构造函数中引用本类的其他构造函数</p>
<p>this(待传入参数，可为空)，只能放在构造函数的第一行，不可与super()同时出现</p>
</li>
</ol>
<h4 id="super关键字使用"><a href="#super关键字使用" class="headerlink" title="super关键字使用"></a>super关键字使用</h4><p>super为指向超（父）类对象的指针，此超类为离当前类最近的一个父类。</p>
<p>super的用法与this类似</p>
<ol>
<li><p>普通的直接引用，使用super.xxx来引用父类成员</p>
</li>
<li><p>子类中的成员变量与父类中成员变量重名时，用super()区分</p>
</li>
<li><p>引用父类构造函数</p>
<p>super(参数)，调用父类中构造函数，在子类的构造函数第一行默认为super()，如果有this()，则没有super()，因为二者均需要出现在构造函数第一行</p>
</li>
</ol>
<h4 id="this与super-1"><a href="#this与super-1" class="headerlink" title="this与super"></a>this与super</h4><ol>
<li>this指当前对象，super指父类对象</li>
<li>this在本类中调用本来方法，super在子类中调用父类方法</li>
<li>this与super均要放在构造函数的第一行</li>
<li>this与super不能出现在一个构造函数中，因为this()中调用其他构造函数，其他构造函数中有super()</li>
<li>二者均不可在static环境中使用，如static变量，static方法，static代码块</li>
</ol>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h3><h4 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h4><p>面向过程：具体化的，流程化的，为了解决问题，需要一步步分析和实现</p>
<p>面向对象：模型化的，将过程的实现抽象为多个类，直接去调用类的属性和方法，不用去一步步实现，面向对象的底层是面向过程，将面向过程抽象成类并进行封装，就是面向对象了</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>优点</th>
<th>缺点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>面向过程</td>
<td>性能更高，没有调用类的资源消耗。</td>
<td>没有面向对象易维护、复用、扩展</td>
<td>单片机，嵌入式开发，Linux/Unix</td>
</tr>
<tr>
<td>面向对象</td>
<td>易维护、易复用、易扩展，系统耦合性更低</td>
<td>性能比面向过程低</td>
<td>需求变化多，互联网应用</td>
</tr>
</tbody></table>
<h4 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h4><p>面向对象的特征主要有4个方面，抽象，封装，继承和多态</p>
<p>抽象：将一类对象的<strong>共同特征</strong>总结出来构造类的过程，包括<strong>数据抽象</strong>和<strong>行为抽象</strong>两方面，抽象只关注对象的属性和行为，并不关心其实现细节。</p>
<p>封装：将一个对象的<strong>属性私有化</strong>，同时对外提供可以<strong>访问属性的方法</strong>。在类中编写方法对实现细节进行封装，隐藏一切可隐藏的，只对外暴露最简单的编程<strong>接口</strong>。</p>
<p>继承：从父类继承属性与方法到子类，子类可以增加新的数据和功能，方便复用，继承会增加类之间的耦合性。（里氏替换原则）</p>
<p>多态：某一种事物具有多种形态，用父类类型指向子类对象，一个对象对应着不同类型。</p>
<h4 id="面向对象的基本原则"><a href="#面向对象的基本原则" class="headerlink" title="面向对象的基本原则"></a>面向对象的基本原则</h4><ol>
<li><p>单一职责原则</p>
<p>一个类只有一个职责，内部高内聚</p>
</li>
<li><p>接口隔离原则</p>
<p>一个类对另一个类的依赖建立在最小的接口上</p>
</li>
<li><p>依赖倒转原则</p>
<p>抽象不应该依赖细节，细节应该依赖抽象，<strong>面向接口编程</strong>。依赖关系的三种传递：接口传递、构造方法传递、setter方法传递</p>
</li>
<li><p>里氏替换原则</p>
<p>与继承相关，任何时候子类都能替换父类</p>
</li>
<li><p>开放封闭原则</p>
<p>模块和函数应该对<strong>扩展开放</strong>（对提供方），对<strong>修改关闭</strong>（对使用方），<strong>用抽象构建框架，用实现扩展细节</strong></p>
</li>
<li><p>迪米特法则（最少知道原则）</p>
<p>一个类对自己依赖的类知道越少越好，陌生的类最好不要以局部变量形式出现在类的内部</p>
</li>
<li><p>合成复用原则</p>
<p>尽量使用合成/聚合的方式，而不是继承</p>
</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="继承的好处"><a href="#继承的好处" class="headerlink" title="继承的好处"></a>继承的好处</h4><ol>
<li>提高了代码的复用性</li>
<li>让类与类之间有了联系，为多态提供了前提</li>
</ol>
<h4 id="继承的注意事项"><a href="#继承的注意事项" class="headerlink" title="继承的注意事项"></a>继承的注意事项</h4><ol>
<li><p>Java中支持单继承，不直接支持多继承</p>
<p>多继承会出现父类成员变量调用的不确定性，可以多实现</p>
</li>
<li><p>子类中有父类非private的属性和方法</p>
</li>
<li><p>子类可以对父类的属性和功能进行扩展</p>
</li>
<li><p>子类可以对父类方法进行覆盖</p>
</li>
</ol>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="多态的特点与实现方式"><a href="#多态的特点与实现方式" class="headerlink" title="多态的特点与实现方式"></a>多态的特点与实现方式</h4><p>程序中的引用变量所指向的具体类型和调用方法只有在程序运行时才能确定，这样可以实现引用变量绑定到不同的类上，让程序可以选择多个运行状态。</p>
<p>利用父类或接口引用变量指向子类或具体实现类的对象，提高程序的扩展性。</p>
<p>方法<strong>重载</strong>（overload）实现的是<strong>编译</strong>时的多态性（也称<strong>前绑定</strong>），根据参数列表的不同来区分不同的函数；方法<strong>覆盖</strong>（override）实现的是<strong>运行</strong>时的多态性（也称<strong>后绑定</strong>），运行时的多态是面向对象最精髓的（引用变量调用的方法只有在运行时才能确定）。</p>
<p>实现多态需要做到</p>
<ul>
<li><p>继承（子类继承父类）</p>
</li>
<li><p>方法重写（子类重写父类中的<strong>已有</strong>或抽象方法）</p>
</li>
<li><p>向上转型（父类型引用子类对象，接口类型引用实现类的对象，相同的调用会根据子类对象不同而表现不同的行为）</p>
</li>
</ul>
<h3 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h3><h4 id="抽象类和接口的对比"><a href="#抽象类和接口的对比" class="headerlink" title="抽象类和接口的对比"></a>抽象类和接口的对比</h4><p>从设计层面来说，抽象类是对<strong>类的抽象</strong>，是一种模板设计；接口是<strong>行为的抽象</strong>，是一种行为的规范</p>
<p>相同点</p>
<ul>
<li>接口和抽象类<strong>不能直接实例化</strong></li>
<li>位于继承的顶端，用于被其他类实现或继承</li>
<li>都包含抽象方法，其子类必须覆写这些抽象方法</li>
</ul>
<p>不同点</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>声明</td>
<td>abstract关键字</td>
<td>interface关键字</td>
</tr>
<tr>
<td>实现</td>
<td>子类使用extends继承</td>
<td>子类使用implements实现</td>
</tr>
<tr>
<td>构造器</td>
<td>可以有</td>
<td>没有</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>方法可以为任意访问修饰符</td>
<td>接口方法默认为public，不允许定义为private或protected</td>
</tr>
<tr>
<td>多继承</td>
<td>只能继承一个类</td>
<td>可以多实现</td>
</tr>
<tr>
<td>抽象方法</td>
<td>可以有非抽象方法</td>
<td>全为抽象方法</td>
</tr>
</tbody></table>
<p>选择抽象类或者接口，遵循如下原则</p>
<ul>
<li>行为模型总是通过接口而不是抽象类定义，通常<strong>优先使用接口</strong>，少使用抽象类</li>
<li>选择抽象类的情况：需要定义子类的行为，又要为子类提供通用的功能</li>
</ul>
<h4 id="普通类与抽象类区别"><a href="#普通类与抽象类区别" class="headerlink" title="普通类与抽象类区别"></a>普通类与抽象类区别</h4><ul>
<li>普通类中不能有抽象方法，抽象类中可以包含抽象方法</li>
<li>普通类可以直接实例化，抽象类不能直接实例化</li>
</ul>
<h4 id="抽象类能用final修饰吗"><a href="#抽象类能用final修饰吗" class="headerlink" title="抽象类能用final修饰吗"></a>抽象类能用final修饰吗</h4><p>不能，定义抽象类的目的是让其他类继承，而final关键字修饰的类不能被继承，二者相违背，因此抽象类不能被final修饰</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="创建一个对象用什么关键字？对象实例与对象引用有何不同？"><a href="#创建一个对象用什么关键字？对象实例与对象引用有何不同？" class="headerlink" title="创建一个对象用什么关键字？对象实例与对象引用有何不同？"></a>创建一个对象用什么关键字？对象实例与对象引用有何不同？</h4><p>创建类使用关键字new，对象实例存在于堆内存中，而对象引用指向对象实例，对象引用可以指向一个对象实例或者指向空，而一个对象实例可以有多个对象引用指向它。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="成员变量与局部变量区别"><a href="#成员变量与局部变量区别" class="headerlink" title="成员变量与局部变量区别"></a>成员变量与局部变量区别</h4><p>成员变量定义在方法外部，局部变量定义在类的方法或代码块中。</p>
<ul>
<li>作用域：成员变量针对整个类有效，局部变量只在方法或代码块中有效</li>
<li>存储位置：成员变量存储在堆内存中，局部变量存储在栈中</li>
<li>生命周期：成员变量周期与对象一样，局部变量周期与方法一样</li>
<li>初始值：成员变量默认有初始值，局部变量没有默认初始值，使用前需要赋值</li>
<li>使用原则：就近原则，先在局部范围找，接着在成员中找</li>
</ul>
<h4 id="静态变量和实例变量区别"><a href="#静态变量和实例变量区别" class="headerlink" title="静态变量和实例变量区别"></a>静态变量和实例变量区别</h4><p>静态变量，随类的加载而加载，被当前类所有对象共享，内存中只有一份。</p>
<p>实例变量：随每次创建对象而创建，有几个对象就有几个实例变量。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h4><p>public static void main(String[] args)</p>
<p>main方法是Java程序的入口，public表示任何类和对象可以访问，static表示方法随类而加载，可使用类名来调用，void表明没有返回值，main为JVM识别的特殊方法名，不是关键字。字符串数组args可以用来输入参数。main为最先加载的方法（不一定最先执行），因此需要被静态调用。</p>
<p>是否有其他写法？</p>
<p>public与static可以交换顺序，也可以定义为final，也可以用synchronized来修饰main方法。</p>
<h4 id="在main方法执行前输出"><a href="#在main方法执行前输出" class="headerlink" title="在main方法执行前输出"></a>在main方法执行前输出</h4><p>可以使用静态代码块，静态代码块在类加载时被调用</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>{</span><br><span class="line">	<span class="keyword">static</span>{</span><br><span class="line">		Sout(<span class="string">"Hello1"</span>);</span><br><span class="line">	}</span><br><span class="line">	main(){</span><br><span class="line">		Sout(<span class="string">"Hello2"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="函数的重载与覆盖"><a href="#函数的重载与覆盖" class="headerlink" title="函数的重载与覆盖"></a>函数的重载与覆盖</h4><p>都是实现多态的方式。</p>
<ul>
<li>重载：重载发生于<strong>一个类</strong>中，若同名的方法有不同的输入参数列表（参数类型不同，参数个数不同或均不同）视为重载，编译时的多态性，前绑定</li>
<li>覆盖：也称为覆写，重写，override，发生在<strong>子类和父类</strong>之间，要求子类重写方法与父类有相同的参数列表和返回类型，子类方法权限大于等于父类方法（父类方法不能被private修饰），子类方法声明异常不能多于父类异常（其子类或子集）。运行时的多态性，后绑定，精髓。</li>
</ul>
<h4 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h4><ol>
<li>调用方式不同，实例方法只能通过对象.方法调用，而静态方法多了类名.方法，无需创建对象。</li>
<li>访问成员变量限制，在静态方法中只能访问静态成员（静态成员变量和静态方法），不能访问实例成员，而实例方法没有此限制。</li>
</ol>
<h4 id="和-equals-的区别是什么"><a href="#和-equals-的区别是什么" class="headerlink" title="== 和 equals 的区别是什么"></a>== 和 equals 的区别是什么</h4><p>==比较的是地址，equals分两种情况</p>
<ul>
<li>该类覆写了equals方法，比较的是值或内容</li>
<li>该类没有覆写equals方法，比较的仍然为地址</li>
</ul>
<h4 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode 与 equals"></a>hashCode 与 equals</h4><p>将对象加入Set或Map集合中，必须要覆写hashCode或equals方法。通过hashCode计算哈希散列值，寻找在桶中的位置，然后在该桶处的链表或树上通过equals方法来寻找是否有相同的节点，如果有就进行替换（HashMap的put方法逻辑）。覆写hashCode与equals需要确保</p>
<ul>
<li>两个相等对象的哈希值相同</li>
<li>两个相等对象返回equals返回true</li>
<li>哈希值相等的对象不一定相等</li>
</ul>
<p>这样在重写equals时必须重写hashCode，哈希值不等的对象即使有相同的数据也不等。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在Java中定义一个不做事且没有参数的构造方法的作用"></a>在Java中定义一个不做事且没有参数的构造方法的作用</h4><p>在执行子类的构造方法前，默认执行super()，若父类中只有有参数的构造方法，则编译会报错，因为程序在父类中找不到相应方法来执行，因此需要在父类中加上一个不做事的空参的构造方法</p>
<h4 id="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"><a href="#在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？" class="headerlink" title="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"></a>在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</h4><p>子类与父类有较强的耦合性，在初始化子类前，需要相应对父类进行初始化，此函数可以帮助子类做初始化工作</p>
<h4 id="一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？"><a href="#一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？" class="headerlink" title="一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？"></a>一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？</h4><p>构造方法的主要作用是完成对类对象的<strong>初始化</strong>工作。若没有显式声明构造方法，程序也能正确执行，因为每个类中有一个默认的空参的构造方法，但当自己定义了构造方法后，就没有该默认构造方法了。</p>
<h4 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="构造方法有哪些特性？"></a>构造方法有哪些特性？</h4><ul>
<li>名字与类相同</li>
<li>没有返回值，不能用void声明函数</li>
<li>在new对象时自动调用该方法</li>
</ul>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="内部类定义"><a href="#内部类定义" class="headerlink" title="内部类定义"></a>内部类定义</h4><p>将类定义在内的内部，方便访问外部类中成员。外部类要访问内部类中成员，必须新建外部类对象。内部类可以访问外部类中数据的原理是持有外部类的this引用。</p>
<h4 id="内部类种类"><a href="#内部类种类" class="headerlink" title="内部类种类"></a>内部类种类</h4><ul>
<li><p>成员内部类（成员位置上非静态类）</p>
<p>需要先创建外部类对象，再创建内部类对象</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outer.Inner in = <span class="keyword">new</span> Outer().<span class="keyword">new</span> Inner();</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>局部内部类（定义在方法中的内部类）</p>
<p>可访问外部类中所有方法</p>
</li>
<li><p>匿名内部类（没有名字的内部类，开发较多）</p>
</li>
<li><p>静态内部类（static修饰）</p>
<p>不可以访问外部类中的非静态变量，外部类可通过外部类的对象调用，不用新建内部类对象</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outer.StaticInner inner = <span class="keyword">new</span> Outer.StaticInner();</span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><ul>
<li>必须继承一个抽象类或接口</li>
<li>不能定义任何静态成员与静态方法</li>
<li>所在方法的形参被匿名内部类使用，需要用final修饰</li>
<li>匿名内部类不能是抽象的，必须实现继承的类或实现的接口所有的抽象方法</li>
</ul>
<p>创建方式如下</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类/接口{ </span><br><span class="line">  <span class="comment">//匿名内部类实现部分</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="内部类优点"><a href="#内部类优点" class="headerlink" title="内部类优点"></a>内部类优点</h4><ul>
<li>方便访问其外部类中所有数据</li>
<li>不被其他包中的类所见，封装性较好</li>
</ul>
<h4 id="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"><a href="#局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？" class="headerlink" title="局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"></a>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</h4><p>因为生命周期不同，局部变量存储在栈中，在方法执行结束后，非final的局部变量被销毁，但局部内部类对此变量引用仍然存在，这样当要调用的时候就会出错，增加final可以延长局部变量的生命周期。</p>
<h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><p>值传递指在方法调用时，传递的是参数列表值的拷贝</p>
<p>引用传递指方法调用时，传递的是引用的地址</p>
<h4 id="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"></a>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</h4><p>值传递，Java语言的传递只支持值传递，当对象实例被传入方法，方法得到的只是参数的拷贝，因此方法中参数的值为此对象实例的一个引用，对象的属性可以在被调用时改变，但对对象引用的改变无法传递给调用者。</p>
<ul>
<li>方法不能修改一个<strong>基本数据类型</strong>的参数（即数值型或布尔型》</li>
<li>方法可以改变一个对象参数的状态（存储在堆内存中）</li>
<li>方法不能让对象参数的引用</li>
</ul>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="String的equals、-与intern"><a href="#String的equals、-与intern" class="headerlink" title="String的equals、==与intern"></a>String的equals、==与intern</h4><p>==的作用</p>
<ol>
<li>判断基础数据类型的</li>
<li>判断引用是否指向堆内存的同一地址</li>
</ol>
<p>equals方法在Object类中，String类中对其进行重写，判断两个String对象内容是否相同。先比较地址，再每个字符进行比较。</p>
<p>String类中有对应的String池即String pool，每个内容相同的字符串对应一个pool中的对象。</p>
<p>String的三种比较</p>
<p>比较1：值相同，对象不同</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1==s2);            <span class="comment">//false</span></span><br></pre></td></tr></tbody></table></figure>

<p>当使用new，就是新建对象，s1与s2指向堆中的不同空间，因此使用==判断为false。</p>
<p>比较2：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String s2 = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false</span></span><br></pre></td></tr></tbody></table></figure>

<p>s1新建时，在pool和堆内存中都新建了对象，而s1指向堆内存中的对象，由于“abc”已经存在于常量池，因此s2指向的是常量池中的对象，一个指向堆，一个指向常量值，因此地址不同。</p>
<p>比较3：均不使用new</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(s1==s2);            <span class="comment">//true</span></span><br></pre></td></tr></tbody></table></figure>

<p>s1新建时，常量池中没有“abc”，会在常量池中新建，s1指向常量池中对象，而s2也指向常量池中对象，因此二者地址相同。</p>
<p>而String中的intern方法，返回字符串对象的规范化表示形式，即此字符串对应常量池中的对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">System.out.println(s == s1.intern());<span class="comment">//false</span></span><br><span class="line">System.out.println(s == s2.intern());<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s2.intern());<span class="comment">//true</span></span><br></pre></td></tr></tbody></table></figure>

<p>intern的具体步骤是，当字符串s在常量池中不存在对应对象，创建并返回常量池对象；若常量池中存在对应对象，则返回常量池中的对象。</p>
<p>s指向堆内存，s1.intern指向常量池，二者不相同；s指向堆内存，s2.intern指向常量池，二者不相同；s1指向常量池，s2.intern指向常量池，二者相同。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String hello = <span class="string">"hello"</span>;</span><br><span class="line">String hel = <span class="string">"hel"</span>;</span><br><span class="line">String lo = <span class="string">"lo"</span>;</span><br><span class="line">System.out.println(hello == <span class="string">"hel"</span> + <span class="string">"lo"</span>);<span class="comment">//true</span></span><br><span class="line">System.out.println(hello == <span class="string">"hel"</span> + lo);<span class="comment">//false</span></span><br></pre></td></tr></tbody></table></figure>

<p>hello指向的是常量池中的徐爱那个，而“hel”+“lo”也指向常量池中对象，而lo+“hel”，相当于调用StringBuilder的append方法，重新在堆中生成了一个对象，因此地址不同。</p>
<h4 id="String不变性的理解"><a href="#String不变性的理解" class="headerlink" title="String不变性的理解"></a>String不变性的理解</h4><ul>
<li>String类被final修饰，不能被继承</li>
<li>用+号拼接字符串后，会创建新的字符串</li>
<li>String s = new String(“hello”)可能创建一个或两个对象。若静态区中有“hello”字符串常量对象，仅在堆中创建一个对象。若静态区中没有“hello”对象，堆上和静态区中都需要创建对象</li>
<li>在Java中，通过+拼接字符串，底层会转为StringBuilder实例的append()方法来实现</li>
</ul>
<h4 id="String重写equals而不重写hashCode的问题"><a href="#String重写equals而不重写hashCode的问题" class="headerlink" title="String重写equals而不重写hashCode的问题"></a>String重写equals而不重写hashCode的问题</h4><p>在equals()被重写时，通常有必要重写hashCode()方法，以维护hashCode()方法的约定，即相对等的两个对象要有相同的hashCode，若只重写equals而不重写hashCode，在将String类对象加入Set或Map集合时，会先判断hashCode，再判断equals，但因为没有重写hashCode，会在集合中存储两个值相同的对象，导致混淆。</p>
<h4 id="String、StringBuffer、StringBuilder区别"><a href="#String、StringBuffer、StringBuilder区别" class="headerlink" title="String、StringBuffer、StringBuilder区别"></a>String、StringBuffer、StringBuilder区别</h4><ul>
<li>String、StringBuffer与StringBuilder均为final类，不允许被继承</li>
<li>字符串拼接时，String类可使用+号，而另外两个类需要使用append()方法</li>
<li>String长度不可变，而StringBuffer与StringBuilder长度可变</li>
<li>StringBuffer是线程安全的，而StringBuilder不是，StringBuffer在StringBuilder方法上加入了synchronized修饰，因此StringBuffer性能更低。多线程时使用StringBuffer，单线程下使用StringBuilder。</li>
<li>若String类型的字符串，在编译时就可以确定为字符串常量，在编译完成后，字符串会自动拼接为一个常量，此时String性能会更好</li>
</ul>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="其他类如何默认继承Object"><a href="#其他类如何默认继承Object" class="headerlink" title="其他类如何默认继承Object"></a>其他类如何默认继承Object</h4><blockquote>
<p>引用自掘金博客 <a href="https://juejin.im/post/5ca1e8ade51d454e6a300048" target="_blank" rel="noopener">https://juejin.im/post/5ca1e8ade51d454e6a300048</a></p>
</blockquote>
<p>首先Object的类是所有类的父类，因为所有类中有包含有Object类中的方法，但是我们在编程的时候并没有写过extends Object，那么Java语言是如何确定当前类的父类是继承自Object类中的呢？有两种可能的原因，一种是在编译期间确定的，如果当前类没有显式继承自一个类，则编译时认为其继承自Object，另一种是由JVM处理的。如果是在编译期间确定的，那么其class文件中应该写明了当前类继承自Object，根据引用博客的实验，在JDK6时，得到的反编译结果是当前类的class文件中指出了当前类是继承自Object。但在JDK7及之后，在反编译的结果中是没有extends Object的。</p>
<p>这样得到的一个推测的结果是：在JDK6及之前，是在编译期间确定的；在JDK7及之后，是由JVM虚拟机来处理的。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Java中的内存泄漏多与集合容器相关。当集合中持有生命周期较短的对象，当对象作用已经结束，需要被销毁时，因为有长生命周期的集合持有，如果不进行手动销毁，会存在内存泄漏。如在坦克的项目中，如果子弹集合中，子弹生命周期结束，没有手动将此子弹移出集合，就会造成内存泄漏。</p>
<h3 id="List与Set"><a href="#List与Set" class="headerlink" title="List与Set"></a>List与Set</h3><p>Collection下有List、Set和Queue，重点说明List与Set的区别。</p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/list%E4%B8%8Eset.png" class title="This is an example image">

<p>一、特点</p>
<p>按照特点来看</p>
<ul>
<li>List：元素有序（存入和取出顺序一致），可以索引（角标）操作元素，元素可以重复</li>
<li>Set：元素不能重复，无序</li>
</ul>
<p>二、种类</p>
<ul>
<li><p>List</p>
<ul>
<li>底层是数组，查询快，增删慢<ul>
<li>Vector，线程安全，效率低</li>
<li>ArrayList，线程不安全，效率高</li>
</ul>
</li>
<li>底层是链表，查询慢，增删快<ul>
<li>LinkedList，线程不安全，效率高</li>
</ul>
</li>
</ul>
</li>
<li><p>Set</p>
<ul>
<li><p>底层是哈希表</p>
<p>HashSet，保证元素唯一性，存入的类需要覆写hashcode()和equals()方法</p>
<p>先判断hashcode()，再判断equals()</p>
</li>
<li><p>底层是二叉树</p>
<p>TreeSet，保证元素排序，两种排序方式，比较器优先使用</p>
<ul>
<li>自然顺序，让对象所属的类实现Compareble接口，覆盖compareTo()方法，无参构造</li>
<li>让集合自身具备比较功能，比较器实现Comparator接口，覆盖compare()方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>其中，Vector虽安全，但不适用于高并发。HashSet底层为HashMap，在add元素时，以键的形式放入，值为PRESENT。TreeSet的核心在排序，不排序用HashSet。TreeSet有两种排序方式，方式一是被排序类实现Compareble接口（实现equals()、hashcode()、compareTo()方法），方式二为传入比较器，比较器需要实现Comparator接口（实现compare()方法）。TreeSet底层为TreeMap，两种排序方式比较器优先级较高。</p>
<h4 id="ArrayList-和-LinkedList-的区别"><a href="#ArrayList-和-LinkedList-的区别" class="headerlink" title="ArrayList 和 LinkedList 的区别"></a>ArrayList 和 LinkedList 的区别</h4><ol>
<li>数据结构实现：ArrayList底层为动态数组（可动态扩容），LinkedList底层为双向链表</li>
<li>随机查询效率：ArrayList随机查询效率更高，而LinkedList只能依靠遍历，因此ArrayList查询效率更高</li>
<li>增加和删除效率：在增加和删除非首尾元素时，LinkedList效率更高，因为ArrayList的增加和删除操作会影响到其他位置的元素，涉及元素的移动</li>
<li>内存空间占用：LinkedList比ArrayList更占内存，因为LinkedList中除了存放数据，还有指向前后的引用</li>
<li>线程安全方面：二者都是不安全的</li>
</ol>
<p>因此，如果涉及频繁的查询操作，ArrayList更合适；涉及频繁的增删操作，LinkedList更合适</p>
<h4 id="ArrayList-和Vector-的区别"><a href="#ArrayList-和Vector-的区别" class="headerlink" title="ArrayList 和Vector 的区别"></a>ArrayList 和Vector 的区别</h4><ol>
<li>线程安全：Vector使用synchronized保障线程安全，ArrayList不是</li>
<li>性能：因为Vector存在锁，因此性能不如ArrayList</li>
<li>扩容：ArrayList和Vector均可以动态扩容，Vector新容量为原来的2倍，而ArrayList新容量为原来的1.5倍</li>
</ol>
<p>在不需要线程安全时，建议使用ArrayList。</p>
<p>如果想在多线程下使用ArrayList，可以使用Collections.synchronizedList(list)方法</p>
<h4 id="List遍历时删除问题"><a href="#List遍历时删除问题" class="headerlink" title="List遍历时删除问题"></a>List遍历时删除问题</h4><p>如果直接for循环遍历List，再进行remove操作，会报ConcurrentModificationException，因为使用了foreach语句时，会自动生成一个Iterator来遍历list，但同时该list又在被iterator.remove()方法修改，不允许在其他地方进行删除，因此这样会出问题。</p>
<p>解决办法1：使用迭代器来获取List中全部元素，再调用iterator的remove方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator<integer> it = list.iterator();</integer></span><br><span class="line"><span class="keyword">while</span>(it.hasNext()){</span><br><span class="line">   *<span class="comment">// do something*</span></span><br><span class="line">   it.remove();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>解决办法2：利用下标来获取元素，再使用删除</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < list.size(); i++) {</span><br><span class="line">          list.remove(list.get(i));</span><br><span class="line">      }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="HashSet实现原理"><a href="#HashSet实现原理" class="headerlink" title="HashSet实现原理"></a>HashSet实现原理</h4><p>HashSet基于HashMap而实现，HashSet中的值存放于HashMap的key上，HashMap的value全部为PRESENT，HashSet底层方面基本是调用HashMap来实现的。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap为Java中非常重要和常用的一种数据结构，下面将重点介绍HashMap的底层原理及方法实现。</p>
<p>Java8以前：数组+链表</p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/%E9%93%BE%E8%A1%A8hash.png" class title="This is an example image">

<p>操作为非同步，效率较高。<strong>数组默认16</strong>，存储链表头节点，数组位置的获得方式是hash(key.hashCode())%len，计算键的哈希值再算出%数组长度的值。实际中通过位运算来实现。其中数组的类型为Entry<k,v>，当发生哈希冲突时，则将数组中的Entry设置为新值的next，新值放在数组中，旧值在新值的链表上。</k,v></p>
<p>最坏的情况下，链表会集中在一个数组，这样查找的时间复杂度从O(1)变为O(n)。</p>
<p>Java8及以后：链表+数组+红黑树</p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/%E7%BA%A2%E9%BB%91%E6%A0%91hash.png" class title="This is an example image">

<p>当数组中某个位置链表长度大于TREEIFY_THRESHOLD常量时，链表转换为红黑树，最坏情况下的性能从O(n)提高到O(logn)。数组类型变为Node，当链表大小<strong>超过</strong>TREEIFY_THRESHOLD（<strong>默认是8</strong>）时，链表被改造成红黑树。当红黑树元素被删除<strong>低于</strong>UNTREEIFY_THRESHOLD（<strong>默认是6</strong>）时，红黑树被转成链表。HashMap在首次使用时才被初始化，可以扩容，当插入一个元素，若对应位置数组没有元素，则新建；如果有，则判断是树还是链表，按照相应方式插入。若链表元素超过阈值，则树化；若插入值的键重复，就更新值。</p>
<h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><p>HashMap的put方法逻辑是：</p>
<ol>
<li>若HashMap未被初始化 ，进行初始化</li>
<li>对key求hash值，计算下标</li>
<li>如果没有碰撞，直接放入桶中</li>
<li>如果碰撞了，以链表的方式链接到后面</li>
<li>如果链表长度超过阈值（8），把链表转成红黑树</li>
<li>如果链表的长度低于6，把红黑树转成链表</li>
<li>如果key对应节点存在，替换旧值</li>
<li>如果桶满了（容量16*负载因子0.75），需要resize（扩容2倍重排）</li>
</ol>
<h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><p>先计算hash值找到对应的桶，然后在链表或者红黑树中通过equals方法找到对应的节点，找到值并返回。</p>
<h4 id="扩容resize-方法"><a href="#扩容resize-方法" class="headerlink" title="扩容resize()方法"></a>扩容resize()方法</h4><p>在构造哈希表时，若不指明初始大小，默认为16，若大小达到了容量16*负载因子0.75，用大数组去替代小数组，重新调整hashmap大小为原来2倍，比较耗时。</p>
<p>具体逻辑为创建一个大小为原数组大小2倍的新数组，要原数组中的元素重新计算在新数组中的索引，然后添加至新数组中。</p>
<ul>
<li>在多线程环境下，调整大小会存在条件竞争，容易造成<strong>死锁</strong></li>
<li>rehashing是一个比较耗时的过程</li>
</ul>
<p>在JDK7前，哈希表扩容，需要重新计算每个元素在新的数组中的位置，然后进行移动。在JDK8中进行了优化，通过位运算来判断元素是否需要移动，如果位置不变可直接放入对应的位置；如果出现了变化，新的位置是原来的下标位置+原数组长度。</p>
<p>可以这么做是因为计算hash的时候，采用的是散列后的哈希值与上数组长度减一。初始为16，二进制的长度减一为1111，当扩容后，数组新长度为11111，如果一个key倒数第5位本来计算就是0，这样当扩容后计算的位置还是不变的，如果倒数第5位是1，相当于要加上10000，即老数组长度16，因此若有变化将原来老数组下标加上老数组长度就是在新数组中的位置。</p>
<h4 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h4><p>为何负载因子要选为0.75，而不是更高的1，或者更小的0.5呢。如果负载因子选为1，则resize()的阈值会变得比较高，更不容易扩容，减少了rehash的成本，但是这样桶中元素更密集，哈希碰撞更严重，降低了查询效率。如果选为0.5，则resize()的阈值变得很低，扩容频繁，虽然桶中元素分布更散列，但扩容成本变高。因此为了权衡扩容成本与查询效率，选了折中的数字0.75。</p>
<h4 id="cpu占用100-的问题"><a href="#cpu占用100-的问题" class="headerlink" title="cpu占用100%的问题"></a>cpu占用100%的问题</h4><p>出现在JDK7，因为在JDK7中链表元素的插入采用的是头插法，即如果插入元素的顺序为1,2,3，链表的顺序是3->2->1，然后在扩容的时候，当两个线程均新建了一个新的数组，一个数组将链表元素放入到新数组中，由于从头节点开始放，因此此时的顺序是1->2->3，而对于第二个链表，其当前记录指针e若指向3，e的next指向2，此时会让3再指向2，这样相当于形成了一个循环链表，这样当使用get()方法的时候，就会死循环。</p>
<p>JDK8后，链表插入采用尾插入的方法，这样便解决了死循环问题，但在多线程下HashMap仍然会存在节点丢失等问题，因此不能在单线程下使用。</p>
<h4 id="如何减少碰撞"><a href="#如何减少碰撞" class="headerlink" title="如何减少碰撞"></a>如何减少碰撞</h4><ul>
<li><p>使用扰动函数：促使元素位置分布均匀，减少碰撞几率</p>
</li>
<li><p>使用final对象，并采用合适的equals()和hashCode()方法</p>
<p>使用String、Integer等类作为键很好，防止键值改变，放入和获取到的键不一样，就不能获取到</p>
</li>
</ul>
<p>哈希散列的过程：可以看到<strong>hashmap允许键为null</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> h;</span><br><span class="line">	<span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h=key.hashCode()) ^ (h >>> <span class="number">16</span>); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>将hashCode右移16位，去除低位，与原数据异或，混合原始哈希码的高位和低位，加大低位随机性，散列更均匀，计算下标使用(数组长度-1)&hash，数组长度总为2^n（传入值时替换为最接近2的n次方的值），等价于对长度取模，效率更高。    </p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/hash%E6%95%A3%E5%88%97.png" class title="This is an example image">

<h4 id="Dos攻击"><a href="#Dos攻击" class="headerlink" title="Dos攻击"></a>Dos攻击</h4><p>在JDK7以前，如果对方知道我方使用哈希算法，可以发送大量哈希值相同的请求来导致严重的哈希碰撞，然后不停访问这些key就可以显著影响服务器的性能（大量占用CPU），这样形成了一次拒绝服务供给（DoS）。这样将最坏性能从O（N）优化至O（logN），有较大的改善。</p>
<p>那么怎么进一步处理呢？</p>
<ol>
<li>限制POST和GET请求参数个数</li>
<li>限制POST请求的请求体大小</li>
<li>Web Application FireWall（WAF）</li>
</ol>
<p>对于JDK7，HashMap会动态的使用一个专门的TreeMap实现来替换掉它。</p>
<h4 id="多线程下的HashMap"><a href="#多线程下的HashMap" class="headerlink" title="多线程下的HashMap"></a>多线程下的HashMap</h4><p>由于HashMap不是线程安全的，在多线程下会出现问题，有</p>
<ul>
<li><p>多线程put操作后，get操作导致死循环</p>
<p>rehash时容易出现环状链表</p>
</li>
<li><p>多线程put非null元素后，get操作得到null值</p>
</li>
<li><p>多线程put操作，导致元素丢失</p>
</li>
</ul>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><blockquote>
<p>引用自博客<code>https://my.oschina.net/hosee/blog/618828</code></p>
</blockquote>
<p>要了解红黑树是什么，为什么要有红黑树。</p>
<p>红黑树是<strong>相对平衡</strong>的<strong>二叉查找树</strong>，不同的是在每个结点上增加一个存储位来表示颜色，Red或Black。而红黑树的特点是通过对任何一条从根到叶子的路径上各个结点的着色方式的限制，<strong>红黑树确保没有一条路径比其他路径长出两倍</strong>，树是接近平衡的。没有AVL树那么平衡。</p>
<p>二叉查找树简单理解是：</p>
<ul>
<li>若有左子树，则左子树上所有结点的值均小于根节点值 </li>
<li>若有右子树，则右子树上所有结点的值均大于根节点值</li>
<li>任意节点的左、右子树分别为二叉查找树</li>
<li>没有键值相等的节点</li>
</ul>
<p>一般普通的二叉查找树高度为log(N)，但如果二叉查找树退化为一个链表，最坏时间会变成O（N）,那么红黑树如何保证树相对平衡呢？介绍其5个性质：</p>
<ol>
<li>每个节点要么红、要么黑</li>
<li>根节点是黑</li>
<li>叶节点是黑的空节点</li>
<li>若一个节点是红，两个儿子都是黑的（不存在两个连续的红色节点）</li>
<li>对任意节点，其到叶节点尾端指针的每条路径都包含相同数目的黑节点</li>
</ol>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%9B%BE.png" class title="This is an example image">

<p>数学证明红黑树的操作时间复杂度最差为O(logN)。</p>
<h4 id="HashMap与HashTable"><a href="#HashMap与HashTable" class="headerlink" title="HashMap与HashTable"></a>HashMap与HashTable</h4><p>因为HashMap在多线程下不安全，而线程安全的类有HashTable，其线程安全原因是使用了synchronized修饰符，锁为调用者的this，与Collections.synchronizedMap(hashMap)几乎无区别，只是锁不一样，synchronizedMap锁为Object类的mutex，hashMap方法均用synchronized(mutex)加锁。</p>
<p>而HashTable初始容量为11，与HashMap不同。扩容时，计算容量为2倍原来容量+1。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span><<span class="title">K</span>,<span class="title">V</span>> <span class="keyword">extends</span> <span class="title">Dictionary</span><<span class="title">K</span>,<span class="title">V</span>> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span><<span class="title">K</span>,<span class="title">V</span>>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{...}</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{...}</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>{...}</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{...}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但HashTable在多线程下效率较低，因此又引入了ConcurrentHashMap。</p>
<p>二者的区别概括为</p>
<ul>
<li><p>线程安全</p>
<p>HashMap不安全，HashTable安全</p>
</li>
<li><p>能否存空键</p>
<p>HashMap可以，计算散列值时null的hash为0，HashTable不可以</p>
</li>
<li><p>初始容量与扩容</p>
<p>HashMap默认初始16，HashTable为11；</p>
<p>扩容时，HashMap为原来2倍，HashTable为原来2倍+1；</p>
<p>指定容量，HashMap会计算与指定的最接近的2的整数次幂作为初始容量，HashTable按照指定的</p>
</li>
<li><p>效率</p>
<p>HashMap效率更高，HashTable因为有synchronized，效率更低</p>
</li>
<li><p>底层结构</p>
<p>HashMap1.8后底层为数组+链表+红黑树，HashTable没有树化的机制</p>
</li>
</ul>
<h4 id="HashMap与ConcurrentHashMap"><a href="#HashMap与ConcurrentHashMap" class="headerlink" title="HashMap与ConcurrentHashMap"></a>HashMap与ConcurrentHashMap</h4><p>那么该如何优化HashTable呢？</p>
<p><strong>通过锁细粒度化，将整锁拆解成多个锁进行优化</strong>。</p>
<p>早期的ConcurrentHashMap通过<strong>分段锁Segment</strong>实现</p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/segment.png" class title="This is an example image">

<p>在HashMap的基础上，外面多了一层数组结构，有多个Segment（一种可重入锁），Segment继承自ReentrantLock，每个Segment中有多段数据（HashEntry），当一个线程占用一个锁时，位于此Segment上的其他数据也可以被访问到。默认分配<strong>16</strong>个Segment，理论上比HashTable效率高16倍。将HashMap的table数组逻辑上拆分为多个子数组，每个子数组配置一个Segment，线程只有在获取到某把分段锁后，才能获取到其中的子数组，其他没有该Segment的线程访问其中数据被阻塞，而访问没有被Segment锁住的数据不会被阻塞。</p>
<p>而当前的ConcurrentHashMap，使用<strong>CAS+Synchronized使锁更细化</strong></p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/%E6%96%B0con.png" class title="This is an example image">

<p>使用CAS+synchronized为保证并发安全，数据结构使用数组+链表/红黑树，synchronized锁定的是当前链表或树的首节点，只要没有哈希冲突，效率就可以被进一步提高。许多参数与HashMap类似，如树化和反树化参数。也有一些特有的参数，如sizeCtl，是大小控制的标识符，-1表示正在初始化，-n表示有n-1个线程在执行扩容操作，正数或零表示还没有初始化，数值表示下一次初始化或扩容大小，此参数有volatile修饰，在多线程间可见。</p>
<p>相比于HashMap可以添加null键，ConcurrentHashMap不允许添加null键和null值，其对数组元素的更新使用CAS操作。</p>
<p>ConcurrentHashMap的put方法</p>
<ol>
<li>判断Node[]数组是否初始化，没有则进行初始化操作</li>
<li>通过hash值定位数组的索引坐标，看是否有Node节点，如果没有则使用<strong>CAS添加</strong>（链表的头节点f），添加失败进入下次循环</li>
<li>若检查到内部在扩容，<strong>协助扩容</strong></li>
<li>判断链表/红黑树头节点f是否为空，若不为空则<strong>用synchronized锁住</strong><ul>
<li>若为链表结构，执行链表的添加操作</li>
<li>若为树结构，执行树的添加操作</li>
</ul>
</li>
<li>如果链表长度到达临界值（默认为8），将链表转换为树结构</li>
</ol>
<p>比起Segment，锁更细化，只要没有哈希冲突就不会有并发获得锁的情况，因为其锁的是每一个桶。在put方法操作时，比较关键的是若当前没有Node节点，先使用<strong>CAS操作插入头节点</strong>，失败则循环重试；若已经有头节点，则<strong>获取头节点的锁</strong>后再进行相关操作。</p>
<p>此外，计算map的大小时，有size()和mappingCount()方法，从源码可以看出，size()返回的为int类型，有大小限制，而mappingCount()方法返回long类型，JDK更推荐使用mappingCount()方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">mappingCount</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> (n < <span class="number">0L</span>) ? <span class="number">0L</span> : n; <span class="comment">// ignore transient negative values</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n < <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n > (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="三者的比较"><a href="#三者的比较" class="headerlink" title="三者的比较"></a>三者的比较</h4><ul>
<li>HashMap线程不安全，数组+链表+红黑树</li>
<li>HashTable线程安全，锁住整个对象，数组+链表</li>
<li>ConcurrentHashMap线程安全，CAS+synchronized，数组+链表+红黑树</li>
<li>HashMap的key、value均可为null，而其他两个类不支持</li>
</ul>
<h3 id="其他数据结构"><a href="#其他数据结构" class="headerlink" title="其他数据结构"></a>其他数据结构</h3><h4 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h4><p>为了实现数据的排序，在单线程下可以使用TreeSet与TreeMap，但这两种结构不是并发安全的，为了在多线程下实现数据的有序存放，可以使用ConcurrentSkipListSet与ConcurrentSkipListMap，跳表的本质是在普通的链表上加上了多层类似索引的结构，这样加快查找效率，以空间换时间，查找的时候不用顺序遍历链表，而是可以跳过某些数据，因此叫做跳表。相比于红黑树，实现结构更加简单。</p>
<p>而哪些数据可以被当做索引，是根据概率来决定的。</p>
<p>使用场景：加速链表的查询效率。Redis中有使用。</p>
<h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><p>阻塞队列是支持阻塞的获取元素与阻塞的放入元素的队列，主要是应用于生产者与消费者模式，当队列满了以后，生产者放入元素被阻塞；当队列空了以后，消费者取出元素被阻塞。解决的问题是生产者与消费者能力不匹配的问题。</p>
<p>BlockingQueue中常用的方法有如下</p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95.png" class title="This is an example image">

<p>常用的阻塞队列有</p>
<ul>
<li><p>ArrayBlockingQueue</p>
<p>有界的阻塞队列，需要传入默认大小，锁没有分离（生产消费使用一个锁）</p>
</li>
<li><p>ListBlockingQueue</p>
<p>有界的阻塞队列，可以不指定大小（最好指定），默认Integer.MAX_VALUE，锁分离（生产消费使用不同锁），应用于固定大小的线程池</p>
</li>
<li><p>PriorityBlockingQueue</p>
<p>有优先级的无界队列</p>
</li>
<li><p>DelayQueue</p>
<p>使用优先级队列实现的无界阻塞队列，放入队列元素要实现Delayed接口，重写getDelay(TimeUnit unit)与compareTo(Delayed o) 方法，实现的功能是在某个元素过期后，才能被获取到，getDelay方法用于获取剩余过期时间，compareTo方法用于堆的排序。常用于<span style="color:red;">缓存系统的设计</span>（一旦元素可以被取出，表示缓存到期），<span style="color:red;">订单到期</span>，<span style="color:red;">限时支付等</span>。</p>
</li>
<li><p>SynchronousQueue</p>
<p>不存储元素的队列，一个生产必须要一个消费。</p>
</li>
<li><p>LinkedTranferQueue</p>
<p>链表结构组成的无界阻塞队列</p>
</li>
<li><p>LinkedBlockingDequeue：双向阻塞队列，用于forkJoin框架，方便一个线程从其他任务队列中拿取任务</p>
</li>
</ul>
<p>实现原理：为了实现阻塞与继续生产或消费，需要在满足一定条件时将线程唤醒，即<span style="color:red;">等待通知范式</span>，使用<span style="color:red;">一个锁+2个监视器</span>。当有生产时，同时消费的监视器；当有消费时，同时生产的监视器。</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>框架：最早是BIO，后来有NIO，再后来有AIO，但这些API都不好用，于是Netty基于NIO进行了封装。</p>
<h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>Blocking IO(Input-Output)</p>
<p>IO速度相比CPU速度非常慢</p>
<p>半双工，读的时候不能同时写。</p>
<p>阻塞IO，有个client连接，服务端就新建一个线程进行连接。</p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/BIO.png" class title="This is an example image">

<p>服务端：服务端等待客户端建立连接，通过accept方法获取Socket，此方法会阻塞直到客户端连接，服务端获取到socket后，新建一个线程处理socket的数据读写。socket的读与写不是双向的，单独拿出socket的InputStream来读，拿出OutputStream来写。</p>
<p>客户端：建立一个Socket，向输出流写信息，从服务端读信息，关闭socket连接。</p>
<p>Blocking在于：建立连接阻塞，读写阻塞</p>
<ul>
<li>Server端accpet方法阻塞，没有客户端连接就wait</li>
<li>在处理socket流的读与写方法也是阻塞的</li>
</ul>
<p>需要是多线程，因为accept为阻塞的，一个连接一个线程，只有一个线程其他客户端会被阻塞，一次只能处理一个客户端。可以使用线程池。</p>
<p>BIO效率低，并发量不好。BIO很少用，代码简单，适合建立连接少的情况。</p>
<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>Non-Blocking IO </p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/NIO.png" class title="This is an example image">

<p>上面为NIO的<strong>单线程模型</strong>，用一个线程处理客户端的连接，selector轮询客户端是否有连接与读写，门面模式？selector负责client的连接与读写。并不是只能一个连接，而是selector一次处理一次请求。</p>
<p>NIO服务端对socket封装为ServerSocketChannel，此通道为<strong>双向</strong>，可同时读写，设置非阻塞，打开并注册selector，此时关心的只是建立连接，selector进行select，此<strong>方法</strong>也是<strong>阻塞</strong>，获取到key并进行处理。</p>
<p>为了处理客户端的连接，需要将selector注册到客户端的channel中，因此selector处理的是服务端的channel+客户端的channel，不同的channel上的时间在一个set中，selector从set中获取事件并处理，每次处理事件后要将其移除。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();<span class="comment">//服务端的socket</span></span><br><span class="line">      ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">8888</span>));<span class="comment">//绑定地址</span></span><br><span class="line">      ssc.configureBlocking(<span class="keyword">false</span>);<span class="comment">//设置非阻塞</span></span><br><span class="line">      System.out.println(<span class="string">"server started, listening on :"</span> + ssc.getLocalAddress());</span><br><span class="line">      <span class="comment">//要有selector</span></span><br><span class="line">      Selector seletor = Selector.open();</span><br><span class="line">      ssc.register(seletor, SelectionKey.OP_ACCEPT);<span class="comment">//将selector注册</span></span><br><span class="line">      <span class="comment">//轮训</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">          seletor.select();<span class="comment">//看是否有连接，阻塞</span></span><br><span class="line">          Set<selectionkey> keys = seletor.selectedKeys();<span class="comment">//获取所有的keys</span></selectionkey></span><br><span class="line">          <span class="comment">//迭代keys</span></span><br><span class="line">          Iterator<selectionkey> it = keys.iterator();</selectionkey></span><br><span class="line">          <span class="keyword">while</span> (it.hasNext()){</span><br><span class="line">              SelectionKey key = it.next();</span><br><span class="line">              <span class="comment">//获取后移除，不移除会重复处理</span></span><br><span class="line">              it.remove();</span><br><span class="line">              handle(key);</span><br><span class="line">          }</span><br><span class="line">      }</span><br></pre></td></tr></tbody></table></figure>

<p>此时Selector负责客户端连接与读写，干的太负责，于是有了reactor模式</p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/NIO2.png" class title="This is an example image">

<p>NIO的多线程模型</p>
<p>Observer模式，响应式编程。selector只负责与客户端建立连接，然后又客户端要进行读写后，selector交给线程池进行处理。selector+worker。</p>
<p>如果客户端消息来不及处理，可以放入消息队列。NIO的ByteBuffer比较难用，读与写只用一个指针，较少直接用NIO，多用Netty。</p>
<p>NIO相比BIO，不用一个客户端连接建立一个线程，客户端连接只需要一个线程来管理。但NIO需要一直轮询。</p>
<h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><p>Asynchronous-IO</p>
<p>客户端要建立连接时，操作系统通知selector，selector连接通道，再交给工人去执行读写操作。</p>
<img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/AIO.png" class title="This is an example image">

<p>AIO的accpet不是阻塞的，当执行accpet后会<strong>继续往下</strong>，因此要在accept后设置循环等待避免main方法结束。当有客户端连接，交给CompletionHandler来处理，本质是模板方法模式，只重写关心的方法。方法写好了，当有客户端连接时自动调用completed方法执行。</p>
<p>总的来说，当操作系统发现有客户端连接请求，调用写好的建立连接的方法，建立连接的方法再调用写的方法，使用观察者模式来实现异步操作。</p>
<p>现在读也可以是非阻塞的，读了就执行其他，当读完后再执行一个CompletionHandler。</p>
<p>AIO与NIO在Linux下都是基于epoll实现的，epoll也是轮询，因此底层实现一样，<strong>AIO多了层封装</strong>，在Linux下使用AIO效率并一定高，Netty对NIO进行封装，使得API更像AIO，更好用。Windows下的AIO单独实现，使用Completion Port，但大多数Server都是基于Linux实现的，因此Netty还是基于NIO封装。</p>
<h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><p>实现对NIO，BIO的封装，封装成AIO的样子。建立两个group，一个负责建立连接，一个负责读写，将这两个group交给Server启动的封装类，指定连接后者两个group的类型，对每个客户端连接增加监听器，进行处理，一旦通道被初始化，在此通道添加对此通道的监听器，这样将连接与业务处理代码解耦。对于读写的处理过程，重写channelRead方法等。对于异常处理，将相应的通道关闭。</p>
<h4 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h4><p>客户端的写法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//事件处理线程池，可处理连接或读写事件</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);<span class="comment">//1个线程</span></span><br><span class="line">        <span class="comment">//辅助启动类</span></span><br><span class="line">        Bootstrap b = <span class="keyword">new</span> Bootstrap();<span class="comment">//启动</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//连接server</span></span><br><span class="line">            b.group(group)<span class="comment">//传入group</span></span><br><span class="line">                    <span class="comment">//指定channel类型为nio</span></span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)//指定<span class="title">channel</span>类型</span></span><br><span class="line"><span class="class">                    //当<span class="title">channel</span>有事件，指定处理的<span class="title">handler</span></span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ClientChannelInitializer</span>())</span></span><br><span class="line">                    .connect("localhost",8888)//连接远程，异步方法，无法知道是否成功</span><br><span class="line">                    .sync();<span class="comment">//必须等其结束，不让继续进行</span></span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            group.shutdownGracefully();<span class="comment">//正常结束</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span><<span class="title">SocketChannel</span>></span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        System.out.println(ch);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>1、定义事件处理的线程池</p>
<p>2、定义辅助启动类</p>
<p>3、链式编程</p>
<ul>
<li>将辅助类中传入线程池</li>
<li>指定channel的类型为bio还是nio</li>
<li>增加连接后的处理handler</li>
<li>进行连接，返回的是ChannelFuture，为了知道是否连接成功<ul>
<li>再加入sync方法</li>
<li>或自定义监听器</li>
</ul>
</li>
</ul>
<p>Netty中方法均是异步的。</p>
<p>connet为异步，返回ChannelFuture，使用sync才知道是否有成功执行，如果不用sync的写法，需要在Future中增加监听器。因为ChannelFuture得到的是异步的结果，当其中有结果后，会调用监听器中的方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接server</span></span><br><span class="line">         ChannelFuture f = b.group(group)<span class="comment">//传入group</span></span><br><span class="line">                 <span class="comment">//指定channel类型为nio</span></span><br><span class="line">                 .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)//指定<span class="title">channel</span>类型</span></span><br><span class="line"><span class="class">                 //当<span class="title">channel</span>有事件，指定处理的<span class="title">handler</span></span></span><br><span class="line"><span class="class">                 .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ClientChannelInitializer</span>())</span></span><br><span class="line">                 .connect("localhost", 8888);//连接远程，异步方法，无法知道是否成功</span><br><span class="line">         f.addListener(<span class="keyword">new</span> ChannelFutureListener() {</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                 <span class="keyword">if</span> (!future.isSuccess()){</span><br><span class="line">                     System.out.println(<span class="string">"not connected!"</span>);</span><br><span class="line">                 }<span class="keyword">else</span> {</span><br><span class="line">                     System.out.println(<span class="string">"connected!"</span>);</span><br><span class="line">                 }</span><br><span class="line">             }</span><br><span class="line">         });</span><br><span class="line">         f.sync();</span><br></pre></td></tr></tbody></table></figure>

<p>因为Future异步，加入监听器后也会继续往下 ，为了阻塞住它，加上sync，在结束后才继续进行，加sync是为了防止客户端还没有建立好连接则main线程直接结束。</p>
<p>其中打印的顺序是，channel初始化的时候，客户端打印SocketChannel，服务端连接上客户端后，服务端打印信息，然后客户端的监听器打印。</p>
<h4 id="服务端连接"><a href="#服务端连接" class="headerlink" title="服务端连接"></a>服务端连接</h4><p>对于服务端的写法</p>
<p>1、指定负责连接与读写的线程池</p>
<p>2、服务端的启动类</p>
<p>3、链式编程</p>
<ul>
<li>启动类绑定两个线程池</li>
<li>指定channel类型为NIO</li>
<li>为客户端的通道增加监听器</li>
<li>绑定监听端口</li>
<li>等待future返回</li>
</ul>
<p>4、让服务器等待被关闭</p>
<ul>
<li>获取到future对应的服务端的channel，再调用closeFuture，不调用close就被阻塞，调用sync等待此future结束</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);<span class="comment">//负责连接</span></span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>);<span class="comment">//负责读写</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            ChannelFuture f = b.group(bossGroup, workerGroup)<span class="comment">//指定线程池类型，一个连接，一个读写</span></span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)//指定<span class="title">channel</span>类型</span></span><br><span class="line"><span class="class">                    //加在客户端上</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span><<span class="title">SocketChannel</span>>() </span>{</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                            System.out.println(ch);<span class="comment">//打印客户端端口</span></span><br><span class="line">                        }</span><br><span class="line">                    })</span><br><span class="line">                    .bind(<span class="number">8888</span>)<span class="comment">//监听端口</span></span><br><span class="line">                    .sync();<span class="comment">//等待future执行完毕</span></span><br><span class="line">            System.out.println(<span class="string">"server started!"</span>);</span><br><span class="line">            <span class="comment">//等着服务器关闭</span></span><br><span class="line">            f.channel().closeFuture().sync();<span class="comment">//阻塞，拿到server的channel，没有调用close，closeFuture会被一直阻塞</span></span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">//关闭</span></span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>很多情况下都使用到了sync的写法，因为Netty中方法为异步，为了知道执行结果必须加入sync，只有有返回值后才继续进行。</p>
<h4 id="客户端与服务端读写数据"><a href="#客户端与服务端读写数据" class="headerlink" title="客户端与服务端读写数据"></a>客户端与服务端读写数据</h4><p>客户端如果需要向服务端写数据，需要在其被初始化完成后，调用的initChannel方法中，在此channel的责任链上加上一个监听器，继承自<code>ChannelInboundHandlerAdapter</code>，就是Channel的Handler，其中Adapter表示实现了其骨架，只需要重写部分方法即可。当此channel被激活后，就可以写数据，Netty写数据通过Bytebuf，此为直接内存，为操作系统管理，读写更高效，将要写的消息转为字节再写入。其中需要释放Bytebuf的内存，当使用writeAndFlush后，自动释放 。为了读取服务端数据，重写channelRead方法。</p>
<p>其中ChannelHandlerContext是通道上下文信息，聚合了Channel。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span><<span class="title">SocketChannel</span>></span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> ClientHandler());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//channel第一次连上可用，写出一个字符串</span></span><br><span class="line">        <span class="comment">//写数据依靠ByteBuf，堆外内存Direct Memory</span></span><br><span class="line">        <span class="comment">//需要释放buf</span></span><br><span class="line">        ByteBuf buf = Unpooled.copiedBuffer(<span class="string">"hello"</span>.getBytes());</span><br><span class="line">        ctx.writeAndFlush(buf);<span class="comment">//自动释放</span></span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//数据存在msg中</span></span><br><span class="line">        ByteBuf buf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            buf = (ByteBuf)msg;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.readableBytes()];</span><br><span class="line">            buf.getBytes(buf.readerIndex(),bytes);<span class="comment">//读到字节数组中</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">//手动释放内存</span></span><br><span class="line">            <span class="keyword">if</span> (buf != <span class="keyword">null</span>) ReferenceCountUtil.release(buf);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在服务端中，也是类似，当channel初始化后，加上一个服务端channel的监听器</p>
<p>将对应客户端的流的责任链上加上一个监听器</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture f = b.group(bossGroup, workerGroup)<span class="comment">//指定线程池类型，一个连接，一个读写</span></span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)//指定<span class="title">channel</span>类型</span></span><br><span class="line"><span class="class">                    //加在客户端上，每个客户端通道初始化完成后调用</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span><<span class="title">SocketChannel</span>>() </span>{</span><br><span class="line">                        <span class="comment">//相当于客户端进来了</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                            <span class="comment">//负责客户端连接后的事宜</span></span><br><span class="line">                            <span class="comment">//责任链模式</span></span><br><span class="line">                            ChannelPipeline pl = ch.pipeline();<span class="comment">//在每个责任链上加入一个handler</span></span><br><span class="line">                            pl.addLast(<span class="keyword">new</span> ServerChildHandler());</span><br><span class="line">                        }</span><br><span class="line">                    })</span><br><span class="line">                    .bind(<span class="number">8888</span>)<span class="comment">//监听端口</span></span><br><span class="line">                    .sync();<span class="comment">//等待future执行完毕</span></span><br></pre></td></tr></tbody></table></figure>

<p>然后读的handler如下，使用的是channelRead，在有数据读入的时候被调用，将 msg转为Bytebuf，然后获取此Bytebuf中可读数据长度，构建字节数组，通过buf的得到字节方法，指定可读的初始位置与要存入的位置，将数据读取到数组中，转为String即可输出。因为此buf需要被手动释放，因此在finally中释放。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerChildHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span></span>{</span><br><span class="line">    <span class="comment">//接收数据</span></span><br><span class="line">    <span class="comment">//当此管道有数据读入，将数据保存到这里</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//数据存在msg中</span></span><br><span class="line">        ByteBuf buf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            buf = (ByteBuf)msg;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.readableBytes()];</span><br><span class="line">            buf.getBytes(buf.readerIndex(),bytes);<span class="comment">//读到字节数组中</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line"><span class="comment">//            System.out.println(buf);</span></span><br><span class="line"><span class="comment">//            System.out.println(buf.refCnt());</span></span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">//手动释放内存</span></span><br><span class="line">            <span class="keyword">if</span> (buf != <span class="keyword">null</span>) ReferenceCountUtil.release(buf);</span><br><span class="line"><span class="comment">//            System.out.println(buf.refCnt());</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但是当服务端读到数据后，立刻向客户端写数据，此时就不用自己关闭了，再次关闭会出错。通过ctx来写。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="comment">//数据存在msg中</span></span><br><span class="line">    ByteBuf buf = <span class="keyword">null</span>;</span><br><span class="line">    buf = (ByteBuf)msg;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.readableBytes()];</span><br><span class="line">    buf.getBytes(buf.readerIndex(),bytes);<span class="comment">//读到字节数组中</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line">    <span class="comment">//写回数据</span></span><br><span class="line">    ctx.writeAndFlush(buf);<span class="comment">//不能再自己释放</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>遇到了服务端写数据，服务端出错的异常，后来检查发现是因为客户端建立连接后，异步方法继续向下走，导致main方法结束，客户端关闭了，因此异步的方法一定要注意加sync来手动阻塞。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f.sync();</span><br><span class="line"><span class="comment">//客户端中也要加上sync，避免客户端自己关闭</span></span><br><span class="line">f.channel().closeFuture().sync();</span><br></pre></td></tr></tbody></table></figure>

<h4 id="服务器分发数据"><a href="#服务器分发数据" class="headerlink" title="服务器分发数据"></a>服务器分发数据</h4><p>服务端为了向客户端分发数据，需要有channelGroup，传入相应的处理线程。然后在客户端通道被激活时，将其加入到通道组中，在写数据的时候，写到通道组中。</p>
<p>服务端属性：通道组</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ChannelGroup clients = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br></pre></td></tr></tbody></table></figure>

<p>客户端通道激活时</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">      <span class="comment">//通道可用时，将其放入通道</span></span><br><span class="line">      Server.clients.add(ctx.channel());</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<p>在写数据的时候</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写到每一个通道组中</span></span><br><span class="line">   Server.clients.writeAndFlush(buf);<span class="comment">//不能再自己释放</span></span><br></pre></td></tr></tbody></table></figure>

<p>这样就将一个客户端写入的数据分发到了所有的客户端。这种方法核心为通道组。</p>
<h4 id="客户端与服务端图形化界面"><a href="#客户端与服务端图形化界面" class="headerlink" title="客户端与服务端图形化界面"></a>客户端与服务端图形化界面</h4><p>客户端：</p>
<p>新建客户端窗口类，可以输入字符串，显示在窗口上。</p>
<p>新建客户端类，将之前写在main中的连接服务器的方法封装在connect方法中，在其main方法中，新建一个客户端对象，调用其connect方法就可以与服务端建立连接。客户端窗口类持有一个客户端对象，在图形化界面初始化后，新建一个客户端对象，调用其connect方法即可连接服务器。</p>
<blockquote>
<p>设计思路：将客户端与图形化界面解耦合，单一职责原则。</p>
</blockquote>
<p>为了之后方便去给服务端写数据，客户端对象持有一个Channel对象，在成功连接服务器后，初始化channel</p>
<p>channel为客户端与服务端之间的通道，pipeline为此通道上的责任链</p>
<p>客户端类提供send(String msg)方法，当调用时，使用持有的channel写信息。</p>
<p>在客户端界面类，当界面初始化后，调用自身的连接至服务器方法，新建一个客户端类，并调用其connect方法，然后在文本框中增加监听器，当按下回车时，读取到文本框中的信息，并调用客户端的send方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientFrame</span> <span class="keyword">extends</span> <span class="title">Frame</span> </span>{</span><br><span class="line">    TextArea ta = <span class="keyword">new</span> TextArea();<span class="comment">//多行</span></span><br><span class="line">    TextField tf = <span class="keyword">new</span> TextField();<span class="comment">//单行</span></span><br><span class="line">    Client c = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientFrame</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.setSize(<span class="number">600</span>,<span class="number">400</span>);</span><br><span class="line">        <span class="keyword">this</span>.setLocation(<span class="number">100</span>,<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">this</span>.add(ta,BorderLayout.CENTER);</span><br><span class="line">        <span class="keyword">this</span>.add(tf,BorderLayout.SOUTH);</span><br><span class="line">        tf.addActionListener(<span class="keyword">new</span> ActionListener() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>{</span><br><span class="line">                <span class="comment">//把字符串发送到服务器</span></span><br><span class="line">                ta.setText(ta.getText()+tf.getText());</span><br><span class="line">                c.send(tf.getText());</span><br><span class="line">                <span class="comment">//写发送消息的逻辑</span></span><br><span class="line">                tf.setText(<span class="string">""</span>);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">        connectToServer();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectToServer</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//初始化client,调用connect</span></span><br><span class="line">        c = <span class="keyword">new</span> Client();</span><br><span class="line">        c.connect();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ClientFrame cf = <span class="keyword">new</span> ClientFrame();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>对于客户端类</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span></span>{</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            ChannelFuture f = b.group(group)</span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span><<span class="title">SocketChannel</span>>() </span>{</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> ClientHandler());</span><br><span class="line">                        }</span><br><span class="line">                    })</span><br><span class="line">                    .connect(<span class="string">"localhost"</span>, <span class="number">8888</span>)</span><br><span class="line">                    .addListener(<span class="keyword">new</span> ChannelFutureListener() {</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                            <span class="keyword">if</span> (future.isSuccess()){</span><br><span class="line">                                System.out.println(<span class="string">"connected"</span>);</span><br><span class="line">                                channel = future.channel();<span class="comment">//初始化</span></span><br><span class="line">                            }<span class="keyword">else</span> {</span><br><span class="line">                                System.out.println(<span class="string">"not connected"</span>);</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    })</span><br><span class="line">                    .sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String msg)</span></span>{</span><br><span class="line">        <span class="comment">//调用时，将msg通过channel写出去</span></span><br><span class="line">        ByteBuf buf = Unpooled.copiedBuffer(msg.getBytes());</span><br><span class="line">        channel.writeAndFlush(buf);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//数据存在msg中</span></span><br><span class="line">        ByteBuf buf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            buf = (ByteBuf)msg;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.readableBytes()];</span><br><span class="line">            buf.getBytes(buf.readerIndex(),bytes);<span class="comment">//读到字节数组中</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes));</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">//手动释放内存</span></span><br><span class="line">            <span class="keyword">if</span> (buf != <span class="keyword">null</span>) ReferenceCountUtil.release(buf);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>核心为：调用客户端类，建立与服务端的连接，为了在另一个类中实现写消息，让客户端传给服务端，那么客户端中需要提供此方法，而写消息要通过channel，因此客户端需要有个channel的属性，在第一次初始化后初始channel，在发送消息的方法中，直接在channel中写入信息即可，重点为持有channel。</p>
<p>现在需要将服务端发送来的信息显示在客户端界面类中，那么接收消息是在客户端类中，那么客户端必须要跟客户端界面类耦合才能将信息显示在客户端界面类中，一种做法是客户端类中持有客户端界面类的引用，另一种做法是将客户端界面类做成单例。对于更新方法，拿到一个字符串后，加入换行符显示在界面上。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端界面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ClientFrame INSTANCE = <span class="keyword">new</span> ClientFrame();</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateText</span><span class="params">(String msgAccepted)</span></span>{</span><br><span class="line">       ta.setText(ta.getText()+System.getProperty(<span class="string">"line.separator"</span>)+msgAccepted);</span><br><span class="line">   }</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">       ClientFrame cf = ClientFrame.INSTANCE;</span><br><span class="line">       cf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">       cf.connectToServer();</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<p>在客户端，因为客户端对象是单例的，直接通过类名就可以获取，不需要传入对象</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">       <span class="comment">//数据存在msg中</span></span><br><span class="line">       ByteBuf buf = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> {</span><br><span class="line">           buf = (ByteBuf)msg;</span><br><span class="line">           <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.readableBytes()];</span><br><span class="line">           buf.getBytes(buf.readerIndex(),bytes);<span class="comment">//读到字节数组中</span></span><br><span class="line">           <span class="comment">//写在clientFrame中</span></span><br><span class="line">           String msgAccepted = <span class="keyword">new</span> String(bytes);</span><br><span class="line">           ClientFrame.INSTANCE.updateText(msgAccepted);</span><br><span class="line">       }<span class="keyword">finally</span> {</span><br><span class="line">           <span class="comment">//手动释放内存</span></span><br><span class="line">           <span class="keyword">if</span> (buf != <span class="keyword">null</span>) ReferenceCountUtil.release(buf);</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<p>因为服务端是将所有客户端的channel都写入了信息，有信息的分发，客户端接收到信息后显示在窗口上，而多个客户端界面是运行在各自的JVM上，因此单个JVM上的客户端界面是单例，但不同的JVM上客户端界面是不同的，这样可以实现不同客户端之间的聊天。</p>
<p>但当关闭一个客户端后，服务端会报错，因为没有将此客户端从服务端的ChannelGroup中删除</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">       cause.printStackTrace();</span><br><span class="line">       <span class="comment">//从clients删除</span></span><br><span class="line">       Server.clients.remove(ctx.channel());</span><br><span class="line">       ctx.close();<span class="comment">//关闭此流</span></span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<p>接下来客户端需要优雅的关闭，给客户端界面类添加窗口监听器，当关闭窗口时，调用客户端的关闭方法，再推出页面。客户端向服务端发送一个<code>_bye_</code>字符串，服务端接收消息进行判断，如果客户端发送的是bye，将此channel从组中移除，关闭此channel，如果不是，分发给channel组。</p>
<p>客户端界面</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addWindowListener(<span class="keyword">new</span> WindowAdapter() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>{</span><br><span class="line">        c.closeConnect();</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>客户端类</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeConnect</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">this</span>.send(<span class="string">"_bye_"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>服务端类</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//数据存在msg中</span></span><br><span class="line">        ByteBuf buf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            buf = (ByteBuf)msg;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.readableBytes()];</span><br><span class="line">            buf.getBytes(buf.readerIndex(),bytes);<span class="comment">//读到字节数组中</span></span><br><span class="line">            String s = <span class="keyword">new</span> String(bytes);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"_bye_"</span>.equals(s)){</span><br><span class="line">                System.out.println(<span class="string">"客户端要退出"</span>);</span><br><span class="line">                Server.clients.remove(ctx.channel());</span><br><span class="line">                ctx.close();</span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">//写到每一个通道组中</span></span><br><span class="line">                Server.clients.writeAndFlush(buf);<span class="comment">//不能再自己释放</span></span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">//手动释放内存</span></span><br><span class="line"><span class="comment">//            if (buf != null) ReferenceCountUtil.release(buf);</span></span><br><span class="line"><span class="comment">//            System.out.println(buf.refCnt());</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>增加服务端的窗口，同样将服务器类的信息封装到serverConnect方法，同时当有信息的时候直接写入到服务器窗口类即可。其中要注意的是，因为服务器类会阻塞，因此为了避免UI线程被阻塞，起服务器的线程最好放在main线程中。同样为了方便服务器类与服务器窗口类通信，将服务器窗口类做成单例。</p>
<p>这时候完成了客户端与服务端字符串的通信。</p>
<h4 id="Netty-Codec"><a href="#Netty-Codec" class="headerlink" title="Netty Codec"></a>Netty Codec</h4><p>1、定义TankMsg x,y</p>
<p>2、TankMsgEncoder负责编码，继承自MessageToByteEncoder<code><tankmsg></tankmsg></code></p>
<ul>
<li>负责将TankMsg转为字节</li>
</ul>
<p>3、TankMsgDecoder负责解码</p>
<ul>
<li>将字节转为坦克消息类</li>
</ul>
<p>4、在客户端加上编码的Handler</p>
<ul>
<li>写消息的时候，直接写TankMsg即可</li>
</ul>
<p>5、在服务端加上解码的Handler</p>
<ul>
<li>读消息的时候，读出来的就是TankMsg</li>
</ul>
<p>定义自己要处理的消息类</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankMsg</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TankMsg</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"TankMsg{"</span> +</span><br><span class="line">                <span class="string">"x="</span> + x +</span><br><span class="line">                <span class="string">", y="</span> + y +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后定义此类的加码类，将其转为字节，继承MessageToByteEncoder，指定要加码的类型</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将TankMsg转换为字节</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankMsgEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span><<span class="title">TankMsg</span>> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, TankMsg msg, ByteBuf buf)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        buf.writeInt(msg.x);</span><br><span class="line">        buf.writeInt(msg.y);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>此加码类也是一个Handler，在客户端将其加入到pipeLine责任链上，先加解码，再加InBound</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span><<span class="title">SocketChannel</span>></span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ch.pipeline()</span><br><span class="line">                .addLast(<span class="keyword">new</span> TankMsgEncoder())</span><br><span class="line">                .addLast(<span class="keyword">new</span> ClientHandler());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后在初始化的Handler中，写消息的时候直接写TankMsg即可，因为责任链上加了加码的责任链，因此在Channel中传输的时候自己被转为字节</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    ctx.writeAndFlush(<span class="keyword">new</span> TankMsg(<span class="number">5</span>,<span class="number">8</span>));<span class="comment">//自动由handler转为二进制</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>为了解码，需要定义解码类，将字节转为自定义的消息，为了解决TCP的拆包与黏包的问题，即将一个消息分成多个包，在字节数不够的时候直接返回，按照编码的顺序进行解码，并加入到out这个集合中。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankMsgDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List<object> out) <span class="keyword">throws</span> Exception {<br><span class="line">        <span class="comment">//没有读取完，返回，TCP拆包与黏包问题</span></span><br><span class="line">        <span class="comment">//字节数不够，就等着</span></span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes()<<span class="number">8</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//in.markReaderIndex();</span></span><br><span class="line">        <span class="keyword">int</span> x = in.readInt();</span><br><span class="line">        <span class="keyword">int</span> y = in.readInt();</span><br><span class="line">        <span class="comment">//将解析出来的消息放在List中</span></span><br><span class="line">        out.add(<span class="keyword">new</span> TankMsg(x,y));</span><br><span class="line">    }</span><br><span class="line">}</span><br></object></span></span></span></pre></td></tr></tbody></table></figure>

<p>为了在服务端读取此消息，需要将此Handle加入到服务端的pipeLine上，先加解码的责任，这样在读取的时候，直接读取到的就是对应的TankMsg类</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span><<span class="title">SocketChannel</span>></span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//在每个责任链上加入一个handler</span></span><br><span class="line">        ch.pipeline()</span><br><span class="line">                .addLast(<span class="keyword">new</span> TankMsgDecoder())</span><br><span class="line">                .addLast(<span class="keyword">new</span> ServerChildHandler());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在读取的时候，直接将msg转为TankMsg读取</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">       <span class="comment">//数据存在msg中</span></span><br><span class="line">       System.out.println(<span class="string">"channelRead "</span>);</span><br><span class="line">       <span class="keyword">try</span> {</span><br><span class="line">           TankMsg tm = (TankMsg)msg;</span><br><span class="line">           System.out.println(tm);</span><br><span class="line">       }<span class="keyword">finally</span> {</span><br><span class="line">           <span class="comment">//手动释放内存</span></span><br><span class="line">           ReferenceCountUtil.release(msg);</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Codec单元测试"><a href="#Codec单元测试" class="headerlink" title="Codec单元测试"></a>Codec单元测试</h4><p>采用Junit单元测试的好处是，不用一个个去比对结果，避免人眼观察出错。复用测试，不用重新写测试。</p>
<p>在写自己定义的二进制加码解码时，先用Junit测试通过后，再组装。</p>
<p>EmbeddedChannel只用于单元测试上。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankMsgEncoderTest</span> </span>{</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTankMsgEncoder</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//往外写的测试</span></span><br><span class="line">        TankMsg msg = <span class="keyword">new</span> TankMsg(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//使用Embedded嵌入的Channel，不是连接到网上</span></span><br><span class="line">        <span class="comment">//加入自己的Encoder</span></span><br><span class="line">        EmbeddedChannel ch = <span class="keyword">new</span> EmbeddedChannel(<span class="keyword">new</span> TankMsgEncoder());</span><br><span class="line">        <span class="comment">//往外写消息</span></span><br><span class="line">        ch.writeOutbound(msg);</span><br><span class="line">        <span class="comment">//将输出的消息读出来</span></span><br><span class="line">        ByteBuf buf = (ByteBuf) ch.readOutbound();</span><br><span class="line">        <span class="keyword">int</span> x = buf.readInt();</span><br><span class="line">        <span class="keyword">int</span> y = buf.readInt();</span><br><span class="line">        Assert.assertTrue(x == <span class="number">10</span> && y == <span class="number">10</span>);</span><br><span class="line">        buf.release();</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTankMsgEncoder2</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//往里写的测试，先经过Decoder，再经过Encoder</span></span><br><span class="line">        ByteBuf buf = Unpooled.buffer();</span><br><span class="line">        TankMsg msg = <span class="keyword">new</span> TankMsg(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">        buf.writeInt(msg.x);</span><br><span class="line">        buf.writeInt(msg.y);</span><br><span class="line">        <span class="comment">//加两个</span></span><br><span class="line">        <span class="comment">//写的是ByteBuf，先经过Decoder被转为msg，不符合Encoder的要求</span></span><br><span class="line">        EmbeddedChannel ch = <span class="keyword">new</span> EmbeddedChannel(<span class="keyword">new</span> TankMsgEncoder(),<span class="keyword">new</span> TankMsgDecoder());</span><br><span class="line">        ch.writeInbound(buf.duplicate());</span><br><span class="line">        TankMsg tm = (TankMsg)ch.readInbound();</span><br><span class="line">        Assert.assertTrue(tm.x == <span class="number">10</span> && tm.y == <span class="number">10</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="同步异步阻塞非阻塞"><a href="#同步异步阻塞非阻塞" class="headerlink" title="同步异步阻塞非阻塞"></a>同步异步阻塞非阻塞</h3><p>同步异步关注的是<strong>消息通信机制</strong></p>
<ul>
<li>同步：烧水时，自己开开关，自己关。消息回来仍需要自己处理</li>
<li>异步：烧水时，自己打开，水开了后调用写好的代码去关。消息回来后其他人去处理。</li>
</ul>
<p>阻塞非阻塞关注的是<strong>等待消息时的状态</strong></p>
<ul>
<li>阻塞：等烧水时，不做别的，盯着水</li>
<li>非阻塞：等烧水时，干点其他事</li>
</ul>
<p>同步阻塞：自己开火后，等水开，水不开不做别的，自己关火。</p>
<p>同步非阻塞：自己开火，等水时去看电视，做点别的，自己关火。</p>
<p>异步阻塞：自己开火，自己盯着水看，水开后铃铛响，让其他工具关火。很少发生。</p>
<p>异步非阻塞：自己开火，做好火开的处理，自己去做别的事，让其他工具关火。</p>
<p>程序相当于人，操作系统相当于水。对accept于读写的处理要分开说明。</p>
<h3 id="select，poll与epoll"><a href="#select，poll与epoll" class="headerlink" title="select，poll与epoll"></a>select，poll与epoll</h3><p>三者均为IO多路复用，需要IO多路复用是因为，之前使用的是需要对所有的客户端fd进行顺序的读取操作，这样n个客户端涉及n次系统调用（用户态与内核态的切换），这样解决办法是，能否多个客户端，只一次系统调用，即一次性将所有的fd交给kernel处理，然后自己程序中对kernel返回的结果集进行处理。这样有了select，poll与epoll。</p>
<p>每个网络连接以文件描述符Fd的方式存在于内核中。</p>
<p>在单线程处理网络连接时，可以用如下这种简单的方式进行处理</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">	<span class="keyword">for</span>(fd1 ~ fdn){</span><br><span class="line">		<span class="keyword">if</span>(fd有数据)</span><br><span class="line">			读fd，处理</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>而select，判断fd中有数据，从用户态拷贝rset(一个bitmap，存了fds信息)至内核态来判断，如果没有数据，select会阻塞，当有数据的时候，内核将rset对应的fd置位（表示有数据），select返回，程序继续运行，遍历全部fd（可能多个fd中有数据），判断哪个fd中有数据，将对应数据读取并处理。</p>
<p>select缺点</p>
<ul>
<li>bitmap默认大小为1024，大小有限</li>
<li>内核修改rset，FD_SET不可重用，需要重新创建bitmap</li>
<li>从用户态拷贝至内核态存在一定开销</li>
<li>select后判断哪个fd中有数据，需要有O(n)的复杂度</li>
</ul>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/poll.png" class title="This is an example image">

<p>poll原理与select相似，poll的改进围绕传入的结构体，poll没有用bitmap，而是pollfd，其中fd为传入的fd，events在意的事件（读还是写），revents是对events的回馈。poll函数仍为阻塞，内核置位的时候，置的是revents字段，不像select修改bitmap会导致bitmap不可重用，poll返回。判断如果revents被置位，需要读取，将revents重置。</p>
<p>poll解决了select大小默认1024的问题，传入的结构体可以重用。但poll仍然存在select中剩下两个缺点</p>
<ul>
<li>从用户态拷贝至内核态存在一定开销</li>
<li>poll后判断哪个fd中有数据，需要有O(n)的复杂度</li>
</ul>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><img src="/2020/03/03/JavaSE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/epoll.png" class title="This is an example image">

<p>epoll的epoll_event中有fd跟event两个字段，epfd暂且理解为容器，其中有5个epoll_event，既有fd，又有event。epfd是直接内存，省去了拷贝的过程，内核判断是否有数据到来，在没有数据的时候，也会阻塞，在有数据的时候，select与poll是置位+函数返回，在epoll中通过重排来置位，将有数据的fd放到最前面，然后返回fd触发事件的个数，这样只需要遍历触发时间个数的数据就可以处理完毕，时间复杂度从O(n)变为O(1)。</p>
<p>因此epoll解决了从用户态拷贝数据到内核态的过程，且轮询时间复杂度从O(n)减少至O(1)。</p>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":1},"log":false});</script>
    </div>

    
    
    
        <div class="reward-container">
  <div>怕什么真理无穷，进一寸有一寸的欢喜</div>
  <button disable="enable" onclick="var qr = document.getElementById("qr"); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechat.jpg" alt="未名Hugh 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JavaSE/" rel="tag"># JavaSE</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/" rel="prev" title="并发与锁总结">
      <i class="fa fa-chevron-left"></i> 并发与锁总结
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/06/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/" rel="next" title="哈夫曼树">
      哈夫曼树 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java基础"><span class="nav-number">1.</span> <span class="nav-text">Java基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java基本语法、特性"><span class="nav-number">1.1.</span> <span class="nav-text">Java基本语法、特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型"><span class="nav-number">1.1.1.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java有哪些数据类型"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">Java有哪些数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#float与double"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">float与double</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Math-round-11-5-等于多少？Math-round-11-5-等于多少"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运算符"><span class="nav-number">1.1.2.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最有效率的方式计算2乘以8"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">最有效率的方式计算2乘以8</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算-6"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">计算~6</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#amp-和-amp-amp-的区别"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">&和&&的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流程控制语句"><span class="nav-number">1.1.3.</span> <span class="nav-text">流程控制语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#switch的作用类型"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">switch的作用类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#break-continue-return-的区别及作用"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">break ,continue ,return 的区别及作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在-Java-中，如何跳出当前的多重嵌套循环"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">在 Java 中，如何跳出当前的多重嵌套循环</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修饰符"><span class="nav-number">1.1.4.</span> <span class="nav-text">修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#四种访问修饰符及区别"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">四种访问修饰符及区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关键字"><span class="nav-number">1.2.</span> <span class="nav-text">关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#static"><span class="nav-number">1.2.1.</span> <span class="nav-text">static</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#static作用"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">static作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static特点"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">static特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static应用场景"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">static应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static注意事项"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">static注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法调用顺序"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">方法调用顺序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final"><span class="nav-number">1.2.2.</span> <span class="nav-text">final</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#final作用"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">final作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#final-finally-finalize区别"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">final finally finalize区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this与super"><span class="nav-number">1.2.3.</span> <span class="nav-text">this与super</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#this关键字使用"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">this关键字使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#super关键字使用"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">super关键字使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#this与super-1"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">this与super</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象"><span class="nav-number">1.3.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象思想"><span class="nav-number">1.3.1.</span> <span class="nav-text">面向对象思想</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#面向对象和面向过程的区别"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">面向对象和面向过程的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#面向对象特征"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">面向对象特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#面向对象的基本原则"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">面向对象的基本原则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承"><span class="nav-number">1.3.2.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#继承的好处"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">继承的好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#继承的注意事项"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">继承的注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多态"><span class="nav-number">1.3.3.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多态的特点与实现方式"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">多态的特点与实现方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象类与接口"><span class="nav-number">1.3.4.</span> <span class="nav-text">抽象类与接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象类和接口的对比"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">抽象类和接口的对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#普通类与抽象类区别"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">普通类与抽象类区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象类能用final修饰吗"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">抽象类能用final修饰吗</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象"><span class="nav-number">1.3.5.</span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建一个对象用什么关键字？对象实例与对象引用有何不同？"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">创建一个对象用什么关键字？对象实例与对象引用有何不同？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量"><span class="nav-number">1.3.6.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#成员变量与局部变量区别"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">成员变量与局部变量区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态变量和实例变量区别"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">静态变量和实例变量区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法"><span class="nav-number">1.3.7.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#main方法"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">main方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在main方法执行前输出"><span class="nav-number">1.3.7.2.</span> <span class="nav-text">在main方法执行前输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数的重载与覆盖"><span class="nav-number">1.3.7.3.</span> <span class="nav-text">函数的重载与覆盖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态方法和实例方法有何不同？"><span class="nav-number">1.3.7.4.</span> <span class="nav-text">静态方法和实例方法有何不同？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#和-equals-的区别是什么"><span class="nav-number">1.3.7.5.</span> <span class="nav-text">== 和 equals 的区别是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashCode-与-equals"><span class="nav-number">1.3.7.6.</span> <span class="nav-text">hashCode 与 equals</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造方法"><span class="nav-number">1.3.8.</span> <span class="nav-text">构造方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#在Java中定义一个不做事且没有参数的构造方法的作用"><span class="nav-number">1.3.8.1.</span> <span class="nav-text">在Java中定义一个不做事且没有参数的构造方法的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"><span class="nav-number">1.3.8.2.</span> <span class="nav-text">在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？"><span class="nav-number">1.3.8.3.</span> <span class="nav-text">一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法有哪些特性？"><span class="nav-number">1.3.8.4.</span> <span class="nav-text">构造方法有哪些特性？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部类"><span class="nav-number">1.3.9.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内部类定义"><span class="nav-number">1.3.9.1.</span> <span class="nav-text">内部类定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部类种类"><span class="nav-number">1.3.9.2.</span> <span class="nav-text">内部类种类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#匿名内部类"><span class="nav-number">1.3.9.3.</span> <span class="nav-text">匿名内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部类优点"><span class="nav-number">1.3.9.4.</span> <span class="nav-text">内部类优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"><span class="nav-number">1.3.9.5.</span> <span class="nav-text">局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#值传递"><span class="nav-number">1.3.10.</span> <span class="nav-text">值传递</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><span class="nav-number">1.3.10.1.</span> <span class="nav-text">当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String"><span class="nav-number">1.3.11.</span> <span class="nav-text">String</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#String的equals、-与intern"><span class="nav-number">1.3.11.1.</span> <span class="nav-text">String的equals、==与intern</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String不变性的理解"><span class="nav-number">1.3.11.2.</span> <span class="nav-text">String不变性的理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String重写equals而不重写hashCode的问题"><span class="nav-number">1.3.11.3.</span> <span class="nav-text">String重写equals而不重写hashCode的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String、StringBuffer、StringBuilder区别"><span class="nav-number">1.3.11.4.</span> <span class="nav-text">String、StringBuffer、StringBuilder区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object"><span class="nav-number">1.3.12.</span> <span class="nav-text">Object</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#其他类如何默认继承Object"><span class="nav-number">1.3.12.1.</span> <span class="nav-text">其他类如何默认继承Object</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合"><span class="nav-number">1.4.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#List与Set"><span class="nav-number">1.4.1.</span> <span class="nav-text">List与Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList-和-LinkedList-的区别"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">ArrayList 和 LinkedList 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList-和Vector-的区别"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">ArrayList 和Vector 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#List遍历时删除问题"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">List遍历时删除问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet实现原理"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">HashSet实现原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap"><span class="nav-number">1.4.2.</span> <span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#put方法"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">put方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#get方法"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">get方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#扩容resize-方法"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">扩容resize()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#负载因子"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">负载因子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cpu占用100-的问题"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">cpu占用100%的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何减少碰撞"><span class="nav-number">1.4.2.6.</span> <span class="nav-text">如何减少碰撞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dos攻击"><span class="nav-number">1.4.2.7.</span> <span class="nav-text">Dos攻击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多线程下的HashMap"><span class="nav-number">1.4.2.8.</span> <span class="nav-text">多线程下的HashMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#红黑树"><span class="nav-number">1.4.2.9.</span> <span class="nav-text">红黑树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap与HashTable"><span class="nav-number">1.4.2.10.</span> <span class="nav-text">HashMap与HashTable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap与ConcurrentHashMap"><span class="nav-number">1.4.2.11.</span> <span class="nav-text">HashMap与ConcurrentHashMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三者的比较"><span class="nav-number">1.4.2.12.</span> <span class="nav-text">三者的比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他数据结构"><span class="nav-number">1.4.3.</span> <span class="nav-text">其他数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#跳表"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">跳表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阻塞队列"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">阻塞队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络"><span class="nav-number">1.5.</span> <span class="nav-text">网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO"><span class="nav-number">1.5.1.</span> <span class="nav-text">BIO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO"><span class="nav-number">1.5.2.</span> <span class="nav-text">NIO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AIO"><span class="nav-number">1.5.3.</span> <span class="nav-text">AIO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Netty"><span class="nav-number">1.5.4.</span> <span class="nav-text">Netty</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#客户端连接"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">客户端连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#服务端连接"><span class="nav-number">1.5.4.2.</span> <span class="nav-text">服务端连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#客户端与服务端读写数据"><span class="nav-number">1.5.4.3.</span> <span class="nav-text">客户端与服务端读写数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#服务器分发数据"><span class="nav-number">1.5.4.4.</span> <span class="nav-text">服务器分发数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#客户端与服务端图形化界面"><span class="nav-number">1.5.4.5.</span> <span class="nav-text">客户端与服务端图形化界面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Netty-Codec"><span class="nav-number">1.5.4.6.</span> <span class="nav-text">Netty Codec</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Codec单元测试"><span class="nav-number">1.5.4.7.</span> <span class="nav-text">Codec单元测试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步异步阻塞非阻塞"><span class="nav-number">1.5.5.</span> <span class="nav-text">同步异步阻塞非阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select，poll与epoll"><span class="nav-number">1.5.6.</span> <span class="nav-text">select，poll与epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#select"><span class="nav-number">1.5.6.1.</span> <span class="nav-text">select</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#poll"><span class="nav-number">1.5.6.2.</span> <span class="nav-text">poll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll"><span class="nav-number">1.5.6.3.</span> <span class="nav-text">epoll</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="未名Hugh" src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">未名Hugh</p>
  <div class="site-description" itemprop="description">技术博客，Java，并发编程，算法</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  © 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">未名Hugh</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">479k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:15</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.6.0
  </div>
-->
<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共123.8k字</span>
</div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":1},"log":false});</script>



<script type="text/javascript" src="/js/clicklove.js"></script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html><!-- 页面点击小红心 -->