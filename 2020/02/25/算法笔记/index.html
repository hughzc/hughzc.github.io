<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://hughzc.github.io').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="OJ处理技巧类名为public class Main 较好的做法是将要用到的类都封装好，不要放在Main类中，主类只需要持有要用到的类的对象，然后调用即可。 StringBuilder类的append方法，res.append(str1).append(str2)比res.append(str1+str2)效率高。">
<meta property="og:type" content="article">
<meta property="og:title" content="算法笔记">
<meta property="og:url" content="https://hughzc.github.io/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="未名的奇妙旅程">
<meta property="og:description" content="OJ处理技巧类名为public class Main 较好的做法是将要用到的类都封装好，不要放在Main类中，主类只需要持有要用到的类的对象，然后调用即可。 StringBuilder类的append方法，res.append(str1).append(str2)比res.append(str1+str2)效率高。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hughzc.github.io/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%BD%AC%E5%9C%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.png">
<meta property="og:image" content="https://hughzc.github.io/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%BD%AC%E5%9C%88%E7%9F%A9%E9%98%B5%E7%BA%A6%E6%9D%9F.png">
<meta property="og:image" content="https://hughzc.github.io/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%B9%8B%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.png">
<meta property="og:image" content="https://hughzc.github.io/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%9F%A9%E9%98%B5%E6%89%BE%E6%95%B0.png">
<meta property="og:image" content="https://hughzc.github.io/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%93%BE%E8%A1%A8%E5%85%A5%E7%8E%AF.png">
<meta property="og:image" content="https://hughzc.github.io/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://hughzc.github.io/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8A%98%E7%BA%B8.png">
<meta property="og:image" content="https://hughzc.github.io/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8A%98%E7%BA%B8%E6%A0%91.png">
<meta property="article:published_time" content="2020-02-25T01:51:49.000Z">
<meta property="article:modified_time" content="2020-03-24T10:09:18.493Z">
<meta property="article:author" content="未名Hugh">
<meta property="article:tag" content="左神算法">
<meta property="article:tag" content="剑指offer">
<meta property="article:tag" content="leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hughzc.github.io/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%BD%AC%E5%9C%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.png">

<link rel="canonical" href="https://hughzc.github.io/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>算法笔记 | 未名的奇妙旅程</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">未名的奇妙旅程</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">怕什么真理无穷，进一寸有一寸的欢喜</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hughzc.github.io/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="未名Hugh">
      <meta itemprop="description" content="技术博客，Java，并发编程，算法">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="未名的奇妙旅程">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          算法笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-25 09:51:49" itemprop="dateCreated datePublished" datetime="2020-02-25T09:51:49+08:00">2020-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-24 18:09:18" itemprop="dateModified" datetime="2020-03-24T18:09:18+08:00">2020-03-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="OJ处理技巧"><a href="#OJ处理技巧" class="headerlink" title="OJ处理技巧"></a>OJ处理技巧</h1><p>类名为public class Main</p>
<p>较好的做法是将要用到的类都封装好，不要放在Main类中，主类只需要持有要用到的类的对象，然后调用即可。</p>
<p>StringBuilder类的append方法，res.append(str1).append(str2)比res.append(str1+str2)效率高。</p>
<a id="more"></a>

<h2 id="获取不知次数的输入"><a href="#获取不知次数的输入" class="headerlink" title="获取不知次数的输入"></a>获取不知次数的输入</h2><p>使用BufferedReader来获取，需要Import，主函数需要抛出异常</p>
<p>valueOf返回值类型为Integer，parseInt返回值类型为int</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((s = br.readLine())!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//获取第一行输入，输入为一个数</span></span><br><span class="line">            <span class="keyword">int</span> len = Integer.valueOf(s);</span><br><span class="line">            <span class="comment">//获取第二行输入，输入为数组</span></span><br><span class="line">            String[] arrStr = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">int</span> [] arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                arr[i] = Integer.valueOf(arrStr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(要求的函数);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取有限次数的输入"><a href="#获取有限次数的输入" class="headerlink" title="获取有限次数的输入"></a>获取有限次数的输入</h2><p>输出的结果先用StringBuilder类存起来，如果有多行，每一行最后要加上换行标识。最后要输出的时候，将stringbuilder转变为String类输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="comment">//要持有的写的类</span></span><br><span class="line">        DogCatQueue dq = <span class="keyword">new</span> DogCatQueue();</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s = br.readLine();</span><br><span class="line">        <span class="keyword">int</span> count = Integer.valueOf(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            String[] strArr = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//if或者switch判断</span></span><br><span class="line">            <span class="keyword">switch</span> (strArr[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"add"</span>:</span><br><span class="line">                    String type=strArr[<span class="number">1</span>];</span><br><span class="line">                    dq.add(<span class="keyword">new</span> Pet(type,Integer.valueOf(strArr[<span class="number">2</span>])));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"pollAll"</span>:</span><br><span class="line">                    <span class="keyword">while</span>(!dq.isEmpty())&#123;</span><br><span class="line">                        pet = dq.pollAll();</span><br><span class="line">                        res.append(pet.getPetType()+<span class="string">" "</span>+pet.getPetIndex()+<span class="string">"\n"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"isDogEmpty"</span> :</span><br><span class="line">                    res.append(dq.isDogEmpty()?<span class="string">"yes\n"</span>:<span class="string">"no\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res.substring(<span class="number">0</span>,res.length()-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取输入矩阵"><a href="#获取输入矩阵" class="headerlink" title="获取输入矩阵"></a>获取输入矩阵</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="comment">//要持有的写的类</span></span><br><span class="line">        <span class="comment">//PringtEdge pe = new PringtEdge();</span></span><br><span class="line">        String[] s = <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="comment">//获取第一行的矩阵行与列</span></span><br><span class="line">        <span class="keyword">int</span> row = Integer.valueOf(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> col = Integer.valueOf(s[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        <span class="comment">//获取后面几行的矩阵数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            s = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                arr[i][j] = Integer.valueOf(s[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过自己编写方法获取结果</span></span><br><span class="line">        <span class="comment">//res = pe.printCircle(arr);</span></span><br><span class="line">        System.out.println(res.substring(<span class="number">0</span>,res.length()-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取数组"><a href="#获取数组" class="headerlink" title="获取数组"></a>获取数组</h2><p>输入只有一行，为数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">	<span class="comment">//交换数组中的数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//打印数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArr</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            System.out.print(arr[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        String[] strArray = str.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span>[] intArray = <span class="keyword">new</span> <span class="keyword">int</span>[strArray.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;strArray.length;i++) &#123;</span><br><span class="line">            intArray[i] = Integer.parseInt(strArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//要解决的</span></span><br><span class="line">        Solution(intArray);</span><br><span class="line">    	<span class="comment">//输出数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;intArray.length;i++) &#123;</span><br><span class="line">            System.out.print(intArray[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//or</span></span><br><span class="line">    	printArr(printArr);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输入有两行，第一行为数组长度，第二行为数组</p>
<p>获取long类型的数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">int</span> len = Integer.parseInt(br.readLine());</span><br><span class="line">        <span class="keyword">long</span>[] arr = <span class="keyword">new</span> <span class="keyword">long</span>[len];</span><br><span class="line">        String[] strArray = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">            arr[i] = Long.parseLong(strArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        LessMoney lm = <span class="keyword">new</span> LessMoney();</span><br><span class="line">        System.out.println(lm.getLessMoney(arr));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="获取链表"><a href="#获取链表" class="headerlink" title="获取链表"></a>获取链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node next;</span><br><span class="line">    Node pre;</span><br><span class="line">    Node(<span class="keyword">int</span> value)&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建单向链表</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">createNode</span><span class="params">(String[] str,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        Node head = <span class="keyword">new</span> Node(Integer.parseInt(str[<span class="number">0</span>]));</span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(Integer.parseInt(str[i]));</span><br><span class="line">            node.next = newNode;</span><br><span class="line">            node = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建双向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">createNodeDL</span><span class="params">(String[] str,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        Node head = <span class="keyword">new</span> Node(Integer.parseInt(str[<span class="number">0</span>]));</span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(Integer.parseInt(str[i]));</span><br><span class="line">            node.next = newNode;</span><br><span class="line">            node.next.pre = node;</span><br><span class="line">            node = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//打印列表</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            builder.append(node.value).append(<span class="string">" "</span>);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(builder.toString());</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//主函数部分</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="comment">//创建第一个链表</span></span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(input.readLine());</span><br><span class="line">        String[] strings1 = input.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        Node list1 = createNode(strings1,n);</span><br><span class="line">        <span class="comment">//创建第二个链表</span></span><br><span class="line">        <span class="keyword">int</span> m = Integer.parseInt(input.readLine());</span><br><span class="line">        String[] strings2 = input.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        Node list2 = createNode(strings2,m);</span><br><span class="line">        <span class="comment">//要操作的函数</span></span><br><span class="line">        <span class="comment">//printCommonPart(list1,list2);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取树"><a href="#获取树" class="headerlink" title="获取树"></a>获取树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="comment">//读取总的节点数与根节点数</span></span><br><span class="line">        String[] s=reader.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> rootIdx = Integer.parseInt(s[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//构造桶，将每个节点放入对应值，分别存其左、右结点的值</span></span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="comment">//将节点的数放入对应的桶中，构造得到数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            String[] sts = reader.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            t = Integer.parseInt(sts[<span class="number">0</span>]);</span><br><span class="line">            arr[t][<span class="number">0</span>] = Integer.parseInt(sts[<span class="number">1</span>]);</span><br><span class="line">            arr[t][<span class="number">1</span>] = Integer.parseInt(sts[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拿出头节点</span></span><br><span class="line">        Node head = <span class="keyword">new</span> Node(rootIdx);</span><br><span class="line">        createTree(head,arr);</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        preOrderRecur(head,res);</span><br><span class="line">        System.out.println(res.substring(<span class="number">0</span>,res.length()-<span class="number">1</span>));</span><br><span class="line">        res.delete(<span class="number">0</span>,res.length());</span><br><span class="line">        inOrderRecur(head,res);</span><br><span class="line">        System.out.println(res.substring(<span class="number">0</span>,res.length()-<span class="number">1</span>));</span><br><span class="line">        res.delete(<span class="number">0</span>,res.length());</span><br><span class="line">        posOrderRecur(head,res);</span><br><span class="line">        System.out.println(res.substring(<span class="number">0</span>,res.length()-<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createTree</span><span class="params">(Node root,<span class="keyword">int</span>[][] a)</span></span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=root.value;</span><br><span class="line">        <span class="keyword">int</span> l=a[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> r=a[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//左子树不为空，构造左子树</span></span><br><span class="line">        <span class="keyword">if</span>(l!=<span class="number">0</span>)&#123;</span><br><span class="line">            Node leftNode=<span class="keyword">new</span> Node(l);</span><br><span class="line">            root.left=leftNode;</span><br><span class="line">            <span class="comment">//递归产生左子树</span></span><br><span class="line">            createTree(leftNode,a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右子树不为空，构造右子树</span></span><br><span class="line">        <span class="keyword">if</span>(r!=<span class="number">0</span>)&#123;</span><br><span class="line">            Node rightNode=<span class="keyword">new</span> Node(r);</span><br><span class="line">            root.right=rightNode;</span><br><span class="line">            createTree(rightNode,a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="左神算法笔记"><a href="#左神算法笔记" class="headerlink" title="左神算法笔记"></a>左神算法笔记</h1><h2 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a>排序问题</h2><h3 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h3><p>题目描述：</p>
<p>数组小和的定义如下：</p>
<p>例如，数组s = [1, 3, 5, 2, 4, 6]，在s[0]的左边小于或等于s[0]的数的和为0；在s[1]的左边小于或等于s[1]的数的和为1；在s[2]的左边小于或等于s[2]的数的和为1+3=4；在s[3]的左边小于或等于s[3]的数的和为1；</p>
<p>在s[4]的左边小于或等于s[4]的数的和为1+3+2=6；在s[5]的左边小于或等于s[5]的数的和为1+3+5+2+4=15。所以s的小和为0+1+4+1+6+15=27</p>
<p>给定一个数组s，实现函数返回s的小和</p>
<p>[要求]</p>
<p>时间复杂度为O(nlogn)，空间复杂度为O(n)</p>
<p>思路：找小和，就是看当前数右边哪些数比他大 ，顺序并没有关系，因此可以用mergesort的思想，先分再合，产生小和的过程为merge的过程，如果右边数比左边大，那么总的小和个数为左边当前数*右边数个数，然后将两个数组sort中产生的数和当前merge共三部门数相加即可。</p>
<p>坑：</p>
<p>最后的小和可能很大，需要long类型才能过OJ，小和为小于等于，因此merge外排时判断为&lt;=</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">public class Main&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        String s = null;</span><br><span class="line">        while((s=br.readLine())!=null)&#123;</span><br><span class="line">            int len = Integer.valueOf(s);</span><br><span class="line">            String[] arrStr = br.readLine().split(" ");</span><br><span class="line">            int[] arr = new int[len];</span><br><span class="line">            for(int i = 0;i &lt; len;i++)&#123;</span><br><span class="line">                arr[i] = Integer.parseInt(arrStr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(smallSum(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static long smallSum(int[] arr)&#123;</span><br><span class="line">        if(arr == null || arr.length &lt; 2)</span><br><span class="line">            return 0;</span><br><span class="line">        return sortProcess(arr,0,arr.length-1);</span><br><span class="line">    &#125;</span><br><span class="line">    public static long sortProcess(int[] arr,int l,int r)&#123;</span><br><span class="line">        if(l == r)</span><br><span class="line">            return 0;</span><br><span class="line">        int mid = l + (r - l)/2;</span><br><span class="line">        return sortProcess(arr,l,mid)+sortProcess(arr,mid+1,r)+<span class="keyword">merge</span>(arr,l,<span class="keyword">mid</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    public static long <span class="keyword">merge</span>(<span class="built_in">int</span>[] arr,<span class="built_in">int</span> l,<span class="built_in">int</span> <span class="keyword">mid</span>, <span class="built_in">int</span> r)&#123;</span><br><span class="line">        <span class="built_in">int</span> p1 = l,p2 = <span class="keyword">mid</span>+<span class="number">1</span>,i = <span class="number">0</span>;</span><br><span class="line">        int[] <span class="keyword">help</span> = <span class="keyword">new</span> <span class="built_in">int</span>[r-l+<span class="number">1</span>];</span><br><span class="line">        long res = 0;</span><br><span class="line">        while(p1&lt;=mid &amp;&amp; p2 &lt;= r)&#123;</span><br><span class="line">            if(arr[p1] &lt;= arr[p2])&#123;</span><br><span class="line">                res += arr[p1] * (r-p2+1);</span><br><span class="line">                <span class="keyword">help</span>[i++] = arr[p1++];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                <span class="keyword">help</span>[i++] = arr[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(p1&lt;=mid)&#123;</span><br><span class="line">            <span class="keyword">help</span>[i++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        while(p2&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">help</span>[i++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        for(i = 0;i&lt;help.length;i++)&#123;</span><br><span class="line">            arr[l+i] = <span class="keyword">help</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组排序后相邻数的最大差值"><a href="#数组排序后相邻数的最大差值" class="headerlink" title="数组排序后相邻数的最大差值"></a>数组排序后相邻数的最大差值</h3><p>题目描述</p>
<p>给定一个整形数组arr，返回排序后相邻两数的最大差值</p>
<p>arr = [9, 3, 1, 10]。如果排序，结果为[1, 3, 9, 10]，9和3的差为最大差值，故返回6。</p>
<p>arr = [5, 5, 5, 5]。返回0。</p>
<p>[要求]</p>
<p>时间复杂度为O(n)，空间复杂度为O(n)</p>
<p>当要排序，然后时间复杂度给定O(n)，那么只能使用桶排序，思路为把n个数放在n+1个桶中，那么肯定有1个桶中没有数字，这样最大的差值一定出现在两个桶之间，那么桶中有哪些数字不重要，只需要关注桶中是否有数字，最大数字和最小数字即可，最大差值为当前非空桶的最小值减去上一个非空桶的最大值。将数字放入桶，依据为将min-max的数据，放入0-len的桶中，数据长度为为len，桶的个数为len+1。在计算时为了避免越界，采用long型，然后转换为int。可以优化的点在于，如果算出来数组的最大值和最小值相等，那么可以直接返回0，不用建立桶。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((s=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> len = Integer.valueOf(s);</span><br><span class="line">            <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">            String[] arrStr = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                arr[i] = Integer.valueOf(arrStr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(maxGap(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxGap</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计数组最大和最小值</span></span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            min = Math.min(min,arr[i]);</span><br><span class="line">            max = Math.max(max,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果max=min，那么可以直接返回0</span></span><br><span class="line">        <span class="keyword">if</span>(max == min)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//建立桶，范围是0-len</span></span><br><span class="line">        <span class="comment">//有三个属性，是否进来过数，最大值，最小值</span></span><br><span class="line">        <span class="keyword">boolean</span>[] hasNum = <span class="keyword">new</span> <span class="keyword">boolean</span>[len+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] maxs = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] mins = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> bid = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将每一个数装入桶</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len;i++)&#123;</span><br><span class="line">            <span class="comment">//计算当前数应该在哪个桶</span></span><br><span class="line">            bid = bucket(arr[i],len,min,max);</span><br><span class="line">            <span class="comment">//统计桶的最大最小值，是否进去过数</span></span><br><span class="line">            maxs[bid] = hasNum[bid]?Math.max(maxs[bid],arr[i]):arr[i];</span><br><span class="line">            mins[bid] = hasNum[bid]?Math.min(mins[bid],arr[i]):arr[i];</span><br><span class="line">            hasNum[bid] = <span class="keyword">true</span>;<span class="comment">//当前桶进去了数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始计算差值</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lastMax = maxs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hasNum[i])&#123;</span><br><span class="line">                res = Math.max(res,mins[i]-lastMax);</span><br><span class="line">                lastMax = maxs[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bucket</span><span class="params">(<span class="keyword">long</span> num,<span class="keyword">long</span> len, <span class="keyword">long</span> min, <span class="keyword">long</span> max)</span></span>&#123;</span><br><span class="line">        <span class="comment">//目的，让值为min的在0桶，让值为max的在len桶</span></span><br><span class="line">        <span class="comment">//范围变换，从min-max变化为0-len</span></span><br><span class="line">        <span class="keyword">int</span> res = (<span class="keyword">int</span>)((num-min)*len/(max-min));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列和栈"><a href="#队列和栈" class="headerlink" title="队列和栈"></a>队列和栈</h2><h3 id="用数组实现栈和队列"><a href="#用数组实现栈和队列" class="headerlink" title="用数组实现栈和队列"></a>用数组实现栈和队列</h3><p>用数组实现栈比较简单，此类需要持有一个数组和当前位置标记，有初始化构造函数，获取最上面一个数peek方法，入栈push方法，出栈pop方法，要注意的是执行者三个方法时第一步为判断index范围，pop方法返回类型要是Integer而不是int，因为换成int不能返回null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用数组实现栈，应该持有数组，当前位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The init size is less than 0"</span>);</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//peek，获取最上面的数</span></span><br><span class="line">    <span class="comment">//返回类型为Integer，不然不能返回NULL</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> arr[index-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> obj)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果超出范围，报错</span></span><br><span class="line">        <span class="keyword">if</span> (index == arr.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"The stack is full"</span>);</span><br><span class="line">        <span class="comment">//如果正常，放入数据</span></span><br><span class="line">        arr[index++] = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"The stack is empty"</span>);</span><br><span class="line">        <span class="keyword">return</span> arr[--index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用数组实现队列，需要持有一个数组，一个入队列位置end，一个出队列位置start，一个队列大小size，用size来给end和start解耦</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用数组实现队列，需要持有数组，队列末尾，队列开始，size</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> initSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initSize &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The init size is less than 0"</span>);</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[initSize];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        end = <span class="number">0</span>;</span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//peek方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> arr[start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//push方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == arr.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"The queue is full"</span>);</span><br><span class="line">        size++;</span><br><span class="line">        arr[end] = obj;</span><br><span class="line">        <span class="comment">//循环队列</span></span><br><span class="line">        end = (end + <span class="number">1</span>) % arr.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//poll方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"The queue is empty"</span>);</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[start];</span><br><span class="line">        start = (start+<span class="number">1</span>)%arr.length;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getMin-功能的栈"><a href="#getMin-功能的栈" class="headerlink" title="getMin()功能的栈"></a>getMin()功能的栈</h3><p>实现一个特殊功能的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。</p>
<p>思路：持有两个栈，一个为数据栈，一个为最小栈，数据栈正常进出，而最小栈有两种方法实现。</p>
<p>方法一：当进来的数比最小数要小，直接入栈；当比最小数大，入栈最小数出栈时。两个栈正常出栈，返回data栈的值。</p>
<p>方法二：当进来的数比最小数要小，直接入栈；当比最小数大，min不入栈 。出栈时，当data出栈数等于最小数才出栈 ，其他时候min不出栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第二种方法，入栈的时候，如果当前数比较大，则min栈不进</span></span><br><span class="line">    <span class="comment">//出栈的时候，如果当前数比min栈小，min栈不出</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; dataStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getMin()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果栈为空，返回空</span></span><br><span class="line">        <span class="keyword">if</span> (minStack.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入栈方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minStack.empty()) &#123;</span><br><span class="line">            minStack.push(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt;= getMin()) &#123;</span><br><span class="line">            minStack.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        dataStack.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出栈方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dataStack.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> num = dataStack.pop();</span><br><span class="line">        <span class="comment">//只有当前数等于getmin，min栈才出</span></span><br><span class="line">        <span class="comment">//只有等于，没有小于</span></span><br><span class="line">        <span class="keyword">if</span> (num == getMin())</span><br><span class="line">            minStack.pop();</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h3><p>用队列来实现栈的功能，要有2个队列，当push的时候，正常进入队列，当peek的时候，先弹出其他的进入辅助队列，然后获取剩下来的一个的值，再将其放入辅助队列，再交换两个的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoQueueStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用两个队列实现栈</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; help;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoQueueStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        help = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//push</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        queue.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue.size()!=<span class="number">1</span>)&#123;</span><br><span class="line">            help.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = queue.poll();</span><br><span class="line">        help.add(res);</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            help.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = queue.poll();</span><br><span class="line">        swap();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换两个队列引用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; temp = queue;</span><br><span class="line">        queue = help;</span><br><span class="line">        help = queue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><p>准备两个栈，一个push栈只用于push数据进去，一个pop栈只用于pop数据出来。从push栈倒数据进pop栈有两个要求，一个是pop栈中不能有数据，另一个是倒就要全部倒完。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoStackQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackPush;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackPop;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoStackQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stackPush = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stackPop = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        stackPush.push(num);</span><br><span class="line">        goTo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关键的倒数据步骤</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goTo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (stackPop.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//要倒完</span></span><br><span class="line">            <span class="keyword">while</span> (!stackPush.isEmpty())&#123;</span><br><span class="line">                stackPop.push(stackPush.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//peek步骤</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackPush.isEmpty() &amp;&amp; stackPop.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"The stack is empty"</span>);</span><br><span class="line">        goTo();</span><br><span class="line">        <span class="keyword">return</span> stackPop.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackPush.isEmpty() &amp;&amp; stackPop.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"The stack is empty"</span>);</span><br><span class="line">        goTo();</span><br><span class="line">        <span class="keyword">return</span> stackPop.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="猫狗队列"><a href="#猫狗队列" class="headerlink" title="猫狗队列"></a>猫狗队列</h3><p>实现一种猫狗队列的结构，要求如下：</p>
<ol>
<li><p>用户可以调用 add 方法将 cat 或者 dog 放入队列中</p>
</li>
<li><p>用户可以调用 pollAll 方法将队列中的 cat 和 dog 按照进队列的先后顺序依次弹出</p>
</li>
<li><p>用户可以调用 pollDog 方法将队列中的 dog 按照进队列的先后顺序依次弹出</p>
</li>
<li><p>用户可以调用 pollCat 方法将队列中的 cat 按照进队列的先后顺序依次弹出</p>
</li>
<li><p>用户可以调用 isEmpty 方法检查队列中是否还有 dog 或 cat</p>
</li>
<li><p>用户可以调用 isDogEmpty 方法检查队列中是否还有 dog</p>
</li>
<li><p>用户可以调用 isCatEmpty 方法检查队列中是否还有 cat</p>
</li>
</ol>
<p>思路：将Pet封装上一个index数据项，这样使用一个新类将二者封装。然后持有一个狗队列，一个猫队列，持有index，初始为0，在add操作中，如果是狗，就加入狗队列，是猫就加入猫队列。从队列中弹出较早入队列的，比较猫、狗队列中较小的index，弹出即可。</p>
<p>坑点：牛客网上的题目相比于原始题目，Pet自己也需要封装上一个index项，而比较的时候，比的是封装后的宠物队列类自己定义的index，而不是pet的index。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pet</span><span class="params">(String type,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.x = index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPetType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPetIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PetEnterQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//持有Pet和index</span></span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PetEnterQueue</span><span class="params">(Pet pet, <span class="keyword">long</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pet = pet;</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//API：获取当前类型，index</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">getPet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPetType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pet.getPetType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DogCatQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//猫狗队列，一个持有猫，，一个持有狗</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;PetEnterQueue&gt; dogQueue;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;PetEnterQueue&gt; catQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DogCatQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dogQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        catQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Pet pet)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果为狗，加到狗；如果为猫，加到猫</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"dog"</span>.equals(pet.getPetType()))&#123;</span><br><span class="line">            dogQueue.add(<span class="keyword">new</span> PetEnterQueue(pet,index++));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"cat"</span>.equals(pet.getPetType()))&#123;</span><br><span class="line">            catQueue.add(<span class="keyword">new</span> PetEnterQueue(pet,index++));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"error, no dog or cat"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹出猫或者狗中较小的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">pollAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果两个均不为空</span></span><br><span class="line">        <span class="keyword">if</span> (!dogQueue.isEmpty() &amp;&amp; !catQueue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (dogQueue.peek().getIndex() &lt; catQueue.peek().getIndex())&#123;</span><br><span class="line">                <span class="keyword">return</span> dogQueue.poll().getPet();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> catQueue.poll().getPet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!dogQueue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//狗不为空</span></span><br><span class="line">            <span class="keyword">return</span> dogQueue.poll().getPet();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!catQueue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//猫不为空</span></span><br><span class="line">            <span class="keyword">return</span> catQueue.poll().getPet();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"The queue is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹出狗队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">pollDog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dogQueue.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Dog queue is empty"</span>);</span><br><span class="line">        <span class="keyword">return</span> dogQueue.poll().getPet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//弹出猫队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">pollCat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (catQueue.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Dog queue is empty"</span>);</span><br><span class="line">        <span class="keyword">return</span> catQueue.poll().getPet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isCatEmpty()&amp;&amp;isDogEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCatEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> catQueue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDogEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dogQueue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入输出的处理比较麻烦，使用StringBuilder来添加结果，最后用substring方法将其转换为字符串，要记得添加换行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        DogCatQueue dq = <span class="keyword">new</span> DogCatQueue();</span><br><span class="line">        Pet pet = <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s = br.readLine();</span><br><span class="line">        <span class="keyword">int</span> count = Integer.valueOf(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            String[] strArr = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">switch</span> (strArr[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"add"</span>:</span><br><span class="line">                    String type=strArr[<span class="number">1</span>];</span><br><span class="line">                    dq.add(<span class="keyword">new</span> Pet(type,Integer.valueOf(strArr[<span class="number">2</span>])));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"pollAll"</span>:</span><br><span class="line">                    <span class="keyword">while</span>(!dq.isEmpty())&#123;</span><br><span class="line">                        pet = dq.pollAll();</span><br><span class="line">                        res.append(pet.getPetType()+<span class="string">" "</span>+pet.getPetIndex()+<span class="string">"\n"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"pollCat"</span>:</span><br><span class="line">                    <span class="keyword">while</span>(!dq.isCatEmpty())&#123;</span><br><span class="line">                        pet = dq.pollCat();</span><br><span class="line">                        res.append(pet.getPetType()+<span class="string">" "</span>+pet.getPetIndex()+<span class="string">"\n"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"pollDog"</span>:</span><br><span class="line">                    <span class="keyword">while</span>(!dq.isDogEmpty())&#123;</span><br><span class="line">                        pet = dq.pollDog();</span><br><span class="line">                        res.append(pet.getPetType()+<span class="string">" "</span>+pet.getPetIndex()+<span class="string">"\n"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"isDogEmpty"</span> :</span><br><span class="line">                    res.append(dq.isDogEmpty()?<span class="string">"yes\n"</span>:<span class="string">"no\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"isCatEmpty"</span>:</span><br><span class="line">                    res.append(dq.isCatEmpty()?<span class="string">"yes\n"</span>:<span class="string">"no\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"isEmpty"</span>:</span><br><span class="line">                    res.append(dq.isEmpty()?<span class="string">"yes\n"</span>:<span class="string">"no\n"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res.substring(<span class="number">0</span>,res.length()-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="RandomPool结构"><a href="#RandomPool结构" class="headerlink" title="RandomPool结构"></a>RandomPool结构</h3><p>题目：</p>
<p>设计一种结构，在该结构中加入如下三种功能</p>
<p>insert(key)：将某个key加入到该结构，做到不重复加入</p>
<p>delete(key)：将原本在结构中的某个key移除</p>
<p>getRandom()：等概率随机返回结构中的任何一个key</p>
<p>要求：这三种方法的时间复杂度均为O(1)</p>
<p>思路：一个不行就两个。持有两个哈希表，一个为key-index映射，一个为index-key映射，麻烦的地方在于删除后如何保证之后的随机性，解决方法为每次找到要删除的位置，然后获取其key，获取最后行的key和index，然后将最后行的数据存到要删除行，再删除最后行数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomPool</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//持有两个哈希表，一个索引</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;K,Integer&gt; keyIndexMap;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer,K&gt; indexKeyMap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        keyIndexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        indexKeyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果已经存在了，返回</span></span><br><span class="line">        <span class="keyword">if</span> (keyIndexMap.containsKey(key))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        keyIndexMap.put(key,index);</span><br><span class="line">        indexKeyMap.put(index++,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//随机返回方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getRandom</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果没有数据，返回空</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> res = (<span class="keyword">int</span>)(Math.random()*index);</span><br><span class="line">        <span class="keyword">return</span> indexKeyMap.get(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!keyIndexMap.containsKey(key))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//1、找到要删除位置的index</span></span><br><span class="line">        <span class="keyword">int</span> deleteIndex = keyIndexMap.get(key);</span><br><span class="line">        <span class="comment">//2、找到最后的index和key</span></span><br><span class="line">        <span class="keyword">int</span> lastIndex = --index;</span><br><span class="line">        K lastKey = indexKeyMap.get(lastIndex);</span><br><span class="line">        <span class="comment">//3、将待删除位置的值替换为最后行的值</span></span><br><span class="line">        keyIndexMap.put(lastKey,deleteIndex);</span><br><span class="line">        indexKeyMap.put(deleteIndex,lastKey);</span><br><span class="line">        <span class="comment">//4、删除最后行数据，将行数-1</span></span><br><span class="line">        keyIndexMap.remove(key);</span><br><span class="line">        indexKeyMap.remove(lastIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h3><p>解决问题</p>
<p>应用在多服务器的场合，为了解决负载均衡问题，即客户端的请求能较均衡的分配到每台服务器上。经典的服务器结构是若有n台机器，将前端获取信息计算一个哈希值，然后%n，得到对应服务器并访问，但当服务器个数变化时信息需要重新计算才能再次均衡。</p>
<p>如何做</p>
<p>而一致性哈希就是为了解决这个问题，将哈希域映射到一个圆环，将服务器信息计算出哈希值映射到圆上，客户端请求信息的key同样计算哈希值映射到圆上，将信息交给顺时针找到的第一台服务器进行处理。当减少一台服务器，将要访问此机器的数据交由顺时针的下一个机器即可。当增加一台服务器，将其映射到圆上，将此机器逆时针上一台机器到此机器之间的顺序交给本机器处理即可。</p>
<p>存在问题</p>
<p>但是这样当服务器个数较少的时候，不容易在环上均匀分配，这样无法实现负载均衡。可以采用虚拟节点的方式，给每台机器分配多个虚拟节点，让虚拟节点在环上均衡分配，数据的key寻找对应的虚拟节点，再由虚拟节点寻找对应的机器。</p>
<h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><p> 1、轮训法</p>
<p>将请求按顺序轮流分配到后端服务器上，均衡对待每一台服务器，而不关心服务器本身的连接数和负载情况</p>
<p>2、随机法</p>
<p>通过系统随机计算，从后端服务器中随机选取一台来访问，当访问次数多了后，根据概率论，每台服务器上访问会均衡</p>
<p>3、源地址哈希</p>
<p>根据客户端的ip，计算哈希值，对服务器台数进行取模运算，得到的便是要访问的服务器。</p>
<p>4、加权轮训法</p>
<p>不同服务器抗压能力不同，给配置高、负载低的服务器更高的权重，处理更多的请求；而配置低、负载高的服务器更低权重，处理更少请求，降低负载</p>
<p>5、加权随机法</p>
<p>根据负载不同计算不同权重，按照权重随机请求服务器，而不是顺序的</p>
<p>6、最小连接数法</p>
<p>根据后端服务器当前连接情况，动态的选取当前积压连接数最少的服务器来处理当前请求，尽可能提高后端的利用率。</p>
<p>7、一致性哈希</p>
<p>在源地址哈希上改进，将哈希域映射为环，将计算器映射到环上，计算请求的key对应的哈希值，在顺时针找到的第一台服务器上进行请求。增加虚拟节点，来解决初始服务器数量少，负载不均衡的问题。</p>
<h3 id="常见的hash算法"><a href="#常见的hash算法" class="headerlink" title="常见的hash算法"></a>常见的hash算法</h3><p>1、直接寻址法</p>
<p>取key的某个线性函数值作为散列地址，其哈希值为a*key+b</p>
<p>2、数字分析法</p>
<p>找出数字的规律，利用数据来构造冲突几率较低的散列地址</p>
<p>3、平方取中法</p>
<p>取key平方后的中间几位作为散列地址</p>
<p>4、折叠法</p>
<p>将key分割为位数相同的几部分，最后一部分位数可以不同，取这几份去除进位的叠加和来作为散列地址</p>
<p>5、随机数法</p>
<p>选择随机函数，取key的随机值作为散列地址，通常用在key长度不同的场合</p>
<p>6、除留余数法</p>
<p>将key对不大于散列表长的数p取余，得到的数为地址。不仅可以直接取模，也可以在折叠，平方取中后取模，一般将p取素数或散列表长</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="转圈打印矩阵"><a href="#转圈打印矩阵" class="headerlink" title="转圈打印矩阵"></a>转圈打印矩阵</h3><img src="/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%BD%AC%E5%9C%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.png" class title="This is an example image">

<p>思路：打印矩阵的思路一般都是宏观调度，用有限个变量去约束要打印的范围，然后循环调用打印函数。此处用左上角和右下角的点去约束范围，调用打印函数，然后将左上角和右下角的点进行收缩。打印矩阵函数为分别判断一行，一列和多行多列的情况，如果为单行单列的，用for循环控制行和列，如果为多行多列，分四次打印。</p>
<img src="/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%BD%AC%E5%9C%88%E7%9F%A9%E9%98%B5%E7%BA%A6%E6%9D%9F.png" class title="This is an example image">

<p>说明的是，在原方法中采用的是直接sout输出，此处使用StringBuilder进行添加。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PringtEdge</span> </span>&#123;</span><br><span class="line">    <span class="comment">//转圈打印矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">printCircle</span><span class="params">(<span class="keyword">int</span>[][] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、找两个边界点</span></span><br><span class="line">        <span class="keyword">int</span> row1 = <span class="number">0</span>, col1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row2 = arr.length-<span class="number">1</span>,col2 = arr[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//只要满足边界条件，循环调用打印函数</span></span><br><span class="line">        <span class="keyword">while</span> (row1 &lt;= row2 &amp;&amp; col1 &lt;= col2)&#123;</span><br><span class="line">            printEdge(arr,sb,row1++,col1++,row2--,col2--);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(<span class="keyword">int</span>[][] arr, StringBuilder sb, <span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、如果只有一行</span></span><br><span class="line">        <span class="keyword">if</span> (row1 == row2)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = col1; i &lt;= col2; i++) &#123;</span><br><span class="line">                sb.append(arr[row1][i]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(col1 == col2)&#123;</span><br><span class="line">            <span class="comment">//2、如果只有一列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = row1; i &lt;= row2; i++) &#123;</span><br><span class="line">                sb.append(arr[i][col1]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//3、分四部分打印</span></span><br><span class="line">            <span class="keyword">int</span> curR = row1;<span class="comment">//当前行</span></span><br><span class="line">            <span class="keyword">int</span> curL = col1;<span class="comment">//当前列</span></span><br><span class="line">            <span class="keyword">while</span> (curL &lt; col2)&#123;</span><br><span class="line">                sb.append(arr[curR][curL++]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curR &lt; row2)&#123;</span><br><span class="line">                sb.append(arr[curR++][curL]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curL &gt; col1)&#123;</span><br><span class="line">                sb.append(arr[curR][curL--]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (curR &gt; row1)&#123;</span><br><span class="line">                sb.append(arr[curR--][curL]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="comment">//要持有的写的类</span></span><br><span class="line">        PringtEdge pe = <span class="keyword">new</span> PringtEdge();</span><br><span class="line">        String[] s = <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span> row = Integer.valueOf(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> col = Integer.valueOf(s[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            s = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                arr[i][j] = Integer.valueOf(s[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = pe.printCircle(arr);</span><br><span class="line">        System.out.println(res.substring(<span class="number">0</span>,res.length()-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="之字型打印矩阵"><a href="#之字型打印矩阵" class="headerlink" title="之字型打印矩阵"></a>之字型打印矩阵</h3><img src="/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%B9%8B%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.png" class title="This is an example image">

<p>思路：宏观调度，打印的是两个点之间的对角线的值，那么只要解决点的运动路径和打印对角线即可。要注意的是点在运动过程中时，如果变量A依靠变量B来约束其行为，要先改变变量A，再改变B，不然B先改变则A会缺少值。而对角线打印的时候有方向变化，可以用标记变量来控制。</p>
<p>这种题目依靠的是宏观调度，不要去想每个点到底怎么变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//之字型打印矩阵，找宏观规律</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">printZhi</span><span class="params">(<span class="keyword">int</span>[][] m)</span></span>&#123;</span><br><span class="line">        <span class="comment">//往右，再下</span></span><br><span class="line">        <span class="keyword">int</span> row1 = <span class="number">0</span>,col1 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//往下，再右</span></span><br><span class="line">        <span class="keyword">int</span> row2 = <span class="number">0</span>,col2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> endR = m.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> endC = m[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//先下，再上</span></span><br><span class="line">        <span class="keyword">boolean</span> fromUp = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (row1 &lt;= endR)&#123;</span><br><span class="line">            printProcess(m,res,row1,col1,row2,col2,fromUp);</span><br><span class="line">            <span class="comment">//路径变化</span></span><br><span class="line">            <span class="comment">//关键为将引发判断的值后判断</span></span><br><span class="line">            row1 = col1 == endC ? row1+<span class="number">1</span>:row1;</span><br><span class="line">            col1 = col1 == endC ? col1:col1+<span class="number">1</span>;</span><br><span class="line">            col2 = row2 == endR ? col2+<span class="number">1</span> : col2;</span><br><span class="line">            row2 = row2 == endR ? row2:row2+<span class="number">1</span>;</span><br><span class="line">            fromUp = !fromUp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printProcess</span><span class="params">(<span class="keyword">int</span>[][] m,StringBuilder res, <span class="keyword">int</span> row1,<span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2,<span class="keyword">boolean</span> fromUp)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果fromUp为false，从左下向右上打印</span></span><br><span class="line">        <span class="keyword">if</span> (!fromUp)&#123;</span><br><span class="line">            <span class="keyword">while</span> (row1 &lt;= row2)&#123;</span><br><span class="line">                res.append(m[row2--][col2++]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (row1 &lt;= row2)&#123;</span><br><span class="line">                res.append(m[row1++][col1--]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="在行列都排好序的矩阵中找数"><a href="#在行列都排好序的矩阵中找数" class="headerlink" title="在行列都排好序的矩阵中找数"></a>在行列都排好序的矩阵中找数</h3><img src="/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%9F%A9%E9%98%B5%E6%89%BE%E6%95%B0.png" class title="This is an example image">

<p>思路：从右上角或者左下角开始找，此处选右上角，要是当前数小了就往下，当前数大了就往左。</p>
<p>精髓的点在于开始寻找的位置，利用矩阵的特征，可以将部分不可能的情况给排除掉，这题从右上角或者左下角开始找都可以。但是左上和右下不行，因为没办法缩小规模。核心在于右上或左下，<strong>一边比它大，一边比它小</strong>。这样子存在<strong>要么去一边，要么另一边</strong>的0 1情况，即非黑即白。</p>
<p>实质是将没有可能的数据直接舍弃，即将问题的规模进行缩小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在已排序的矩阵中找到数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNum</span><span class="params">(<span class="keyword">int</span>[][] m,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//选择右上角的数</span></span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>,col = m[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> endR = m.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (row&lt;=endR &amp;&amp; col &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//如果当前数小，往下走</span></span><br><span class="line">        <span class="keyword">if</span> (m[row][col] == k)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(m[row][col]&gt;k)&#123;</span><br><span class="line">            <span class="comment">//当前数比较大，往左走</span></span><br><span class="line">            col--;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="打印两个链表的公共部分"><a href="#打印两个链表的公共部分" class="headerlink" title="打印两个链表的公共部分"></a>打印两个链表的公共部分</h3><p>给定两个升序链表，打印两个升序链表的公共部分。</p>
<p>思路：类似于外排，谁小动谁，如果相等，打印并两个一起动</p>
<p>值得注意的点：将head1或者2为空的情况放在最上面，直接返回；将head1.value==head2.value的情况放在三种判断的第一个，这样可以缩短判断时间；整理链表基本结构及生成链表的套路。StringBuilder添加时候，使用两次append比一次append两个str效率高。原因是使用+的时候多了生成String的步骤，这样降低了效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印两个链表公共部分</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCommonPart</span><span class="params">(Node head1,Node head2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将不可能的情况先列出</span></span><br><span class="line">    <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//类似外排</span></span><br><span class="line">    <span class="comment">//谁小动谁，如果相等，添加并两个一起动</span></span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//将相等的判断放在最上面</span></span><br><span class="line">        <span class="keyword">if</span> (head1.value == head2.value) &#123;</span><br><span class="line">            <span class="comment">//这样比直接append(value+" ")效率高</span></span><br><span class="line">            res.append(head1.value).append(<span class="string">" "</span>);</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(head1.value &lt; head2.value)&#123;</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(res.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合并两个有序的链表"><a href="#合并两个有序的链表" class="headerlink" title="合并两个有序的链表"></a>合并两个有序的链表</h3><p>给定两个升序的单链表的头节点 head1 和 head2，请合并两个升序链表， 合并后的链表依然升序，并返回合并后链表的头节点。</p>
<p>思路：类似于外排，如果两个均不为空，谁小动谁；如果哪个为空，把另一个不为空的接到新链表后即可。</p>
<p>小技巧：新链表自己先做一个头节点会比较方便，在动链表的时候，流程为让新链表的下一个指向小节点，新链表当前节点跳到下一个，小节点链表头节点跳到下一个。另外如果有一个链表已经为空了，则不需要一个个节点去添加，直接把整个加上去即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并链表</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">mergeLink</span><span class="params">(Node head1, Node head2)</span></span>&#123;</span><br><span class="line">       <span class="comment">//类似于外排</span></span><br><span class="line">       Node res = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">       Node cur = res;</span><br><span class="line">       <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span> (head1.value &lt;= head2.value)&#123;</span><br><span class="line">               cur.next = head1;</span><br><span class="line">               cur = head1;</span><br><span class="line">               head1 = head1.next;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               cur.next = head2;</span><br><span class="line">               cur = head2;</span><br><span class="line">               head2 = head2.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//将空的链表部分直接拼接到新链表后面即可</span></span><br><span class="line">       cur.next = head1 == <span class="keyword">null</span> ? head2 : head1;</span><br><span class="line">       cur = res.next;</span><br><span class="line">       res = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">return</span> cur;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断链表是否为回文结构"><a href="#判断链表是否为回文结构" class="headerlink" title="判断链表是否为回文结构"></a>判断链表是否为回文结构</h3><p>给定链表的头结点，判断是否为回文链表</p>
<p>方式一：将链表元素全部存进栈中，利用栈先进后出的特点，与链表逐个比较，额外空间复杂度O(N)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法1：将链表中的数据用栈存起来，然后一个个取出来进行对比</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome1</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//准备一个栈</span></span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Node node = head;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取出来比较</span></span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.value != stack.pop().value)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：只放一半的元素进栈中，缩短一半的额外空间。</p>
<p>为了找到链表中点，用到的方法为快慢指针，是链表题目中比较常见的方法，慢指针一下子走一步，快指针走两步，当快指针走到末尾时，慢指针正好走到中间。注意：如果是要中点位置，慢指针从头结点开始，如果是中点位置下一个，慢指针从头节点下一个开始。此处慢指针的起始点就是头节点下一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法2：只需要判断链表的一半即可，问题是如何找到链表的中点</span></span><br><span class="line">    <span class="comment">//用快慢指针</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome2</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Node slow = head.next;</span><br><span class="line">        Node fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时slow来到中点位置，将剩下的节点存入栈中</span></span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(slow);</span><br><span class="line">        &#125;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (slow.value != stack.pop().value)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>方法三：进阶方式，额外空间复杂度为O(1)，不依靠栈，而是先找到链表中点，将链表右半部分进行翻转，这里有个操作是将中点节点指向null，方便后面判断。然后从链表两端进行判断，注意不能直接返回值，因为还需要将链表还原。判断结束后，将链表右半部分还原。</p>
<p>注意：反转链表，删除链表节点需要利用3个指针，一个指向当前节点，一个指向当前节点的前序节点，一个指向当前节点的后序节点。先保存其下一个进行位置的，再进行操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法3，不利用栈，先找到链表的中点，反转剩下的链表</span></span><br><span class="line">    <span class="comment">//进行判断，然后将链表还原</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome3</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//找到链表中点</span></span><br><span class="line">        Node n1 = head;</span><br><span class="line">        Node n2 = head;</span><br><span class="line">        <span class="keyword">while</span>(n2.next != <span class="keyword">null</span> &amp;&amp; n2.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            n1 = n1.next;</span><br><span class="line">            n2 = n2.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时n1来到中点，反转链表，先要记录n1下一个位置</span></span><br><span class="line">        n2 = n1.next;</span><br><span class="line">        n1.next = <span class="keyword">null</span>;</span><br><span class="line">        Node n3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//反转链表</span></span><br><span class="line">        <span class="keyword">while</span> (n2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            n3 = n2.next;</span><br><span class="line">            n2.next = n1;</span><br><span class="line">            n1 = n2;</span><br><span class="line">            n2 = n3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时n1为链表末尾，进行记录</span></span><br><span class="line">        n3 = n1;</span><br><span class="line">        <span class="comment">//开始判断头和尾的值是否相等</span></span><br><span class="line">        n2 = head;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (n2 != <span class="keyword">null</span> &amp;&amp; n1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (n2.value != n1.value)&#123;</span><br><span class="line">                <span class="comment">//不能直接返回假，这样链表没有被调整回来</span></span><br><span class="line">                res = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n2 = n2.next;</span><br><span class="line">            n1 = n1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//还原链表</span></span><br><span class="line">        n2 = n3.next;</span><br><span class="line">        n3.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (n2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            n1 = n2.next;</span><br><span class="line">            n2.next = n3;</span><br><span class="line">            n3 = n2;</span><br><span class="line">            n2 = n1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="单向链表的基础partition"><a href="#单向链表的基础partition" class="headerlink" title="单向链表的基础partition"></a>单向链表的基础partition</h3><p>题目描述：</p>
<p>给定一个链表，再给定一个整数 pivot，请将链表调整为左部分都是值小于 pivot 的节点，中间部分都是值等于 pivot 的节点， 右边部分都是大于 pivot 的节点。</p>
<p>除此之外，对调整后的节点顺序没有更多要求。</p>
<p>思路：将链表用数组存起来，然后对数组partition，再将数组组合成链表，返回arr[0]，要注意的是将数组的最后个元素的next指向null，以及partition过程的约束条件是index&lt;more，不能取等于，不然会越界。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表的partition基础问题，利用数组来实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listPartition</span><span class="params">(Node head,<span class="keyword">int</span> pivot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//1、统计链表长度</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、造数组，将链表中元素填充进去</span></span><br><span class="line">        Node[] arr = <span class="keyword">new</span> Node[len];</span><br><span class="line">        node = head;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            arr[i++] = node;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、数组的partition问题</span></span><br><span class="line">        <span class="comment">//将其封装为函数</span></span><br><span class="line">        partitionArr(arr,pivot);</span><br><span class="line">        <span class="comment">//将数组组合成链表</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            arr[i-<span class="number">1</span>].next = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将最后个节点指针指向null</span></span><br><span class="line">        arr[i-<span class="number">1</span>].next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">partitionArr</span><span class="params">(Node[] arr, <span class="keyword">int</span> pivot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> less = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> more = arr.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//约束条件为i &lt; more或者i != more</span></span><br><span class="line">        <span class="comment">//如果是等于，当more为数组最后，会越界</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; more)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i].value &lt; pivot)&#123;</span><br><span class="line">                swap(arr,i++,++less);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[i].value &gt; pivot)&#123;</span><br><span class="line">                swap(arr,i,--more);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="单链表的partition进阶"><a href="#单链表的partition进阶" class="headerlink" title="单链表的partition进阶"></a>单链表的partition进阶</h3><p>要求：在原来基础之上，partition后每个部分的节点从左至右的顺序和原链表中节点的顺序一致。要时间复杂度O（N）,额外空间复杂度O（1）。</p>
<p>思路：将原链表拆分为小，等，大三个区域，遍历链表，来一个就丢到对应的位置中去（将节点从原链表中断开），最后将三个链表合并，考察的是扣边界能力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表的复杂partition</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listPartition2</span><span class="params">(Node head,<span class="keyword">int</span> pivot)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//分三个部分，小于、等于、大于区，来个节点就丢到对应的地方去</span></span><br><span class="line">    <span class="comment">//最后将三个部分合并</span></span><br><span class="line">    Node sH = <span class="keyword">null</span>;</span><br><span class="line">    Node sT = <span class="keyword">null</span>;</span><br><span class="line">    Node eH = <span class="keyword">null</span>;</span><br><span class="line">    Node eT = <span class="keyword">null</span>;</span><br><span class="line">    Node bH = <span class="keyword">null</span>;</span><br><span class="line">    Node bT = <span class="keyword">null</span>;</span><br><span class="line">    Node next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//将当前节点丢到三个部分中</span></span><br><span class="line">        <span class="keyword">if</span> (head.value &lt; pivot)&#123;</span><br><span class="line">            <span class="comment">//如果为空</span></span><br><span class="line">            <span class="keyword">if</span> (sH == <span class="keyword">null</span>)&#123;</span><br><span class="line">                sH = head;</span><br><span class="line">                sT = head;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sT.next = head;</span><br><span class="line">                sT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(head.value == pivot)&#123;</span><br><span class="line">            <span class="keyword">if</span> (eH == <span class="keyword">null</span>)&#123;</span><br><span class="line">                eH = head;</span><br><span class="line">                eT = head;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                eT.next = head;</span><br><span class="line">                eT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (bH == <span class="keyword">null</span>)&#123;</span><br><span class="line">                bH = head;</span><br><span class="line">                bT = head;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                bT.next = head;</span><br><span class="line">                bT = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将三个链表连接</span></span><br><span class="line">    <span class="keyword">if</span> (sT != <span class="keyword">null</span>)&#123;</span><br><span class="line">        sT.next = eH;</span><br><span class="line">        eT = eT == <span class="keyword">null</span> ? sT:eT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (eT != <span class="keyword">null</span>)&#123;</span><br><span class="line">        eT.next = bH;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sH != <span class="keyword">null</span> ? sH : eH != <span class="keyword">null</span> ? eH : bH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复制含有随机节点的链表"><a href="#复制含有随机节点的链表" class="headerlink" title="复制含有随机节点的链表"></a>复制含有随机节点的链表</h3><p>方法一：用哈希表，将key为原链表节点，value为新链表节点，然后再复制下一个和rand指针关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">copyListWithRand1</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建存储用的HashMap，key与value均为Node</span></span><br><span class="line">    HashMap&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;Node,Node&gt;();</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="comment">//对每个结点进行拷贝</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        map.put(cur, <span class="keyword">new</span> Node(cur.value));</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//将复制节点的next与random指向cur相同部分</span></span><br><span class="line">        <span class="comment">//get(x)为得到x节点的拷贝结点x'</span></span><br><span class="line">        map.get(cur).next = map.get(cur.next);<span class="comment">//1' 指向 2(1.next)的对应节点2'</span></span><br><span class="line">        map.get(cur).random = map.get(cur.random);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：不使用其他数据结构，在原来链表中每个节点后面复制一个新节点，然后复制rand指针关系，再将两个链表拆分开来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">copyListWithRand2</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// copy node and link to every node</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        next = cur.next;</span><br><span class="line">        cur.next = <span class="keyword">new</span> Node(cur.value);</span><br><span class="line">        cur.next.next = next;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head;</span><br><span class="line">    Node curCopy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// set copy node rand</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        next = cur.next.next;</span><br><span class="line">        curCopy = cur.next;</span><br><span class="line">        curCopy.random = cur.random != <span class="keyword">null</span> ? cur.random.next : <span class="keyword">null</span>;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node res = head.next;<span class="comment">//记录下复制链表的头结点</span></span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="comment">// split</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        next = cur.next.next;</span><br><span class="line">        curCopy = cur.next;</span><br><span class="line">        cur.next = next;</span><br><span class="line">        curCopy.next = next != <span class="keyword">null</span> ? next.next : <span class="keyword">null</span>;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>非递归实现</p>
<p>反转单链表和双链表，基本思路是持有三个节点，当前节点的前序节点，当前节点，下一个节点。</p>
<p>对于单链表，如果当前节点不为空，保存其下一个节点next，当前节点指向前序节点pre，pre=当前节点，当前节点=next，这样便实现了反转；对于双向链表，只是多了一步让当前节点的前序节点=next，其他和单向链表一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反转单向链表</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseListSL</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">       <span class="comment">//准备三个节点</span></span><br><span class="line">       Node pre = <span class="keyword">null</span>;</span><br><span class="line">       Node cur = head;</span><br><span class="line">       Node next = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">           next = cur.next;</span><br><span class="line">           cur.next = pre;</span><br><span class="line">           pre = cur;</span><br><span class="line">           cur = next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pre;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//反转双向链表</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseListDL</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">       <span class="comment">//准备三个节点</span></span><br><span class="line">       Node pre = <span class="keyword">null</span>;</span><br><span class="line">       Node cur = head;</span><br><span class="line">       Node next = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">           next = cur.next;</span><br><span class="line">           cur.next = pre;</span><br><span class="line">           cur.pre = next;</span><br><span class="line">           pre = cur;</span><br><span class="line">           cur = next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pre;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>递归实现</p>
<p>看其是否可以分解成具有相同解决思路的子问题。反转链表1-&gt;2-&gt;3-&gt;4，如果把1以后的链表都反转好了，让2指向1,1指向空即可。对于1后面的子链表，也可以这样去处理。因此可以使用递归去解决</p>
<ol>
<li><p>定义递归函数，明确函数功能及返回值</p>
<p>此递归函数实现的功能是反转某个节点开始的链表，返回的是反转后的新的结点</p>
</li>
<li><p>寻找递归公式</p>
<ul>
<li>先反转当前节点以后的链表，这样1-&gt;2-&gt;3-&gt;4变为1-&gt;2&lt;-3&lt;-4</li>
<li>将当前node(1)的下一个节点(node.next)的指向(node.next.next)改为当前节点(node)，node的后继结点变为空</li>
<li>返回新的头结点</li>
</ul>
</li>
<li><p>将递推公式带入定义好的递归函数中</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反转链表的递归实现</span></span><br><span class="line"><span class="comment">//递归函数要实现的功能是反转链表，返回的是反转后的链表头节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseList2</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (node.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    <span class="comment">//对当前节点做操作</span></span><br><span class="line">    <span class="comment">//把后面的链表进行反转</span></span><br><span class="line">    Node newHead = reverseList2(node.next);</span><br><span class="line">    <span class="comment">//把后面的反转好后，让当前node的下一个节点的下一个指向当前节点</span></span><br><span class="line">    <span class="comment">//让当前节点的下一个指向空</span></span><br><span class="line">    node.next.next = node;</span><br><span class="line">    node.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//返回新的头节点</span></span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反转部分单向链表"><a href="#反转部分单向链表" class="headerlink" title="反转部分单向链表"></a>反转部分单向链表</h3><p>给定一个单链表，在链表中把第 L 个节点到第 R 个节点这一部分进行反转。</p>
<p>思路：找到from-1,from,to,to+1处的四个链表，如果from或者to为空，直接返回，反转from-to之间的链表，然后让from-1指向to，from指向to+1。如果from-1为空，那么to变为新链表的头结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反转from-to之间的链表</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reversePartList</span><span class="params">(Node head, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       <span class="comment">//找到from-1,fro,to,to+1处的链表节点</span></span><br><span class="line">       Node fromPre = <span class="keyword">null</span>;</span><br><span class="line">       Node from = <span class="keyword">null</span>;</span><br><span class="line">       Node to = <span class="keyword">null</span>;</span><br><span class="line">       Node toPos = <span class="keyword">null</span>;</span><br><span class="line">       Node cur = head;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//如果from和to的距离超过了链表长度，就不进行操作</span></span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">           count++;</span><br><span class="line">           <span class="keyword">if</span> (count == fromIndex - <span class="number">1</span>)&#123;</span><br><span class="line">               fromPre = cur;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> (count == fromIndex)&#123;</span><br><span class="line">               from = cur;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> (count == toIndex)&#123;</span><br><span class="line">               to = cur;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> (count == toIndex + <span class="number">1</span>)&#123;</span><br><span class="line">               toPos = cur;</span><br><span class="line">           &#125;</span><br><span class="line">           cur = cur.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (from == <span class="keyword">null</span> || to == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       <span class="comment">//反转from-to之间的结点</span></span><br><span class="line">       Node pre = <span class="keyword">null</span>;</span><br><span class="line">       cur = from;</span><br><span class="line">       Node next = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span> (cur != toPos)&#123;</span><br><span class="line">           next = cur.next;</span><br><span class="line">           cur.next = pre;</span><br><span class="line">           pre = cur;</span><br><span class="line">           cur = next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果from为头结点，新的头结点为to</span></span><br><span class="line">       <span class="keyword">if</span> (fromPre == <span class="keyword">null</span>)&#123;</span><br><span class="line">           head = to;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           fromPre.next = to;</span><br><span class="line">       &#125;</span><br><span class="line">       from.next = toPos;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="两链表相交问题（五星级）"><a href="#两链表相交问题（五星级）" class="headerlink" title="两链表相交问题（五星级）"></a>两链表相交问题（五星级）</h3><p>在本题中，单链表可能有环，也可能无环。给定两个链表的头节点，实现函数，如果两链表相交，返回相交的第一个节点；如果不相交，返回null即可。</p>
<p>要求：如果链表1的长度为N，链表2的长度为M，时间复杂度达到O（N+M），额外空间复杂度达到O（1）。</p>
<p>思路：遇到复杂问题进行拆解，首先需要判断两个链表是否有环，如果两个都没有环，那就是两个无环链表的相交问题；如果两个都有环，那就是两个有环链表的相交问题；如果一个有环，一个无环，是没有这种结构的。因此将问题差结成了三个，首先需要求解链表的入环节点。</p>
<p>判断链表是否有环有两种方法，一种是利用哈希表，如果当前节点在哈希表中，返回当前节点，否则加入哈希表，并遍历到下一个节点，此方法额外空间复杂度不为O(1)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getFirstLoopNode</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(head))&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方法是利用快慢指针，如果快指针没有遇到慢指针，快指针走2步，慢指针走1步，如果快指针后面为空，返回空。当快慢指针相遇，让快指针从链表头开始，和慢指针一起每次走一步，二者相遇的地方即为链表的入环节点。</p>
<img src="/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%93%BE%E8%A1%A8%E5%85%A5%E7%8E%AF.png" class title="This is an example image">

<p>假设起始点到入环处的长度为<code>a</code>，环的长度为<code>L</code>，当快指针与慢指针相遇时，设慢指针所走的路程为<code>b</code>，当慢指针入环时，快指针已经在环上了，设快指针距离入环点距离为c，这时候当慢指针继续走c步时，快指针就会赶上慢指针了，c&lt;=L，此时慢指针还没有走一圈。</p>
<p>当快慢指针相遇时 ，两个指针走的距离为</p>
<p>p慢=a+b=n</p>
<p>p快=a+b+k*L=2n（快指针比慢指针多走k圈）</p>
<p>因此有<code>n=a+b=k*L</code>。此时若让快指针从头节点重新走a步，<code>a=k*L-b</code>，对于慢指针，因为其已经走了b步，此时再走a步，正好在环上走了k圈（a+b=k*L）,因此两个指针会在入环点相遇。</p>
<p>判断条件是快慢指针没有相遇，而一旦快指针后面为null，返回即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLoopNode</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node slow = head.next;</span><br><span class="line">    Node fast = head.next.next;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样便可以判断出链表是否有环。对于两个都没有环的链表，如果他们相交，则最后个节点一定相等，让更长的链表先将多的部分走完，两个链表再一起走，便会在第一个相交的地方相遇。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两条链表没有环的情况</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">noLoop</span><span class="params">(Node head1, Node head2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node cur1 = head1;</span><br><span class="line">    Node cur2 = head2;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找到最后个节点并求两条链表长度差</span></span><br><span class="line">    <span class="keyword">while</span> (cur1.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        n++;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cur2.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        n--;</span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后节点不相同，一定不相交</span></span><br><span class="line">    <span class="keyword">if</span>(cur1 != cur2)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//将cur1指向更长的链表</span></span><br><span class="line">    cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">    cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">    n = Math.abs(n);<span class="comment">//得到较长链表需要多走的步数</span></span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>)&#123;</span><br><span class="line">        n--;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//共同走到相同的节点</span></span><br><span class="line">    <span class="keyword">while</span> (cur1 != cur2)&#123;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而对于两个都有环的链表，有如下的三种结构。</p>
<img src="/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.png" class title="This is an example image">

<p>其中如果两个链表的入环节点为同一个，则是第二种结构，可以简化为无环链表的相交问题；如果入环节点不为同一个，则让一个节点从环上走一圈，如果没有碰到另一个链表的入环节点，则说明是第一种，否则返回其中一个链表的入环节点即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个链表都有环的情况</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">bothLoop</span><span class="params">(Node head1, Node loop1, Node head2, Node loop2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//有3种情况</span></span><br><span class="line">    Node cur1 = <span class="keyword">null</span>;</span><br><span class="line">    Node cur2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//演变为无环链表的相交问题</span></span><br><span class="line">    <span class="keyword">if</span>(loop1 == loop2)&#123;</span><br><span class="line">        cur1 = head1;</span><br><span class="line">        cur2 = head2;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != loop1)&#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur2 != loop2)&#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">        cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">        n = Math.abs(n);</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != cur2)&#123;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//遍历loop1到自己，看是否遇到loop2</span></span><br><span class="line">        cur1 = loop1.next;</span><br><span class="line">        <span class="keyword">while</span>(cur1 != loop1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1 == loop2)&#123;</span><br><span class="line">                <span class="keyword">return</span> loop1;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下的主方法就比较简单，求两个链表的入环节点，然后对无环链表相交，有环链表相交和一个有环一个无环进行判断即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getIntersectNode</span><span class="params">(Node head1, Node head2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node loop1 = getLoopNode(head1);</span><br><span class="line">    Node loop2 = getLoopNode(head2);</span><br><span class="line">    <span class="keyword">if</span>(loop1 == <span class="keyword">null</span> &amp;&amp; loop2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> noLoop(head1, head2);</span><br><span class="line">    <span class="keyword">if</span>(loop1 != <span class="keyword">null</span> &amp;&amp; loop2 != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> bothLoop(head1,loop1,head2,loop2);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆本质是一个二叉树 ，在Java中实现为优先级队列（PriorityQueue），默认为小根堆，即最小的在最上面。可以通过在新建堆时传入比较器对象来定义大根堆或者小根堆。其中如果比较器只用到一次，没有必要去专门定义一个类，可以用匿名内部类，实现compare()方法即可，更简单的是用lambda表达式，更简洁。</p>
<p>堆的结构很好用，在取中位数，第k大or第k小的数，前k大or前k小，贪心中经常用到。</p>
<h3 id="随时找到数据流的中位数"><a href="#随时找到数据流的中位数" class="headerlink" title="随时找到数据流的中位数"></a>随时找到数据流的中位数</h3><p>题目描述：有一个源源不断的吐出整数的数据流，假设你有足够的空间来保存吐出的数。请设计一个名叫MedianHolder的结构，MedianHolder可以随时取得之前吐出所有数的中位数。</p>
<p>[要求]</p>
<ol>
<li><p>如果MedianHolder已经保存了吐出的N个数，那么将一个新数加入到MedianHolder的过程，其时间复杂度是O(logN)。</p>
</li>
<li><p>取得已经吐出的N个数整体的中位数的过程，时间复杂度为O(1)</p>
</li>
</ol>
<p>思路：持有两个堆，一个大根堆，一个小根堆，大根堆中存放较小的一半数，小根堆中存放较大的一半数，这样中位数就被大根堆和小根堆夹着。如果两个堆大小相等，则取平均；不然就返回较多的那个堆的堆顶元素。</p>
<p>其中比较关键的是将数加入堆的操作，如果大根堆为空或者当前数比大根堆顶的数小，则直接放入大根堆中，否则放入小根堆。然后进行堆的调整：哪个堆中的数据比另一个堆中数据多了2个，则拿一个到另一个堆中。这样将放数和调整堆进行了<strong>解耦</strong>，可以让代码变得更简洁。</p>
<p>其中牛客网要求格式化输出数据，可以用DecimalFormat类，进行一位小数的输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MedianHolder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//随时找到数据流的中位数，需要持有两个堆</span></span><br><span class="line">    <span class="comment">//大根堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//小根堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 取出所有整数部分和一位小数，格式化输出</span></span><br><span class="line">    DecimalFormat df = <span class="keyword">new</span> DecimalFormat(<span class="string">"#.0"</span>);</span><br><span class="line">    <span class="comment">//构造方法，初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianHolder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((o1,o2)-&gt;o2-o1);</span><br><span class="line">        minHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((o1,o2)-&gt;o1-o2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将数添加进堆中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果大根堆为空或者数比大根堆顶的数小，添加到大根堆</span></span><br><span class="line">        <span class="keyword">if</span> (maxHeap.isEmpty() || num &lt;= maxHeap.peek())&#123;</span><br><span class="line">            maxHeap.add(num);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minHeap.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//堆的调整</span></span><br><span class="line">        modifyTwoHeap();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//调整堆</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">modifyTwoHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果大根堆比小根堆多两个，放一个进小根堆</span></span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() == minHeap.size() + <span class="number">2</span>)&#123;</span><br><span class="line">            minHeap.add(maxHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minHeap.size() == maxHeap.size() + <span class="number">2</span>)&#123;</span><br><span class="line">            maxHeap.add(minHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找中位数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMedian</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果两个为空，返回空</span></span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果两个堆中数相等，取两个堆顶平均</span></span><br><span class="line">        <span class="keyword">if</span> (minHeap.size() == maxHeap.size())&#123;</span><br><span class="line">            System.out.println(df.format((maxHeap.peek()+minHeap.peek())/<span class="number">2.0</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//哪个多返回哪个的</span></span><br><span class="line">            System.out.println(df.format(maxHeap.size() &gt; minHeap.size() ? maxHeap.peek() : minHeap.peek()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s = br.readLine();</span><br><span class="line">        <span class="keyword">int</span> count = Integer.valueOf(s);</span><br><span class="line">        <span class="comment">//要持有的写的类</span></span><br><span class="line">        MedianHolder m = <span class="keyword">new</span> MedianHolder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="comment">//读一行数据</span></span><br><span class="line">            String[] str = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"2"</span>.equals(str[<span class="number">0</span>]))&#123;</span><br><span class="line">                m.getMedian();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                m.addNum(Integer.valueOf(str[<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="切金条"><a href="#切金条" class="headerlink" title="切金条"></a>切金条</h3><p>题目描述：给定一个正数数组arr，arr的累加和代表金条的总长度，arr的每个数代表金条要分成的长度。规定长度为k的金条分成两块，费用为k个铜板。返回把金条分出arr中的每个数字需要的最小代价。</p>
<p>要求：时间复杂度为O(n log n)，空间复杂度为O(n)</p>
<p>题目说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果先分成40和20两块，将花费60个铜板，再把长度为40的金条分成10和30两块，将花费40个铜板，总花费为100个铜板；</span><br><span class="line">如果先分成10和50两块，将花费60个铜板，再把长度为50的金条分成20和30两块，将花费50个铜板，总花费为110个铜板；</span><br><span class="line">如果先分成30和30两块，将花费60个铜板，再把其中一根长度为30的金条分成10和20两块，将花费30个铜板，总花费为90个铜板；</span><br><span class="line">因此最低花费为90</span><br></pre></td></tr></table></figure>

<p>思路：哈夫曼编码问题，即每次选出权重最小的数，新节点权重为二者相加，将新节点加入，再拿出两个，直到之后只有一个数，其值就是总的权重。</p>
<p>哈夫曼编码的应用：给出传递的电文，计算每个字母的权重，选出较小的两个节点构造成一个二叉树（小的在左，大的在右），新二叉树的权重为二者权重之和，然后将新二叉树放入，再重新拿出两个权重最小的。树构造好后，进行编码，左边为0，右边为1，只有叶子节点在存储了信息，这样从头节点找到叶子节点，便可以找到每个字母对应的编码。当给定了编码后，要如何去找到对应的字母呢？可以从字符串中取出字符，然后在树中进行寻找，如果找到了叶子节点，就得到了一个字母，再继续找下去。</p>
<h3 id="做项目"><a href="#做项目" class="headerlink" title="做项目"></a>做项目</h3><p>题目描述：</p>
<p>输入：</p>
<p>参数1：正数数组costs</p>
<p>参数2：正数数组profits</p>
<p>参数3：正数k</p>
<p>参数4：正数m</p>
<p>参数说明：cost[i]表示i号项目的花费，profits[i]表示i号项目在扣除花费后还能挣到的钱（利润），k表示你不能并行、只能串行的最多做k个项目，m表示你初始的资金。</p>
<p>说明：你每做完一个项目，马上获得的收益，可以支持你去做下一个项目</p>
<p>输出：你最后获得的最大钱数。</p>
<p>分析：标准的贪心问题，选择项目的标准是：在花费比资金小的项目中，选择利润最多的，积累利润后，再选择花费比当前资金小的项目，直到做了k个项目。</p>
<p>思路：持有两个堆，一个小根堆，一个大根堆，小根堆依照项目花费排序，大根堆中依靠项目利润排序，从小根堆中弹出花费比当前资金少的项目进大根堆，然后从大根堆中弹出一个项目来做，累积资金，直到做了k个项目。</p>
<p>坑点：返回的收益需要是<strong>long</strong>类型，<strong>避免溢出</strong>！！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将项目的花费和利润封装为一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">proNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> p;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proNode</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">        <span class="keyword">this</span>.p = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindMaximizedCapital</span> </span>&#123;</span><br><span class="line">    <span class="comment">//持有两个堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;proNode&gt; minHeap;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;proNode&gt; maxHeap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FindMaximizedCapital</span><span class="params">()</span></span>&#123;</span><br><span class="line">        minHeap = <span class="keyword">new</span> PriorityQueue&lt;proNode&gt;((o1,o2)-&gt;o1.c-o2.c);</span><br><span class="line">        maxHeap = <span class="keyword">new</span> PriorityQueue&lt;proNode&gt;((o1,o2)-&gt;o2.p-o1.p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算项目最大利润</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">findMaximizedCapital</span><span class="params">(<span class="keyword">int</span>[] costs,<span class="keyword">int</span>[] profits,<span class="keyword">int</span> k,<span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将花费和利润封装放进小根堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; costs.length; i++) &#123;</span><br><span class="line">            minHeap.add(<span class="keyword">new</span> proNode(costs[i],profits[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行k次循环做项目</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="comment">//知道小根堆不为空且堆顶项目花费比m少，弹进大根堆</span></span><br><span class="line">            <span class="keyword">while</span> (!minHeap.isEmpty() &amp;&amp; minHeap.peek().c &lt;= m)&#123;</span><br><span class="line">                maxHeap.add(minHeap.poll());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//需要考虑到大根堆为空的情况，即虽然没有到k次，但没有项目可做</span></span><br><span class="line">            <span class="keyword">if</span> (maxHeap.isEmpty())</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            <span class="comment">//选出一个项目来做</span></span><br><span class="line">            m += maxHeap.poll().p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String[] str = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span> n = Integer.valueOf(str[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> w = Integer.valueOf(str[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> k = Integer.valueOf(str[<span class="number">2</span>]);</span><br><span class="line">        String[] strC = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        String[] strP = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span>[] costs = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] profits = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            costs[i] = Integer.parseInt(strC[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            profits[i] = Integer.parseInt(strP[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        FindMaximizedCapital fm = <span class="keyword">new</span> FindMaximizedCapital();</span><br><span class="line">        <span class="keyword">long</span> win = fm.findMaximizedCapital(costs,profits,k,w);</span><br><span class="line">        System.out.println(win);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>给定一个字符串类型的数组strs，找到一种拼接方式，使得把所有字符串拼起来之后形成的字符串具有最低的字典序。</p>
<p>​    字典序：每个字母相当于26进制的数，如果位数相同则比较字面值，长度不能的时候，把短的补到跟长的一样，补的内容相当于ASCII表中最小的内容，然后从最高位开始比较。</p>
<p>比较两个字符串，若str1+str2&lt;= str2 + str1，则str1放前面，否则str2放前面。不要去证明贪心问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//负数认为o1小，谁作为前缀小谁放前面</span></span><br><span class="line">        <span class="keyword">return</span> (o1 + o2).compareTo(o2 + o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用比较器来排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">lowestString</span><span class="params">(String[] strs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    Arrays.sort(strs,<span class="keyword">new</span> MyComparator());</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (String s : strs)&#123;</span><br><span class="line">        sb.append(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树的深度遍历"><a href="#树的深度遍历" class="headerlink" title="树的深度遍历"></a>树的深度遍历</h3><h4 id="递归遍历方法"><a href="#递归遍历方法" class="headerlink" title="递归遍历方法"></a>递归遍历方法</h4><p>先序遍历：先中、再左、再右。对每一个结点，先打印当前结点，再打印其左子树所有结点，再打印右子树所有结点。</p>
<p>中序遍历：先左、再中、再右。对每一个结点，先打印其左子树所有结点，再打印当前结点，再打印右子树所有结点。</p>
<p>后序遍历：先左、再右、再中。对每一个结点，先打印其左子树所有结点，再打印右子树所有结点，再打印当前结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序打印二叉树的递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//先打印当前节点</span></span><br><span class="line">    System.out.print(head.value+<span class="string">" "</span>);</span><br><span class="line">    <span class="comment">//递归打印左子树</span></span><br><span class="line">    preOrderRecur(head.left);</span><br><span class="line">    <span class="comment">//递归打印右子树</span></span><br><span class="line">    preOrderRecur(head.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序打印二叉树的递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//先打印左子树，再打印中间，再打印右子树</span></span><br><span class="line">    inOrderRecur(head.left);</span><br><span class="line">    System.out.print(head.value +<span class="string">" "</span>);</span><br><span class="line">    inOrderRecur(head.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序打印二叉树的递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">posOrderRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//先打印左子树，再打印右子树，再打印当前节点</span></span><br><span class="line">    posOrderRecur(head.left);</span><br><span class="line">    posOrderRecur(head.right);</span><br><span class="line">    System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="非递归遍历方法"><a href="#非递归遍历方法" class="headerlink" title="非递归遍历方法"></a>非递归遍历方法</h4><p>先序遍历用栈结构实现，顺序为先中，再左，再右。将头结点放入栈，如果栈不为空，弹出当前节点，弹出就打印。如果右不为空，把右边的放入栈中。如果左不为空，把左边的放入栈中。为了让先弹左，再弹右，因此放入栈的时候要先右再左。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderUnRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"pre-order: "</span>);</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//准备一个栈</span></span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        <span class="comment">//将头结点压入</span></span><br><span class="line">        stack.add(head);</span><br><span class="line">        <span class="comment">//只要栈不为空</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//弹出并打印头结点</span></span><br><span class="line">            head = stack.pop();</span><br><span class="line">            System.out.print(head.value+<span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//如果右节点不为空，压入</span></span><br><span class="line">            <span class="keyword">if</span>(head.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果左节点不为空，压入</span></span><br><span class="line">            <span class="keyword">if</span>(head.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中序遍历用栈结构实现，顺序为先左，再中，再右。栈中先放所有的左边界，head从头往左移动，直到空，这样所有的左边界都到栈中了。当往左移动不下去了，从栈中弹出一个并打印，并向右移动。</p>
<p>​    因为从中一直往左压栈，因此弹出的时候一定是从左到中，往右跑是因为要把右子树也按照这种方法压入栈。那么整个顺序是先左再中再右。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderUnRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"in-order: "</span>);</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//只要栈不为空或者head不为空就循环</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果head不为空，一直将左节点压入栈</span></span><br><span class="line">            <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head);</span><br><span class="line">                head = head.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果head为空，弹出并打印栈中元素，</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                head = stack.pop();</span><br><span class="line">                System.out.print(head.value + <span class="string">" "</span>);</span><br><span class="line">                head = head.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后续遍历是先左再右再中。中左右，是先弹出中，然后压入右，压入左。那么中右左就是先弹出中，然后压入左，压入右。然后该打印的时候不打印，放入一个help，再弹出来，就是先左再右再中了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">posOrderUnRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"pos order: "</span>);</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Node&gt; help = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//先把头节点压入</span></span><br><span class="line">        stack.push(head);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            head = stack.pop();</span><br><span class="line">            <span class="comment">//该输出的时候弹入辅助栈</span></span><br><span class="line">            help.push(head);</span><br><span class="line">            <span class="comment">//先压左后压右</span></span><br><span class="line">            <span class="keyword">if</span>(head.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将辅助栈中数据弹出</span></span><br><span class="line">        <span class="keyword">while</span> (!help.isEmpty())&#123;</span><br><span class="line">            System.out.print(help.pop().value+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="折纸问题"><a href="#折纸问题" class="headerlink" title="折纸问题"></a>折纸问题</h4><img src="/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8A%98%E7%BA%B8.png" class title="This is an example image">

<p>这个问题实质是二叉树的中序遍历问题，头结点为下，左孩子为下，右孩子为下，用递归方式解决，递归函数参数列表有当前树高度，为左还是右（左为下，右为上）</p>
<img src="/2020/02/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8A%98%E7%BA%B8%E6%A0%91.png" class title="This is an example image">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直观打印折纸</span></span><br><span class="line"><span class="comment">//本质上是树的中序遍历，左结点为下，右结点为上，头节点为下</span></span><br><span class="line"><span class="comment">//用递归实现，功能是中序打印二叉树，需要传入当前树的高度，左还是右</span></span><br><span class="line"><span class="comment">//因为只有两种可能，所以可以用布尔类型的变量来表示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAllFolds</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    printProcess(<span class="number">1</span>,N,<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printProcess</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n, <span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; n)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//left,cur,right</span></span><br><span class="line">    printProcess(i+<span class="number">1</span>,n,<span class="keyword">true</span>);</span><br><span class="line">    System.out.println(b ? <span class="string">"下"</span> : <span class="string">"上"</span>);</span><br><span class="line">    printProcess(i+<span class="number">1</span>,n,<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在二叉树中找到一个节点的后继节点"><a href="#在二叉树中找到一个节点的后继节点" class="headerlink" title="在二叉树中找到一个节点的后继节点"></a>在二叉树中找到一个节点的后继节点</h3><p>现在树结点多了一个parent结点，指向父节点，头节点的parent指向null。只给一个在二叉树中某个节点node，实现返回node的后继节点的函数。在二叉树的后序遍历的序列中，node的下一个节点叫做node的后继节点。</p>
<p>中序遍历为左、中、右，考虑当前节点为中的情况，因此如果有右子树，后继节点应该是右子树的最左结点。当前节点如果为左，其为父节点的左孩子，则父节点就是后继节点。如果当前节点为右，表明其所在的左子树已被遍历完，需要找到某个节点，其为父节点的左孩子，返回此父节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getNextNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//node有右子树，找到右子树最左节点</span></span><br><span class="line">    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> getLeftMost(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有右子树</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node parent = node.parent;<span class="comment">//拿到父节点</span></span><br><span class="line">        <span class="comment">//只要此节点不为父节点的左子树</span></span><br><span class="line">        <span class="comment">//跳到node是parent左节点停，返回parent</span></span><br><span class="line">        <span class="comment">//加上Parent不为空是为了兼顾没有后继的情况</span></span><br><span class="line">        <span class="comment">//其中parent不为空要放在前面，不然就算空了，因为parent左孩子不为node，循环仍继续</span></span><br><span class="line">        <span class="keyword">while</span> (parent != <span class="keyword">null</span> &amp;&amp; parent.left != node)&#123;</span><br><span class="line">            <span class="comment">//当前节点不是父节点的左孩子则继续</span></span><br><span class="line">            node = parent;</span><br><span class="line">            parent = node.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找最左节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLeftMost</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树的序列化"><a href="#树的序列化" class="headerlink" title="树的序列化"></a>树的序列化</h3><h4 id="树的先序方式序列化与反序列化"><a href="#树的先序方式序列化与反序列化" class="headerlink" title="树的先序方式序列化与反序列化"></a>树的先序方式序列化与反序列化</h4><p>中、左、右。将遍历的结果用字符串进行记录。当一个节点的左子树为空时，可以用一个特殊符号来记录，如#。</p>
<p>序列化思路：利用递归来进行中序遍历，如果是空节点，则添加#！，如果不为空，添加value!，然后遍历左子树与右子树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">serialByPre</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中、左、右的递归</span></span><br><span class="line">    String res = head.value + <span class="string">"!"</span>;</span><br><span class="line">    res += serialByPre(head.left);</span><br><span class="line">    res += serialByPre(head.right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反序列化思路：将字符串用！进行分割，然后将数组中的字符一个个构造成节点，可以将其加入到队列中，也可以用index+数组来取，这样当为#，返回空，构造一个新节点，递归构造其左子树与右子树，然后返回头节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序方式反序列化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reconByPreString</span><span class="params">(String preStr)</span></span>&#123;</span><br><span class="line">    <span class="comment">//分割字符串</span></span><br><span class="line">    String[] values = preStr.split(<span class="string">"!"</span>);</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//将所有元素加入到队列，用数组也可以，需要传递下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != values.length; i++) &#123;</span><br><span class="line">        queue.offer(values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reconPreOrder(queue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给一个队列建立树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reconPreOrder</span><span class="params">(Queue&lt;String&gt; queue)</span></span>&#123;</span><br><span class="line">    String value = queue.poll();</span><br><span class="line">    <span class="comment">//空节点</span></span><br><span class="line">    <span class="keyword">if</span> (value.equals(<span class="string">"#"</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//建立新节点等于head</span></span><br><span class="line">    Node head = <span class="keyword">new</span> Node(Integer.valueOf(value));</span><br><span class="line">    <span class="comment">//左、右子树分别交给递归去实现</span></span><br><span class="line">    head.left = reconPreOrder(queue);</span><br><span class="line">    head.right = reconPreOrder(queue);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="树的层序方式序列化与反序列化"><a href="#树的层序方式序列化与反序列化" class="headerlink" title="树的层序方式序列化与反序列化"></a>树的层序方式序列化与反序列化</h4><p>层序方式也是广度优先遍历。</p>
<p>序列化思路：将头节点加入队列，并将其添加进StringBuilder，从队列中弹出一个节点，将其左右子树的值加入，没有就加入#，而不选择在弹出的时候添加是因为空节点无法加入队列。如果左子树不为空，加入队列；如果右子树不为空，加入队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按层序列化</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">serialByLevel</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       queue.offer(head);</span><br><span class="line">       sb.append(head.value).append(<span class="string">"!"</span>);</span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">           head = queue.poll();</span><br><span class="line">           <span class="comment">//在节点进去的时候就添加，不然添加不了空节点</span></span><br><span class="line">           <span class="keyword">if</span> (head.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">               queue.offer(head.left);</span><br><span class="line">               sb.append(head.left.value).append(<span class="string">"!"</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               sb.append(<span class="string">"#!"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (head.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">               queue.offer(head.right);</span><br><span class="line">               sb.append(head.right.value).append(<span class="string">"!"</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               sb.append(<span class="string">"#!"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sb.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>按层方式反序列化 思路：将字符串分割，建造头节点并放入队列中，记录头节点。从队列中弹出一个节点，建造其左子树与右子树，如果左子树不为空，加入队列；如果右子树不为空，加入队列。此处用index+数组来控制当前要利用的字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按层方式反序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reconByLevelString</span><span class="params">(String levelStr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将字符串分割</span></span><br><span class="line">        String[] str = levelStr.split(<span class="string">"!"</span>);</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//产生头节点，并放进队列中</span></span><br><span class="line">        Node res = generateNode(str[value++]);</span><br><span class="line">        Node head = res;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(head);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            head = queue.poll();</span><br><span class="line">            head.left = generateNode(str[value++]);</span><br><span class="line">            head.right = generateNode(str[value++]);</span><br><span class="line">            <span class="keyword">if</span> (head.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.offer(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.offer(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断树的类型"><a href="#判断树的类型" class="headerlink" title="判断树的类型"></a>判断树的类型</h3><h4 id="判断树是否为平衡二叉树"><a href="#判断树是否为平衡二叉树" class="headerlink" title="判断树是否为平衡二叉树"></a>判断树是否为平衡二叉树</h4><p>平衡二叉树中，在任何一个节点，左子树与右子树高度差，不超过1。</p>
<p>思路：以每一个节点为头节点的树为平衡二叉树，总体才是，对当前节点，需要其左子树为平衡二叉树，右子树为平衡二叉树，两个子树高度差不超过1，才是平衡二叉树。可以用树的后序遍历递归方式解决，当前函数需要给下一级函数传递当前子树是否平衡，树的高度，如果树不平衡，则高度没有用。可以将是否平衡与树的高度信息进行封装。关键是看函数功能是什么，需要传递什么参数。</p>
<p>平衡性用来解决效率问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isB</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> process(head).isB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ReturnData <span class="title">process</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="comment">//空树是高度为0的平衡树</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">    ReturnData leftData = process(head.left);</span><br><span class="line">    <span class="comment">//左子树不平衡，则直接不平衡</span></span><br><span class="line">    <span class="comment">//在不满足时高度为0是因为高度用不上</span></span><br><span class="line">    <span class="keyword">if</span> (!leftData.isB) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ReturnData rightData = process(head.right);</span><br><span class="line">    <span class="keyword">if</span> (!rightData.isB)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左、右树均平衡</span></span><br><span class="line">    <span class="keyword">if</span> (Math.abs(leftData.h - rightData.h) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在满足的时候，子结构要给父过程提供高度，为二者中较高的+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReturnData(<span class="keyword">true</span>,Math.max(leftData.h, rightData.h)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断一棵二叉树是否是搜索二叉树"><a href="#判断一棵二叉树是否是搜索二叉树" class="headerlink" title="判断一棵二叉树是否是搜索二叉树"></a>判断一棵二叉树是否是搜索二叉树</h4><p>如果为搜索二叉树，则其中序遍历的输出一定是升序的，那么中序遍历树，如果当前节点的值小于上一个节点的值，则不为搜索二叉树，因此需要记录上一个节点的值 ，第一个节点的上一个节点为Integer的最小值，当遍历到节点比上一个节点小，返回假，否则更新上一个节点值为当前节点值，遍历下一个节点。当将树遍历完后，返回真。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否是搜索二叉树，用中序遍历非递归改</span></span><br><span class="line"><span class="comment">//只要在返回的时候，判断是否比前一个数大即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">int</span> pre = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() || head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(head);</span><br><span class="line">            head = head.left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//弹出一个元素</span></span><br><span class="line">            head = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (head.value &lt; pre)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = head.value;</span><br><span class="line">            head = head.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断一棵二叉树是否为完全二叉树"><a href="#判断一棵二叉树是否为完全二叉树" class="headerlink" title="判断一棵二叉树是否为完全二叉树"></a>判断一棵二叉树是否为完全二叉树</h4><p>思路：利用层级优先遍历，一个节点的左右子树有四种不同状态，如果左有且右有，则继续判断；如果左有，右没有，则后面不能出现叶子节点；如果左没有，右有，肯定不是；如果左没有，右没有，后面不能出现叶子节点。</p>
<p>因此有两种是绝对不可能的</p>
<ul>
<li>左没有，右有</li>
<li>之前有右边没有的，后来有非空节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCBT</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//双端链表，实现队列</span></span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//表示是否开启了情况2</span></span><br><span class="line">    <span class="keyword">boolean</span> leaf = <span class="keyword">false</span>;</span><br><span class="line">    Node l = <span class="keyword">null</span>;</span><br><span class="line">    Node r = <span class="keyword">null</span>;</span><br><span class="line">    queue.offer(head);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        head = queue.poll();</span><br><span class="line">        l = head.left;</span><br><span class="line">        r = head.right;</span><br><span class="line">        <span class="comment">//有右没左或子节点不全且之后有非叶节点</span></span><br><span class="line">        <span class="keyword">if</span> ((leaf &amp;&amp; (l !=<span class="keyword">null</span> || r != <span class="keyword">null</span>)) || (l == <span class="keyword">null</span> &amp;&amp; r !=<span class="keyword">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="keyword">null</span>)</span><br><span class="line">            queue.offer(l);</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(r);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//右为空，开启状态2</span></span><br><span class="line">            leaf = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="剑指Offer"><a href="#剑指Offer" class="headerlink" title="剑指Offer"></a>剑指Offer</h1><h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><h3 id="数组中重复数字"><a href="#数组中重复数字" class="headerlink" title="数组中重复数字"></a>数组中重复数字</h3><h4 id="允许修改数组"><a href="#允许修改数组" class="headerlink" title="允许修改数组"></a>允许修改数组</h4><p>长度为n的数组里所有数字均出现在o~n-1的范围内，数组内某些数字是重复的，但不知道几个重复了，也不知道数字重复了几次。找出数组中任意一个重复的数字。如 ，长度为7的数组{2,3,1,0,2,5,3}，对应的输出为重复数字为2或者3。</p>
<p>方法1：使用哈希表，如果一个元素添加进哈希表了，就返回此元素，如果没有加入过，就加入。</p>
<p>时间复杂度O(n)，额外空间复杂度O(n)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用哈希表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">findNumHash</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(arr[i]))</span><br><span class="line">            <span class="keyword">return</span> arr[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            set.add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下解决的是找到第一个重复元素的问题，但是要额外建立一个哈希表。</p>
<p>方法2：抽屉原理</p>
<p>如果有n个数分布为0-n-1，在没有重复的时候，必然是一个萝卜一个坑，即可以将值为<code>i</code>的元素（i=0~n-1）放在第<code>i</code>个坑中，但是因为有重复的元素存在，会出现在第<code>i</code>个坑中值不为i的情况，这时候可以将它放在它原本应在的地方，直到当前坑中放了对应的萝卜，如果此时第<code>i</code>个坑中元素为<code>k</code>，但第<code>k</code>个坑中元素也为<code>k</code>，说明当前元素就是重复的。</p>
<p>总的时间复杂度为O(n)，额外空间复杂度O(1)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到第一个重复的数字，抽屉原理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">findNum</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果数组的长度不在0-arr.length-1之间，返回</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; <span class="number">0</span> || arr[i] &gt; arr.length-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从第一个到最后一个</span></span><br><span class="line">        <span class="comment">//如果当前数和角标不等，交换，直到相等或和要交换角标处的值相等</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[i] != i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] == arr[arr[i]])&#123;</span><br><span class="line">                    <span class="keyword">return</span> arr[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//swap(arr,i,arr[i])</span></span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[arr[i]];</span><br><span class="line">                <span class="comment">//不能直接使用arr[arr[i]]，因为此时arr[i]已经变化了</span></span><br><span class="line">                arr[temp] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="不修改数组找到重复数字"><a href="#不修改数组找到重复数字" class="headerlink" title="不修改数组找到重复数字"></a>不修改数组找到重复数字</h4><p>在长度为n+1的数组里的所有数字都在1~n的范围之内，因此数组中至少有一个数字是重复的。找出任意一个重复的数字，但不能修改输入的数组，如输入长度为8的数组{2,3,5,4,3,2,6,7}，输出为重复的数字2或者3。额外空间复杂度为O(1)。</p>
<p>不能使用哈希表，不能使用抽屉原理，这时候可以考虑二分。因为如果<code>1~n</code>的数字没有重复，那么<code>1~(n-1)/2</code>和<code>(n-1)/2+1~n</code>中元素个数应该和其角标left-right之间的范围相同，但是因为有重复的，那么假设重复数字为3，那么<code>1~7</code>分为<code>1~4</code>和<code>5~7</code>，这时候<code>1~4</code>中的元素个数肯定会多于4，然后再到<code>1~4</code>中进行寻找，直到找到left=right，如果这时候left值的数字出现个数&gt;1，则输出left。</p>
<p>用到的为二分的模板</p>
<p>核心为</p>
<ol>
<li>left与right的取值很重要，需要夹住所有可能的情况</li>
<li>while循环中用left &lt; right，这样退出循环的时候一定有left==right，不用思考返回left还是right</li>
<li>mid选择左中位数（left + ((right - left) &gt;&gt; 1)）或者右中位数（left + ((right - left+1) &gt;&gt; 1)）</li>
<li>只用两个判断，一次排除一半的结果</li>
<li>可以选择是否在循环结束后对夹住的数进行判断</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left = 数<span class="number">1</span>, right = 数<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(判断条件<span class="number">1</span>)&#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//或者</span></span><br><span class="line">    <span class="keyword">if</span>(判断条件<span class="number">1</span>)&#123;</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        left = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在while结束后，对left处的值选择性进行判断</span></span><br><span class="line"><span class="comment">//多种输出可能</span></span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line"><span class="keyword">return</span> arr[left];</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>此题具体的实现代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用二分的思路</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">findNum2</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//看是否在0-n-1范围之内</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; <span class="number">0</span> || arr[i] &gt; arr.length-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二分，看哪边的数字更多，再继续找</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right-left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//计算个数</span></span><br><span class="line">            <span class="keyword">int</span> count = getFre(arr,left,mid);</span><br><span class="line">            <span class="keyword">if</span> (count &gt; mid + <span class="number">1</span> - left)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//去另一半</span></span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = getFre(arr,left,right);</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        <span class="comment">//没有找到</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计在l-m之间出现的次数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getFre</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt;= l &amp;&amp; arr[i] &lt;= m)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。</p>
<p>思路：回溯的经典案例。如果当前字符可以，则看其上下左右的是否符合，不进入已经去过的位置，如果匹配长度为字符串的长度，返回真，不然的话就返回假，并重置当前所做的操作。</p>
<p>关键在于要维护一个与矩阵大小相同的布尔型矩阵，表示当前字符是否已经遍历过，如果遍历过了则不进入，如果当前字符与要遍历的第i个字符相等，则将布尔型的矩阵相对应位置置为true，再看其上下左右的，如果失败了，则让当前位置的标志重置为false。</p>
<p>容易错的点为，base case判断不完全，应该有</p>
<ol>
<li>当前遍历到的(i,j)在矩阵范围内</li>
<li>当前位置的字符与第k个字符相等</li>
<li>当前位置没有进来过</li>
</ol>
<p>同时需要注意的是一维到二维的映射关系，应该是第i行*列数+当前列j。</p>
<p>最后成功的base case条件为已经将所有的字符都判断完毕了，需要传递给下一级递归函数一个int变量。</p>
<p>递归函数实现的功能为，判断当前字符周围的字符是否可以找到所给的字符串。需要传递的参数有基本的矩阵的参数等，以及下一次寻找的起始位置(i,j)，下一次遍历的字符串位置len。为了不让重复的字符遍历到，当遍历一个字符后，需要将其标志变量置为true，这样下一次不会再遍历。同时回溯为了消除下一次的影响，需要将标志位重置。</p>
<p>回溯的小总结</p>
<ol>
<li>利用递归来处理子问题</li>
<li>base case（递归终止条件，包括失败与成功条件）</li>
<li>改变当前位置状态，进行子问题的递归</li>
<li>子问题递归失败，重置当前状态</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果数据不相符，直接返回假</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || str == <span class="keyword">null</span> || matrix.length != rows * cols || str.length &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//新建一个判断矩阵</span></span><br><span class="line">        <span class="keyword">boolean</span>[] isIn = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows * cols];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; isIn.length; i++) &#123;</span><br><span class="line">            isIn[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用来检测现在判断字符串长度的变量</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//对每一个数都进行判断</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="comment">//如果当前字符开头的数组可以，则返回真</span></span><br><span class="line">                <span class="keyword">if</span> (process(matrix, rows, cols, str, isIn, i, j, len))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str, <span class="keyword">boolean</span>[] isIn, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一维映射到二维，很重要</span></span><br><span class="line">        <span class="keyword">int</span> index = i * cols + j;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="comment">//如果当前数据不再矩阵范围内，直接返回假</span></span><br><span class="line">        <span class="comment">//如果已经进入了当前位置，返回假</span></span><br><span class="line">        <span class="comment">//当前位置的数和str第len个字符不等</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols || matrix[index] != str[len] || isIn[index])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//如果已经将数字找完了，返回真</span></span><br><span class="line">        <span class="keyword">if</span> (len == str.length - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//当前数字进入过了</span></span><br><span class="line">        isIn[index] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//看当前数字的上下左右是否符合</span></span><br><span class="line">        <span class="keyword">if</span> (process(matrix,rows,cols,str,isIn,i-<span class="number">1</span>,j,len+<span class="number">1</span>)</span><br><span class="line">        || process(matrix,rows,cols,str,isIn,i+<span class="number">1</span>,j,len+<span class="number">1</span>)</span><br><span class="line">        || process(matrix,rows,cols,str,isIn,i,j-<span class="number">1</span>,len+<span class="number">1</span>)</span><br><span class="line">        || process(matrix,rows,cols,str,isIn,i,j+<span class="number">1</span>,len+<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//还原当前状态</span></span><br><span class="line">        isIn[index] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="机器人的行走路径"><a href="#机器人的行走路径" class="headerlink" title="机器人的行走路径"></a>机器人的行走路径</h3><p>描述：地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<p>思路：回溯法，从当前格子开始走，需要维护一个是否走过的矩阵。在递归中，如果超出范围，已经走过了，当前位置不适合，返回0，然后计算四个方向能走的个数+当前走的1步，进行返回。注意的是：因为之前的矩阵中的路径，当前位置走的路径是对其他位置开始的路径没有影响的，因此需要回溯消除当前影响，而这里因为走的位置不能重复，因此之前走的对其他步是有影响的，不能消除影响。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//基础判断</span></span><br><span class="line">        <span class="keyword">if</span>(rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span> || threshold &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//准备是否进入的矩阵</span></span><br><span class="line">        <span class="keyword">boolean</span>[]  f = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows * cols];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f.length; i++) &#123;</span><br><span class="line">            f[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = getCount(threshold,rows,cols,<span class="number">0</span>,<span class="number">0</span>,f);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span>[] f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = i * cols + j;</span><br><span class="line">        <span class="comment">//如果超出范围，已经进来过，得到的数不符合，返回0</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols || f[index] || getAllNum(i) + getAllNum(j) &gt; threshold)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前数字进来过了</span></span><br><span class="line">        f[index] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//总的计数+1，返回其他四个方向的</span></span><br><span class="line">        <span class="comment">//因为这个路径走过的，其他也不能走，因此不用重置f的状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + getCount(threshold,rows,cols,i - <span class="number">1</span>,j,f)</span><br><span class="line">                + getCount(threshold,rows,cols,i + <span class="number">1</span>,j,f)</span><br><span class="line">                + getCount(threshold,rows,cols,i,j - <span class="number">1</span>,f)</span><br><span class="line">                + getCount(threshold,rows,cols,i,j + <span class="number">1</span>,f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getAllNum</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//得到所有位数之和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            sum += i % <span class="number">10</span>;</span><br><span class="line">            i = i / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>总结：对于矩阵上路径的遍历或者人物的行走，非常适合用回溯算法。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><p>请实现一个函数，把字符串中的每个空格替换成“%20”，如输入“We are happy”，则输出“We%are%happy”</p>
<p>方法：先统计传入的字符串str中空格的个数，然后建造一个新的字符数组，其长度为str非空格字符长度+空格个数*待替换字符串长度，然后用两个指针，一个遍历str，一个指向新的字符数组末尾，如果str当前不为空格，直接复制到新数组，新数组指针移动；如果str当前为空格，新数组从后逐个拷贝传入的字符串，直到遍历完str。</p>
<p>其中要注意的是新数组长度，需要先将原数组长度减去空格，再加上空格长度乘待替换字符串长度。如果不减去空格长度，新数组前面会有空余。如果没有空格，直接返回输入字符串即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不用系统的split方法，先统计插入后的字符个数，再从最后一个开始插入</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceBlank2</span><span class="params">(String str, String s)</span></span>&#123;</span><br><span class="line">       <span class="comment">//统计str空格数量及s长度</span></span><br><span class="line">       <span class="keyword">int</span> spCount = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> sSize = s.length();</span><br><span class="line">       <span class="comment">//统计str中空格个数</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="string">' '</span>==str.charAt(i))&#123;</span><br><span class="line">               spCount++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (spCount == <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> str;</span><br><span class="line">       <span class="comment">//非空格字符数+替换后的字符数</span></span><br><span class="line">       <span class="keyword">int</span> newSize = str.length() - spCount + spCount * sSize;</span><br><span class="line">       <span class="keyword">char</span>[] res = <span class="keyword">new</span> <span class="keyword">char</span>[newSize];</span><br><span class="line">       <span class="comment">//两个指针，一个指向strArr，一个指向res</span></span><br><span class="line">       <span class="keyword">int</span> p1 = str.length() - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> p2 = res.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (; p1 &gt;= <span class="number">0</span>; p1--) &#123;</span><br><span class="line">           <span class="keyword">char</span> c = str.charAt(p1);</span><br><span class="line">           <span class="keyword">if</span> (<span class="string">' '</span> != c)&#123;</span><br><span class="line">               <span class="comment">//当前不为空格，直接复制</span></span><br><span class="line">               res[p2--] = c;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//如果为空格，p2拷贝s</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = sSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                   res[p2--] = s.charAt(i);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> String(res);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h2><h3 id="反向打印链表"><a href="#反向打印链表" class="headerlink" title="反向打印链表"></a>反向打印链表</h3><p>输入一个链表的头节点，从尾到头反过来打印出每个节点的值。</p>
<p>方法1：遍历链表，将值存入栈。遍历栈，弹出值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反向打印链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reversePrint</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(node.value);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        sb.append(stack.pop()).append(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法2：既然有用到栈 ，那么也可以用递归来实现，递归函数的功能是打印此节点后面的节点。基本过程是调用递归函数，然后打印当前节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//既然有用到栈，那么就可以用递归来实现，先打印后面的，然后打印当前的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reversePrint2</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    process(node,sb);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Node node, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归来实现</span></span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归后面的节点</span></span><br><span class="line">    process(node.next,sb);</span><br><span class="line">    <span class="comment">//打印当前节点</span></span><br><span class="line">    sb.append(node.value).append(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树-1"><a href="#树-1" class="headerlink" title="树"></a>树</h2><h3 id="树的重构"><a href="#树的重构" class="headerlink" title="树的重构"></a>树的重构</h3><p>根据先序和中序数组来重构一棵二叉树</p>
<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><h3 id="找旋转数组的最小值"><a href="#找旋转数组的最小值" class="headerlink" title="找旋转数组的最小值"></a>找旋转数组的最小值</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p>思路：先判断，如果最左边数比最右边树小，那么最左边的是最小的。如果最左边的与中间和最右边数相等，那么没法二分，只能顺序查找。</p>
<p>用二分模板，左边指向左侧升序数组，右边指向右侧升序数组，当左右相邻，说明左边到了升序数组末尾，右边到了右边升序数组的开头，这样右边的数为最小数。不然，当左边数比中间数小，说明左边为升序，那么将左边移动到中间；否则将右边移动到中间。判断依据是，在旋转数组中，最小的数一定不是出现在升序数组中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minNumberInRotatedArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="comment">//错误情况</span></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//如果为顺序，返回第一个</span></span><br><span class="line">    <span class="keyword">if</span> (arr[l] &lt; arr[r])</span><br><span class="line">        <span class="keyword">return</span> arr[l];</span><br><span class="line">    <span class="comment">//如果三个相等，顺序查找</span></span><br><span class="line">    <span class="keyword">if</span> (arr[l] == arr[mid] &amp;&amp; arr[mid] == arr[r])&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l+<span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[i-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分模板</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="comment">//r为右边的递增数组开头，l为左边递增数组末尾</span></span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> arr[r];</span><br><span class="line">        mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//若左边有序，往右边找</span></span><br><span class="line">        <span class="keyword">if</span> (arr[l] &lt;= arr[mid])&#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h3><p>描述：给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>思路：如果长度小于等于3的，必须要切，单独给出结果，如果长度为4的，可以切成1,3，也可以切成2,2，这样得到的递归公式为f(n)=max(f(i)*f(n-i))，拆分为小问题解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//数据不和规格的情况</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果是1-3的情况，只能再分，对应的数字较小</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//如果是大于3的情况，1，2,3可以不用再分，这时候值会更大</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                res = Math.max(res,dp[j] * dp[i - j]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>二进制的用法：</p>
<p>&amp;：</p>
<ul>
<li>将所有位清零 n &amp; 0</li>
<li>取指定位置上的数，如取二进制的后四位，n &amp; 00001111</li>
</ul>
<p>|：</p>
<ul>
<li>将某些位数置为1：n | 00001111</li>
</ul>
<p>^</p>
<ul>
<li>将某些位置取反：n ^ 00001111，将后四位取反</li>
<li>保留原值：n ^ 0</li>
<li>交换两个数：<code>a=a^b;b=a^b;a=a^b</code>，完成a与b的交换</li>
</ul>
<h3 id="1的个数"><a href="#1的个数" class="headerlink" title="1的个数"></a>1的个数</h3><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<p>如9的二进制为1001，得到的输出为2.</p>
<p>方法一：逐位相与。一个数为1的地方，与1与不为0，统计这个数每个位都与1相与，不为0的次数即可。有两种选择，一种是右移这个数，一种是左移1。如果是右移这个数，需要使用无符号位右移，因为如果是带符号的，对于负数会有死循环。而左移1，需要进行32次判断。</p>
<p>需要注意的是n&amp;1结果不为0，进行统计。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//将要计算的数右移</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">NumberOf1_Solution1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (n != <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">               ++count;</span><br><span class="line">           n = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//将1左移</span></span><br><span class="line">   <span class="comment">//看有多少个1，可以每一位与1相与，然后统计</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">NumberOf1_Solution2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//计算32次</span></span><br><span class="line">       <span class="keyword">while</span> (flag != <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span> ((n &amp; flag) != <span class="number">0</span>)</span><br><span class="line">               ++count;</span><br><span class="line">           flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>方法二：将当前数与减去1后的数相与，得到的数会将最右侧的1变为0，这样有几个1进行几次操作，最后会得到0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">NumberOf1_Solution3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将一个数和其减一后的数相与，会把最右边为1的数后均变为0</span></span><br><span class="line">    <span class="comment">//有几个1，进行几次这样的操作</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>)&#123;</span><br><span class="line">        ++count;</span><br><span class="line">        n = n &amp; (n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展：用一条语句判断整数是不是2的整数次方，如果是，则只有一个数为1，那么将其与减去1的数相与，如果得到0，说明只有一个1。</p>
<p>输入两个数m与n，统计需要改变m的二进制中多少个数才能得到n</p>
<ul>
<li>得到m与n的异或，不同的位置为1</li>
<li>统计1的个数</li>
</ul>
<h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h3><p>题目描述：给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<p>注意空字符串可被认为是有效字符串。</p>
<p>思路：先将左右括号的对应关系放入一个map中，然后如果是左括号，放入栈中；如果是右括号，若栈为空，则返回假，若不为空，弹出一个元素，如果在map中弹出元素对应的括号与当前括号不同，则返回假。遍历完字符串后，若栈不为空，返回假，否则返回真。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//准备一个栈和一个哈希表</span></span><br><span class="line">        HashMap&lt;Character,Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">'('</span>,<span class="string">')'</span>);</span><br><span class="line">        map.put(<span class="string">'['</span>,<span class="string">']'</span>);</span><br><span class="line">        map.put(<span class="string">'&#123;'</span>,<span class="string">'&#125;'</span>);</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Character c : s.toCharArray())&#123;</span><br><span class="line">            <span class="comment">//如果是左括号，压入栈</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(c))&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//不存在，先判断栈是否为空</span></span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//如果不符合，直接返回</span></span><br><span class="line">                <span class="keyword">if</span>(map.get(stack.pop()) != c)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty() ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h2><h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h3><p>描述：给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>示例 :</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p>方法：滑动窗口</p>
<p>因为要求不能重复，因此想到可以用哈希表跟双指针来维护一个窗口，如果右边的元素跟窗口内元素不重复，移动窗口，并更新最大窗口值；如果右边的元素重复了，则将窗口往左滑动，直到没有重复的。</p>
<p>精髓在于双指针跟哈希表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (r &lt; str.length())&#123;</span><br><span class="line">        <span class="comment">//如果没有进来过，移动右窗口</span></span><br><span class="line">        <span class="keyword">if</span> (!set.contains(str.charAt(r)))&#123;</span><br><span class="line">            set.add(str.charAt(r++));</span><br><span class="line">            <span class="comment">//更新结果</span></span><br><span class="line">            ans = Math.max(ans,r-l);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果包含了，则缩小窗口</span></span><br><span class="line">            set.remove(str.charAt(l++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表-2"><a href="#链表-2" class="headerlink" title="链表"></a>链表</h2><h3 id="LRU缓存机制"><a href="#LRU缓存机制" class="headerlink" title="LRU缓存机制"></a>LRU缓存机制</h3><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>
<p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。时间复杂度O(1)。</p>
<p>思路：这种数据结构要求的特点是插入删除快，获取快。获取时间复杂度O(1)，想到哈希表，但是哈希表是无序的，没办法做到找到最近操作的数。为了让插入删除快，想到链表。因此将二者结合，便想到了LinkedHashMap，先自己造轮子，代码思路来自于<a href="https://leetcode-cn.com/problems/lru-cache/solution/lru-ce-lue-xiang-jie-he-shi-xian-by-labuladong/" target="_blank" rel="noopener">leetcode评论区解法</a>。</p>
<p>方法一：自己造轮子</p>
<p>为了让链表与哈希表相结合，需要让哈希表与链表进行映射，哈希表存储key和对应的节点，链表为了方便删除操作，使用双向链表，链表的节点定义如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    DoubleNode pre;</span><br><span class="line">    DoubleNode next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleNode</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于链表的操作，需要实现的功能有，在链表前面插入节点，删除一个节点，删除末尾节点，获取链表容量，双向链表的实现如下。维护头节点与尾节点，方便进行插入与删除的操作，对于插入一个元素，需要改变4个指向的关系，让size自增。对于删除一个节点，需要改变2个指向的关系，size递减，返回删除元素的key。对于删除末尾节点，调用删除节点的方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span></span>&#123;</span><br><span class="line">    <span class="comment">//头节点与尾节点</span></span><br><span class="line">    <span class="keyword">private</span> DoubleNode head;</span><br><span class="line">    <span class="keyword">private</span> DoubleNode tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> DoubleNode(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> DoubleNode(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//往链表头节点添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(DoubleNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//添加当前节点的指向</span></span><br><span class="line">        node.next = head.next;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        head.next.pre = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在链表中移除元素，其中节点一定在链表中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">(DoubleNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//删除2个关系</span></span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> node.key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移除链表末尾元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> remove(tail.pre);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于LRU缓存，需要维护一个哈希表和一个双向链表，同时需要设置一个阈值容量。get方法的逻辑为，如果哈希表中不存在key，返回-1；如果存在，调用put方法，更新哈希表和链表，返回对应的value。对于put方法，逻辑为，构造一个新节点，当这个key存在于map中，在链表中将此key对应的节点删除，将新节点插入到链表头部，更新map。如果不存在于map中，当容量满了，删除链表最后的元素，在哈希表中删除其对应的key，然后将节点添加至链表头部，更新哈希表。实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">//持有一个map和一个双向链表，根据key找到对应Node,然后在链表中操作</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer,DoubleNode&gt; map;</span><br><span class="line">    <span class="keyword">private</span> DoubleList list;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cap;<span class="comment">//容量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> cap)</span></span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        list = <span class="keyword">new</span> DoubleList();</span><br><span class="line">        <span class="keyword">this</span>.cap = cap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//get方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果不存在，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = map.get(key).value;</span><br><span class="line">        <span class="comment">//更新链表</span></span><br><span class="line">        put(key,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        DoubleNode node = <span class="keyword">new</span> DoubleNode(key,value);</span><br><span class="line">        <span class="comment">//如果已经存在了，进行替换</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key))&#123;</span><br><span class="line">            <span class="comment">//在链表中删除</span></span><br><span class="line">            list.remove(map.get(key));</span><br><span class="line">            <span class="comment">//将新节点加入</span></span><br><span class="line">            list.addFirst(node);</span><br><span class="line">            <span class="comment">//更新哈希表</span></span><br><span class="line">            map.put(key,node);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果链表长度等于容量，删除末尾节点，然后将新节点添加至头部</span></span><br><span class="line">            <span class="keyword">if</span> (list.getSize() == cap)&#123;</span><br><span class="line">                <span class="comment">//记录被删除节点的key，便于从哈希表中移出</span></span><br><span class="line">                <span class="keyword">int</span> temp = list.removeLast();</span><br><span class="line">                map.remove(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            list.addFirst(node);</span><br><span class="line">            map.put(key,node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：用轮子</p>
<p>Java中有序的哈希表为LinkedHashMap，直接用一个类去继承，初始化的时候为了让取出顺序为访问顺序，传入true，然后get方法调用父类的getOrDefault方法，put方法调用父类的put方法，为了删除超出容量的节点，需要覆写removeEldestEntry方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache2</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">Integer</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache2</span><span class="params">(<span class="keyword">int</span> cap)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当为true的时候,get的顺序为访问的顺序</span></span><br><span class="line">        <span class="keyword">super</span>(cap,<span class="number">0.75F</span>,<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.cap = cap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getOrDefault(key,-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer,Integer&gt; eldest)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; cap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95/" rel="tag"># 左神算法</a>
              <a href="/tags/%E5%89%91%E6%8C%87offer/" rel="tag"># 剑指offer</a>
              <a href="/tags/leetcode/" rel="tag"># leetcode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/02/09/MySQL/" rel="prev" title="MySQL">
      <i class="fa fa-chevron-left"></i> MySQL
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/02/27/%E5%B9%B6%E5%8F%91%E4%B8%8E%E9%94%81%E6%80%BB%E7%BB%93/" rel="next" title="并发与锁总结">
      并发与锁总结 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#OJ处理技巧"><span class="nav-number">1.</span> <span class="nav-text">OJ处理技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#获取不知次数的输入"><span class="nav-number">1.1.</span> <span class="nav-text">获取不知次数的输入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取有限次数的输入"><span class="nav-number">1.2.</span> <span class="nav-text">获取有限次数的输入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取输入矩阵"><span class="nav-number">1.3.</span> <span class="nav-text">获取输入矩阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取数组"><span class="nav-number">1.4.</span> <span class="nav-text">获取数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取链表"><span class="nav-number">1.5.</span> <span class="nav-text">获取链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取树"><span class="nav-number">1.6.</span> <span class="nav-text">获取树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#左神算法笔记"><span class="nav-number">2.</span> <span class="nav-text">左神算法笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#排序问题"><span class="nav-number">2.1.</span> <span class="nav-text">排序问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#小和问题"><span class="nav-number">2.1.1.</span> <span class="nav-text">小和问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组排序后相邻数的最大差值"><span class="nav-number">2.1.2.</span> <span class="nav-text">数组排序后相邻数的最大差值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#队列和栈"><span class="nav-number">2.2.</span> <span class="nav-text">队列和栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用数组实现栈和队列"><span class="nav-number">2.2.1.</span> <span class="nav-text">用数组实现栈和队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getMin-功能的栈"><span class="nav-number">2.2.2.</span> <span class="nav-text">getMin()功能的栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用队列实现栈"><span class="nav-number">2.2.3.</span> <span class="nav-text">用队列实现栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用栈实现队列"><span class="nav-number">2.2.4.</span> <span class="nav-text">用栈实现队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#猫狗队列"><span class="nav-number">2.2.5.</span> <span class="nav-text">猫狗队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希表"><span class="nav-number">2.3.</span> <span class="nav-text">哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RandomPool结构"><span class="nav-number">2.3.1.</span> <span class="nav-text">RandomPool结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一致性哈希"><span class="nav-number">2.3.2.</span> <span class="nav-text">一致性哈希</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#负载均衡算法"><span class="nav-number">2.3.3.</span> <span class="nav-text">负载均衡算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见的hash算法"><span class="nav-number">2.3.4.</span> <span class="nav-text">常见的hash算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">2.4.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#转圈打印矩阵"><span class="nav-number">2.4.1.</span> <span class="nav-text">转圈打印矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#之字型打印矩阵"><span class="nav-number">2.4.2.</span> <span class="nav-text">之字型打印矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在行列都排好序的矩阵中找数"><span class="nav-number">2.4.3.</span> <span class="nav-text">在行列都排好序的矩阵中找数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链表"><span class="nav-number">2.5.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#打印两个链表的公共部分"><span class="nav-number">2.5.1.</span> <span class="nav-text">打印两个链表的公共部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#合并两个有序的链表"><span class="nav-number">2.5.2.</span> <span class="nav-text">合并两个有序的链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断链表是否为回文结构"><span class="nav-number">2.5.3.</span> <span class="nav-text">判断链表是否为回文结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单向链表的基础partition"><span class="nav-number">2.5.4.</span> <span class="nav-text">单向链表的基础partition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单链表的partition进阶"><span class="nav-number">2.5.5.</span> <span class="nav-text">单链表的partition进阶</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制含有随机节点的链表"><span class="nav-number">2.5.6.</span> <span class="nav-text">复制含有随机节点的链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反转链表"><span class="nav-number">2.5.7.</span> <span class="nav-text">反转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反转部分单向链表"><span class="nav-number">2.5.8.</span> <span class="nav-text">反转部分单向链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两链表相交问题（五星级）"><span class="nav-number">2.5.9.</span> <span class="nav-text">两链表相交问题（五星级）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆"><span class="nav-number">2.6.</span> <span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#随时找到数据流的中位数"><span class="nav-number">2.6.1.</span> <span class="nav-text">随时找到数据流的中位数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#切金条"><span class="nav-number">2.6.2.</span> <span class="nav-text">切金条</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#做项目"><span class="nav-number">2.6.3.</span> <span class="nav-text">做项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串拼接"><span class="nav-number">2.6.4.</span> <span class="nav-text">字符串拼接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树"><span class="nav-number">2.7.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#树的深度遍历"><span class="nav-number">2.7.1.</span> <span class="nav-text">树的深度遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#递归遍历方法"><span class="nav-number">2.7.1.1.</span> <span class="nav-text">递归遍历方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非递归遍历方法"><span class="nav-number">2.7.1.2.</span> <span class="nav-text">非递归遍历方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#折纸问题"><span class="nav-number">2.7.1.3.</span> <span class="nav-text">折纸问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在二叉树中找到一个节点的后继节点"><span class="nav-number">2.7.2.</span> <span class="nav-text">在二叉树中找到一个节点的后继节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#树的序列化"><span class="nav-number">2.7.3.</span> <span class="nav-text">树的序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#树的先序方式序列化与反序列化"><span class="nav-number">2.7.3.1.</span> <span class="nav-text">树的先序方式序列化与反序列化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#树的层序方式序列化与反序列化"><span class="nav-number">2.7.3.2.</span> <span class="nav-text">树的层序方式序列化与反序列化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断树的类型"><span class="nav-number">2.7.4.</span> <span class="nav-text">判断树的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#判断树是否为平衡二叉树"><span class="nav-number">2.7.4.1.</span> <span class="nav-text">判断树是否为平衡二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断一棵二叉树是否是搜索二叉树"><span class="nav-number">2.7.4.2.</span> <span class="nav-text">判断一棵二叉树是否是搜索二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断一棵二叉树是否为完全二叉树"><span class="nav-number">2.7.4.3.</span> <span class="nav-text">判断一棵二叉树是否为完全二叉树</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#剑指Offer"><span class="nav-number">3.</span> <span class="nav-text">剑指Offer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数组-1"><span class="nav-number">3.1.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数组中重复数字"><span class="nav-number">3.1.1.</span> <span class="nav-text">数组中重复数字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#允许修改数组"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">允许修改数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不修改数组找到重复数字"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">不修改数组找到重复数字</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#矩阵中的路径"><span class="nav-number">3.1.2.</span> <span class="nav-text">矩阵中的路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#机器人的行走路径"><span class="nav-number">3.1.3.</span> <span class="nav-text">机器人的行走路径</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串"><span class="nav-number">3.2.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#替换空格"><span class="nav-number">3.2.1.</span> <span class="nav-text">替换空格</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链表-1"><span class="nav-number">3.3.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#反向打印链表"><span class="nav-number">3.3.1.</span> <span class="nav-text">反向打印链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树-1"><span class="nav-number">3.4.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#树的重构"><span class="nav-number">3.4.1.</span> <span class="nav-text">树的重构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二分"><span class="nav-number">3.5.</span> <span class="nav-text">二分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#找旋转数组的最小值"><span class="nav-number">3.5.1.</span> <span class="nav-text">找旋转数组的最小值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态规划"><span class="nav-number">3.6.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#剪绳子"><span class="nav-number">3.6.1.</span> <span class="nav-text">剪绳子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二进制"><span class="nav-number">3.7.</span> <span class="nav-text">二进制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1的个数"><span class="nav-number">3.7.1.</span> <span class="nav-text">1的个数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode"><span class="nav-number">4.</span> <span class="nav-text">leetcode</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#栈"><span class="nav-number">4.1.</span> <span class="nav-text">栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#有效的括号"><span class="nav-number">4.1.1.</span> <span class="nav-text">有效的括号</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串-1"><span class="nav-number">4.2.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#无重复字符的最长子串"><span class="nav-number">4.2.1.</span> <span class="nav-text">无重复字符的最长子串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链表-2"><span class="nav-number">4.3.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LRU缓存机制"><span class="nav-number">4.3.1.</span> <span class="nav-text">LRU缓存机制</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="未名Hugh"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">未名Hugh</p>
  <div class="site-description" itemprop="description">技术博客，Java，并发编程，算法</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">未名Hugh</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.6.0
  </div>
-->

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共165.8k字</span>
</div>
        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>